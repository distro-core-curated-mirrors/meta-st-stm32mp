From 7f8bbe6b0f21a4e194309b433e3db0499bd437d3 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Fri, 12 Jul 2024 14:28:46 +0200
Subject: [PATCH] v2023.10-stm32mp-r1

---
 .gitignore                                    |    3 +
 CODE_OF_CONDUCT.md                            |   73 +
 CONTRIBUTING.md                               |   30 +
 MAINTAINERS                                   |   13 +-
 Makefile                                      |    8 +-
 SECURITY.md                                   |    8 +
 arch/Kconfig                                  |    2 +-
 arch/arm/Kconfig                              |    2 +-
 arch/arm/dts/Makefile                         |   26 +-
 arch/arm/dts/stm32429i-eval.dts               |   32 +-
 arch/arm/dts/stm32f4-pinctrl.dtsi             |   31 +-
 arch/arm/dts/stm32f429-disco.dts              |    2 +-
 arch/arm/dts/stm32f429.dtsi                   |   32 +-
 arch/arm/dts/stm32f469-disco.dts              |    4 +-
 arch/arm/dts/stm32f7-pinctrl.dtsi             |  127 +-
 arch/arm/dts/stm32f746-disco-u-boot.dtsi      |  103 +-
 arch/arm/dts/stm32f746-disco.dts              |   69 +-
 arch/arm/dts/stm32f746-pinctrl.dtsi           |   46 +-
 arch/arm/dts/stm32f746.dtsi                   |   61 +-
 arch/arm/dts/stm32f769-pinctrl.dtsi           |   46 +-
 arch/arm/dts/stm32h7-pinctrl.dtsi             |    6 +-
 arch/arm/dts/stm32h743.dtsi                   |    3 +-
 arch/arm/dts/stm32h750i-art-pi.dts            |    2 +-
 arch/arm/dts/stm32mp13-pinctrl.dtsi           |  249 ++
 arch/arm/dts/stm32mp13-u-boot.dtsi            |   16 +
 arch/arm/dts/stm32mp131.dtsi                  | 1615 +++++---
 arch/arm/dts/stm32mp133.dtsi                  |   84 +-
 arch/arm/dts/stm32mp135.dtsi                  |   24 +-
 arch/arm/dts/stm32mp135f-dk-u-boot.dtsi       |   27 +-
 arch/arm/dts/stm32mp135f-dk.dts               |  389 +-
 arch/arm/dts/stm32mp13xa.dtsi                 |    5 +
 arch/arm/dts/stm32mp13xc.dtsi                 |   22 +-
 arch/arm/dts/stm32mp13xd.dtsi                 |   28 +
 arch/arm/dts/stm32mp13xf.dtsi                 |   43 +-
 arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi    |  524 +++
 arch/arm/dts/stm32mp15-m4-srm.dtsi            |  447 +++
 arch/arm/dts/stm32mp15-pinctrl.dtsi           |  586 ++-
 arch/arm/dts/stm32mp15-scmi-u-boot.dtsi       |    8 +-
 arch/arm/dts/stm32mp15-scmi.dtsi              |   56 +-
 arch/arm/dts/stm32mp15-u-boot.dtsi            |    6 +-
 arch/arm/dts/stm32mp151.dtsi                  | 3381 ++++++++++-------
 arch/arm/dts/stm32mp153.dtsi                  |   55 +-
 arch/arm/dts/stm32mp157.dtsi                  |   17 +-
 arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi |   55 -
 ...dk1-scmi.dts => stm32mp157a-dk1-scmi.dtsi} |   20 +-
 arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi      |  165 +-
 arch/arm/dts/stm32mp157a-dk1.dts              |    2 +
 arch/arm/dts/stm32mp157a-ed1-scmi.dtsi        |   94 +
 arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157a-ed1.dts              |  441 +++
 arch/arm/dts/stm32mp157a-ev1-scmi.dtsi        |   91 +
 arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157a-ev1.dts              |  798 ++++
 ...157a-microgea-stm32mp1-microdev2.0-of7.dts |    4 +-
 arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi |   13 -
 ...dk2-scmi.dts => stm32mp157c-dk2-scmi.dtsi} |   25 +-
 arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi      |    8 +-
 arch/arm/dts/stm32mp157c-dk2.dts              |   94 +-
 arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi |   45 -
 ...ed1-scmi.dts => stm32mp157c-ed1-scmi.dtsi} |   29 +-
 arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi      |  193 +-
 arch/arm/dts/stm32mp157c-ed1.dts              |   90 +-
 arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi |  142 -
 ...ev1-scmi.dts => stm32mp157c-ev1-scmi.dtsi} |   28 +-
 arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi      |   78 +-
 arch/arm/dts/stm32mp157c-ev1.dts              |  420 +-
 arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157d-dk1.dts              |   27 +
 arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157d-ed1.dts              |  441 +++
 arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157d-ev1.dts              |  798 ++++
 arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi      |   10 +
 arch/arm/dts/stm32mp157f-dk2.dts              |  163 +
 arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157f-ed1.dts              |  445 +++
 arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157f-ev1.dts              |  811 ++++
 arch/arm/dts/stm32mp15xa.dtsi                 |    5 +
 arch/arm/dts/stm32mp15xc.dtsi                 |   24 +-
 arch/arm/dts/stm32mp15xd.dtsi                 |   28 +
 arch/arm/dts/stm32mp15xf.dtsi                 |   22 +
 arch/arm/dts/stm32mp15xx-dhcom-som.dtsi       |   12 +-
 arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi    |   12 +-
 arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi |   34 +-
 arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi    |    8 +-
 arch/arm/dts/stm32mp15xx-dkx.dtsi             |  156 +-
 arch/arm/dts/stm32mp21-pinctrl.dtsi           |  613 +++
 arch/arm/dts/stm32mp21-u-boot.dtsi            |  111 +
 arch/arm/dts/stm32mp211.dtsi                  | 2692 +++++++++++++
 arch/arm/dts/stm32mp213.dtsi                  |   97 +
 arch/arm/dts/stm32mp215.dtsi                  |   36 +
 .../dts/stm32mp215f-dk-ca35tdcid-resmem.dtsi  |  157 +
 arch/arm/dts/stm32mp215f-dk-u-boot.dtsi       |   32 +
 arch/arm/dts/stm32mp215f-dk.dts               |  547 +++
 arch/arm/dts/stm32mp21xc.dtsi                 |   20 +
 arch/arm/dts/stm32mp21xf.dtsi                 |   20 +
 arch/arm/dts/stm32mp21xxal-pinctrl.dtsi       |   71 +
 arch/arm/dts/stm32mp21xxam-pinctrl.dtsi       |   71 +
 arch/arm/dts/stm32mp21xxan-pinctrl.dtsi       |   71 +
 arch/arm/dts/stm32mp21xxao-pinctrl.dtsi       |   63 +
 arch/arm/dts/stm32mp23-u-boot.dtsi            |  129 +
 arch/arm/dts/stm32mp231.dtsi                  | 3022 +++++++++++++++
 arch/arm/dts/stm32mp233.dtsi                  |  172 +
 arch/arm/dts/stm32mp235.dtsi                  |  173 +
 .../dts/stm32mp235f-dk-ca35tdcid-resmem.dtsi  |  167 +
 arch/arm/dts/stm32mp235f-dk-u-boot.dtsi       |   49 +
 arch/arm/dts/stm32mp235f-dk.dts               |  747 ++++
 arch/arm/dts/stm32mp23xc.dtsi                 |   21 +
 arch/arm/dts/stm32mp23xf.dtsi                 |   21 +
 arch/arm/dts/stm32mp25-pinctrl.dtsi           | 1014 +++++
 arch/arm/dts/stm32mp25-u-boot.dtsi            |  129 +
 arch/arm/dts/stm32mp251.dtsi                  | 3373 ++++++++++++++++
 arch/arm/dts/stm32mp253.dtsi                  |  202 +
 arch/arm/dts/stm32mp255.dtsi                  |  183 +
 arch/arm/dts/stm32mp257.dtsi                  |   50 +
 .../dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi  |  185 +
 arch/arm/dts/stm32mp257f-dk-u-boot.dtsi       |   49 +
 arch/arm/dts/stm32mp257f-dk.dts               |  890 +++++
 .../dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi |  189 +
 arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi      |   88 +
 arch/arm/dts/stm32mp257f-ev1.dts              |  913 +++++
 arch/arm/dts/stm32mp25xc.dtsi                 |   35 +
 arch/arm/dts/stm32mp25xf.dtsi                 |   35 +
 arch/arm/dts/stm32mp25xxai-pinctrl.dtsi       |   83 +
 arch/arm/dts/stm32mp25xxaj-pinctrl.dtsi       |   71 +
 arch/arm/dts/stm32mp25xxak-pinctrl.dtsi       |   71 +
 arch/arm/dts/stm32mp25xxal-pinctrl.dtsi       |   71 +
 arch/arm/include/asm/system.h                 |   16 +-
 arch/arm/mach-stm32/Kconfig                   |    3 -
 arch/arm/mach-stm32mp/Kconfig                 |  109 +-
 arch/arm/mach-stm32mp/Kconfig.13x             |    6 +-
 arch/arm/mach-stm32mp/Kconfig.15x             |   12 +-
 arch/arm/mach-stm32mp/Kconfig.21x             |   43 +
 arch/arm/mach-stm32mp/Kconfig.23x             |   43 +
 arch/arm/mach-stm32mp/Kconfig.25x             |   43 +
 arch/arm/mach-stm32mp/Makefile                |   23 +-
 arch/arm/mach-stm32mp/bsec.c                  |   74 +-
 arch/arm/mach-stm32mp/cmd_stm32key.c          |  367 +-
 arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig   |    3 +
 .../cmd_stm32prog/cmd_stm32prog.c             |    8 -
 .../mach-stm32mp/cmd_stm32prog/stm32prog.c    |   22 +-
 .../mach-stm32mp/cmd_stm32prog/stm32prog.h    |   15 +-
 arch/arm/mach-stm32mp/dram_init.c             |   34 +-
 arch/arm/mach-stm32mp/etzpc.c                 |  195 +
 arch/arm/mach-stm32mp/fdt.c                   |  514 ---
 arch/arm/mach-stm32mp/include/mach/etzpc.h    |   32 +
 arch/arm/mach-stm32mp/include/mach/rif.h      |   26 +
 arch/arm/mach-stm32mp/include/mach/stm32.h    |  199 +-
 .../mach-stm32mp/include/mach/stm32mp1_smc.h  |   48 +-
 .../arm/mach-stm32mp/include/mach/stm32prog.h |    2 -
 .../arm/mach-stm32mp/include/mach/sys_proto.h |   89 +-
 arch/arm/mach-stm32mp/nvram.c                 |  665 ++++
 arch/arm/mach-stm32mp/soc.c                   |   80 +
 arch/arm/mach-stm32mp/stm32mp1/Makefile       |   21 +
 arch/arm/mach-stm32mp/{ => stm32mp1}/cpu.c    |   85 +-
 arch/arm/mach-stm32mp/stm32mp1/fdt.c          |  256 ++
 arch/arm/mach-stm32mp/{ => stm32mp1}/psci.c   |    0
 .../{ => stm32mp1}/pwr_regulator.c            |    6 +
 arch/arm/mach-stm32mp/{ => stm32mp1}/spl.c    |    4 +-
 .../mach-stm32mp/{ => stm32mp1}/stm32mp13x.c  |    0
 .../mach-stm32mp/{ => stm32mp1}/stm32mp15x.c  |    2 +-
 arch/arm/mach-stm32mp/{ => stm32mp1}/tzc400.c |    0
 arch/arm/mach-stm32mp/stm32mp2/Makefile       |   12 +
 arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c    |   80 +
 arch/arm/mach-stm32mp/stm32mp2/cpu.c          |  293 ++
 arch/arm/mach-stm32mp/stm32mp2/fdt.c          |   16 +
 arch/arm/mach-stm32mp/stm32mp2/rifsc.c        |  365 ++
 arch/arm/mach-stm32mp/stm32mp2/stm32mp21x.c   |  192 +
 arch/arm/mach-stm32mp/stm32mp2/stm32mp23x.c   |  186 +
 arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c   |  208 +
 arch/arm/mach-stm32mp/syscon.c                |    4 +-
 arch/sandbox/include/asm/gpio.h               |    3 +-
 board/dhelectronics/dh_stm32mp1/board.c       |    7 +-
 board/st/common/Kconfig                       |    8 +-
 board/st/common/Makefile                      |    2 +-
 board/st/common/cmd_stboard.c                 |    3 +
 board/st/common/stm32mp_dfu.c                 |  132 +-
 board/st/common/stm32mp_dfu_virt.c            |   99 +
 board/st/common/stusb160x.c                   |   48 -
 board/st/common/stusb160x.h                   |   10 -
 board/st/stm32f746-disco/stm32f746-disco.c    |    6 -
 board/st/stm32mp1/Kconfig                     |    4 +-
 board/st/stm32mp1/stm32mp1.c                  |  513 ++-
 board/st/stm32mp2/Kconfig                     |   41 +
 board/st/stm32mp2/MAINTAINERS                 |   10 +
 board/st/stm32mp2/Makefile                    |    6 +
 board/st/stm32mp2/README                      |    1 +
 board/st/stm32mp2/stm32mp2.c                  |  893 +++++
 cmd/clk.c                                     |    6 +-
 cmd/fwu_mdata.c                               |   39 +-
 cmd/legacy-mtd-utils.c                        |   70 +-
 cmd/mtdparts.c                                |   90 +-
 common/console.c                              |   27 +-
 common/fdt_support.c                          |    6 +-
 common/usb_onboard_hub.c                      |   13 -
 configs/corstone1000_defconfig                |    2 +
 configs/sandbox64_defconfig                   |    1 +
 configs/stm32f746-disco_defconfig             |    4 +-
 configs/stm32f746-disco_spl_defconfig         |    4 +-
 configs/stm32f769-disco_defconfig             |    2 +-
 configs/stm32f769-disco_spl_defconfig         |    2 +-
 configs/stm32mp13_defconfig                   |   98 +-
 configs/stm32mp15_basic_defconfig             |   33 +-
 configs/stm32mp15_defconfig                   |   32 +-
 configs/stm32mp15_trusted_defconfig           |   37 +-
 configs/stm32mp21_defconfig                   |  185 +
 configs/stm32mp23_defconfig                   |  191 +
 configs/stm32mp25_defconfig                   |  193 +
 configs/synquacer_developerbox_defconfig      |    2 +
 configs/tools-only_defconfig                  |    1 +
 doc/board/st/index.rst                        |    1 +
 doc/board/st/st-dt.rst                        |    1 +
 doc/board/st/stm32mp1.rst                     |   42 +-
 doc/board/st/stm32mp2.rst                     |  544 +++
 doc/develop/uefi/fwu_updates.rst              |   20 +-
 doc/mkfwumdata.1                              |   16 +-
 drivers/adc/adc-uclass.c                      |    4 +-
 drivers/adc/stm32-adc-core.c                  |   79 +-
 drivers/adc/stm32-adc-core.h                  |    2 +
 drivers/adc/stm32-adc.c                       |  504 ++-
 drivers/button/button-gpio.c                  |    3 +
 drivers/clk/Kconfig                           |   11 +
 drivers/clk/clk-uclass.c                      |   39 +-
 drivers/clk/clk_fixed_rate.c                  |    1 +
 drivers/clk/clk_sandbox.c                     |   35 +-
 drivers/clk/clk_sandbox_ccf.c                 |   48 +-
 drivers/clk/clk_scmi.c                        |   18 +-
 drivers/clk/stm32/Kconfig                     |   22 +-
 drivers/clk/stm32/Makefile                    |    4 +-
 drivers/clk/stm32/clk-stm32-core.c            |   73 +-
 drivers/clk/stm32/clk-stm32-core.h            |    2 +-
 drivers/clk/stm32/clk-stm32mp1.c              |    8 +
 drivers/clk/stm32/clk-stm32mp13.c             |    7 +-
 drivers/clk/stm32/clk-stm32mp21.c             |  627 +++
 drivers/clk/stm32/clk-stm32mp25.c             |  785 ++++
 drivers/core/ofnode.c                         |   17 +-
 drivers/dfu/dfu_mtd.c                         |   32 +-
 drivers/fastboot/fb_command.c                 |    7 +-
 drivers/fastboot/fb_mmc.c                     |    8 +-
 drivers/fwu-mdata/fwu-mdata-uclass.c          |   10 +-
 drivers/fwu-mdata/gpt_blk.c                   |   23 +-
 drivers/fwu-mdata/raw_mtd.c                   |   78 +-
 drivers/gpio/gpio-uclass.c                    |    1 +
 drivers/gpio/sandbox.c                        |   16 +-
 drivers/gpio/stm32_gpio.c                     |  148 +-
 drivers/gpio/stm32_gpio_priv.h                |   70 +-
 drivers/hwspinlock/hwspinlock-uclass.c        |    2 +-
 drivers/i2c/stm32f7_i2c.c                     |   39 +-
 drivers/mailbox/stm32-ipcc.c                  |   19 +-
 drivers/memory/Kconfig                        |    8 +
 drivers/memory/Makefile                       |    1 +
 drivers/memory/stm32-fmc2-ebi.c               |  449 ++-
 drivers/memory/stm32-omi.c                    |  523 +++
 drivers/misc/Kconfig                          |   17 +
 drivers/misc/Makefile                         |    1 +
 drivers/misc/stm32_omm.c                      |  428 +++
 drivers/misc/stm32_rcc.c                      |   77 +-
 drivers/mmc/stm32_sdmmc2.c                    |    9 +-
 drivers/mtd/Kconfig                           |   15 +
 drivers/mtd/Makefile                          |    2 +
 drivers/mtd/cfi_flash.c                       |  290 +-
 drivers/mtd/cfi_mtd.c                         |    3 +-
 drivers/mtd/mtd_uboot.c                       |   14 +-
 drivers/mtd/nand/raw/stm32_fmc2_nand.c        |   47 +-
 drivers/mtd/sfdp_flash.c                      |   85 +
 drivers/mtd/spi/spi-nor-core.c                |    9 +
 drivers/mtd/stm32_hyperbus.c                  |  356 ++
 drivers/net/dwc_eth_qos.c                     |  159 +-
 drivers/net/dwc_eth_qos.h                     |   15 +-
 drivers/phy/Kconfig                           |    8 +
 drivers/phy/Makefile                          |    1 +
 drivers/phy/phy-stm32-usb2phy.c               |  726 ++++
 drivers/phy/phy-stm32-usbphyc.c               |   19 +
 drivers/phy/phy-uclass.c                      |   16 +
 drivers/pinctrl/Kconfig                       |    8 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/pinctrl-mcp23017.c            |  411 ++
 drivers/pinctrl/pinctrl-stmfx.c               |    4 +-
 drivers/pinctrl/pinctrl_stm32.c               |  149 +-
 drivers/power/regulator/scmi_regulator.c      |    2 +-
 drivers/ram/stm32mp1/stm32mp1_ram.c           |    3 +-
 drivers/remoteproc/Kconfig                    |    8 +
 drivers/remoteproc/Makefile                   |    1 +
 drivers/remoteproc/rproc-optee.c              |  239 ++
 drivers/remoteproc/stm32_copro.c              |  294 +-
 drivers/reset/Kconfig                         |   10 +-
 drivers/reset/Makefile                        |    4 +-
 drivers/reset/reset-scmi.c                    |    2 +-
 drivers/reset/reset-uclass.c                  |    4 -
 drivers/reset/stm32-reset.c                   |   98 -
 drivers/reset/stm32/Kconfig                   |   30 +
 drivers/reset/stm32/Makefile                  |   10 +
 drivers/reset/stm32/stm32-reset-core.c        |   92 +
 drivers/reset/stm32/stm32-reset-mp1.c         |   55 +
 drivers/reset/stm32/stm32-reset-mp21.c        |  136 +
 drivers/reset/stm32/stm32-reset-mp25.c        |  159 +
 drivers/reset/stm32/stm32-reset.c             |   43 +
 drivers/rng/Kconfig                           |    8 +-
 drivers/rng/Makefile                          |    2 +-
 drivers/rng/stm32_rng.c                       |  445 +++
 drivers/rng/stm32mp1_rng.c                    |  198 -
 drivers/rtc/stm32_rtc.c                       |   57 +-
 drivers/serial/serial_stm32.c                 |   46 +-
 drivers/serial/serial_stm32.h                 |    2 +-
 drivers/spi/Kconfig                           |    8 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-mem.c                         |    8 -
 drivers/spi/stm32_ospi.c                      |  738 ++++
 drivers/spi/stm32_qspi.c                      |    4 +-
 drivers/tee/optee/core.c                      |   12 +-
 drivers/usb/Kconfig                           |    2 +
 drivers/usb/cdns3/core.h                      |    6 -
 drivers/usb/dwc3/core.c                       |   40 +-
 drivers/usb/dwc3/dwc3-generic.c               |   79 +-
 drivers/usb/dwc3/gadget.c                     |    4 +
 drivers/usb/gadget/dwc2_udc_otg.c             |   60 +-
 drivers/usb/gadget/dwc2_udc_otg_regs.h        |   24 +-
 drivers/usb/gadget/f_mass_storage.c           |    1 +
 drivers/usb/host/Kconfig                      |   14 +
 drivers/usb/host/Makefile                     |    3 +
 drivers/usb/host/dwc2.c                       |   18 +-
 drivers/usb/host/dwc2.h                       |    4 +
 drivers/usb/host/ehci-generic.c               |    6 +
 drivers/usb/host/ehci-hcd.c                   |   22 +-
 drivers/usb/host/ohci-generic.c               |   96 +-
 drivers/usb/host/ohci-hcd.c                   |    3 +-
 drivers/usb/host/usb-uclass.c                 |   36 +
 drivers/usb/host/usbh-stm32.c                 |  108 +
 drivers/usb/typec/Kconfig                     |   24 +
 drivers/usb/typec/Makefile                    |    5 +
 drivers/usb/typec/typec-stusb160x.c           |  130 +
 drivers/usb/typec/typec-uclass.c              |  127 +
 drivers/usb/typec/ucsi/Kconfig                |   26 +
 drivers/usb/typec/ucsi/Makefile               |    4 +
 drivers/usb/typec/ucsi/ucsi-stm32g0.c         |  117 +
 drivers/usb/typec/ucsi/ucsi-uclass.c          |  393 ++
 drivers/video/Kconfig                         |    9 +
 drivers/video/Makefile                        |    1 +
 drivers/video/dw_mipi_dsi.c                   |  118 +-
 drivers/video/rocktech-hx8394.c               |  250 ++
 drivers/video/simple_panel.c                  |    2 +
 drivers/video/stm32/Kconfig                   |    9 +
 drivers/video/stm32/Makefile                  |    1 +
 drivers/video/stm32/stm32_dsi.c               |  607 ++-
 drivers/video/stm32/stm32_ltdc.c              |  525 ++-
 drivers/video/stm32/stm32_lvds.c              |  716 ++++
 drivers/watchdog/arm_smc_wdt.c                |   17 +
 drivers/watchdog/stm32mp_wdt.c                |   33 +
 drivers/watchdog/wdt-uclass.c                 |   13 +-
 dts/Makefile                                  |   12 +-
 env/common.c                                  |    3 +-
 env/flash.c                                   |  220 +-
 env/mmc.c                                     |    7 +
 include/asm-generic/gpio.h                    |    1 +
 include/clk.h                                 |   26 +-
 include/configs/stm32f746-disco.h             |    7 +-
 include/configs/stm32mp13_common.h            |   46 +-
 include/configs/stm32mp13_st_common.h         |   35 +
 include/configs/stm32mp15_common.h            |   14 +-
 include/configs/stm32mp15_dh_dhsom.h          |   25 +-
 include/configs/stm32mp15_st_common.h         |    5 +-
 include/configs/stm32mp21_common.h            |  130 +
 include/configs/stm32mp21_st_common.h         |   51 +
 include/configs/stm32mp23_common.h            |  130 +
 include/configs/stm32mp23_st_common.h         |   51 +
 include/configs/stm32mp25_common.h            |  130 +
 include/configs/stm32mp25_st_common.h         |   51 +
 include/dm/pinctrl.h                          |    2 +-
 include/dm/uclass-id.h                        |    2 +
 include/dt-bindings/arm/coresight-cti-dt.h    |   37 +
 include/dt-bindings/bus/stm32mp13_sys_bus.h   |   60 +
 include/dt-bindings/bus/stm32mp15_sys_bus.h   |   98 +
 include/dt-bindings/clock/st,stm32mp21-rcc.h  |  430 +++
 include/dt-bindings/clock/st,stm32mp25-rcc.h  |  532 +++
 include/dt-bindings/clock/stm32mp1-clks.h     |    8 +-
 include/dt-bindings/clock/stm32mp13-clks.h    |   10 +-
 include/dt-bindings/clock/stm32mp2-clksrc.h   |   89 +
 include/dt-bindings/gpio/gpio.h               |    3 +
 include/dt-bindings/mfd/stm32f7-rcc.h         |    1 +
 include/dt-bindings/pinctrl/stm32-pinfunc.h   |    7 +
 include/dt-bindings/pinctrl/stm32mp15-hdp.h   |  116 +
 .../dt-bindings/power/st,stm32mp25-power.h    |   11 +
 .../regulator/st,stm32mp13-regulator.h        |   42 +
 .../regulator/st,stm32mp21-regulator.h        |   48 +
 .../regulator/st,stm32mp25-regulator.h        |   48 +
 include/dt-bindings/reset/st,stm32mp21-rcc.h  |  141 +
 include/dt-bindings/reset/st,stm32mp25-rcc.h  |  167 +
 include/dt-bindings/reset/stm32mp1-resets.h   |    2 +-
 include/dt-bindings/reset/stm32mp13-resets.h  |    2 +-
 include/dt-bindings/rtc/rtc-stm32.h           |   14 +
 include/dt-bindings/soc/stm32-hdp.h           |  108 +
 include/dt-bindings/soc/stm32mp13-hdp.h       |  133 +
 include/flash.h                               |    2 +
 include/fwu.h                                 |  160 +-
 include/fwu_mdata.h                           |   71 +-
 include/generic-phy.h                         |   16 +
 include/linux/clk-provider.h                  |    9 +-
 include/linux/ioport.h                        |   16 +
 include/linux/mtd/spi-nor.h                   |    1 +
 include/linux/usb/otg.h                       |    6 +
 include/mtd/cfi_flash.h                       |    1 +
 include/mtd/sfdp_flash.h                      |   11 +
 include/netdev.h                              |    2 +-
 include/reset.h                               |    9 +-
 include/rproc_optee.h                         |  127 +
 include/spi-mem.h                             |    3 +
 include/st_logo_data.h                        | 3265 ----------------
 include/stm32-reset-core.h                    |   31 +
 include/stm32_omi.h                           |  182 +
 include/stm32_rcc.h                           |    7 +-
 .../clk/stm32 => include}/stm32mp13_rcc.h     |    0
 include/stm32mp21_rcc.h                       |  652 ++++
 include/stm32mp25_rcc.h                       |  712 ++++
 include/typec.h                               |  154 +
 include/ucsi.h                                |  112 +
 include/usb.h                                 |    6 +
 include/usb/dwc2_udc.h                        |    2 +
 include/wdt.h                                 |    9 +
 lib/efi_loader/efi_capsule.c                  |   14 +-
 lib/efi_loader/efi_disk.c                     |    4 +-
 lib/efi_loader/efi_firmware.c                 |   11 +-
 lib/fwu_updates/Kconfig                       |   14 +
 lib/fwu_updates/Makefile                      |    2 +
 lib/fwu_updates/fwu.c                         |  248 +-
 lib/fwu_updates/fwu_mtd.c                     |   34 +-
 lib/fwu_updates/fwu_v1.c                      |  167 +
 lib/fwu_updates/fwu_v2.c                      |  260 ++
 lib/lmb.c                                     |   55 +-
 scripts/Makefile.lib                          |    2 +
 scripts/dtc/pylibfdt/setup.py                 |    2 +-
 test/dm/clk_ccf.c                             |   26 +-
 test/dm/fwu_mdata.c                           |   17 +-
 test/dm/gpio.c                                |    5 +
 test/dm/reset.c                               |   22 +
 test/py/tests/test_pinmux.py                  |   40 +-
 tools/buildman/bsettings.py                   |    2 +-
 tools/eficapsule.h                            |    2 +
 tools/mkeficapsule.c                          |  223 +-
 tools/mkfwumdata.c                            |  235 +-
 440 files changed, 52750 insertions(+), 8987 deletions(-)
 create mode 100644 CODE_OF_CONDUCT.md
 create mode 100644 CONTRIBUTING.md
 create mode 100644 SECURITY.md
 create mode 100644 arch/arm/dts/stm32mp13xa.dtsi
 create mode 100644 arch/arm/dts/stm32mp13xd.dtsi
 create mode 100644 arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp15-m4-srm.dtsi
 delete mode 100644 arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157a-dk1-scmi.dts => stm32mp157a-dk1-scmi.dtsi} (79%)
 create mode 100644 arch/arm/dts/stm32mp157a-ed1-scmi.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ed1.dts
 create mode 100644 arch/arm/dts/stm32mp157a-ev1-scmi.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ev1.dts
 delete mode 100644 arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157c-dk2-scmi.dts => stm32mp157c-dk2-scmi.dtsi} (78%)
 delete mode 100644 arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157c-ed1-scmi.dts => stm32mp157c-ed1-scmi.dtsi} (74%)
 delete mode 100644 arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157c-ev1-scmi.dts => stm32mp157c-ev1-scmi.dtsi} (78%)
 create mode 100644 arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157d-dk1.dts
 create mode 100644 arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157d-ed1.dts
 create mode 100644 arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157d-ev1.dts
 create mode 100644 arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157f-dk2.dts
 create mode 100644 arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157f-ed1.dts
 create mode 100644 arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157f-ev1.dts
 create mode 100644 arch/arm/dts/stm32mp15xa.dtsi
 create mode 100644 arch/arm/dts/stm32mp15xd.dtsi
 create mode 100644 arch/arm/dts/stm32mp15xf.dtsi
 create mode 100644 arch/arm/dts/stm32mp21-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp21-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp211.dtsi
 create mode 100644 arch/arm/dts/stm32mp213.dtsi
 create mode 100644 arch/arm/dts/stm32mp215.dtsi
 create mode 100644 arch/arm/dts/stm32mp215f-dk-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm/dts/stm32mp215f-dk-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp215f-dk.dts
 create mode 100644 arch/arm/dts/stm32mp21xc.dtsi
 create mode 100644 arch/arm/dts/stm32mp21xf.dtsi
 create mode 100644 arch/arm/dts/stm32mp21xxal-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp21xxam-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp21xxan-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp21xxao-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp23-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp231.dtsi
 create mode 100644 arch/arm/dts/stm32mp233.dtsi
 create mode 100644 arch/arm/dts/stm32mp235.dtsi
 create mode 100644 arch/arm/dts/stm32mp235f-dk-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm/dts/stm32mp235f-dk-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp235f-dk.dts
 create mode 100644 arch/arm/dts/stm32mp23xc.dtsi
 create mode 100644 arch/arm/dts/stm32mp23xf.dtsi
 create mode 100644 arch/arm/dts/stm32mp25-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp251.dtsi
 create mode 100644 arch/arm/dts/stm32mp253.dtsi
 create mode 100644 arch/arm/dts/stm32mp255.dtsi
 create mode 100644 arch/arm/dts/stm32mp257.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-dk-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-dk.dts
 create mode 100644 arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-ev1.dts
 create mode 100644 arch/arm/dts/stm32mp25xc.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xf.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxai-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxaj-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxak-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxal-pinctrl.dtsi
 create mode 100644 arch/arm/mach-stm32mp/Kconfig.21x
 create mode 100644 arch/arm/mach-stm32mp/Kconfig.23x
 create mode 100644 arch/arm/mach-stm32mp/Kconfig.25x
 create mode 100644 arch/arm/mach-stm32mp/etzpc.c
 delete mode 100644 arch/arm/mach-stm32mp/fdt.c
 create mode 100644 arch/arm/mach-stm32mp/include/mach/etzpc.h
 create mode 100644 arch/arm/mach-stm32mp/include/mach/rif.h
 create mode 100644 arch/arm/mach-stm32mp/nvram.c
 create mode 100644 arch/arm/mach-stm32mp/soc.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp1/Makefile
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/cpu.c (86%)
 create mode 100644 arch/arm/mach-stm32mp/stm32mp1/fdt.c
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/psci.c (100%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/pwr_regulator.c (96%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/spl.c (98%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/stm32mp13x.c (100%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/stm32mp15x.c (99%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/tzc400.c (100%)
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/Makefile
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/cpu.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/fdt.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/rifsc.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/stm32mp21x.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/stm32mp23x.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c
 create mode 100644 board/st/common/stm32mp_dfu_virt.c
 delete mode 100644 board/st/common/stusb160x.c
 delete mode 100644 board/st/common/stusb160x.h
 create mode 100644 board/st/stm32mp2/Kconfig
 create mode 100644 board/st/stm32mp2/MAINTAINERS
 create mode 100644 board/st/stm32mp2/Makefile
 create mode 100644 board/st/stm32mp2/README
 create mode 100644 board/st/stm32mp2/stm32mp2.c
 create mode 100644 configs/stm32mp21_defconfig
 create mode 100644 configs/stm32mp23_defconfig
 create mode 100644 configs/stm32mp25_defconfig
 create mode 100644 doc/board/st/stm32mp2.rst
 create mode 100644 drivers/clk/stm32/clk-stm32mp21.c
 create mode 100644 drivers/clk/stm32/clk-stm32mp25.c
 create mode 100644 drivers/memory/stm32-omi.c
 create mode 100644 drivers/misc/stm32_omm.c
 create mode 100644 drivers/mtd/sfdp_flash.c
 create mode 100644 drivers/mtd/stm32_hyperbus.c
 create mode 100644 drivers/phy/phy-stm32-usb2phy.c
 create mode 100644 drivers/pinctrl/pinctrl-mcp23017.c
 create mode 100644 drivers/remoteproc/rproc-optee.c
 delete mode 100644 drivers/reset/stm32-reset.c
 create mode 100644 drivers/reset/stm32/Kconfig
 create mode 100644 drivers/reset/stm32/Makefile
 create mode 100644 drivers/reset/stm32/stm32-reset-core.c
 create mode 100644 drivers/reset/stm32/stm32-reset-mp1.c
 create mode 100644 drivers/reset/stm32/stm32-reset-mp21.c
 create mode 100644 drivers/reset/stm32/stm32-reset-mp25.c
 create mode 100644 drivers/reset/stm32/stm32-reset.c
 create mode 100644 drivers/rng/stm32_rng.c
 delete mode 100644 drivers/rng/stm32mp1_rng.c
 create mode 100644 drivers/spi/stm32_ospi.c
 create mode 100644 drivers/usb/host/usbh-stm32.c
 create mode 100644 drivers/usb/typec/Kconfig
 create mode 100644 drivers/usb/typec/Makefile
 create mode 100644 drivers/usb/typec/typec-stusb160x.c
 create mode 100644 drivers/usb/typec/typec-uclass.c
 create mode 100644 drivers/usb/typec/ucsi/Kconfig
 create mode 100644 drivers/usb/typec/ucsi/Makefile
 create mode 100644 drivers/usb/typec/ucsi/ucsi-stm32g0.c
 create mode 100644 drivers/usb/typec/ucsi/ucsi-uclass.c
 create mode 100644 drivers/video/rocktech-hx8394.c
 create mode 100644 drivers/video/stm32/stm32_lvds.c
 create mode 100644 include/configs/stm32mp21_common.h
 create mode 100644 include/configs/stm32mp21_st_common.h
 create mode 100644 include/configs/stm32mp23_common.h
 create mode 100644 include/configs/stm32mp23_st_common.h
 create mode 100644 include/configs/stm32mp25_common.h
 create mode 100644 include/configs/stm32mp25_st_common.h
 create mode 100644 include/dt-bindings/arm/coresight-cti-dt.h
 create mode 100644 include/dt-bindings/bus/stm32mp13_sys_bus.h
 create mode 100644 include/dt-bindings/bus/stm32mp15_sys_bus.h
 create mode 100644 include/dt-bindings/clock/st,stm32mp21-rcc.h
 create mode 100644 include/dt-bindings/clock/st,stm32mp25-rcc.h
 create mode 100644 include/dt-bindings/clock/stm32mp2-clksrc.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp15-hdp.h
 create mode 100644 include/dt-bindings/power/st,stm32mp25-power.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp13-regulator.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp21-regulator.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp25-regulator.h
 create mode 100644 include/dt-bindings/reset/st,stm32mp21-rcc.h
 create mode 100644 include/dt-bindings/reset/st,stm32mp25-rcc.h
 create mode 100644 include/dt-bindings/rtc/rtc-stm32.h
 create mode 100644 include/dt-bindings/soc/stm32-hdp.h
 create mode 100644 include/dt-bindings/soc/stm32mp13-hdp.h
 create mode 100644 include/mtd/sfdp_flash.h
 create mode 100644 include/rproc_optee.h
 delete mode 100644 include/st_logo_data.h
 create mode 100644 include/stm32-reset-core.h
 create mode 100644 include/stm32_omi.h
 rename {drivers/clk/stm32 => include}/stm32mp13_rcc.h (100%)
 create mode 100644 include/stm32mp21_rcc.h
 create mode 100644 include/stm32mp25_rcc.h
 create mode 100644 include/typec.h
 create mode 100644 include/ucsi.h
 create mode 100644 lib/fwu_updates/fwu_v1.c
 create mode 100644 lib/fwu_updates/fwu_v2.c

diff --git a/.gitignore b/.gitignore
index 002f95de4f..261a1d6754 100644
--- a/.gitignore
+++ b/.gitignore
@@ -109,3 +109,6 @@ __pycache__
 
 # moveconfig database
 /moveconfig.db
+
+# Clang's compilation database file
+/compile_commands.json
diff --git a/CODE_OF_CONDUCT.md b/CODE_OF_CONDUCT.md
new file mode 100644
index 0000000000..bf0ca35d95
--- /dev/null
+++ b/CODE_OF_CONDUCT.md
@@ -0,0 +1,73 @@
+# Contributor Covenant Code of Conduct
+
+## Our Pledge
+
+In the interest of fostering an open and welcoming environment, we as
+contributors and maintainers pledge to making participation in our project and
+our community a harassment-free experience for everyone, regardless of age, body
+size, disability, ethnicity, sex characteristics, gender identity and expression,
+level of experience, education, socio-economic status, nationality, personal
+appearance, race, religion, or sexual identity and orientation.
+
+## Our Standards
+
+Examples of behavior that contributes to creating a positive environment
+include:
+
+* Using welcoming and inclusive language
+* Being respectful of differing viewpoints and experiences
+* Gracefully accepting constructive criticism
+* Focusing on what is best for the community
+* Showing empathy towards other community members
+
+Examples of unacceptable behavior by participants include:
+
+* The use of sexualized language or imagery and unwelcome sexual attention or
+ advances
+* Trolling, insulting/derogatory comments, and personal or political attacks
+* Public or private harassment
+* Publishing others' private information, such as a physical or electronic
+ address, without explicit permission
+* Other conduct which could reasonably be considered inappropriate in a
+ professional setting
+
+## Our Responsibilities
+
+Project maintainers are responsible for clarifying the standards of acceptable
+behavior and are expected to take appropriate and fair corrective action in
+response to any instances of unacceptable behavior.
+
+Project maintainers have the right and responsibility to remove, edit, or
+reject comments, commits, code, wiki edits, issues, and other contributions
+that are not aligned to this Code of Conduct, or to ban temporarily or
+permanently any contributor for other behaviors that they deem inappropriate,
+threatening, offensive, or harmful.
+
+## Scope
+
+This Code of Conduct applies both within project spaces and in public spaces
+when an individual is representing the project or its community. Examples of
+representing a project or community include using an official project e-mail
+address, posting via an official social media account, or acting as an appointed
+representative at an online or offline event. Representation of a project may be
+further defined and clarified by project maintainers.
+
+## Enforcement
+
+Instances of abusive, harassing, or otherwise unacceptable behavior may be
+reported by contacting the project team via this [link](https://www.st.com/content/st_com/en/contact-us.html).
+All complaints will be reviewed and investigated and will result in a response that
+is deemed necessary and appropriate to the circumstances. The project team is
+obligated to maintain confidentiality with regard to the reporter of an incident.
+Further details of specific enforcement policies may be posted separately.
+
+Project maintainers who do not follow or enforce the Code of Conduct in good
+faith may face temporary or permanent repercussions as determined by other
+members of the project's leadership.
+
+## Attribution
+
+This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4,
+available [here](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html).
+
+For answers to common questions about this code of conduct, refer to the FAQ section [here](https://www.contributor-covenant.org/faq).
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000000..3d1bacd78a
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+﻿# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/MAINTAINERS b/MAINTAINERS
index 1999191620..592aab68dc 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -621,17 +621,20 @@ F:	drivers/ram/stm32mp1/
 F:	drivers/remoteproc/stm32_copro.c
 F:	drivers/reset/stm32-reset.c
 F:	drivers/rng/optee_rng.c
-F:	drivers/rng/stm32mp1_rng.c
+F:	drivers/rng/stm32_rng.c
 F:	drivers/rtc/stm32_rtc.c
 F:	drivers/serial/serial_stm32.*
 F:	drivers/spi/stm32_qspi.c
 F:	drivers/spi/stm32_spi.c
 F:	drivers/video/stm32/stm32_ltdc.c
 F:	drivers/watchdog/stm32mp_wdt.c
+F:	include/dt-bindings/bus/stm32mp*
 F:	include/dt-bindings/clock/stm32fx-clock.h
 F:	include/dt-bindings/clock/stm32mp*
 F:	include/dt-bindings/pinctrl/stm32-pinfunc.h
 F:	include/dt-bindings/reset/stm32mp*
+F:	include/dt-bindings/rtc/rtc-stm32.h
+F:	include/dt-bindings/soc/stm32*
 F:	include/stm32_rcc.h
 F:	tools/logos/st.bmp
 F:	tools/stm32image.c
@@ -1096,6 +1099,14 @@ T:	git https://source.denx.de/u-boot/custodians/u-boot-fsl-qoriq.git
 F:	drivers/watchdog/sp805_wdt.c
 F:	drivers/watchdog/sbsa_gwdt.c
 
+FWU Multi Bank Update
+M:	Sughosh Ganu <sughosh.ganu@linaro.org>
+S:	Maintained
+T:	git https://source.denx.de/u-boot/custodians/u-boot-efi.git
+F:	lib/fwu_updates/*
+F:	drivers/fwu-mdata/*
+F:	tools/mkfwumdata.c
+
 GATEWORKS_SC
 M:	Tim Harvey <tharvey@gateworks.com>
 S:	Maintained
diff --git a/Makefile b/Makefile
index ac65605a26..f2fd2befd1 100644
--- a/Makefile
+++ b/Makefile
@@ -3,7 +3,7 @@
 VERSION = 2023
 PATCHLEVEL = 10
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -stm32mp-r1
 NAME =
 
 # *DOCUMENTATION*
@@ -485,6 +485,11 @@ export RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o    \
 export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
 			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
 
+# handle external device tree
+
+EXT_DTS ?= $(srctree)/arch/$(ARCH)/dts/external-dt/u-boot
+export EXT_DTS
+
 # ===========================================================================
 # Rules shared between *config targets and build targets
 
@@ -868,6 +873,7 @@ libs-y += drivers/usb/musb/
 libs-y += drivers/usb/musb-new/
 libs-y += drivers/usb/isp1760/
 libs-y += drivers/usb/phy/
+libs-y += drivers/usb/typec/
 libs-y += drivers/usb/ulpi/
 ifdef CONFIG_POST
 libs-y += post/
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 0000000000..4b3e4e6ba5
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,8 @@
+# Report potential product security vulnerabilities
+ST places a high priority on security, and our Product Security Incident Response Team (PSIRT) is committed to rapidly addressing potential security vulnerabilities affecting our products. PSIRT's long history and vast experience in security allows ST to perform clear analyses and provide appropriate guidance on mitigations  and solutions when applicable.
+If you wish to report potential security vulnerabilities regarding our products, **please do not report them through public GitHub issues.** Instead, we encourage you to report them to our ST PSIRT following the process described at: **https://www.st.com/content/st_com/en/security/report-vulnerabilities.html**
+
+### IMPORTANT - READ CAREFULLY:
+STMicroelectronics International N.V., on behalf of itself, its affiliates and  subsidiaries, (collectively “ST”) takes all potential security vulnerability reports or other related communications (“Report(s)”)  seriously. In order to review Your Report (the terms “You” and “Yours”  include your employer, and all affiliates, subsidiaries and related  persons or entities) and take actions as deemed appropriate, ST requires that we have the rights and Your permission to do so.
+As such, by submitting Your Report to ST, You agree that You have the right to do so, and You grant to ST the rights to use the Report for purposes related to security vulnerability analysis, testing, correction, patching, reporting and any other related purpose or function.
+By submitting Your Report, You agree that ST’s [Privacy Policy](https://www.st.com/content/st_com/en/common/privacy-portal.html) applies to all related communications.
diff --git a/arch/Kconfig b/arch/Kconfig
index c9a3359225..e418667ce7 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -450,7 +450,7 @@ endmenu
 
 config SYS_HAS_NONCACHED_MEMORY
 	bool "Enable reserving a non-cached memory area for drivers"
-	depends on (ARM || MIPS) && (RTL8169 || MEDIATEK_ETH)
+	depends on (ARM || MIPS) && (RTL8169 || MEDIATEK_ETH || DWC_ETH_QOS)
 	help
 	  This is useful for drivers that would otherwise require a lot of
 	  explicit cache maintenance. For some drivers it's also impossible to
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 328e2ddc33..1b8b833b97 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1932,7 +1932,7 @@ config ARCH_STM32MP
 	select REGMAP
 	select SYSCON
 	select SYSRESET
-	select SYS_THUMB_BUILD
+	select SYS_THUMB_BUILD if !ARM64
 	imply SPL_SYSRESET
 	imply CMD_DM
 	imply CMD_POWEROFF
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 85fd5b1157..0fd5fee226 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -1282,23 +1282,27 @@ dtb-$(CONFIG_ASPEED_AST2600) += ast2600-evb.dtb
 
 dtb-$(CONFIG_ARCH_STI) += stih410-b2260.dtb
 
-dtb-$(CONFIG_STM32MP13x) += \
+dtb-$(CONFIG_STM32MP13X) += \
 	stm32mp135f-dk.dtb
 
-dtb-$(CONFIG_STM32MP15x) += \
+dtb-$(CONFIG_STM32MP15X) += \
 	stm32mp157a-dk1.dtb \
-	stm32mp157a-dk1-scmi.dtb \
+	stm32mp157a-ed1.dtb \
+	stm32mp157a-ev1.dtb \
 	stm32mp157a-icore-stm32mp1-ctouch2.dtb \
 	stm32mp157a-icore-stm32mp1-edimm2.2.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dtb \
 	stm32mp157c-dk2.dtb \
-	stm32mp157c-dk2-scmi.dtb \
 	stm32mp157c-ed1.dtb \
-	stm32mp157c-ed1-scmi.dtb \
 	stm32mp157c-ev1.dtb \
-	stm32mp157c-ev1-scmi.dtb \
 	stm32mp157c-odyssey.dtb \
+	stm32mp157d-dk1.dtb \
+	stm32mp157d-ed1.dtb \
+	stm32mp157d-ev1.dtb \
+	stm32mp157f-dk2.dtb \
+	stm32mp157f-ed1.dtb \
+	stm32mp157f-ev1.dtb \
 	stm32mp15xx-dhcom-drc02.dtb \
 	stm32mp15xx-dhcom-pdk2.dtb \
 	stm32mp15xx-dhcom-picoitx.dtb \
@@ -1306,6 +1310,16 @@ dtb-$(CONFIG_STM32MP15x) += \
 	stm32mp15xx-dhcor-drc-compact.dtb \
 	stm32mp15xx-dhcor-testbench.dtb
 
+dtb-$(CONFIG_STM32MP21X) += \
+	stm32mp215f-dk.dtb
+
+dtb-$(CONFIG_STM32MP23X) += \
+	stm32mp235f-dk.dtb
+
+dtb-$(CONFIG_STM32MP25X) += \
+	stm32mp257f-dk.dtb \
+	stm32mp257f-ev1.dtb
+
 dtb-$(CONFIG_SOC_K3_AM654) += \
 	k3-am654-base-board.dtb \
 	k3-am654-r5-base-board.dtb \
diff --git a/arch/arm/dts/stm32429i-eval.dts b/arch/arm/dts/stm32429i-eval.dts
index 592b182c1a..ab3bbc0a84 100644
--- a/arch/arm/dts/stm32429i-eval.dts
+++ b/arch/arm/dts/stm32429i-eval.dts
@@ -9,6 +9,7 @@
 #include "stm32f429-pinctrl.dtsi"
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/media/video-interfaces.h>
 
 / {
 	model = "STMicroelectronics STM32429i-EVAL board";
@@ -19,7 +20,7 @@
 		stdout-path = "serial0:115200n8";
 	};
 
-	memory@00000000 {
+	memory@0 {
 		device_type = "memory";
 		reg = <0x00000000 0x2000000>;
 	};
@@ -78,17 +79,15 @@
 		};
 	};
 
-	gpio_keys {
+	gpio-keys {
 		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
 		autorepeat;
-		button@0 {
+		button-0 {
 			label = "Wake up";
 			linux,code = <KEY_WAKEUP>;
 			gpios = <&gpioa 0 0>;
 		};
-		button@1 {
+		button-1 {
 			label = "Tamper";
 			linux,code = <KEY_RESTART>;
 			gpios = <&gpioc 13 0>;
@@ -147,6 +146,7 @@
 	port {
 		dcmi_0: endpoint {
 			remote-endpoint = <&ov2640_0>;
+			bus-type = <MEDIA_BUS_TYPE_PARALLEL>;
 			bus-width = <8>;
 			hsync-active = <0>;
 			vsync-active = <0>;
@@ -211,10 +211,10 @@
 
 &mac {
 	status = "okay";
-	pinctrl-0	= <&ethernet_mii>;
-	pinctrl-names	= "default";
-	phy-mode	= "mii";
-	phy-handle	= <&phy1>;
+	pinctrl-0 = <&ethernet_mii>;
+	pinctrl-names = "default";
+	phy-mode = "mii";
+	phy-handle = <&phy1>;
 	mdio0 {
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -268,6 +268,18 @@
 	};
 };
 
+&timers5 {
+	/* Override timer5 to act as clockevent */
+	compatible = "st,stm32-timer";
+	interrupts = <50>;
+	status = "okay";
+	/delete-property/#address-cells;
+	/delete-property/#size-cells;
+	/delete-property/clock-names;
+	/delete-node/pwm;
+	/delete-node/timer@4;
+};
+
 &usart1 {
 	pinctrl-0 = <&usart1_pins_a>;
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/stm32f4-pinctrl.dtsi b/arch/arm/dts/stm32f4-pinctrl.dtsi
index 46815c965d..bd46861bc9 100644
--- a/arch/arm/dts/stm32f4-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f4-pinctrl.dtsi
@@ -15,7 +15,6 @@
 			ranges = <0 0x40020000 0x3000>;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&syscfg 0x8>;
-			pins-are-numbered;
 
 			gpioa: gpio@40020000 {
 				gpio-controller;
@@ -412,6 +411,36 @@
 					slew-rate = <2>;
 				};
 			};
+
+			can1_pins_a: can1-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 9, AF9)>; /* CAN1_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 8, AF9)>; /* CAN1_RX */
+					bias-pull-up;
+				};
+			};
+
+			can2_pins_a: can2-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 13, AF9)>; /* CAN2_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 5, AF9)>; /* CAN2_RX */
+					bias-pull-up;
+				};
+			};
+
+			can2_pins_b: can2-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 13, AF9)>; /* CAN2_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 12, AF9)>; /* CAN2_RX */
+					bias-pull-up;
+				};
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32f429-disco.dts b/arch/arm/dts/stm32f429-disco.dts
index 30daabd10a..541b890def 100644
--- a/arch/arm/dts/stm32f429-disco.dts
+++ b/arch/arm/dts/stm32f429-disco.dts
@@ -148,7 +148,7 @@
 		status = "okay";
 	};
 
-	display: display@1{
+	display: display@1 {
 		/* Connect panel-ilitek-9341 to ltdc */
 		compatible = "st,sf-tc240t-9370-t", "ilitek,ili9341";
 		reg = <1>;
diff --git a/arch/arm/dts/stm32f429.dtsi b/arch/arm/dts/stm32f429.dtsi
index e5b13aca40..0c6da7d554 100644
--- a/arch/arm/dts/stm32f429.dtsi
+++ b/arch/arm/dts/stm32f429.dtsi
@@ -4,7 +4,7 @@
  *
  */
 
-#include "armv7-m.dtsi"
+#include "../armv7-m.dtsi"
 #include <dt-bindings/clock/stm32fx-clock.h>
 #include <dt-bindings/mfd/stm32f4-rcc.h>
 
@@ -321,6 +321,36 @@
 			status = "disabled";
 		};
 
+		can1: can@40006400 {
+			compatible = "st,stm32f4-bxcan";
+			reg = <0x40006400 0x200>;
+			interrupts = <19>, <20>, <21>, <22>;
+			interrupt-names = "tx", "rx0", "rx1", "sce";
+			resets = <&rcc STM32F4_APB1_RESET(CAN1)>;
+			clocks = <&rcc 0 STM32F4_APB1_CLOCK(CAN1)>;
+			st,can-primary;
+			st,gcan = <&gcan>;
+			status = "disabled";
+		};
+
+		gcan: gcan@40006600 {
+			compatible = "st,stm32f4-gcan", "syscon";
+			reg = <0x40006600 0x200>;
+			clocks = <&rcc 0 STM32F4_APB1_CLOCK(CAN1)>;
+		};
+
+		can2: can@40006800 {
+			compatible = "st,stm32f4-bxcan";
+			reg = <0x40006800 0x200>;
+			interrupts = <63>, <64>, <65>, <66>;
+			interrupt-names = "tx", "rx0", "rx1", "sce";
+			resets = <&rcc STM32F4_APB1_RESET(CAN2)>;
+			clocks = <&rcc 0 STM32F4_APB1_CLOCK(CAN2)>;
+			st,can-secondary;
+			st,gcan = <&gcan>;
+			status = "disabled";
+		};
+
 		dac: dac@40007400 {
 			compatible = "st,stm32f4-dac-core";
 			reg = <0x40007400 0x400>;
diff --git a/arch/arm/dts/stm32f469-disco.dts b/arch/arm/dts/stm32f469-disco.dts
index 6e0ffc1903..c9acabf0f5 100644
--- a/arch/arm/dts/stm32f469-disco.dts
+++ b/arch/arm/dts/stm32f469-disco.dts
@@ -119,7 +119,7 @@
 		};
 	};
 
-	panel-dsi@0 {
+	panel@0 {
 		compatible = "orisetech,otm8009a";
 		reg = <0>; /* dsi virtual channel (0..3) */
 		reset-gpios = <&gpioh 7 GPIO_ACTIVE_LOW>;
@@ -138,7 +138,7 @@
 	status = "okay";
 
 	port {
-		ltdc_out_dsi: endpoint@0 {
+		ltdc_out_dsi: endpoint {
 			remote-endpoint = <&dsi_in>;
 		};
 	};
diff --git a/arch/arm/dts/stm32f7-pinctrl.dtsi b/arch/arm/dts/stm32f7-pinctrl.dtsi
index 8f37aefa73..842f2b17c4 100644
--- a/arch/arm/dts/stm32f7-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f7-pinctrl.dtsi
@@ -15,7 +15,6 @@
 			ranges = <0 0x40020000 0x3000>;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&syscfg 0x8>;
-			pins-are-numbered;
 
 			gpioa: gpio@40020000 {
 				gpio-controller;
@@ -172,6 +171,16 @@
 				};
 			};
 
+			i2c3_pins_a: i2c3-0 {
+				pins {
+					pinmux = <STM32_PINMUX('H', 8, AF4)>, /* I2C3_SDA */
+						 <STM32_PINMUX('H', 7, AF4)>; /* I2C3_SCL */
+					bias-disable;
+					drive-open-drain;
+					slew-rate = <0>;
+				};
+			};
+
 			usbotg_hs_pins_a: usbotg-hs-0 {
 				pins {
 					pinmux = <STM32_PINMUX('H', 4, AF10)>, /* OTG_HS_ULPI_NXT */
@@ -284,6 +293,122 @@
 					slew-rate = <2>;
 				};
 			};
+
+			can1_pins_a: can1-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('A', 12, AF9)>; /* CAN1_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('A', 11, AF9)>; /* CAN1_RX */
+					bias-pull-up;
+				};
+			};
+
+			can1_pins_b: can1-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 9, AF9)>; /* CAN1_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 8, AF9)>; /* CAN1_RX */
+					bias-pull-up;
+				};
+			};
+
+			can1_pins_c: can1-2 {
+				pins1 {
+					pinmux = <STM32_PINMUX('D', 1, AF9)>; /* CAN1_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('D', 0, AF9)>; /* CAN1_RX */
+					bias-pull-up;
+
+				};
+			};
+
+			can1_pins_d: can1-3 {
+				pins1 {
+					pinmux = <STM32_PINMUX('H', 13, AF9)>; /* CAN1_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('H', 14, AF9)>; /* CAN1_RX */
+					bias-pull-up;
+
+				};
+			};
+
+			can2_pins_a: can2-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 6, AF9)>; /* CAN2_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 5, AF9)>; /* CAN2_RX */
+					bias-pull-up;
+				};
+			};
+
+			can2_pins_b: can2-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 13, AF9)>; /* CAN2_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 12, AF9)>; /* CAN2_RX */
+					bias-pull-up;
+				};
+			};
+
+			can3_pins_a: can3-0 {
+				pins1 {
+					pinmux = <STM32_PINMUX('A', 15, AF11)>; /* CAN3_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('A', 8, AF11)>; /* CAN3_RX */
+					bias-pull-up;
+				};
+			};
+
+			can3_pins_b: can3-1 {
+				pins1 {
+					pinmux = <STM32_PINMUX('B', 4, AF11)>;  /* CAN3_TX */
+				};
+				pins2 {
+					pinmux = <STM32_PINMUX('B', 3, AF11)>; /* CAN3_RX */
+					bias-pull-up;
+				};
+			};
+
+			ltdc_pins_a: ltdc-0 {
+				pins {
+					pinmux = <STM32_PINMUX('E', 4, AF14)>, /* LCD_B0 */
+						 <STM32_PINMUX('G',12, AF9)>,  /* LCD_B4 */
+						 <STM32_PINMUX('I', 9, AF14)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('I',10, AF14)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I',14, AF14)>, /* LCD_CLK */
+						 <STM32_PINMUX('I',15, AF14)>, /* LCD_R0 */
+						 <STM32_PINMUX('J', 0, AF14)>, /* LCD_R1 */
+						 <STM32_PINMUX('J', 1, AF14)>, /* LCD_R2 */
+						 <STM32_PINMUX('J', 2, AF14)>, /* LCD_R3 */
+						 <STM32_PINMUX('J', 3, AF14)>, /* LCD_R4 */
+						 <STM32_PINMUX('J', 4, AF14)>, /* LCD_R5 */
+						 <STM32_PINMUX('J', 5, AF14)>, /* LCD_R6 */
+						 <STM32_PINMUX('J', 6, AF14)>, /* LCD_R7 */
+						 <STM32_PINMUX('J', 7, AF14)>, /* LCD_G0 */
+						 <STM32_PINMUX('J', 8, AF14)>, /* LCD_G1 */
+						 <STM32_PINMUX('J', 9, AF14)>, /* LCD_G2 */
+						 <STM32_PINMUX('J',10, AF14)>, /* LCD_G3 */
+						 <STM32_PINMUX('J',11, AF14)>, /* LCD_G4 */
+						 <STM32_PINMUX('J',13, AF14)>, /* LCD_B1 */
+						 <STM32_PINMUX('J',14, AF14)>, /* LCD_B2 */
+						 <STM32_PINMUX('J',15, AF14)>, /* LCD_B3 */
+						 <STM32_PINMUX('K', 0, AF14)>, /* LCD_G5 */
+						 <STM32_PINMUX('K', 1, AF14)>, /* LCD_G6 */
+						 <STM32_PINMUX('K', 2, AF14)>, /* LCD_G7 */
+						 <STM32_PINMUX('K', 4, AF14)>, /* LCD_B5 */
+						 <STM32_PINMUX('K', 5, AF14)>, /* LCD_B6 */
+						 <STM32_PINMUX('K', 6, AF14)>, /* LCD_B7 */
+						 <STM32_PINMUX('K', 7, AF14)>; /* LCD_DE */
+					slew-rate = <2>;
+				};
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32f746-disco-u-boot.dtsi b/arch/arm/dts/stm32f746-disco-u-boot.dtsi
index 522cffb1ac..1b42d6cbbc 100644
--- a/arch/arm/dts/stm32f746-disco-u-boot.dtsi
+++ b/arch/arm/dts/stm32f746-disco-u-boot.dtsi
@@ -23,12 +23,6 @@
 		spi0 = &qspi;
 	};
 
-	backlight: backlight {
-		compatible = "gpio-backlight";
-		gpios = <&gpiok 3 0>;
-		status = "okay";
-	};
-
 	button1 {
 		compatible = "st,button1";
 		button-gpio = <&gpioi 11 0>;
@@ -38,44 +32,11 @@
 		compatible = "st,led1";
 		led-gpio = <&gpioi 1 0>;
 	};
+};
 
-	panel-rgb@0 {
-		compatible = "simple-panel";
-		backlight = <&backlight>;
-		enable-gpios = <&gpioi 12 0>;
-		status = "okay";
-
-		display-timings {
-			timing@0 {
-				clock-frequency = <9000000>;
-				hactive = <480>;
-				vactive = <272>;
-				hfront-porch = <2>;
-				hback-porch = <2>;
-				hsync-len = <41>;
-				vfront-porch = <2>;
-				vback-porch = <2>;
-				vsync-len = <10>;
-				hsync-active = <0>;
-				vsync-active = <0>;
-				de-active = <1>;
-				pixelclk-active = <1>;
-			};
-		};
-	};
-
-	soc {
-		ltdc: display-controller@40016800 {
-			compatible = "st,stm32-ltdc";
-			reg = <0x40016800 0x200>;
-			resets = <&rcc STM32F7_APB2_RESET(LTDC)>;
-			clocks = <&rcc 0 STM32F7_APB2_CLOCK(LTDC)>;
-			pinctrl-0 = <&ltdc_pins>;
-
-			status = "okay";
-			bootph-all;
-		};
-	};
+&ltdc {
+	clocks = <&rcc 0 STM32F7_APB2_CLOCK(LTDC)>;
+	bootph-all;
 };
 
 &fmc {
@@ -102,6 +63,28 @@
 	};
 };
 
+&panel_rgb {
+	compatible = "simple-panel";
+
+	display-timings {
+		timing@0 {
+			clock-frequency = <9000000>;
+			hactive = <480>;
+			vactive = <272>;
+			hfront-porch = <2>;
+			hback-porch = <2>;
+			hsync-len = <41>;
+			vfront-porch = <2>;
+			vback-porch = <2>;
+			vsync-len = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <1>;
+		};
+	};
+};
+
 &pinctrl {
 	ethernet_mii: mii@0 {
 		pins {
@@ -166,40 +149,6 @@
 		};
 	};
 
-	ltdc_pins: ltdc@0 {
-		pins {
-			pinmux = <STM32_PINMUX('E', 4, AF14)>, /* B0 */
-				 <STM32_PINMUX('G',12, AF9)>,  /* B4 */
-				 <STM32_PINMUX('I', 9, AF14)>, /* VSYNC */
-				 <STM32_PINMUX('I',10, AF14)>, /* HSYNC */
-				 <STM32_PINMUX('I',14, AF14)>, /* CLK */
-				 <STM32_PINMUX('I',15, AF14)>, /* R0 */
-				 <STM32_PINMUX('J', 0, AF14)>, /* R1 */
-				 <STM32_PINMUX('J', 1, AF14)>, /* R2 */
-				 <STM32_PINMUX('J', 2, AF14)>, /* R3 */
-				 <STM32_PINMUX('J', 3, AF14)>, /* R4 */
-				 <STM32_PINMUX('J', 4, AF14)>, /* R5 */
-				 <STM32_PINMUX('J', 5, AF14)>, /* R6 */
-				 <STM32_PINMUX('J', 6, AF14)>, /* R7 */
-				 <STM32_PINMUX('J', 7, AF14)>, /* G0 */
-				 <STM32_PINMUX('J', 8, AF14)>, /* G1 */
-				 <STM32_PINMUX('J', 9, AF14)>, /* G2 */
-				 <STM32_PINMUX('J',10, AF14)>, /* G3 */
-				 <STM32_PINMUX('J',11, AF14)>, /* G4 */
-				 <STM32_PINMUX('J',13, AF14)>, /* B1 */
-				 <STM32_PINMUX('J',14, AF14)>, /* B2 */
-				 <STM32_PINMUX('J',15, AF14)>, /* B3 */
-				 <STM32_PINMUX('K', 0, AF14)>, /* G5 */
-				 <STM32_PINMUX('K', 1, AF14)>, /* G6 */
-				 <STM32_PINMUX('K', 2, AF14)>, /* G7 */
-				 <STM32_PINMUX('K', 4, AF14)>, /* B5 */
-				 <STM32_PINMUX('K', 5, AF14)>, /* B6 */
-				 <STM32_PINMUX('K', 6, AF14)>, /* B7 */
-				 <STM32_PINMUX('K', 7, AF14)>; /* DE */
-			slew-rate = <2>;
-		};
-	};
-
 	qspi_pins: qspi@0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 2, AF9)>, /* CLK */
diff --git a/arch/arm/dts/stm32f746-disco.dts b/arch/arm/dts/stm32f746-disco.dts
index 1ed58f2361..4312751340 100644
--- a/arch/arm/dts/stm32f746-disco.dts
+++ b/arch/arm/dts/stm32f746-disco.dts
@@ -7,8 +7,9 @@
 /dts-v1/;
 #include "stm32f746.dtsi"
 #include "stm32f746-pinctrl.dtsi"
-#include <dt-bindings/input/input.h>
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
 
 / {
 	model = "STMicroelectronics STM32F746-DISCO board";
@@ -24,6 +25,19 @@
 		reg = <0xC0000000 0x800000>;
 	};
 
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			no-map;
+			size = <0x80000>;
+			linux,dma-default;
+		};
+	};
+
 	aliases {
 		serial0 = &usart1;
 	};
@@ -43,12 +57,31 @@
 		regulator-always-on;
 	};
 
-	mmc_vcard: mmc_vcard {
+	vcc_3v3: vcc-3v3 {
 		compatible = "regulator-fixed";
-		regulator-name = "mmc_vcard";
+		regulator-name = "vcc_3v3";
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
 	};
+
+	backlight: backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiok 3 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	panel_rgb: panel-rgb {
+		compatible = "rocktech,rk043fn48h";
+		power-supply = <&vcc_3v3>;
+		backlight = <&backlight>;
+		enable-gpios = <&gpioi 12 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&ltdc_out_rgb>;
+			};
+		};
+	};
 };
 
 &clk_hse {
@@ -63,9 +96,37 @@
 	status = "okay";
 };
 
+&i2c3 {
+	pinctrl-0 = <&i2c3_pins_a>;
+	pinctrl-names = "default";
+	clock-frequency = <400000>;
+	status = "okay";
+
+	touchscreen@38 {
+		compatible = "edt,edt-ft5306";
+		reg = <0x38>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <272>;
+	};
+};
+
+&ltdc {
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	port {
+		ltdc_out_rgb: endpoint {
+			remote-endpoint = <&panel_in_rgb>;
+		};
+	};
+};
+
 &sdio1 {
 	status = "okay";
-	vmmc-supply = <&mmc_vcard>;
+	vmmc-supply = <&vcc_3v3>;
 	cd-gpios = <&gpioc 13 GPIO_ACTIVE_LOW>;
 	pinctrl-names = "default", "opendrain";
 	pinctrl-0 = <&sdio_pins_a>;
diff --git a/arch/arm/dts/stm32f746-pinctrl.dtsi b/arch/arm/dts/stm32f746-pinctrl.dtsi
index fcfd2ac723..139f72b790 100644
--- a/arch/arm/dts/stm32f746-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f746-pinctrl.dtsi
@@ -6,6 +6,50 @@
 
 #include "stm32f7-pinctrl.dtsi"
 
-&pinctrl{
+&pinctrl {
 	compatible = "st,stm32f746-pinctrl";
+
+	gpioa: gpio@40020000 {
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@40020400 {
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@40020800 {
+		gpio-ranges = <&pinctrl 0 32 16>;
+	};
+
+	gpiod: gpio@40020c00 {
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@40021000 {
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@40021400 {
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@40021800 {
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@40021c00 {
+		gpio-ranges = <&pinctrl 0 112 16>;
+	};
+
+	gpioi: gpio@40022000 {
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@40022400 {
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@40022800 {
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
 };
diff --git a/arch/arm/dts/stm32f746.dtsi b/arch/arm/dts/stm32f746.dtsi
index c97b3d0d07..85deb1a2d2 100644
--- a/arch/arm/dts/stm32f746.dtsi
+++ b/arch/arm/dts/stm32f746.dtsi
@@ -4,7 +4,7 @@
  *
  */
 
-#include "armv7-m.dtsi"
+#include "../armv7-m.dtsi"
 #include <dt-bindings/clock/stm32fx-clock.h>
 #include <dt-bindings/mfd/stm32f7-rcc.h>
 
@@ -221,6 +221,23 @@
 			status = "disabled";
 		};
 
+		can3: can@40003400 {
+			compatible = "st,stm32f4-bxcan";
+			reg = <0x40003400 0x200>;
+			interrupts = <104>, <105>, <106>, <107>;
+			interrupt-names = "tx", "rx0", "rx1", "sce";
+			resets = <&rcc STM32F7_APB1_RESET(CAN3)>;
+			clocks = <&rcc 0 STM32F7_APB1_CLOCK(CAN3)>;
+			st,gcan = <&gcan3>;
+			status = "disabled";
+		};
+
+		gcan3: gcan@40003600 {
+			compatible = "st,stm32f4-gcan", "syscon";
+			reg = <0x40003600 0x200>;
+			clocks = <&rcc 0 STM32F7_APB1_CLOCK(CAN3)>;
+		};
+
 		usart2: serial@40004400 {
 			compatible = "st,stm32f7-uart";
 			reg = <0x40004400 0x400>;
@@ -301,6 +318,36 @@
 			status = "disabled";
 		};
 
+		can1: can@40006400 {
+			compatible = "st,stm32f4-bxcan";
+			reg = <0x40006400 0x200>;
+			interrupts = <19>, <20>, <21>, <22>;
+			interrupt-names = "tx", "rx0", "rx1", "sce";
+			resets = <&rcc STM32F7_APB1_RESET(CAN1)>;
+			clocks = <&rcc 0 STM32F7_APB1_CLOCK(CAN1)>;
+			st,can-primary;
+			st,gcan = <&gcan1>;
+			status = "disabled";
+		};
+
+		gcan1: gcan@40006600 {
+			compatible = "st,stm32f4-gcan", "syscon";
+			reg = <0x40006600 0x200>;
+			clocks = <&rcc 0 STM32F7_APB1_CLOCK(CAN1)>;
+		};
+
+		can2: can@40006800 {
+			compatible = "st,stm32f4-bxcan";
+			reg = <0x40006800 0x200>;
+			interrupts = <63>, <64>, <65>, <66>;
+			interrupt-names = "tx", "rx0", "rx1", "sce";
+			resets = <&rcc STM32F7_APB1_RESET(CAN2)>;
+			clocks = <&rcc 0 STM32F7_APB1_CLOCK(CAN2)>;
+			st,can-secondary;
+			st,gcan = <&gcan1>;
+			status = "disabled";
+		};
+
 		cec: cec@40006c00 {
 			compatible = "st,stm32-cec";
 			reg = <0x40006C00 0x400>;
@@ -471,6 +518,16 @@
 			};
 		};
 
+		ltdc: display-controller@40016800 {
+			compatible = "st,stm32-ltdc";
+			reg = <0x40016800 0x200>;
+			interrupts = <88>, <89>;
+			resets = <&rcc STM32F7_APB2_RESET(LTDC)>;
+			clocks = <&rcc 1 CLK_LCD>;
+			clock-names = "lcd";
+			status = "disabled";
+		};
+
 		pwrcfg: power-config@40007000 {
 			compatible = "st,stm32-power-config", "syscon";
 			reg = <0x40007000 0x400>;
@@ -479,7 +536,7 @@
 		crc: crc@40023000 {
 			compatible = "st,stm32f7-crc";
 			reg = <0x40023000 0x400>;
-			clocks = <&rcc 0 12>;
+			clocks = <&rcc 0 STM32F7_AHB1_CLOCK(CRC)>;
 			status = "disabled";
 		};
 
diff --git a/arch/arm/dts/stm32f769-pinctrl.dtsi b/arch/arm/dts/stm32f769-pinctrl.dtsi
index 31005dd992..02c2a8b084 100644
--- a/arch/arm/dts/stm32f769-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f769-pinctrl.dtsi
@@ -6,6 +6,50 @@
 
 #include "stm32f7-pinctrl.dtsi"
 
-&pinctrl{
+&pinctrl {
 	compatible = "st,stm32f769-pinctrl";
+
+	gpioa: gpio@40020000 {
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@40020400 {
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@40020800 {
+		gpio-ranges = <&pinctrl 0 32 16>;
+	};
+
+	gpiod: gpio@40020c00 {
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@40021000 {
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@40021400 {
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@40021800 {
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@40021c00 {
+		gpio-ranges = <&pinctrl 0 112 16>;
+	};
+
+	gpioi: gpio@40022000 {
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@40022400 {
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@40022800 {
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
 };
diff --git a/arch/arm/dts/stm32h7-pinctrl.dtsi b/arch/arm/dts/stm32h7-pinctrl.dtsi
index aefa32468d..2b194a6bdb 100644
--- a/arch/arm/dts/stm32h7-pinctrl.dtsi
+++ b/arch/arm/dts/stm32h7-pinctrl.dtsi
@@ -94,7 +94,7 @@
 			drive-push-pull;
 			bias-disable;
 		};
-		pins2{
+		pins2 {
 			pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
 			slew-rate = <3>;
 			drive-open-drain;
@@ -122,7 +122,7 @@
 			drive-push-pull;
 			bias-pull-up;
 		};
-		pins2{
+		pins2 {
 			pinmux = <STM32_PINMUX('B', 8, AF7)>; /* SDMMC1_CKIN */
 			bias-pull-up;
 		};
@@ -162,7 +162,7 @@
 			drive-push-pull;
 			bias-disable;
 		};
-		pins2{
+		pins2 {
 			pinmux = <STM32_PINMUX('D', 7, AF11)>; /* SDMMC1_CMD */
 			slew-rate = <3>;
 			drive-open-drain;
diff --git a/arch/arm/dts/stm32h743.dtsi b/arch/arm/dts/stm32h743.dtsi
index c490d0a571..0217dfa7bb 100644
--- a/arch/arm/dts/stm32h743.dtsi
+++ b/arch/arm/dts/stm32h743.dtsi
@@ -4,7 +4,7 @@
  *
  */
 
-#include "armv7-m.dtsi"
+#include "../armv7-m.dtsi"
 #include <dt-bindings/clock/stm32h7-clks.h>
 #include <dt-bindings/mfd/stm32h7-rcc.h>
 #include <dt-bindings/interrupt-controller/irq.h>
@@ -552,7 +552,6 @@
 			ranges = <0 0x58020000 0x3000>;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&syscfg 0x8>;
-			pins-are-numbered;
 
 			gpioa: gpio@58020000 {
 				gpio-controller;
diff --git a/arch/arm/dts/stm32h750i-art-pi.dts b/arch/arm/dts/stm32h750i-art-pi.dts
index c7c7132f22..1d0f70ae64 100644
--- a/arch/arm/dts/stm32h750i-art-pi.dts
+++ b/arch/arm/dts/stm32h750i-art-pi.dts
@@ -169,7 +169,7 @@
 	dmas = <&dmamux1 45 0x400 0x05>,
 	       <&dmamux1 46 0x400 0x05>;
 	dma-names = "rx", "tx";
-	st,hw-flow-ctrl;
+	uart-has-rtscts;
 	status = "okay";
 
 	bluetooth {
diff --git a/arch/arm/dts/stm32mp13-pinctrl.dtsi b/arch/arm/dts/stm32mp13-pinctrl.dtsi
index 27e0c38267..33416738a3 100644
--- a/arch/arm/dts/stm32mp13-pinctrl.dtsi
+++ b/arch/arm/dts/stm32mp13-pinctrl.dtsi
@@ -13,6 +13,171 @@
 		};
 	};
 
+	dcmipp_pins_a: dcmi-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  AF13)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  AF13)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  AF14)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  AF13)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  AF13)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  AF13)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  AF13)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  AF14)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  AF13)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  AF13)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  AF13)>;/* DCMI_D7 */
+			bias-disable;
+		};
+	};
+
+	dcmipp_sleep_pins_a: dcmi-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  ANALOG)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  ANALOG)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  ANALOG)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  ANALOG)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  ANALOG)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  ANALOG)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  ANALOG)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  ANALOG)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  ANALOG)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  ANALOG)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  ANALOG)>;/* DCMI_D7 */
+		};
+	};
+
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	dfsdm_datin1_pins_a: dfsdm-datin1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF6)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin1_sleep_pins_a: dfsdm-datin1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin3_pins_a: dfsdm-datin3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	dfsdm_datin3_sleep_pins_a: dfsdm-datin3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	eth1_rmii_pins_a: eth1-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, AF10)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+
+	};
+
+	eth1_rmii_sleep_pins_a: eth1-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	eth2_rmii_pins_a: eth2-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, AF10)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, AF13)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, AF10)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, AF11)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+	};
+
+	eth2_rmii_sleep_pins_a: eth2-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	goodix_pins_a: goodix-0 {
+		/*
+		 * touchscreen reset needs to be configured
+		 * via the pinctrl not the driver (a pull-down resistor
+		 * has been soldered onto the reset line which forces
+		 * the touchscreen to reset state).
+		 */
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 2, GPIO)>;
+			output-high;
+			bias-pull-up;
+		};
+		/*
+		 * Interrupt line must have a pull-down resistor
+		 * in order to freeze the i2c address at 0x5D
+		 */
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 5, GPIO)>;
+			bias-pull-down;
+		};
+	};
+
 	i2c1_pins_a: i2c1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
@@ -47,6 +212,63 @@
 		};
 	};
 
+	ltdc_pins_a: ltdc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, AF13)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, AF14)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, AF11)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, AF11)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, AF14)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, AF13)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, AF14)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, AF14)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, AF14)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, AF14)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, AF14)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, AF14)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, AF14)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, AF14)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, AF11)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, AF14)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, AF14)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, AF11)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, AF14)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, AF7)>,  /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, AF13)>; /* LCD_B7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ltdc_sleep_pins_a: ltdc-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, ANALOG)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, ANALOG)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, ANALOG)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, ANALOG)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, ANALOG)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, ANALOG)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, ANALOG)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, ANALOG)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, ANALOG)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, ANALOG)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, ANALOG)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, ANALOG)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, ANALOG)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, ANALOG)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, ANALOG)>, /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, ANALOG)>; /* LCD_B7 */
+		};
+	};
+
 	mcp23017_pins_a: mcp23017-0 {
 		pins {
 			pinmux = <STM32_PINMUX('G', 12, GPIO)>;
@@ -114,6 +336,33 @@
 		};
 	};
 
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 1, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1_pins_a: sai1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, AF12)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, AF6)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, AF6)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, AF6)>; /* SAI1_FS_A */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sai1_sleep_pins_a: sai1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, ANALOG)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, ANALOG)>; /* SAI1_FS_A */
+		};
+	};
+
 	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
diff --git a/arch/arm/dts/stm32mp13-u-boot.dtsi b/arch/arm/dts/stm32mp13-u-boot.dtsi
index aa5cfc6e41..fb1507b733 100644
--- a/arch/arm/dts/stm32mp13-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp13-u-boot.dtsi
@@ -41,6 +41,13 @@
 
 			status = "okay";
 		};
+
+		etzpc: bus@5c007000 {
+			/* pre-reloc probe = reserve video frame buffer in video_reserve() */
+			display-controller@5a001000 {
+				bootph-some-ram;
+			};
+		};
 	};
 };
 
@@ -48,6 +55,10 @@
 	bootph-all;
 };
 
+&etzpc {
+	bootph-all;
+};
+
 &gpioa {
 	bootph-all;
 };
@@ -111,3 +122,8 @@
 &syscfg {
 	bootph-all;
 };
+
+&usbphyc {
+	/* stm32-usbphyc-clk = ck_usbo_48m is a source clock of RCC CCF */
+	bootph-all;
+};
diff --git a/arch/arm/dts/stm32mp131.dtsi b/arch/arm/dts/stm32mp131.dtsi
index d23bbc3639..e555717c00 100644
--- a/arch/arm/dts/stm32mp131.dtsi
+++ b/arch/arm/dts/stm32mp131.dtsi
@@ -5,7 +5,9 @@
  */
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/clock/stm32mp13-clks.h>
+#include <dt-bindings/regulator/st,stm32mp13-regulator.h>
 #include <dt-bindings/reset/stm32mp13-resets.h>
+#include <dt-bindings/thermal/thermal.h>
 
 / {
 	#address-cells = <1>;
@@ -19,6 +21,9 @@
 			compatible = "arm,cortex-a7";
 			device_type = "cpu";
 			reg = <0>;
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			#cooling-cells = <2>;
 		};
 	};
 
@@ -29,10 +34,20 @@
 		interrupt-parent = <&intc>;
 	};
 
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xbc000000>;
+		status = "disabled";
+	};
+
 	firmware {
-		optee {
+		optee: optee {
 			method = "smc";
 			compatible = "linaro,optee-tz";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
 		};
 
 		scmi: scmi {
@@ -41,6 +56,11 @@
 			#size-cells = <0>;
 			linaro,optee-channel-id = <0>;
 
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
 			scmi_clk: protocol@14 {
 				reg = <0x14>;
 				#clock-cells = <1>;
@@ -50,6 +70,28 @@
 				reg = <0x16>;
 				#reset-cells = <1>;
 			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_reg11: regulator@0 {
+						reg = <VOLTD_SCMI_REG11>;
+						regulator-name = "reg11";
+					};
+					scmi_reg18: regulator@1 {
+						reg = <VOLTD_SCMI_REG18>;
+						regulator-name = "reg18";
+					};
+					scmi_usb33: regulator@2 {
+						reg = <VOLTD_SCMI_USB33>;
+						regulator-name = "usb33";
+					};
+				};
+			};
 		};
 	};
 
@@ -76,26 +118,40 @@
 		always-on;
 	};
 
-	/* PWR 1v1, 1v8 and 3v3 regulators defined as fixed, waiting for SCMI */
-	reg11: reg11 {
-		compatible = "regulator-fixed";
-		regulator-name = "reg11";
-		regulator-min-microvolt = <1100000>;
-		regulator-max-microvolt = <1100000>;
-	};
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
 
-	reg18: reg18 {
-		compatible = "regulator-fixed";
-		regulator-name = "reg18";
-		regulator-min-microvolt = <1800000>;
-		regulator-max-microvolt = <1800000>;
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
+		};
 	};
 
-	usb33: usb33 {
-		compatible = "regulator-fixed";
-		regulator-name = "usb33";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&dts>;
+
+			trips {
+				cpu_crit: cpu-crit0 {
+					temperature = <120000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
 	};
 
 	soc {
@@ -259,6 +315,11 @@
 			dma-names = "up";
 			status = "disabled";
 
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+
 			timer@5 {
 				compatible = "st,stm32h7-timer-trigger";
 				reg = <5>;
@@ -279,6 +340,11 @@
 			dma-names = "up";
 			status = "disabled";
 
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+
 			timer@6 {
 				compatible = "st,stm32h7-timer-trigger";
 				reg = <6>;
@@ -294,6 +360,7 @@
 			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc LPTIM1_K>;
 			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
 			wakeup-source;
 			status = "disabled";
 
@@ -390,6 +457,7 @@
 			clocks = <&rcc USART3_K>;
 			resets = <&rcc USART3_R>;
 			wakeup-source;
+			power-domains = <&pd_core_ret>;
 			dmas = <&dmamux1 45 0x400 0x5>,
 			       <&dmamux1 46 0x400 0x1>;
 			dma-names = "rx", "tx";
@@ -403,6 +471,7 @@
 			clocks = <&rcc UART4_K>;
 			resets = <&rcc UART4_R>;
 			wakeup-source;
+			power-domains = <&pd_core_ret>;
 			dmas = <&dmamux1 63 0x400 0x5>,
 			       <&dmamux1 64 0x400 0x1>;
 			dma-names = "rx", "tx";
@@ -416,6 +485,7 @@
 			clocks = <&rcc UART5_K>;
 			resets = <&rcc UART5_R>;
 			wakeup-source;
+			power-domains = <&pd_core_ret>;
 			dmas = <&dmamux1 65 0x400 0x5>,
 			       <&dmamux1 66 0x400 0x1>;
 			dma-names = "rx", "tx";
@@ -465,6 +535,7 @@
 			clocks = <&rcc UART7_K>;
 			resets = <&rcc UART7_R>;
 			wakeup-source;
+			power-domains = <&pd_core_ret>;
 			dmas = <&dmamux1 79 0x400 0x5>,
 			       <&dmamux1 80 0x400 0x1>;
 			dma-names = "rx", "tx";
@@ -478,6 +549,7 @@
 			clocks = <&rcc UART8_K>;
 			resets = <&rcc UART8_R>;
 			wakeup-source;
+			power-domains = <&pd_core_ret>;
 			dmas = <&dmamux1 81 0x400 0x5>,
 			       <&dmamux1 82 0x400 0x1>;
 			dma-names = "rx", "tx";
@@ -573,6 +645,7 @@
 			clocks = <&rcc USART6_K>;
 			resets = <&rcc USART6_R>;
 			wakeup-source;
+			power-domains = <&pd_core_ret>;
 			dmas = <&dmamux1 71 0x400 0x5>,
 			       <&dmamux1 72 0x400 0x1>;
 			dma-names = "rx", "tx";
@@ -743,469 +816,279 @@
 			dma-channels = <16>;
 		};
 
-		adc_2: adc@48004000 {
-			compatible = "st,stm32mp13-adc-core";
-			reg = <0x48004000 0x400>;
-			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc ADC2>, <&rcc ADC2_K>;
-			clock-names = "bus", "adc";
-			interrupt-controller;
-			#interrupt-cells = <1>;
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				 <&scmi_clk CK_SCMI_HSI>,
+				 <&scmi_clk CK_SCMI_CSI>,
+				 <&scmi_clk CK_SCMI_LSE>,
+				 <&scmi_clk CK_SCMI_LSI>;
+		};
+
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
+			#size-cells = <1>;
+			compatible = "st,stm32mp135-pinctrl";
+			ranges = <0 0x50002000 0x8400>;
+			interrupt-parent = <&exti>;
 
-			adc2: adc@0 {
-				compatible = "st,stm32mp13-adc";
-				#io-channel-cells = <1>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0x0>;
-				interrupt-parent = <&adc_2>;
-				interrupts = <0>;
-				dmas = <&dmamux1 10 0x400 0x80000001>;
-				dma-names = "rx";
-				status = "disabled";
+			gpioa: gpio@50002000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc GPIOA>;
+				st,bank-name = "GPIOA";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 0 16>;
+			};
 
-				channel@13 {
-					reg = <13>;
-					label = "vrefint";
-				};
-				channel@14 {
-					reg = <14>;
-					label = "vddcore";
-				};
-				channel@16 {
-					reg = <16>;
-					label = "vddcpu";
-				};
-				channel@17 {
-					reg = <17>;
-					label = "vddq_ddr";
-				};
+			gpiob: gpio@50003000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x1000 0x400>;
+				clocks = <&rcc GPIOB>;
+				st,bank-name = "GPIOB";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 16 16>;
 			};
-		};
 
-		usbotg_hs: usb@49000000 {
-			compatible = "st,stm32mp15-hsotg", "snps,dwc2";
-			reg = <0x49000000 0x40000>;
-			clocks = <&rcc USBO_K>;
-			clock-names = "otg";
-			resets = <&rcc USBO_R>;
-			reset-names = "dwc2";
-			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
-			g-rx-fifo-size = <512>;
-			g-np-tx-fifo-size = <32>;
-			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
-			dr_mode = "otg";
-			otg-rev = <0x200>;
-			usb33d-supply = <&usb33>;
-			status = "disabled";
-		};
+			gpioc: gpio@50004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x2000 0x400>;
+				clocks = <&rcc GPIOC>;
+				st,bank-name = "GPIOC";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 32 16>;
+			};
 
-		usart1: serial@4c000000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4c000000 0x400>;
-			interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART1_K>;
-			resets = <&rcc USART1_R>;
-			wakeup-source;
-			dmas = <&dmamux1 41 0x400 0x5>,
-			       <&dmamux1 42 0x400 0x1>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			gpiod: gpio@50005000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x3000 0x400>;
+				clocks = <&rcc GPIOD>;
+				st,bank-name = "GPIOD";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 48 16>;
+			};
 
-		usart2: serial@4c001000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4c001000 0x400>;
-			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART2_K>;
-			resets = <&rcc USART2_R>;
-			wakeup-source;
-			dmas = <&dmamux1 43 0x400 0x5>,
-			       <&dmamux1 44 0x400 0x1>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			gpioe: gpio@50006000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x4000 0x400>;
+				clocks = <&rcc GPIOE>;
+				st,bank-name = "GPIOE";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 64 16>;
+			};
 
-		i2s4: audio-controller@4c002000 {
-			compatible = "st,stm32h7-i2s";
-			reg = <0x4c002000 0x400>;
-			#sound-dai-cells = <0>;
-			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 83 0x400 0x01>,
-			       <&dmamux1 84 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			gpiof: gpio@50007000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x5000 0x400>;
+				clocks = <&rcc GPIOF>;
+				st,bank-name = "GPIOF";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 80 16>;
+			};
 
-		spi4: spi@4c002000 {
-			compatible = "st,stm32h7-spi";
-			reg = <0x4c002000 0x400>;
-			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI4_K>;
-			resets = <&rcc SPI4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 83 0x400 0x01>,
-			       <&dmamux1 84 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			gpiog: gpio@50008000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x6000 0x400>;
+				clocks = <&rcc GPIOG>;
+				st,bank-name = "GPIOG";
+				ngpios = <16>;
+				gpio-ranges = <&pinctrl 0 96 16>;
+			};
 
-		spi5: spi@4c003000 {
-			compatible = "st,stm32h7-spi";
-			reg = <0x4c003000 0x400>;
-			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI5_K>;
-			resets = <&rcc SPI5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 85 0x400 0x01>,
-			       <&dmamux1 86 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			gpioh: gpio@50009000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x7000 0x400>;
+				clocks = <&rcc GPIOH>;
+				st,bank-name = "GPIOH";
+				ngpios = <15>;
+				gpio-ranges = <&pinctrl 0 112 15>;
+			};
 
-		i2c3: i2c@4c004000 {
-			compatible = "st,stm32mp13-i2c";
-			reg = <0x4c004000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C3_K>;
-			resets = <&rcc I2C3_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 73 0x400 0x1>,
-			       <&dmamux1 74 0x400 0x1>;
-			dma-names = "rx", "tx";
-			st,syscfg-fmp = <&syscfg 0x4 0x4>;
-			i2c-analog-filter;
-			status = "disabled";
+			gpioi: gpio@5000a000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x8000 0x400>;
+				clocks = <&rcc GPIOI>;
+				st,bank-name = "GPIOI";
+				ngpios = <8>;
+				gpio-ranges = <&pinctrl 0 128 8>;
+			};
 		};
 
-		i2c4: i2c@4c005000 {
-			compatible = "st,stm32mp13-i2c";
-			reg = <0x4c005000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C4_K>;
-			resets = <&rcc I2C4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 75 0x400 0x1>,
-			       <&dmamux1 76 0x400 0x1>;
-			dma-names = "rx", "tx";
-			st,syscfg-fmp = <&syscfg 0x4 0x8>;
-			i2c-analog-filter;
-			status = "disabled";
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 68  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 41  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 43  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 78  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 34  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 73  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 54  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 84  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_40 */
+				<0>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 96  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 92  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<&intc GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 63  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
 		};
 
-		i2c5: i2c@4c006000 {
-			compatible = "st,stm32mp13-i2c";
-			reg = <0x4c006000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C5_K>;
-			resets = <&rcc I2C5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 115 0x400 0x1>,
-			       <&dmamux1 116 0x400 0x1>;
-			dma-names = "rx", "tx";
-			st,syscfg-fmp = <&syscfg 0x4 0x10>;
-			i2c-analog-filter;
-			status = "disabled";
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
 		};
 
-		timers12: timer@4c007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x4c007000 0x400>;
-			interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM12_K>;
-			clock-names = "int";
+		lptimer4: timer@50023000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50023000 0x400>;
+			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
 			status = "disabled";
 
 			pwm {
-				compatible = "st,stm32-pwm";
+				compatible = "st,stm32-pwm-lp";
 				#pwm-cells = <3>;
 				status = "disabled";
 			};
 
-			timer@11 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <11>;
+			timer {
+				compatible = "st,stm32-lptimer-timer";
 				status = "disabled";
 			};
 		};
 
-		timers13: timer@4c008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x4c008000 0x400>;
-			interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM13_K>;
-			clock-names = "int";
+		lptimer5: timer@50024000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50024000 0x400>;
+			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
 			status = "disabled";
 
 			pwm {
-				compatible = "st,stm32-pwm";
+				compatible = "st,stm32-pwm-lp";
 				#pwm-cells = <3>;
 				status = "disabled";
 			};
 
-			timer@12 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <12>;
-				status = "disabled";
-			};
-		};
-
-		timers14: timer@4c009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x4c009000 0x400>;
-			interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM14_K>;
-			clock-names = "int";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@13 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <13>;
-				status = "disabled";
-			};
-		};
-
-		timers15: timer@4c00a000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x4c00a000 0x400>;
-			interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM15_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 105 0x400 0x1>,
-			       <&dmamux1 106 0x400 0x1>,
-			       <&dmamux1 107 0x400 0x1>,
-			       <&dmamux1 108 0x400 0x1>;
-			dma-names = "ch1", "up", "trig", "com";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@14 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <14>;
-				status = "disabled";
-			};
-		};
-
-		timers16: timer@4c00b000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x4c00b000 0x400>;
-			interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM16_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 109 0x400 0x1>,
-			       <&dmamux1 110 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@15 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <15>;
-				status = "disabled";
-			};
-		};
-
-		timers17: timer@4c00c000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x4c00c000 0x400>;
-			interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM17_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 111 0x400 0x1>,
-			       <&dmamux1 112 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@16 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <16>;
-				status = "disabled";
-			};
-		};
-
-		rcc: rcc@50000000 {
-			compatible = "st,stm32mp13-rcc", "syscon";
-			reg = <0x50000000 0x1000>;
-			#clock-cells = <1>;
-			#reset-cells = <1>;
-			clock-names = "hse", "hsi", "csi", "lse", "lsi";
-			clocks = <&scmi_clk CK_SCMI_HSE>,
-				 <&scmi_clk CK_SCMI_HSI>,
-				 <&scmi_clk CK_SCMI_CSI>,
-				 <&scmi_clk CK_SCMI_LSE>,
-				 <&scmi_clk CK_SCMI_LSI>;
-		};
-
-		exti: interrupt-controller@5000d000 {
-			compatible = "st,stm32mp13-exti", "syscon";
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			reg = <0x5000d000 0x400>;
-		};
-
-		syscfg: syscon@50020000 {
-			compatible = "st,stm32mp157-syscfg", "syscon";
-			reg = <0x50020000 0x400>;
-			clocks = <&rcc SYSCFG>;
-		};
-
-		lptimer2: timer@50021000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50021000 0x400>;
-			interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM2_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			trigger@1 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <1>;
-				status = "disabled";
-			};
-
-			counter {
-				compatible = "st,stm32-lptimer-counter";
-				status = "disabled";
-			};
-
 			timer {
 				compatible = "st,stm32-lptimer-timer";
 				status = "disabled";
 			};
 		};
 
-		lptimer3: timer@50022000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50022000 0x400>;
-			interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM3_K>;
-			clock-names = "mux";
-			wakeup-source;
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc DTS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
+			reg = <0x50028000 0x100>;
 			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			trigger@2 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <2>;
-				status = "disabled";
-			};
-
-			timer {
-				compatible = "st,stm32-lptimer-timer";
-				status = "disabled";
-			};
 		};
 
-		lptimer4: timer@50023000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50023000 0x400>;
-			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM4_K>;
-			clock-names = "mux";
-			wakeup-source;
+		hdp: pinctrl@5002a000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
 			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer {
-				compatible = "st,stm32-lptimer-timer";
-				status = "disabled";
-			};
-		};
-
-		lptimer5: timer@50024000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50024000 0x400>;
-			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM5_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer {
-				compatible = "st,stm32-lptimer-timer";
-				status = "disabled";
-			};
 		};
 
 		mdma: dma-controller@58000000 {
@@ -1218,79 +1101,10 @@
 			dma-requests = <48>;
 		};
 
-		fmc: memory-controller@58002000 {
-			compatible = "st,stm32mp1-fmc2-ebi";
-			reg = <0x58002000 0x1000>;
-			ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
-				 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
-				 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
-				 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
-				 <4 0 0x80000000 0x10000000>; /* NAND */
-			#address-cells = <2>;
-			#size-cells = <1>;
-			clocks = <&rcc FMC_K>;
-			resets = <&rcc FMC_R>;
-			status = "disabled";
-
-			nand-controller@4,0 {
-				compatible = "st,stm32mp1-fmc2-nfc";
-				reg = <4 0x00000000 0x1000>,
-				      <4 0x08010000 0x1000>,
-				      <4 0x08020000 0x1000>,
-				      <4 0x01000000 0x1000>,
-				      <4 0x09010000 0x1000>,
-				      <4 0x09020000 0x1000>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&mdma 24 0x2 0x12000a02 0x0 0x0>,
-				       <&mdma 24 0x2 0x12000a08 0x0 0x0>,
-				       <&mdma 25 0x2 0x12000a0a 0x0 0x0>;
-				dma-names = "tx", "rx", "ecc";
-				status = "disabled";
-			};
-		};
-
-		qspi: spi@58003000 {
-			compatible = "st,stm32f469-qspi";
-			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
-			reg-names = "qspi", "qspi_mm";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&mdma 26 0x2 0x10100002 0x0 0x0>,
-			       <&mdma 26 0x2 0x10100008 0x0 0x0>;
-			dma-names = "tx", "rx";
-			clocks = <&rcc QSPI_K>;
-			resets = <&rcc QSPI_R>;
-			status = "disabled";
-		};
-
-		sdmmc1: mmc@58005000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x20253180>;
-			reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
-			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SDMMC1_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC1_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <130000000>;
-			status = "disabled";
-		};
-
-		sdmmc2: mmc@58007000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x20253180>;
-			reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
-			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SDMMC2_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC2_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <130000000>;
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
 			status = "disabled";
 		};
 
@@ -1300,6 +1114,8 @@
 			clocks = <&usbphyc>, <&rcc USBH>;
 			resets = <&rcc USBH_R>;
 			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&pd_core>;
+			wakeup-source;
 			status = "disabled";
 		};
 
@@ -1310,6 +1126,8 @@
 			resets = <&rcc USBH_R>;
 			interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
 			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
+			wakeup-source;
 			status = "disabled";
 		};
 
@@ -1321,27 +1139,12 @@
 			status = "disabled";
 		};
 
-		usbphyc: usbphyc@5a006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			#clock-cells = <0>;
-			compatible = "st,stm32mp1-usbphyc";
-			reg = <0x5a006000 0x1000>;
-			clocks = <&rcc USBPHY_K>;
-			resets = <&rcc USBPHY_R>;
-			vdda1v1-supply = <&reg11>;
-			vdda1v8-supply = <&reg18>;
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
 			status = "disabled";
-
-			usbphyc_port0: usb-phy@0 {
-				#phy-cells = <0>;
-				reg = <0>;
-			};
-
-			usbphyc_port1: usb-phy@1 {
-				#phy-cells = <1>;
-				reg = <1>;
-			};
 		};
 
 		rtc: rtc@5c004000 {
@@ -1360,136 +1163,690 @@
 			#address-cells = <1>;
 			#size-cells = <1>;
 
-			part_number_otp: part_number_otp@4 {
+			part_number_otp: part-number-otp@4 {
 				reg = <0x4 0x2>;
 				bits = <0 12>;
 			};
+			vrefint: vrefin-cal@52 {
+				reg = <0x52 0x2>;
+			};
 			ts_cal1: calib@5c {
 				reg = <0x5c 0x2>;
 			};
 			ts_cal2: calib@5e {
 				reg = <0x5e 0x2>;
 			};
+			ethernet_mac1_address: mac1@e4 {
+				reg = <0xe4 0x6>;
+			};
+			ethernet_mac2_address: mac2@ea {
+				reg = <0xea 0x6>;
+			};
 		};
 
-		/*
-		 * Break node order to solve dependency probe issue between
-		 * pinctrl and exti.
-		 */
-		pinctrl: pinctrl@50002000 {
+		etzpc: bus@5c007000 {
+			compatible = "st,stm32-etzpc", "simple-bus";
+			reg = <0x5c007000 0x400>;
 			#address-cells = <1>;
 			#size-cells = <1>;
-			compatible = "st,stm32mp135-pinctrl";
-			ranges = <0 0x50002000 0x8400>;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
-
-			gpioa: gpio@50002000 {
-				gpio-controller;
-				#gpio-cells = <2>;
+			#access-controller-cells = <1>;
+			ranges;
+
+			adc_2: adc@48004000 {
+				compatible = "st,stm32mp13-adc-core";
+				reg = <0x48004000 0x400>;
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC2>, <&rcc ADC2_K>;
+				clock-names = "bus", "adc";
 				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x0 0x400>;
-				clocks = <&rcc GPIOA>;
-				st,bank-name = "GPIOA";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 0 16>;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&etzpc 33>;
+				status = "disabled";
+
+				adc2: adc@0 {
+					compatible = "st,stm32mp13-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_2>;
+					interrupts = <0>;
+					dmas = <&dmamux1 10 0x400 0x80000001>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+
+					channel@13 {
+						reg = <13>;
+						label = "vrefint";
+					};
+					channel@14 {
+						reg = <14>;
+						label = "vddcore";
+					};
+					channel@16 {
+						reg = <16>;
+						label = "vddcpu";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddq_ddr";
+					};
+				};
 			};
 
-			gpiob: gpio@50003000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x1000 0x400>;
-				clocks = <&rcc GPIOB>;
-				st,bank-name = "GPIOB";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 16 16>;
+			usbotg_hs: usb@49000000 {
+				compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+				reg = <0x49000000 0x40000>;
+				clocks = <&rcc USBO_K>;
+				clock-names = "otg";
+				resets = <&rcc USBO_R>;
+				reset-names = "dwc2";
+				interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+				g-rx-fifo-size = <512>;
+				g-np-tx-fifo-size = <32>;
+				g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				usb33d-supply = <&scmi_usb33>;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 34>;
+				status = "disabled";
 			};
 
-			gpioc: gpio@50004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x2000 0x400>;
-				clocks = <&rcc GPIOC>;
-				st,bank-name = "GPIOC";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 32 16>;
+			usart1: serial@4c000000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4c000000 0x400>;
+				interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART1_K>;
+				resets = <&rcc USART1_R>;
+				wakeup-source;
+				power-domains = <&pd_core_ret>;
+				dmas = <&dmamux1 41 0x400 0x5>,
+				       <&dmamux1 42 0x400 0x1>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 16>;
+				status = "disabled";
 			};
 
-			gpiod: gpio@50005000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x3000 0x400>;
-				clocks = <&rcc GPIOD>;
-				st,bank-name = "GPIOD";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 48 16>;
+			usart2: serial@4c001000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4c001000 0x400>;
+				interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART2_K>;
+				resets = <&rcc USART2_R>;
+				wakeup-source;
+				power-domains = <&pd_core_ret>;
+				dmas = <&dmamux1 43 0x400 0x5>,
+				       <&dmamux1 44 0x400 0x1>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 17>;
+				status = "disabled";
 			};
 
-			gpioe: gpio@50006000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x4000 0x400>;
-				clocks = <&rcc GPIOE>;
-				st,bank-name = "GPIOE";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 64 16>;
+			i2s4: audio-controller@4c002000 {
+				compatible = "st,stm32h7-i2s";
+				reg = <0x4c002000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 13>;
+				status = "disabled";
 			};
 
-			gpiof: gpio@50007000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x5000 0x400>;
-				clocks = <&rcc GPIOF>;
-				st,bank-name = "GPIOF";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 80 16>;
+			spi4: spi@4c002000 {
+				compatible = "st,stm32h7-spi";
+				reg = <0x4c002000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI4_K>;
+				resets = <&rcc SPI4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 18>;
+				status = "disabled";
 			};
 
-			gpiog: gpio@50008000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x6000 0x400>;
-				clocks = <&rcc GPIOG>;
-				st,bank-name = "GPIOG";
-				ngpios = <16>;
-				gpio-ranges = <&pinctrl 0 96 16>;
+			spi5: spi@4c003000 {
+				compatible = "st,stm32h7-spi";
+				reg = <0x4c003000 0x400>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI5_K>;
+				resets = <&rcc SPI5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 85 0x400 0x01>,
+				       <&dmamux1 86 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 19>;
+				status = "disabled";
 			};
 
-			gpioh: gpio@50009000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x7000 0x400>;
-				clocks = <&rcc GPIOH>;
-				st,bank-name = "GPIOH";
-				ngpios = <15>;
-				gpio-ranges = <&pinctrl 0 112 15>;
+			i2c3: i2c@4c004000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c004000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C3_K>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 73 0x400 0x1>,
+				       <&dmamux1 74 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x4>;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 20>;
+				status = "disabled";
 			};
 
-			gpioi: gpio@5000a000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x8000 0x400>;
-				clocks = <&rcc GPIOI>;
-				st,bank-name = "GPIOI";
-				ngpios = <8>;
-				gpio-ranges = <&pinctrl 0 128 8>;
+			i2c4: i2c@4c005000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c005000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C4_K>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 75 0x400 0x1>,
+				       <&dmamux1 76 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x8>;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 21>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@4c006000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c006000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C5_K>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 115 0x400 0x1>,
+				       <&dmamux1 116 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x10>;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 22>;
+				status = "disabled";
+			};
+
+			timers12: timer@4c007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c007000 0x400>;
+				interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM12_K>;
+				clock-names = "int";
+				access-controllers = <&etzpc 23>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@4c008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c008000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM13_K>;
+				clock-names = "int";
+				access-controllers = <&etzpc 24>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@4c009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c009000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM14_K>;
+				clock-names = "int";
+				access-controllers = <&etzpc 25>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			timers15: timer@4c00a000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00a000 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM15_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 105 0x400 0x1>,
+				       <&dmamux1 106 0x400 0x1>,
+				       <&dmamux1 107 0x400 0x1>,
+				       <&dmamux1 108 0x400 0x1>;
+				dma-names = "ch1", "up", "trig", "com";
+				access-controllers = <&etzpc 26>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@4c00b000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00b000 0x400>;
+				interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM16_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 109 0x400 0x1>,
+				       <&dmamux1 110 0x400 0x1>;
+				dma-names = "ch1", "up";
+				access-controllers = <&etzpc 27>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@4c00c000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00c000 0x400>;
+				interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM17_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 111 0x400 0x1>,
+				       <&dmamux1 112 0x400 0x1>;
+				dma-names = "ch1", "up";
+				access-controllers = <&etzpc 28>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@50021000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50021000 0x400>;
+				interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM2_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core_ret>;
+				wakeup-source;
+				access-controllers = <&etzpc 1>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
+
+			lptimer3: timer@50022000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50022000 0x400>;
+				interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM3_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core_ret>;
+				wakeup-source;
+				access-controllers = <&etzpc 2>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
+
+			hash: hash@54003000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x54003000 0x400>;
+				interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&mdma 30 0x2 0x1000a02 0x0 0x0 0x0>;
+				dma-names = "in";
+				access-controllers = <&etzpc 41>;
+				status = "disabled";
+			};
+
+			rng: rng@54004000 {
+				compatible = "st,stm32mp13-rng";
+				reg = <0x54004000 0x400>;
+				clocks = <&rcc RNG1_K>;
+				resets = <&rcc RNG1_R>;
+				access-controllers = <&etzpc 40>;
+				status = "disabled";
+			};
+
+			fmc: memory-controller@58002000 {
+				compatible = "st,stm32mp1-fmc2-ebi";
+				reg = <0x58002000 0x1000>;
+				ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+					 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+					 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+					 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+					 <4 0 0x80000000 0x10000000>; /* NAND */
+				#address-cells = <2>;
+				#size-cells = <1>;
+				clocks = <&rcc FMC_K>;
+				resets = <&rcc FMC_R>;
+				access-controllers = <&etzpc 54>;
+				status = "disabled";
+
+				nand-controller@4,0 {
+					compatible = "st,stm32mp1-fmc2-nfc";
+					reg = <4 0x00000000 0x1000>,
+					      <4 0x08010000 0x1000>,
+					      <4 0x08020000 0x1000>,
+					      <4 0x01000000 0x1000>,
+					      <4 0x09010000 0x1000>,
+					      <4 0x09020000 0x1000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&mdma 24 0x2 0x12000a02 0x0 0x0>,
+					       <&mdma 24 0x2 0x12000a08 0x0 0x0>,
+					       <&mdma 25 0x2 0x12000a0a 0x0 0x0>;
+					dma-names = "tx", "rx", "ecc";
+					status = "disabled";
+				};
+			};
+
+			qspi: spi@58003000 {
+				compatible = "st,stm32f469-qspi";
+				reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+				reg-names = "qspi", "qspi_mm";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma 26 0x2 0x10100002 0x0 0x0>,
+				       <&mdma 26 0x2 0x10100008 0x0 0x0>;
+				dma-names = "tx", "rx";
+				clocks = <&rcc QSPI_K>;
+				resets = <&rcc QSPI_R>;
+				access-controllers = <&etzpc 55>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@58005000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x20253180>;
+				reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
+				interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC1_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <130000000>;
+				access-controllers = <&etzpc 50>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@58007000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x20253180>;
+				reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC2_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <130000000>;
+				access-controllers = <&etzpc 51>;
+				status = "disabled";
+			};
+
+			ethernet1: ethernet@5800a000 {
+				compatible = "st,stm32mp13-dwmac", "snps,dwmac-4.20a";
+				reg = <0x5800a000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti 68 1>;
+				interrupt-names = "macirq", "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc ETH1MAC>,
+					 <&rcc ETH1TX>,
+					 <&rcc ETH1RX>,
+					 <&rcc ETH1STP>,
+					 <&rcc ETH1CK_K>;
+				st,syscon = <&syscfg 0x4 0xff0000>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				access-controllers = <&etzpc 48>;
+				status = "disabled";
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+			};
+
+			usbphyc: usbphyc@5a006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#clock-cells = <0>;
+				compatible = "st,stm32mp1-usbphyc";
+				reg = <0x5a006000 0x1000>;
+				clocks = <&rcc USBPHY_K>;
+				resets = <&rcc USBPHY_R>;
+				vdda1v1-supply = <&scmi_reg11>;
+				vdda1v8-supply = <&scmi_reg18>;
+				access-controllers = <&etzpc 5>;
+				status = "disabled";
+
+				usbphyc_port0: usb-phy@0 {
+					#phy-cells = <0>;
+					reg = <0>;
+					interrupts-extended = <&exti 42 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				usbphyc_port1: usb-phy@1 {
+					#phy-cells = <1>;
+					reg = <1>;
+					interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+				};
+			};
+		};
+
+		tamp: tamp@5c00a000 {
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x5c00a000 0x400>;
+			ranges;
+
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				reg = <0x5c00a100 0x80>;
+
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+					saes_secret_key: tamp-bkp@0 {
+						/* see saes secret key feature */
+						reg = <0x0 0x20>;
+					};
+					boot_mode: tamp-bkp@78 {
+						/* see boot mode selection feature */
+						reg = <0x78 0x4>;
+					};
+					boot_counter: tamp-bkp@7c {
+						/* see boot counter feature */
+						reg = <0x7c 0x4>;
+					};
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
 			};
 		};
 	};
diff --git a/arch/arm/dts/stm32mp133.dtsi b/arch/arm/dts/stm32mp133.dtsi
index df451c3c2a..4b6e7ae129 100644
--- a/arch/arm/dts/stm32mp133.dtsi
+++ b/arch/arm/dts/stm32mp133.dtsi
@@ -33,36 +33,72 @@
 			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
 			status = "disabled";
 		};
+	};
+};
 
-		adc_1: adc@48003000 {
-			compatible = "st,stm32mp13-adc-core";
-			reg = <0x48003000 0x400>;
-			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc ADC1>, <&rcc ADC1_K>;
-			clock-names = "bus", "adc";
-			interrupt-controller;
-			#interrupt-cells = <1>;
+&etzpc {
+	adc_1: adc@48003000 {
+		compatible = "st,stm32mp13-adc-core";
+		reg = <0x48003000 0x400>;
+		interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc ADC1>, <&rcc ADC1_K>;
+		clock-names = "bus", "adc";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		access-controllers = <&etzpc 32>;
+		status = "disabled";
+
+		adc1: adc@0 {
+			compatible = "st,stm32mp13-adc";
+			#io-channel-cells = <1>;
 			#address-cells = <1>;
 			#size-cells = <0>;
+			reg = <0x0>;
+			interrupt-parent = <&adc_1>;
+			interrupts = <0>;
+			dmas = <&dmamux1 9 0x400 0x80000001>;
+			dma-names = "rx";
+			nvmem-cells = <&vrefint>;
+			nvmem-cell-names = "vrefint";
 			status = "disabled";
 
-			adc1: adc@0 {
-				compatible = "st,stm32mp13-adc";
-				#io-channel-cells = <1>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0x0>;
-				interrupt-parent = <&adc_1>;
-				interrupts = <0>;
-				dmas = <&dmamux1 9 0x400 0x80000001>;
-				dma-names = "rx";
-				status = "disabled";
-
-				channel@18 {
-					reg = <18>;
-					label = "vrefint";
-				};
+			channel@18 {
+				reg = <18>;
+				label = "vrefint";
 			};
 		};
 	};
+
+	ethernet2: ethernet@5800e000 {
+		compatible = "st,stm32mp13-dwmac", "snps,dwmac-4.20a";
+		reg = <0x5800e000 0x2000>;
+		reg-names = "stmmaceth";
+		interrupts-extended = <&intc GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq";
+		clock-names = "stmmaceth",
+			      "mac-clk-tx",
+			      "mac-clk-rx",
+			      "ethstp",
+			      "eth-ck";
+		clocks = <&rcc ETH2MAC>,
+			 <&rcc ETH2TX>,
+			 <&rcc ETH2RX>,
+			 <&rcc ETH2STP>,
+			 <&rcc ETH2CK_K>;
+		st,syscon = <&syscfg 0x4 0xff000000>;
+		snps,mixed-burst;
+		snps,pbl = <2>;
+		snps,axi-config = <&stmmac_axi_config_2>;
+		snps,tso;
+		access-controllers = <&etzpc 49>;
+		status = "disabled";
+
+		stmmac_axi_config_2: stmmac-axi-config {
+			snps,wr_osr_lmt = <0x7>;
+			snps,rd_osr_lmt = <0x7>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+	};
 };
diff --git a/arch/arm/dts/stm32mp135.dtsi b/arch/arm/dts/stm32mp135.dtsi
index abf2acd37b..d95b3d6d94 100644
--- a/arch/arm/dts/stm32mp135.dtsi
+++ b/arch/arm/dts/stm32mp135.dtsi
@@ -6,7 +6,27 @@
 
 #include "stm32mp133.dtsi"
 
-/ {
-	soc {
+&etzpc {
+	dcmipp: dcmipp@5a000000 {
+		compatible = "st,stm32mp13-dcmipp";
+		reg = <0x5a000000 0x400>;
+		interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+		resets = <&rcc DCMIPP_R>;
+		clocks = <&rcc DCMIPP_K>;
+		clock-names = "kclk";
+		access-controllers = <&etzpc 4>;
+		status = "disabled";
+	};
+
+	ltdc: display-controller@5a001000 {
+		compatible = "st,stm32-ltdc";
+		reg = <0x5a001000 0x400>;
+		interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc LTDC_PX>;
+		clock-names = "lcd";
+		resets = <&scmi_reset RST_SCMI_LTDC>;
+		access-controllers = <&etzpc 3>;
+		status = "disabled";
 	};
 };
diff --git a/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi b/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi
index 48605ff8bb..2c31a1bc38 100644
--- a/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi
@@ -11,20 +11,35 @@
 	};
 
 	config {
-		u-boot,boot-led = "led-blue";
-		u-boot,error-led = "led-red";
+		u-boot,boot-led = "heartbeat";
+		u-boot,error-led = "error";
 		u-boot,mmc-env-partition = "u-boot-env";
+		st,adc_usb_pd = <&adc1 6>, <&adc1 12>;
+		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
 	};
 
 	leds {
 		led-red {
-			color = <LED_COLOR_ID_RED>;
+			label = "error";
 			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
+		};
+
+		led-blue {
+			/delete-property/default-state;
 		};
 	};
 };
 
+&sdmmc2 {
+	status = "disabled";
+};
+
 &uart4 {
 	bootph-all;
 };
@@ -38,3 +53,7 @@
 		bootph-all;
 	};
 };
+
+&usbotg_hs {
+	u-boot,force-b-session-valid;
+};
diff --git a/arch/arm/dts/stm32mp135f-dk.dts b/arch/arm/dts/stm32mp135f-dk.dts
index f0900ca672..d3b47650d7 100644
--- a/arch/arm/dts/stm32mp135f-dk.dts
+++ b/arch/arm/dts/stm32mp135f-dk.dts
@@ -9,6 +9,7 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
 #include "stm32mp135.dtsi"
 #include "stm32mp13xf.dtsi"
 #include "stm32mp13-pinctrl.dtsi"
@@ -18,6 +19,8 @@
 	compatible = "st,stm32mp135f-dk", "st,stm32mp135";
 
 	aliases {
+		ethernet0 = &ethernet1;
+		ethernet1 = &ethernet2;
 		serial0 = &uart4;
 		serial1 = &usart1;
 		serial2 = &uart8;
@@ -26,6 +29,29 @@
 
 	chosen {
 		stdout-path = "serial0:115200n8";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_mco1: clk-mco1 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
 	};
 
 	memory@c0000000 {
@@ -52,6 +78,12 @@
 			linux,code = <BTN_1>;
 			gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 		};
+
+		button-wakeup {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+		};
 	};
 
 	leds {
@@ -66,44 +98,67 @@
 		};
 	};
 
-	v3v3_sw: v3v3-sw {
-		compatible = "regulator-fixed";
-		regulator-name = "v3v3_sw";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-always-on;
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioe 12 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
 	};
 
-	vdd_adc: vdd-adc {
-		compatible = "regulator-fixed";
-		regulator-name = "vdd_adc";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-always-on;
-	};
+	panel_rgb: panel-rgb {
+		compatible = "panel-dpi";
+		enable-gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_backlight>;
+		power-supply = <&scmi_v3v3_sw>;
+		data-mapping = "bgr666";
+		status = "okay";
 
-	vdd_sd: vdd-sd {
-		compatible = "regulator-fixed";
-		regulator-name = "vdd_sd";
-		regulator-min-microvolt = <2900000>;
-		regulator-max-microvolt = <2900000>;
-		regulator-always-on;
+		width-mm = <105>;
+		height-mm = <67>;
+
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&ltdc_out_rgb>;
+			};
+		};
+
+		panel-timing {
+			clock-frequency = <10000000>;
+			hactive = <480>;
+			vactive = <272>;
+			hsync-len = <52>;
+			hfront-porch = <10>;
+			hback-porch = <10>;
+			vsync-len = <10>;
+			vfront-porch = <10>;
+			vback-porch = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <1>;
+		};
 	};
 
-	vdd_usb: vdd-usb {
+	v3v3_ao: v3v3-ao {
 		compatible = "regulator-fixed";
-		regulator-name = "vdd_usb";
+		regulator-name = "v3v3_ao";
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
 		regulator-always-on;
 	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&mcp23017 11 GPIO_ACTIVE_LOW>;
+	};
 };
 
 &adc_1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&adc1_usb_cc_pins_a>;
-	vdda-supply = <&vdd_adc>;
-	vref-supply = <&vdd_adc>;
+	vdda-supply = <&scmi_vdd_adc>;
+	vref-supply = <&scmi_vdd_adc>;
 	status = "okay";
 	adc1: adc@0 {
 		status = "okay";
@@ -124,6 +179,94 @@
 	};
 };
 
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp {
+	status = "okay";
+};
+
+&dcmipp {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmipp_pins_a>;
+	pinctrl-1 = <&dcmipp_sleep_pins_a>;
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&mipid02_2>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <0>;
+			pclk-max-frequency = <120000000>;
+		};
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&ethernet1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rmii_pins_a>;
+	pinctrl-1 = <&eth1_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios =  <&mcp23017 9 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <1000>;
+			reset-deassert-us = <30000>;
+			reg = <0>;
+			wakeup-source;
+		};
+	};
+};
+
+&ethernet2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rmii_pins_a>;
+	pinctrl-1 = <&eth2_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	phy-supply = <&scmi_v3v3_sw>;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios = <&mcp23017 10 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <1000>;
+			reset-deassert-us = <30000>;
+			reg = <0>;
+		};
+	};
+};
+
 &i2c1 {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&i2c1_pins_a>;
@@ -153,13 +296,10 @@
 	typec@53 {
 		compatible = "st,stm32g0-typec";
 		reg = <0x53>;
-		/* Alert pin on PI2 */
-		interrupts = <2 IRQ_TYPE_EDGE_FALLING>;
-		interrupt-parent = <&gpioi>;
-		/* Internal pull-up on PI2 */
-		pinctrl-names = "default";
-		pinctrl-0 = <&stm32g0_intn_pins_a>;
+		/* Alert pin on PI2 (PWR wakeup pin), managed by optee */
+		interrupts-extended = <&optee 1>;
 		firmware-name = "stm32g0-ucsi.mp135f-dk.fw";
+		wakeup-source;
 		connector {
 			compatible = "usb-c-connector";
 			label = "USB-C";
@@ -184,17 +324,154 @@
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
+
+	stmipi: stmipi@14 {
+		compatible = "st,st-mipid02";
+		reg = <0x14>;
+		status = "okay";
+		clocks = <&clk_mco1>;
+		clock-names = "xclk";
+		VDDE-supply = <&scmi_v1v8_periph>;
+		VDDIN-supply = <&scmi_v1v8_periph>;
+		reset-gpios = <&mcp23017 2 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+
+				mipid02_0: endpoint {
+					data-lanes = <1 2>;
+					lane-polarities = <0 0 0>;
+					remote-endpoint = <&gc2145_ep>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+
+				mipid02_2: endpoint {
+					bus-width = <8>;
+					hsync-active = <0>;
+					vsync-active = <0>;
+					pclk-sample = <0>;
+					remote-endpoint = <&dcmipp_0>;
+				};
+			};
+		};
+	};
+
+	gc2145: gc2145@3c {
+		compatible = "galaxycore,gc2145";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		iovdd-supply = <&scmi_v3v3_sw>;
+		avdd-supply = <&scmi_v3v3_sw>;
+		dvdd-supply = <&scmi_v3v3_sw>;
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			gc2145_ep: endpoint {
+				remote-endpoint = <&mipid02_0>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <120000000 192000000 240000000>;
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&scmi_v3v3_sw>;
+		status = "disabled";
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		port {
+			ov5640_0: endpoint {
+				/*remote-endpoint = <&mipid02_0>;*/
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	goodix: goodix-ts@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&goodix_pins_a>;
+		interrupt-parent = <&gpiof>;
+		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
+		AVDD28-supply = <&scmi_v3v3_sw>;
+		VDDIO-supply = <&scmi_v3v3_sw>;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <272>;
+		status = "okay" ;
+	};
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	default-on;
 	status = "okay";
+
+	port {
+		ltdc_out_rgb: endpoint {
+			remote-endpoint = <&panel_in_rgb>;
+		};
+	};
 };
 
 &rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
 	status = "okay";
 };
 
+&scmi_regu {
+	scmi_vddcpu: regulator@6 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK1>;
+		regulator-name = "vddcpu";
+	};
+	scmi_vdd: regulator@8 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK3>;
+		regulator-name = "vdd";
+	};
+	scmi_vddcore: regulator@9 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK4>;
+		regulator-name = "vddcore";
+	};
+	scmi_vdd_adc: regulator@10 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO1>;
+		regulator-name = "vdd_adc";
+	};
+	scmi_vdd_usb: regulator@13 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO4>;
+		regulator-name = "vdd_usb";
+	};
+	scmi_vdd_sd: regulator@14 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO5>;
+		regulator-name = "vdd_sd";
+	};
+	scmi_v1v8_periph: regulator@15 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO6>;
+		regulator-name = "v1v8_periph";
+	};
+	scmi_v3v3_sw: regulator@19 {
+		reg = <VOLTD_SCMI_STPMIC1_PWR_SW2>;
+		regulator-name = "v3v3_sw";
+	};
+};
+
 &sdmmc1 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_clk_pins_a>;
@@ -204,10 +481,32 @@
 	disable-wp;
 	st,neg-edge;
 	bus-width = <4>;
-	vmmc-supply = <&vdd_sd>;
+	vmmc-supply = <&scmi_vdd_sd>;
 	status = "okay";
 };
 
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	cap-sdio-irq;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3_ao>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
 &spi5 {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi5_pins_a>;
@@ -219,6 +518,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm3_pins_a>;
 		pinctrl-1 = <&pwm3_sleep_pins_a>;
@@ -234,6 +536,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm4_pins_a>;
 		pinctrl-1 = <&pwm4_sleep_pins_a>;
@@ -249,6 +554,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm8_pins_a>;
 		pinctrl-1 = <&pwm8_sleep_pins_a>;
@@ -262,6 +570,9 @@
 
 &timers14 {
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm14_pins_a>;
 		pinctrl-1 = <&pwm14_sleep_pins_a>;
@@ -310,6 +621,14 @@
 	pinctrl-2 = <&usart2_idle_pins_a>;
 	uart-has-rtscts;
 	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&mcp23017 13 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3_ao>;
+		vddio-supply = <&v3v3_ao>;
+	};
 };
 
 &usbh_ehci {
@@ -321,7 +640,7 @@
 	hub@1 {
 		compatible = "usb424,2514";
 		reg = <1>;
-		vdd-supply = <&v3v3_sw>;
+		vdd-supply = <&scmi_v3v3_sw>;
 	};
 };
 
@@ -342,7 +661,7 @@
 };
 
 &usbphyc_port0 {
-	phy-supply = <&vdd_usb>;
+	phy-supply = <&scmi_vdd_usb>;
 	st,current-boost-microamp = <1000>;
 	st,decrease-hs-slew-rate;
 	st,tune-hs-dc-level = <2>;
@@ -356,7 +675,7 @@
 };
 
 &usbphyc_port1 {
-	phy-supply = <&vdd_usb>;
+	phy-supply = <&scmi_vdd_usb>;
 	st,current-boost-microamp = <1000>;
 	st,decrease-hs-slew-rate;
 	st,tune-hs-dc-level = <2>;
diff --git a/arch/arm/dts/stm32mp13xa.dtsi b/arch/arm/dts/stm32mp13xa.dtsi
new file mode 100644
index 0000000000..cc6456e71b
--- /dev/null
+++ b/arch/arm/dts/stm32mp13xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/dts/stm32mp13xc.dtsi b/arch/arm/dts/stm32mp13xc.dtsi
index 4d00e75928..5ed8fdd40c 100644
--- a/arch/arm/dts/stm32mp13xc.dtsi
+++ b/arch/arm/dts/stm32mp13xc.dtsi
@@ -4,15 +4,17 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/ {
-	soc {
-		cryp: crypto@54002000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
-		};
+&etzpc {
+	cryp: crypto@54002000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x54002000 0x400>;
+		interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&mdma 28 0x0 0x400202 0x0 0x0>,
+		       <&mdma 29 0x3 0x400808 0x0 0x0>;
+		dma-names = "in", "out";
+		access-controllers = <&etzpc 42>;
+		status = "disabled";
 	};
 };
diff --git a/arch/arm/dts/stm32mp13xd.dtsi b/arch/arm/dts/stm32mp13xd.dtsi
new file mode 100644
index 0000000000..2a436a379e
--- /dev/null
+++ b/arch/arm/dts/stm32mp13xd.dtsi
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&cpu_thermal {
+	trips {
+		cpu_alert: cpu-alert0 {
+			temperature = <90000>;
+			hysteresis = <10000>;
+			type = "passive";
+		};
+
+		cpu_crit: cpu-crit0 {
+			temperature = <100000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu_alert>;
+			cooling-device = <&cpu0 1 1>;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp13xf.dtsi b/arch/arm/dts/stm32mp13xf.dtsi
index 4d00e75928..99ddf7e9d5 100644
--- a/arch/arm/dts/stm32mp13xf.dtsi
+++ b/arch/arm/dts/stm32mp13xf.dtsi
@@ -4,15 +4,40 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/ {
-	soc {
-		cryp: crypto@54002000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
+&cpu_thermal {
+	trips {
+		cpu_alert: cpu-alert0 {
+			temperature = <90000>;
+			hysteresis = <10000>;
+			type = "passive";
 		};
+
+		cpu_crit: cpu-crit0 {
+			temperature = <100000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu_alert>;
+			cooling-device = <&cpu0 1 1>;
+		};
+	};
+};
+
+&etzpc {
+	cryp: crypto@54002000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x54002000 0x400>;
+		interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&mdma 28 0x0 0x400202 0x0 0x0>,
+		       <&mdma 29 0x3 0x400808 0x0 0x0>;
+		dma-names = "in", "out";
+		access-controllers = <&etzpc 42>;
+		status = "disabled";
 	};
 };
diff --git a/arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi b/arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi
new file mode 100644
index 0000000000..49a3ea5db9
--- /dev/null
+++ b/arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi
@@ -0,0 +1,524 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	m4_adc1_in6_pins_a: m4-adc1-in6 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, RSVD)>;
+		};
+	};
+
+	m4_adc12_ain_pins_a: m4-adc12-ain-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>, /* ADC1 in13 */
+				 <STM32_PINMUX('F', 12, RSVD)>, /* ADC1 in6 */
+				 <STM32_PINMUX('F', 13, RSVD)>, /* ADC2 in2 */
+				 <STM32_PINMUX('F', 14, RSVD)>; /* ADC2 in6 */
+		};
+	};
+
+	m4_adc12_usb_pwr_pins_a: m4-adc12-usb-pwr-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>, /* ADC12 in18 */
+				 <STM32_PINMUX('A', 5, RSVD)>; /* ADC12 in19 */
+		};
+	};
+
+	m4_cec_pins_a: m4-cec-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, RSVD)>;
+		};
+	};
+
+	m4_cec_pins_b: m4-cec-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, RSVD)>;
+		};
+	};
+
+	m4_dac_ch1_pins_a: m4-dac-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>;
+		};
+	};
+
+	m4_dac_ch2_pins_a: m4-dac-ch2 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, RSVD)>;
+		};
+	};
+
+	m4_dcmi_pins_a: m4-dcmi-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 8,  RSVD)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('B', 7,  RSVD)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('A', 6,  RSVD)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('H', 9,  RSVD)>,/* DCMI_D0 */
+				 <STM32_PINMUX('H', 10, RSVD)>,/* DCMI_D1 */
+				 <STM32_PINMUX('H', 11, RSVD)>,/* DCMI_D2 */
+				 <STM32_PINMUX('H', 12, RSVD)>,/* DCMI_D3 */
+				 <STM32_PINMUX('H', 14, RSVD)>,/* DCMI_D4 */
+				 <STM32_PINMUX('I', 4,  RSVD)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B', 8,  RSVD)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 6,  RSVD)>,/* DCMI_D7 */
+				 <STM32_PINMUX('I', 1,  RSVD)>,/* DCMI_D8 */
+				 <STM32_PINMUX('H', 7,  RSVD)>,/* DCMI_D9 */
+				 <STM32_PINMUX('I', 3,  RSVD)>,/* DCMI_D10 */
+				 <STM32_PINMUX('H', 15, RSVD)>;/* DCMI_D11 */
+		};
+	};
+
+	m4_dfsdm_clkout_pins_a: m4-dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, RSVD)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	m4_dfsdm_data1_pins_a: m4-dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>; /* DFSDM_DATA1 */
+		};
+	};
+
+	m4_dfsdm_data3_pins_a: m4-dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, RSVD)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	m4_ethernet0_rgmii_pins_a: m4-ethernet0-rgmii-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 5, RSVD)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, RSVD)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, RSVD)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, RSVD)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, RSVD)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, RSVD)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, RSVD)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('C', 1, RSVD)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 2, RSVD)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 4, RSVD)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, RSVD)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('B', 0, RSVD)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, RSVD)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, RSVD)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, RSVD)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	m4_fmc_pins_a: m4-fmc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, RSVD)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, RSVD)>, /* FMC_NWE */
+				 <STM32_PINMUX('D', 11, RSVD)>, /* FMC_A16_FMC_CLE */
+				 <STM32_PINMUX('D', 12, RSVD)>, /* FMC_A17_FMC_ALE */
+				 <STM32_PINMUX('D', 14, RSVD)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, RSVD)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, RSVD)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, RSVD)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, RSVD)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, RSVD)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, RSVD)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, RSVD)>, /* FMC_D7 */
+				 <STM32_PINMUX('G', 9, RSVD)>, /* FMC_NE2_FMC_NCE */
+				 <STM32_PINMUX('D', 6, RSVD)>; /* FMC_NWAIT */
+		};
+	};
+
+	m4_hdp0_pins_a: m4-hdp0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 12, RSVD)>; /* HDP0 */
+		};
+	};
+
+	m4_hdp6_pins_a: m4-hdp6-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 5, RSVD)>; /* HDP6 */
+		};
+	};
+
+	m4_hdp7_pins_a: m4-hdp7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 6, RSVD)>; /* HDP7 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, RSVD)>, /* I2C1_SCL */
+				 <STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_i2c2_pins_a: m4-i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 4, RSVD)>, /* I2C2_SCL */
+				 <STM32_PINMUX('H', 5, RSVD)>; /* I2C2_SDA */
+		};
+	};
+
+	m4_i2c5_pins_a: m4-i2c5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* I2C5_SCL */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* I2C5_SDA */
+		};
+	};
+
+	m4_i2s2_pins_a: m4-i2s2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 3, RSVD)>, /* I2S2_SDO */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* I2S2_WS */
+				 <STM32_PINMUX('A', 9, RSVD)>; /* I2S2_CK */
+		};
+	};
+
+	m4_ltdc_pins_a: m4-ltdc-a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G',  7, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 10, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I',  9, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('F', 10, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('H',  2, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('H',  3, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('H',  8, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('H',  9, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('H', 10, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('C',  0, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('H', 12, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('E', 15, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('E',  5, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('E',  6, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('H', 13, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('H', 14, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('H', 15, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('I',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('I',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('I',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('D',  9, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('G', 12, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('D', 10, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('I',  4, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('A',  3, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  8, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('D',  8, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_ltdc_pins_b: m4-ltdc-b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 14, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 12, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I', 13, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('K',  7, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('I', 15, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('J',  0, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('J',  1, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('J',  2, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('J',  3, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('J',  4, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('J',  5, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('J',  6, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('J',  7, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('J',  8, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('J',  9, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('J', 10, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('J', 11, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('K',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('K',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('K',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('J', 12, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('J', 13, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('J', 14, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('J', 15, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('K',  3, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('K',  4, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('K',  5, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('K',  6, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_m_can1_pins_a: m4-m-can1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 13, RSVD)>, /* CAN1_TX */
+				 <STM32_PINMUX('I', 9, RSVD)>; /* CAN1_RX */
+		};
+	};
+
+	m4_pwm1_pins_a: m4-pwm1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>, /* TIM1_CH1 */
+				 <STM32_PINMUX('E', 11, RSVD)>, /* TIM1_CH2 */
+				 <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_pwm2_pins_a: m4-pwm2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, RSVD)>; /* TIM2_CH4 */
+		};
+	};
+
+	m4_pwm3_pins_a: m4-pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, RSVD)>; /* TIM3_CH2 */
+		};
+	};
+
+	m4_pwm4_pins_a: m4-pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 14, RSVD)>, /* TIM4_CH3 */
+				 <STM32_PINMUX('D', 15, RSVD)>; /* TIM4_CH4 */
+		};
+	};
+
+	m4_pwm4_pins_b: m4-pwm4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, RSVD)>; /* TIM4_CH2 */
+		};
+	};
+
+	m4_pwm5_pins_a: m4-pwm5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, RSVD)>; /* TIM5_CH2 */
+		};
+	};
+
+	m4_pwm8_pins_a: m4-pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, RSVD)>; /* TIM8_CH4 */
+		};
+	};
+
+	m4_pwm12_pins_a: m4-pwm12-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 6, RSVD)>; /* TIM12_CH1 */
+		};
+	};
+
+	m4_qspi_bk1_pins_a: m4-qspi-bk1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 8, RSVD)>, /* QSPI_BK1_IO0 */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* QSPI_BK1_IO1 */
+				 <STM32_PINMUX('F', 7, RSVD)>, /* QSPI_BK1_IO2 */
+				 <STM32_PINMUX('F', 6, RSVD)>, /* QSPI_BK1_IO3 */
+				 <STM32_PINMUX('B', 6, RSVD)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	m4_qspi_bk2_pins_a: m4-qspi-bk2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, RSVD)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, RSVD)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, RSVD)>, /* QSPI_BK2_IO3 */
+				 <STM32_PINMUX('C', 0, RSVD)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	m4_qspi_clk_pins_a: m4-qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, RSVD)>; /* QSPI_CLK */
+		};
+	};
+
+	m4_rtc_out2_rmp_pins_a: m4-rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, RSVD)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	m4_sai2a_pins_a: m4-sai2a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 5, RSVD)>, /* SAI2_SCK_A */
+				 <STM32_PINMUX('I', 6, RSVD)>, /* SAI2_SD_A */
+				 <STM32_PINMUX('I', 7, RSVD)>, /* SAI2_FS_A */
+				 <STM32_PINMUX('E', 0, RSVD)>; /* SAI2_MCLK_A */
+		};
+	};
+
+	m4_sai2b_pins_a: m4-sai2b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('E', 13, RSVD)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SAI2_MCLK_B */
+				 <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai2b_pins_b: m4-sai2b-2 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai4a_pins_a: m4-sai4a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, RSVD)>; /* SAI4_SD_A */
+		};
+	};
+
+	m4_sdmmc1_b4_pins_a: m4-sdmmc1-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, RSVD)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, RSVD)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, RSVD)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, RSVD)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, RSVD)>, /* SDMMC1_CMD */
+				 <STM32_PINMUX('C', 12, RSVD)>; /* SDMMC1_CK */
+		};
+	};
+
+	m4_sdmmc1_dir_pins_a: m4-sdmmc1-dir-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, RSVD)>, /* SDMMC1_D0DIR */
+				 <STM32_PINMUX('C', 7, RSVD)>, /* SDMMC1_D123DIR */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* SDMMC1_CDIR */
+				 <STM32_PINMUX('E', 4, RSVD)>; /* SDMMC1_CKIN */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_a: m4-sdmmc2-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_b: m4-sdmmc2-b4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_d47_pins_a: m4-sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, RSVD)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, RSVD)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 5, RSVD)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* SDMMC2_D7 */
+		};
+	};
+
+	m4_sdmmc3_b4_pins_a: m4-sdmmc3-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 0, RSVD)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('F', 4, RSVD)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('F', 5, RSVD)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('D', 7, RSVD)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('F', 1, RSVD)>, /* SDMMC3_CMD */
+				 <STM32_PINMUX('G', 15, RSVD)>; /* SDMMC3_CK */
+		};
+	};
+
+	m4_spdifrx_pins_a: m4-spdifrx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, RSVD)>; /* SPDIF_IN1 */
+		};
+	};
+
+	m4_spi4_pins_a: m4-spi4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SPI4_MOSI */
+				 <STM32_PINMUX('E', 13, RSVD)>; /* SPI4_MISO */
+		};
+	};
+
+	m4_spi5_pins_a: m4-spi5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, RSVD)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* SPI5_MOSI */
+				 <STM32_PINMUX('F', 8, RSVD)>; /* SPI5_MISO */
+		};
+	};
+
+	m4_stusb1600_pins_a: m4-stusb1600-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 11, RSVD)>;
+		};
+	};
+
+	m4_uart4_pins_a: m4-uart4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, RSVD)>, /* UART4_TX */
+				 <STM32_PINMUX('B', 2, RSVD)>; /* UART4_RX */
+		};
+	};
+
+	m4_uart7_pins_a: m4-uart7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 8, RSVD)>, /* USART7_TX */
+				 <STM32_PINMUX('E', 7, RSVD)>; /* USART7_RX */
+		};
+	};
+
+	m4_usart2_pins_a: m4-usart2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 5, RSVD)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, RSVD)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 6, RSVD)>, /* USART2_RX */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* USART2_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('I', 10, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_b: m4-usart3-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 13, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usbotg_fs_dp_dm_pins_a: m4-usbotg-fs-dp-dm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* OTG_FS_DP */
+		};
+	};
+
+	m4_usbotg_hs_pins_a: m4-usbotg-hs-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, RSVD)>; /* OTG_ID */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_i2c4_pins_a: m4-i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, RSVD)>, /* I2C4_SCL */
+				 <STM32_PINMUX('Z', 5, RSVD)>; /* I2C4_SDA */
+		};
+	};
+
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 2, RSVD)>, /* SPI1_MOSI */
+				 <STM32_PINMUX('Z', 1, RSVD)>; /* SPI1_MISO */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15-m4-srm.dtsi b/arch/arm/dts/stm32mp15-m4-srm.dtsi
new file mode 100644
index 0000000000..7fa3ca411a
--- /dev/null
+++ b/arch/arm/dts/stm32mp15-m4-srm.dtsi
@@ -0,0 +1,447 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&m4_rproc {
+	m4_system_resources {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		m4_timers2: timer@40000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40000000 0x400>;
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers3: timer@40001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40001000 0x400>;
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers4: timer@40002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40002000 0x400>;
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers5: timer@40003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40003000 0x400>;
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers6: timer@40004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40004000 0x400>;
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers7: timer@40005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40005000 0x400>;
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers12: timer@40006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40006000 0x400>;
+			clocks = <&rcc TIM12_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers13: timer@40007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40007000 0x400>;
+			clocks = <&rcc TIM13_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers14: timer@40008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40008000 0x400>;
+			clocks = <&rcc TIM14_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_lptimer1: timer@40009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40009000 0x400>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_spi2: spi@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			clocks = <&rcc SPI2_K>;
+			status = "disabled";
+		};
+		m4_i2s2: audio-controller@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			status = "disabled";
+		};
+		m4_spi3: spi@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			clocks = <&rcc SPI3_K>;
+			status = "disabled";
+		};
+		m4_i2s3: audio-controller@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			status = "disabled";
+		};
+		m4_spdifrx: audio-controller@4000d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			status = "disabled";
+		};
+		m4_usart2: serial@4000e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000e000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <27 1>;
+			clocks = <&rcc USART2_K>;
+			status = "disabled";
+		};
+		m4_usart3: serial@4000f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000f000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <28 1>;
+			clocks = <&rcc USART3_K>;
+			status = "disabled";
+		};
+		m4_uart4: serial@40010000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40010000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <30 1>;
+			clocks = <&rcc UART4_K>;
+			status = "disabled";
+		};
+		m4_uart5: serial@40011000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40011000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <31 1>;
+			clocks = <&rcc UART5_K>;
+			status = "disabled";
+		};
+		m4_i2c1: i2c@40012000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40012000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <21 1>;
+			clocks = <&rcc I2C1_K>;
+			status = "disabled";
+		};
+		m4_i2c2: i2c@40013000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40013000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <22 1>;
+			clocks = <&rcc I2C2_K>;
+			status = "disabled";
+		};
+		m4_i2c3: i2c@40014000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40014000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <23 1>;
+			clocks = <&rcc I2C3_K>;
+			status = "disabled";
+		};
+		m4_i2c5: i2c@40015000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40015000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <25 1>;
+			clocks = <&rcc I2C5_K>;
+			status = "disabled";
+		};
+		m4_cec: cec@40016000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40016000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <69 1>;
+			clocks = <&rcc CEC_K>, <&rcc CEC>;
+			clock-names = "cec", "hdmi-cec";
+			status = "disabled";
+		};
+		m4_dac: dac@40017000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40017000 0x400>;
+			clocks = <&rcc DAC12>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+		m4_uart7: serial@40018000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40018000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <32 1>;
+			clocks = <&rcc UART7_K>;
+			status = "disabled";
+		};
+		m4_uart8: serial@40019000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40019000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <33 1>;
+			clocks = <&rcc UART8_K>;
+			status = "disabled";
+		};
+		m4_timers1: timer@44000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44000000 0x400>;
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers8: timer@44001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44001000 0x400>;
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_usart6: serial@44003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44003000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <29 1>;
+			clocks = <&rcc USART6_K>;
+			status = "disabled";
+		};
+		m4_spi1: spi@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			clocks = <&rcc SPI1_K>;
+			status = "disabled";
+		};
+		m4_i2s1: audio-controller@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			status = "disabled";
+		};
+		m4_spi4: spi@44005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44005000 0x400>;
+			clocks = <&rcc SPI4_K>;
+			status = "disabled";
+		};
+		m4_timers15: timer@44006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44006000 0x400>;
+			clocks = <&rcc TIM15_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers16: timer@44007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44007000 0x400>;
+			clocks = <&rcc TIM16_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers17: timer@44008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44008000 0x400>;
+			clocks = <&rcc TIM17_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_spi5: spi@44009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44009000 0x400>;
+			clocks = <&rcc SPI5_K>;
+			status = "disabled";
+		};
+		m4_sai1: sai@4400a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400a000 0x4>;
+			clocks = <&rcc SAI1_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai2: sai@4400b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400b000 0x4>;
+			clocks = <&rcc SAI2_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai3: sai@4400c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400c000 0x4>;
+			clocks = <&rcc SAI3_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_dfsdm: dfsdm@4400d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+			clock-names = "dfsdm", "audio";
+			status = "disabled";
+		};
+		m4_m_can1: can@4400e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400e000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_m_can2: can@4400f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_dma1: dma@48000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48000000 0x400>;
+			clocks = <&rcc DMA1>;
+			status = "disabled";
+		};
+		m4_dma2: dma@48001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48001000 0x400>;
+			clocks = <&rcc DMA2>;
+			status = "disabled";
+		};
+		m4_dmamux1: dma-router@48002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48002000 0x1c>;
+			clocks = <&rcc DMAMUX>;
+			status = "disabled";
+		};
+		m4_adc: adc@48003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48003000 0x400>;
+			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+			clock-names = "bus", "adc";
+			status = "disabled";
+		};
+		m4_sdmmc3: sdmmc@48004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48004000 0x400>, <0x48005000 0x400>;
+			clocks = <&rcc SDMMC3_K>;
+			status = "disabled";
+		};
+		m4_usbotg_hs: usb-otg@49000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x49000000 0x10000>;
+			clocks = <&rcc USBO_K>;
+			clock-names = "otg";
+			status = "disabled";
+		};
+		m4_hash2: hash@4c002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c002000 0x400>;
+			clocks = <&rcc HASH2>;
+			status = "disabled";
+		};
+		m4_rng2: rng@4c003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c003000 0x400>;
+			clocks = <&rcc RNG2_K>;
+			status = "disabled";
+		};
+		m4_crc2: crc@4c004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c004000 0x400>;
+			clocks = <&rcc CRC2>;
+			status = "disabled";
+		};
+		m4_cryp2: cryp@4c005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c005000 0x400>;
+			clocks = <&rcc CRYP2>;
+			status = "disabled";
+		};
+		m4_dcmi: dcmi@4c006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c006000 0x400>;
+			clocks = <&rcc DCMI>;
+			clock-names = "mclk";
+			status = "disabled";
+		};
+		m4_lptimer2: timer@50021000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50021000 0x400>;
+			clocks = <&rcc LPTIM2_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer3: timer@50022000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50022000 0x400>;
+			clocks = <&rcc LPTIM3_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer4: timer@50023000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50023000 0x400>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer5: timer@50024000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50024000 0x400>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_sai4: sai@50027000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50027000 0x4>;
+			clocks = <&rcc SAI4_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+			};
+		m4_fmc: memory-controller@58002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800200 0x1000>;
+			clocks = <&rcc FMC_K>;
+			status = "disabled";
+		};
+		m4_qspi: qspi@58003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+			clocks = <&rcc QSPI_K>;
+			status = "disabled";
+		};
+		m4_ethernet0: ethernet@5800a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800a000 0x2000>;
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "syscfg-clk";
+			clocks = <&rcc ETHMAC>,
+				 <&rcc ETHTX>,
+				 <&rcc ETHRX>,
+				 <&rcc ETHSTP>,
+				 <&rcc SYSCFG>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15-pinctrl.dtsi b/arch/arm/dts/stm32mp15-pinctrl.dtsi
index e86d989dd3..534a03da21 100644
--- a/arch/arm/dts/stm32mp15-pinctrl.dtsi
+++ b/arch/arm/dts/stm32mp15-pinctrl.dtsi
@@ -4,8 +4,27 @@
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
+#include <dt-bindings/pinctrl/stm32mp15-hdp.h>
+
+&hdp {
+	hdp2_gpo: hdp2-pins {
+		pins = "hdp2";
+		function = HDP2_GPOVAL_2;
+	};
+};
 
 &pinctrl {
+	adc1_ain_pins_a: adc1-ain-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 11, ANALOG)>, /* ADC1_INP2 */
+				 <STM32_PINMUX('B', 1, ANALOG)>, /* ADC1_INP5 */
+				 <STM32_PINMUX('B', 0, ANALOG)>, /* ADC1_INP9 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ADC1_INP10 */
+				 <STM32_PINMUX('C', 3, ANALOG)>, /* ADC1_INP13 */
+				 <STM32_PINMUX('A', 3, ANALOG)>; /* ADC1_INP15 */
+		};
+	};
+
 	adc1_in6_pins_a: adc1-in6-0 {
 		pins {
 			pinmux = <STM32_PINMUX('F', 12, ANALOG)>;
@@ -188,7 +207,41 @@
 		};
 	};
 
-	ethernet0_rgmii_pins_a: rgmii-0 {
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+	dfsdm_data1_pins_a: dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_DATA1 */
+		};
+	};
+	dfsdm_data1_sleep_pins_a: dfsdm-data1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_DATA1 */
+		};
+	};
+	dfsdm_data3_pins_a: dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATA3 */
+		};
+	};
+	dfsdm_data3_sleep_pins_a: dfsdm-data3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	ethernet0_rgmii_pins_a: ethernet0-rgmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -219,7 +272,7 @@
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_a: rgmii-sleep-0 {
+	ethernet0_rgmii_sleep_pins_a: ethernet0-rgmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -239,7 +292,7 @@
 		};
 	};
 
-	ethernet0_rgmii_pins_b: rgmii-1 {
+	ethernet0_rgmii_pins_b: ethernet0-rgmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -270,7 +323,7 @@
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_b: rgmii-sleep-1 {
+	ethernet0_rgmii_sleep_pins_b: ethernet0-rgmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -290,7 +343,7 @@
 		 };
 	};
 
-	ethernet0_rgmii_pins_c: rgmii-2 {
+	ethernet0_rgmii_pins_c: ethernet0-rgmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -321,7 +374,7 @@
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_c: rgmii-sleep-2 {
+	ethernet0_rgmii_sleep_pins_c: ethernet0-rgmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -341,7 +394,97 @@
 		};
 	};
 
-	ethernet0_rmii_pins_a: rmii-0 {
+	ethernet0_rgmii_pins_d: ethernet0-rgmii-3 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 13, AF11)>,	/* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>,	/* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, AF11)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, AF11)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, AF11)>,	/* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('C', 1, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 2, AF11)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 6, AF11)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, AF11)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, AF11)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+		};
+	};
+
+	ethernet0_rgmii_sleep_pins_d: ethernet0-rgmii-sleep-3 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 6, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, ANALOG)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	ethernet0_rgmii_pins_e: ethernet0-rgmii-4 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, AF11)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, AF11)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, AF11)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, AF11)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 6, AF11)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 7, AF11)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, AF11)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+		};
+	};
+
+	ethernet0_rgmii_sleep_pins_e: ethernet0-rgmii-sleep-4 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 6, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 7, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, ANALOG)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	ethernet0_rmii_pins_a: ethernet0-rmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -361,7 +504,7 @@
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_a: rmii-sleep-0 {
+	ethernet0_rmii_sleep_pins_a: ethernet0-rmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -375,7 +518,7 @@
 		};
 	};
 
-	ethernet0_rmii_pins_b: rmii-1 {
+	ethernet0_rmii_pins_b: ethernet0-rmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('B', 5, AF0)>, /* ETH1_CLK */
 				<STM32_PINMUX('C', 1, AF11)>, /* ETH1_MDC */
@@ -402,7 +545,7 @@
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_b: rmii-sleep-1 {
+	ethernet0_rmii_sleep_pins_b: ethernet0-rmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
 				<STM32_PINMUX('A', 7, ANALOG)>, /* ETH1_CRS_DV */
@@ -416,7 +559,7 @@
 		};
 	};
 
-	ethernet0_rmii_pins_c: rmii-2 {
+	ethernet0_rmii_pins_c: ethernet0-rmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -436,7 +579,7 @@
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_c: rmii-sleep-2 {
+	ethernet0_rmii_sleep_pins_c: ethernet0-rmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -549,6 +692,21 @@
 		};
 	};
 
+	hdp2_pins_a: hdp2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, AF0)>; /* HDP2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp2_sleep_pins_a: hdp2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>; /* HDP2 */
+		};
+	};
+
 	i2c1_pins_a: i2c1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
@@ -960,36 +1118,6 @@
 		};
 	};
 
-	mco1_pins_a: mco1-0 {
-		pins {
-			pinmux = <STM32_PINMUX('A', 13, AF2)>; /* MCO1 */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <1>;
-		};
-	};
-
-	mco1_sleep_pins_a: mco1-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('A', 13, ANALOG)>; /* MCO1 */
-		};
-	};
-
-	mco2_pins_a: mco2-0 {
-		pins {
-			pinmux = <STM32_PINMUX('G', 2, AF1)>; /* MCO2 */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <2>;
-		};
-	};
-
-	mco2_sleep_pins_a: mco2-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('G', 2, ANALOG)>; /* MCO2 */
-		};
-	};
-
 	m_can1_pins_a: m-can1-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('H', 13, AF9)>; /* CAN1_TX */
@@ -1003,7 +1131,7 @@
 		};
 	};
 
-	m_can1_sleep_pins_a: m_can1-sleep-0 {
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('I', 9, ANALOG)>; /* CAN1_RX */
@@ -1023,7 +1151,7 @@
 		};
 	};
 
-	m_can1_sleep_pins_b: m_can1-sleep-1 {
+	m_can1_sleep_pins_b: m-can1-sleep-1 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('A', 11, ANALOG)>; /* CAN1_RX */
@@ -1043,7 +1171,7 @@
 		};
 	};
 
-	m_can1_sleep_pins_c: m_can1-sleep-2 {
+	m_can1_sleep_pins_c: m-can1-sleep-2 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('H', 14, ANALOG)>; /* CAN1_RX */
@@ -1063,13 +1191,43 @@
 		};
 	};
 
-	m_can2_sleep_pins_a: m_can2-sleep-0 {
+	m_can2_sleep_pins_a: m-can2-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 13, ANALOG)>, /* CAN2_TX */
 				 <STM32_PINMUX('B', 5, ANALOG)>; /* CAN2_RX */
 		};
 	};
 
+	mco1_pins_a: mco1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, AF2)>; /* MCO1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	mco1_sleep_pins_a: mco1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, ANALOG)>; /* MCO1 */
+		};
+	};
+
+	mco2_pins_a: mco2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 2, AF1)>; /* MCO2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	mco2_sleep_pins_a: mco2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 2, ANALOG)>; /* MCO2 */
+		};
+	};
+
 	pwm1_pins_a: pwm1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('E', 9, AF1)>, /* TIM1_CH1 */
@@ -1104,6 +1262,20 @@
 		};
 	};
 
+	pwm1_pins_c: pwm1-2 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 11, AF1)>; /* TIM1_CH2 */
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm1_sleep_pins_c: pwm1-sleep-2 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 11, ANALOG)>; /* TIM1_CH2 */
+		};
+	};
+
 	pwm2_pins_a: pwm2-0 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 3, AF1)>; /* TIM2_CH4 */
@@ -1230,33 +1402,38 @@
 		};
 	};
 
-	pwm12_pins_a: pwm12-0 {
+	pwm8_pins_b: pwm8-1 {
 		pins {
-			pinmux = <STM32_PINMUX('H', 6, AF2)>; /* TIM12_CH1 */
-			bias-pull-down;
+			pinmux = <STM32_PINMUX('I', 5, AF3)>, /* TIM8_CH1 */
+				 <STM32_PINMUX('I', 6, AF3)>, /* TIM8_CH2 */
+				 <STM32_PINMUX('I', 7, AF3)>, /* TIM8_CH3 */
+				 <STM32_PINMUX('C', 9, AF3)>; /* TIM8_CH4 */
 			drive-push-pull;
 			slew-rate = <0>;
 		};
 	};
 
-	pwm12_sleep_pins_a: pwm12-sleep-0 {
+	pwm8_sleep_pins_b: pwm8-sleep-1 {
 		pins {
-			pinmux = <STM32_PINMUX('H', 6, ANALOG)>; /* TIM12_CH1 */
+			pinmux = <STM32_PINMUX('I', 5, ANALOG)>, /* TIM8_CH1 */
+				 <STM32_PINMUX('I', 6, ANALOG)>, /* TIM8_CH2 */
+				 <STM32_PINMUX('I', 7, ANALOG)>, /* TIM8_CH3 */
+				 <STM32_PINMUX('C', 9, ANALOG)>; /* TIM8_CH4 */
 		};
 	};
 
-	qspi_clk_pins_a: qspi-clk-0 {
+	pwm12_pins_a: pwm12-0 {
 		pins {
-			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
-			bias-disable;
+			pinmux = <STM32_PINMUX('H', 6, AF2)>; /* TIM12_CH1 */
+			bias-pull-down;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 	};
 
-	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+	pwm12_sleep_pins_a: pwm12-sleep-0 {
 		pins {
-			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+			pinmux = <STM32_PINMUX('H', 6, ANALOG)>; /* TIM12_CH1 */
 		};
 	};
 
@@ -1302,6 +1479,21 @@
 		};
 	};
 
+	qspi_clk_pins_a: qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+		};
+	};
+
 	qspi_cs1_pins_a: qspi-cs1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
@@ -1332,6 +1524,12 @@
 		};
 	};
 
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
 	sai2a_pins_a: sai2a-0 {
 		pins {
 			pinmux = <STM32_PINMUX('I', 5, AF10)>, /* SAI2_SCK_A */
@@ -1441,6 +1639,30 @@
 		};
 	};
 
+	sai2b_pins_d: sai2b-3 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 2, AF10)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('C', 0, AF8)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('H', 3, AF10)>; /* SAI2_MCLK_B */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 11, AF10)>; /* SAI2_SD_B */
+			bias-disable;
+		};
+	};
+
+	sai2b_sleep_pins_d: sai2b-sleep-3 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* SAI2_MCLK_B */
+				 <STM32_PINMUX('F', 11, ANALOG)>; /* SAI2_SD_B */
+		};
+	};
+
 	sai4a_pins_a: sai4a-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 5, AF10)>; /* SAI4_SD_A */
@@ -1475,6 +1697,18 @@
 		};
 	};
 
+	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
 	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -1499,23 +1733,65 @@
 		};
 	};
 
-	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
+	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc1_b4_pins_b: sdmmc1-b4-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
 				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
-				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 6, AF8)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_b: sdmmc1-b4-od-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 6, AF8)>, /* SDMMC1_D2 */
 				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
 			slew-rate = <1>;
 			drive-push-pull;
 			bias-disable;
 		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-disable;
+		};
 	};
 
-	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+	sdmmc1_b4_sleep_pins_b: sdmmc1-b4-sleep-1 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
 				 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
-				 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC1_D2 */
 				 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
 				 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
 				 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
@@ -1531,7 +1807,7 @@
 			drive-push-pull;
 			bias-pull-up;
 		};
-		pins2{
+		pins2 {
 			pinmux = <STM32_PINMUX('E', 4, AF8)>; /* SDMMC1_CKIN */
 			bias-pull-up;
 		};
@@ -1566,7 +1842,7 @@
 			drive-push-pull;
 			bias-pull-up;
 		};
-		pins2{
+		pins2 {
 			pinmux = <STM32_PINMUX('E', 4, AF8)>; /* SDMMC1_CKIN */
 			bias-pull-up;
 		};
@@ -1759,6 +2035,27 @@
 		};
 	};
 
+	sdmmc2_d47_pins_e: sdmmc2-d47-4 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, AF9)>,	/* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, AF10)>,	/* SDMMC2_D5 */
+				 <STM32_PINMUX('C', 6, AF10)>,	/* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, AF9)>;	/* SDMMC2_D7 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_sleep_pins_e: sdmmc2-d47-sleep-4 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('C', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, ANALOG)>; /* SDMMC2_D7 */
+		};
+	};
+
 	sdmmc3_b4_pins_a: sdmmc3-b4-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('F', 0, AF9)>, /* SDMMC3_D0 */
@@ -1925,6 +2222,20 @@
 		};
 	};
 
+	spi2_pins_c: spi2-2 {
+		pins1 {
+			pinmux = <STM32_PINMUX('I', 1, AF5)>, /* SPI2_SCK */
+				 <STM32_PINMUX('I', 3, AF5)>; /* SPI2_MOSI */
+			bias-disable;
+			drive-push-pull;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 2, AF5)>; /* SPI2_MISO */
+			bias-pull-down;
+		};
+	};
+
 	spi4_pins_a: spi4-0 {
 		pins {
 			pinmux = <STM32_PINMUX('E', 12, AF5)>, /* SPI4_SCK */
@@ -1939,6 +2250,52 @@
 		};
 	};
 
+	spi4_pins_b: spi4-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 12, AF5)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, AF5)>; /* SPI4_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 13, AF5)>; /* SPI4_MISO */
+			bias-disable;
+		};
+	};
+
+	spi4_sleep_pins_b: spi4-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, ANALOG)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* SPI4_MISO */
+				 <STM32_PINMUX('E', 14, ANALOG)>; /* SPI4_MOSI */
+		};
+	};
+
+	spi5_pins_a: spi5-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF5)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, AF5)>; /* SPI5_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF5)>; /* SPI5_MISO */
+			bias-disable;
+		};
+	};
+
+	spi5_sleep_pins_a: spi5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* SPI5_MISO */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* SPI5_MOSI */
+		};
+	};
+
 	stusb1600_pins_a: stusb1600-0 {
 		pins {
 			pinmux = <STM32_PINMUX('I', 11, GPIO)>;
@@ -2124,6 +2481,33 @@
 		};
 	};
 
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 12, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 11, AF7)>; /* USART1_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* USART1_RTS */
+				 <STM32_PINMUX('A', 11, AF7)>; /* USART1_CTS_NSS */
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* USART1_RTS */
+				 <STM32_PINMUX('A', 11, ANALOG)>; /* USART1_CTS_NSS */
+		};
+	};
+
 	usart2_pins_a: usart2-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('F', 5, AF7)>, /* USART2_TX */
@@ -2226,6 +2610,23 @@
 		};
 	};
 
+	usart3_idle_pins_a: usart3-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 10, ANALOG)>; /* USART3_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 12, AF8)>; /* USART3_RX */
+			bias-disable;
+		};
+	};
+
+	usart3_sleep_pins_a: usart3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, ANALOG)>, /* USART3_TX */
+				 <STM32_PINMUX('B', 12, ANALOG)>; /* USART3_RX */
+		};
+	};
+
 	usart3_pins_b: usart3-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('B', 10, AF7)>, /* USART3_TX */
@@ -2385,9 +2786,18 @@
 		};
 	};
 
-	usbotg_hs_pins_a: usbotg-hs-0 {
-		pins {
-			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+	usart3_pins_f: usart3-5 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 10, AF7)>, /* USART3_TX */
+				 <STM32_PINMUX('D', 12, AF7)>; /* USART3_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 12, AF8)>, /* USART3_RX */
+				 <STM32_PINMUX('D', 11, AF7)>; /* USART3_CTS_NSS */
+			bias-disable;
 		};
 	};
 
@@ -2397,6 +2807,12 @@
 				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
 		};
 	};
+
+	usbotg_hs_pins_a: usbotg-hs-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+		};
+	};
 };
 
 &pinctrl_z {
@@ -2463,4 +2879,42 @@
 			bias-disable;
 		};
 	};
+
+	spi1_sleep_pins_a: spi1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, ANALOG)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
+		};
+	};
+
+	usart1_pins_b: usart1-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, AF7)>; /* USART1_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 6, AF7)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_b: usart1-idle-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>; /* USART1_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 6, AF7)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_b: usart1-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART1_RX */
+		};
+	};
 };
diff --git a/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi
index 7c8fec6cbf..7a096b69ef 100644
--- a/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi
@@ -25,6 +25,12 @@
 		multiple-images;
 	};
 
+	firmware {
+		optee {
+			bootph-all;
+		};
+	};
+
 	soc {
 		bootph-all;
 
@@ -135,7 +141,7 @@
 };
 
 &usart1 {
-	resets = <&rcc USART1_R>;
+	resets = <&scmi_reset RST_SCMI_USART1>;
 };
 
 &usart2 {
diff --git a/arch/arm/dts/stm32mp15-scmi.dtsi b/arch/arm/dts/stm32mp15-scmi.dtsi
index ad2584213d..f113ba0036 100644
--- a/arch/arm/dts/stm32mp15-scmi.dtsi
+++ b/arch/arm/dts/stm32mp15-scmi.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Copyright (C) STMicroelectronics 2022-2024 - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
@@ -9,6 +9,8 @@
 		optee: optee {
 			compatible = "linaro,optee-tz";
 			method = "smc";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
 		};
 
 		scmi: scmi {
@@ -26,62 +28,10 @@
 				reg = <0x16>;
 				#reset-cells = <1>;
 			};
-
-			scmi_voltd: protocol@17 {
-				reg = <0x17>;
-
-				scmi_reguls: regulators {
-					#address-cells = <1>;
-					#size-cells = <0>;
-
-					scmi_reg11: reg11@0 {
-						reg = <0>;
-						regulator-name = "reg11";
-						regulator-min-microvolt = <1100000>;
-						regulator-max-microvolt = <1100000>;
-					};
-
-					scmi_reg18: reg18@1 {
-						voltd-name = "reg18";
-						reg = <1>;
-						regulator-name = "reg18";
-						regulator-min-microvolt = <1800000>;
-						regulator-max-microvolt = <1800000>;
-					};
-
-					scmi_usb33: usb33@2 {
-						reg = <2>;
-						regulator-name = "usb33";
-						regulator-min-microvolt = <3300000>;
-						regulator-max-microvolt = <3300000>;
-					};
-				};
-			};
 		};
 	};
 };
 
-&reg11 {
-	status = "disabled";
-};
-
-&reg18 {
-	status = "disabled";
-};
-
-&usb33 {
-	status = "disabled";
-};
-
-&usbotg_hs {
-	usb33d-supply = <&scmi_usb33>;
-};
-
-&usbphyc {
-	vdda1v1-supply = <&scmi_reg11>;
-	vdda1v8-supply = <&scmi_reg18>;
-};
-
 /delete-node/ &clk_hse;
 /delete-node/ &clk_hsi;
 /delete-node/ &clk_lse;
diff --git a/arch/arm/dts/stm32mp15-u-boot.dtsi b/arch/arm/dts/stm32mp15-u-boot.dtsi
index 573dd4d3ed..63fcf348bd 100644
--- a/arch/arm/dts/stm32mp15-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15-u-boot.dtsi
@@ -92,6 +92,10 @@
 	};
 };
 
+&etzpc {
+	bootph-all;
+};
+
 &gpioa {
 	bootph-all;
 };
@@ -206,7 +210,7 @@
 	resets = <&rcc UART8_R>;
 };
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE)
+#if defined(CONFIG_STM32MP15X_STM32IMAGE)
 &binman {
 	u-boot-stm32 {
 		filename = "u-boot.stm32";
diff --git a/arch/arm/dts/stm32mp151.dtsi b/arch/arm/dts/stm32mp151.dtsi
index 21d11be328..d0ae364f56 100644
--- a/arch/arm/dts/stm32mp151.dtsi
+++ b/arch/arm/dts/stm32mp151.dtsi
@@ -5,6 +5,7 @@
  */
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
 
 / {
@@ -17,23 +18,33 @@
 
 		cpu0: cpu@0 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <0>;
+			clock-names = "cpu";
 			operating-points-v2 = <&cpu0_opp_table>;
 			nvmem-cells = <&part_number_otp>;
 			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
 		};
 	};
 
 	cpu0_opp_table: cpu0-opp-table {
 		compatible = "operating-points-v2";
 		opp-shared;
+
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x2>;
+			opp-suspend;
+		};
+
 		opp-650000000 {
 			opp-hz = /bits/ 64 <650000000>;
 			opp-microvolt = <1200000>;
 			opp-supported-hw = <0x1>;
 		};
+
 		opp-800000000 {
 			opp-hz = /bits/ 64 <800000000>;
 			opp-microvolt = <1350000>;
@@ -48,6 +59,12 @@
 		interrupt-parent = <&intc>;
 	};
 
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xbc000000>;
+		status = "disabled";
+	};
+
 	psci {
 		compatible = "arm,psci-1.0";
 		method = "smc";
@@ -68,9 +85,16 @@
 			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
 			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
 		interrupt-parent = <&intc>;
+		arm,no-tick-in-suspend;
 	};
 
 	clocks {
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+
 		clk_hse: clk-hse {
 			#clock-cells = <0>;
 			compatible = "fixed-clock";
@@ -94,11 +118,25 @@
 			compatible = "fixed-clock";
 			clock-frequency = <32000>;
 		};
+	};
 
-		clk_csi: clk-csi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <4000000>;
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
 		};
 	};
 
@@ -109,15 +147,9 @@
 			thermal-sensors = <&dts>;
 
 			trips {
-				cpu_alert1: cpu-alert1 {
-					temperature = <85000>;
-					hysteresis = <0>;
-					type = "passive";
-				};
-
 				cpu-crit {
 					temperature = <120000>;
-					hysteresis = <0>;
+					hysteresis = <1000>;
 					type = "critical";
 				};
 			};
@@ -140,1700 +172,2106 @@
 		interrupt-parent = <&intc>;
 		ranges;
 
-		timers2: timer@40000000 {
+		sram4: sram@10050000 {
+			compatible = "mmio-sram";
+			reg = <0x10050000 0x10000>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40000000 0x400>;
-			interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM2_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 18 0x400 0x1>,
-			       <&dmamux1 19 0x400 0x1>,
-			       <&dmamux1 20 0x400 0x1>,
-			       <&dmamux1 21 0x400 0x1>,
-			       <&dmamux1 22 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@1 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <1>;
-				status = "disabled";
-			};
+			#size-cells = <1>;
+			ranges = <0 0x10050000 0x10000>;
+		};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+		hsem: hwspinlock@4c000000 {
+			compatible = "st,stm32-hwspinlock";
+			#hwlock-cells = <2>;
+			reg = <0x4c000000 0x400>;
+			clocks = <&rcc HSEM>;
+			clock-names = "hsem";
 		};
 
-		timers3: timer@40001000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40001000 0x400>;
-			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM3_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 23 0x400 0x1>,
-			       <&dmamux1 24 0x400 0x1>,
-			       <&dmamux1 25 0x400 0x1>,
-			       <&dmamux1 26 0x400 0x1>,
-			       <&dmamux1 27 0x400 0x1>,
-			       <&dmamux1 28 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+		ipcc: mailbox@4c001000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x4c001000 0x400>;
+			st,proc-id = <0>;
+			interrupts-extended =
+				<&exti 61 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&rcc IPCC>;
+			wakeup-source;
+			power-domains = <&pd_core>;
 			status = "disabled";
+		};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@2 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <2>;
-				status = "disabled";
-			};
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp1-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&clk_hse>, <&clk_hsi>, <&clk_csi>,
+				 <&clk_lse>, <&clk_lsi>;
 		};
 
-		timers4: timer@40002000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40002000 0x400>;
-			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM4_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 29 0x400 0x1>,
-			       <&dmamux1 30 0x400 0x1>,
-			       <&dmamux1 31 0x400 0x1>,
-			       <&dmamux1 32 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4";
-			status = "disabled";
+		pwr_regulators: pwr@50001000 {
+			compatible = "st,stm32mp1,pwr-reg";
+			reg = <0x50001000 0x10>;
+			st,tzcr = <&rcc 0x0 0x1>;
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+			reg11: reg11 {
+				regulator-name = "reg11";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1100000>;
 			};
 
-			timer@3 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <3>;
-				status = "disabled";
+			reg18: reg18 {
+				regulator-name = "reg18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
 			};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			usb33: usb33 {
+				regulator-name = "usb33";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
 			};
 		};
 
-		timers5: timer@40003000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40003000 0x400>;
-			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM5_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 55 0x400 0x1>,
-			       <&dmamux1 56 0x400 0x1>,
-			       <&dmamux1 57 0x400 0x1>,
-			       <&dmamux1 58 0x400 0x1>,
-			       <&dmamux1 59 0x400 0x1>,
-			       <&dmamux1 60 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
+		pwr_mcu: pwr-mcu@50001014 {
+			compatible = "st,stm32mp151-pwr-mcu", "syscon";
+			reg = <0x50001014 0x4>;
+		};
 
-			timer@4 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <4>;
-				status = "disabled";
-			};
+		pwr_irq: pwr@50001020 {
+			compatible = "st,stm32mp1-pwr";
+			reg = <0x50001020 0x100>;
+			interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+			st,wakeup-pins = <&gpioa 0 GPIO_ACTIVE_HIGH>,
+					 <&gpioa 2 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 13 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 8 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 11 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 1 GPIO_ACTIVE_HIGH>;
 		};
 
-		timers6: timer@40004000 {
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40004000 0x400>;
-			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM6_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 69 0x400 0x1>;
-			dma-names = "up";
-			status = "disabled";
+			#size-cells = <1>;
+			compatible = "st,stm32mp157-pinctrl";
+			ranges = <0 0x50002000 0xa400>;
+			interrupt-parent = <&exti>;
+			hwlocks = <&hsem 0 1>;
 
-			timer@5 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <5>;
+			gpioa: gpio@50002000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc GPIOA>;
+				st,bank-name = "GPIOA";
 				status = "disabled";
 			};
-		};
-
-		timers7: timer@40005000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40005000 0x400>;
-			interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM7_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 70 0x400 0x1>;
-			dma-names = "up";
-			status = "disabled";
 
-			timer@6 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <6>;
+			gpiob: gpio@50003000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x1000 0x400>;
+				clocks = <&rcc GPIOB>;
+				st,bank-name = "GPIOB";
 				status = "disabled";
 			};
-		};
-
-		timers12: timer@40006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40006000 0x400>;
-			interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM12_K>;
-			clock-names = "int";
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpioc: gpio@50004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x2000 0x400>;
+				clocks = <&rcc GPIOC>;
+				st,bank-name = "GPIOC";
 				status = "disabled";
 			};
 
-			timer@11 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <11>;
+			gpiod: gpio@50005000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x3000 0x400>;
+				clocks = <&rcc GPIOD>;
+				st,bank-name = "GPIOD";
 				status = "disabled";
 			};
-		};
 
-		timers13: timer@40007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40007000 0x400>;
-			interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM13_K>;
-			clock-names = "int";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpioe: gpio@50006000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x4000 0x400>;
+				clocks = <&rcc GPIOE>;
+				st,bank-name = "GPIOE";
 				status = "disabled";
 			};
 
-			timer@12 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <12>;
+			gpiof: gpio@50007000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x5000 0x400>;
+				clocks = <&rcc GPIOF>;
+				st,bank-name = "GPIOF";
 				status = "disabled";
 			};
-		};
-
-		timers14: timer@40008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40008000 0x400>;
-			interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM14_K>;
-			clock-names = "int";
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiog: gpio@50008000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x6000 0x400>;
+				clocks = <&rcc GPIOG>;
+				st,bank-name = "GPIOG";
 				status = "disabled";
 			};
 
-			timer@13 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <13>;
+			gpioh: gpio@50009000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x7000 0x400>;
+				clocks = <&rcc GPIOH>;
+				st,bank-name = "GPIOH";
 				status = "disabled";
 			};
-		};
-
-		lptimer1: timer@40009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x40009000 0x400>;
-			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM1_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
+			gpioi: gpio@5000a000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x8000 0x400>;
+				clocks = <&rcc GPIOI>;
+				st,bank-name = "GPIOI";
 				status = "disabled";
 			};
 
-			trigger@0 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <0>;
+			gpioj: gpio@5000b000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x9000 0x400>;
+				clocks = <&rcc GPIOJ>;
+				st,bank-name = "GPIOJ";
 				status = "disabled";
 			};
 
-			counter {
-				compatible = "st,stm32-lptimer-counter";
+			gpiok: gpio@5000c000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa000 0x400>;
+				clocks = <&rcc GPIOK>;
+				st,bank-name = "GPIOK";
 				status = "disabled";
 			};
 		};
 
-		spi2: spi@4000b000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI2_K>;
-			resets = <&rcc SPI2_R>;
-			dmas = <&dmamux1 39 0x400 0x05>,
-			       <&dmamux1 40 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+			wakeup-parent = <&pwr_irq>;
+			interrupts-extended =
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 64  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 42  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 76  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 33  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 95  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 37  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 71  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 52  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 82  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<&intc GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+				<&pwr_irq 0 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 1 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 2 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 3 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 4 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 5 IRQ_TYPE_EDGE_FALLING 0>,		/* EXTI_60 */
+				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 94  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 62  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		i2s2: audio-controller@4000b000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 39 0x400 0x01>,
-			       <&dmamux1 40 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
 		};
 
-		spi3: spi@4000c000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI3_K>;
-			resets = <&rcc SPI3_R>;
-			dmas = <&dmamux1 61 0x400 0x05>,
-			       <&dmamux1 62 0x400 0x05>;
-			dma-names = "rx", "tx";
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			reg = <0x50028000 0x100>;
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc TMPSENS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
 			status = "disabled";
 		};
 
-		i2s3: audio-controller@4000c000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 61 0x400 0x01>,
-			       <&dmamux1 62 0x400 0x01>;
-			dma-names = "rx", "tx";
+		hdp: pinctrl@5002a000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
 			status = "disabled";
 		};
 
-		spdifrx: audio-controller@4000d000 {
-			compatible = "st,stm32h7-spdifrx";
-			#sound-dai-cells = <0>;
-			reg = <0x4000d000 0x400>;
-			clocks = <&rcc SPDIF_K>;
-			clock-names = "kclk";
-			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 93 0x400 0x01>,
-			       <&dmamux1 94 0x400 0x01>;
-			dma-names = "rx", "rx-ctrl";
-			status = "disabled";
-		};
+		pinctrl_z: pinctrl@54004000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp157-z-pinctrl";
+			ranges = <0 0x54004000 0x400>;
+			interrupt-parent = <&exti>;
+			hwlocks = <&hsem 0 1>;
 
-		usart2: serial@4000e000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4000e000 0x400>;
-			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART2_K>;
-			wakeup-source;
-			dmas = <&dmamux1 43 0x400 0x15>,
-			       <&dmamux1 44 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+			gpioz: gpio@54004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&rcc GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
 		};
 
-		usart3: serial@4000f000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4000f000 0x400>;
-			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART3_K>;
-			wakeup-source;
-			dmas = <&dmamux1 45 0x400 0x15>,
-			       <&dmamux1 46 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		mdma1: dma-controller@58000000 {
+			compatible = "st,stm32h7-mdma";
+			reg = <0x58000000 0x1000>;
+			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc MDMA>;
+			resets = <&rcc MDMA_R>;
+			#dma-cells = <5>;
+			dma-channels = <32>;
+			dma-requests = <48>;
 		};
 
-		uart4: serial@40010000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40010000 0x400>;
-			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART4_K>;
-			wakeup-source;
-			dmas = <&dmamux1 63 0x400 0x15>,
-			       <&dmamux1 64 0x400 0x11>;
-			dma-names = "rx", "tx";
+		sdmmc1: mmc@58005000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00253180>;
+			reg = <0x58005000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SDMMC1_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
 			status = "disabled";
 		};
 
-		uart5: serial@40011000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40011000 0x400>;
-			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART5_K>;
-			wakeup-source;
-			dmas = <&dmamux1 65 0x400 0x15>,
-			       <&dmamux1 66 0x400 0x11>;
-			dma-names = "rx", "tx";
+		sdmmc2: mmc@58007000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00253180>;
+			reg = <0x58007000 0x1000>;
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SDMMC2_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
 			status = "disabled";
 		};
 
-		i2c1: i2c@40012000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40012000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C1_K>;
-			resets = <&rcc I2C1_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x1>;
-			wakeup-source;
-			i2c-analog-filter;
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
 			status = "disabled";
 		};
 
-		i2c2: i2c@40013000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40013000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C2_K>;
-			resets = <&rcc I2C2_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x2>;
-			wakeup-source;
-			i2c-analog-filter;
+		usbh_ohci: usb@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
-		i2c3: i2c@40014000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40014000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C3_K>;
-			resets = <&rcc I2C3_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x4>;
+		usbh_ehci: usb@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
 			wakeup-source;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
-		i2c5: i2c@40015000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40015000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C5_K>;
-			resets = <&rcc I2C5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x10>;
-			wakeup-source;
-			i2c-analog-filter;
+		ltdc: display-controller@5a001000 {
+			compatible = "st,stm32-ltdc";
+			reg = <0x5a001000 0x400>;
+			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LTDC_PX>;
+			clock-names = "lcd";
+			resets = <&rcc LTDC_R>;
 			status = "disabled";
 		};
 
-		cec: cec@40016000 {
-			compatible = "st,stm32-cec";
-			reg = <0x40016000 0x400>;
-			interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CEC_K>, <&rcc CEC>;
-			clock-names = "cec", "hdmi-cec";
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
+			clock-names = "pclk", "lsi";
 			status = "disabled";
 		};
 
-		dac: dac@40017000 {
-			compatible = "st,stm32h7-dac-core";
-			reg = <0x40017000 0x400>;
-			clocks = <&rcc DAC12>;
-			clock-names = "pclk";
+		usbphyc: usbphyc@5a006000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
+			#clock-cells = <0>;
+			compatible = "st,stm32mp1-usbphyc";
+			reg = <0x5a006000 0x1000>;
+			clocks = <&rcc USBPHY_K>;
+			resets = <&rcc USBPHY_R>;
+			vdda1v1-supply = <&reg11>;
+			vdda1v8-supply = <&reg18>;
 			status = "disabled";
 
-			dac1: dac@1 {
-				compatible = "st,stm32-dac";
-				#io-channel-cells = <1>;
-				reg = <1>;
-				status = "disabled";
+			usbphyc_port0: usb-phy@0 {
+				#phy-cells = <0>;
+				reg = <0>;
 			};
 
-			dac2: dac@2 {
-				compatible = "st,stm32-dac";
-				#io-channel-cells = <1>;
-				reg = <2>;
-				status = "disabled";
+			usbphyc_port1: usb-phy@1 {
+				#phy-cells = <1>;
+				reg = <1>;
 			};
 		};
 
-		uart7: serial@40018000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40018000 0x400>;
-			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART7_K>;
-			wakeup-source;
-			dmas = <&dmamux1 79 0x400 0x15>,
-			       <&dmamux1 80 0x400 0x11>;
-			dma-names = "rx", "tx";
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
 			status = "disabled";
 		};
 
-		uart8: serial@40019000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40019000 0x400>;
-			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART8_K>;
-			wakeup-source;
-			dmas = <&dmamux1 81 0x400 0x15>,
-			       <&dmamux1 82 0x400 0x11>;
-			dma-names = "rx", "tx";
+		rtc: rtc@5c004000 {
+			compatible = "st,stm32mp1-rtc";
+			reg = <0x5c004000 0x400>;
+			clocks = <&rcc RTCAPB>, <&rcc RTC>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
-		timers1: timer@44000000 {
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp15-bsec";
+			reg = <0x5c005000 0x400>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44000000 0x400>;
-			interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "brk", "up", "trg-com", "cc";
-			clocks = <&rcc TIM1_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 11 0x400 0x1>,
-			       <&dmamux1 12 0x400 0x1>,
-			       <&dmamux1 13 0x400 0x1>,
-			       <&dmamux1 14 0x400 0x1>,
-			       <&dmamux1 15 0x400 0x1>,
-			       <&dmamux1 16 0x400 0x1>,
-			       <&dmamux1 17 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4",
-				    "up", "trig", "com";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+			#size-cells = <1>;
+			part_number_otp: part-number-otp@4 {
+				reg = <0x4 0x1>;
 			};
-
-			timer@0 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <0>;
-				status = "disabled";
+			vrefint: vrefin-cal@52 {
+				reg = <0x52 0x2>;
 			};
-
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			ethernet_mac_address: mac@e4 {
+				reg = <0xe4 0x6>;
 			};
 		};
 
-		timers8: timer@44001000 {
+		etzpc: bus@5c007000 {
+			compatible = "st,stm32-etzpc", "simple-bus";
+			reg = <0x5c007000 0x400>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44001000 0x400>;
-			interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "brk", "up", "trg-com", "cc";
-			clocks = <&rcc TIM8_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 47 0x400 0x1>,
-			       <&dmamux1 48 0x400 0x1>,
-			       <&dmamux1 49 0x400 0x1>,
-			       <&dmamux1 50 0x400 0x1>,
-			       <&dmamux1 51 0x400 0x1>,
-			       <&dmamux1 52 0x400 0x1>,
-			       <&dmamux1 53 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4",
-				    "up", "trig", "com";
-			status = "disabled";
+			#size-cells = <1>;
+			#access-controller-cells = <1>;
+			ranges;
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
+			timers2: timer@40000000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM2_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 18 0x400 0x1>,
+				       <&dmamux1 19 0x400 0x1>,
+				       <&dmamux1 20 0x400 0x1>,
+				       <&dmamux1 21 0x400 0x1>,
+				       <&dmamux1 22 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up";
+				access-controllers = <&etzpc 16>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			timer@7 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <7>;
-				status = "disabled";
+				timer@1 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			timers3: timer@40001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40001000 0x400>;
+				interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM3_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 23 0x400 0x1>,
+				       <&dmamux1 24 0x400 0x1>,
+				       <&dmamux1 25 0x400 0x1>,
+				       <&dmamux1 26 0x400 0x1>,
+				       <&dmamux1 27 0x400 0x1>,
+				       <&dmamux1 28 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+				access-controllers = <&etzpc 17>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@2 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
-		};
 
-		usart6: serial@44003000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x44003000 0x400>;
-			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART6_K>;
-			wakeup-source;
-			dmas = <&dmamux1 71 0x400 0x15>,
-			       <&dmamux1 72 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers4: timer@40002000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40002000 0x400>;
+				interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM4_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 29 0x400 0x1>,
+				       <&dmamux1 30 0x400 0x1>,
+				       <&dmamux1 31 0x400 0x1>,
+				       <&dmamux1 32 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4";
+				access-controllers = <&etzpc 18>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		spi1: spi@44004000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44004000 0x400>;
-			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI1_K>;
-			resets = <&rcc SPI1_R>;
-			dmas = <&dmamux1 37 0x400 0x05>,
-			       <&dmamux1 38 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+				timer@3 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
 
-		i2s1: audio-controller@44004000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x44004000 0x400>;
-			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 37 0x400 0x01>,
-			       <&dmamux1 38 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+			};
 
-		spi4: spi@44005000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44005000 0x400>;
-			interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI4_K>;
-			resets = <&rcc SPI4_R>;
-			dmas = <&dmamux1 83 0x400 0x05>,
-			       <&dmamux1 84 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers5: timer@40003000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40003000 0x400>;
+				interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM5_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 55 0x400 0x1>,
+				       <&dmamux1 56 0x400 0x1>,
+				       <&dmamux1 57 0x400 0x1>,
+				       <&dmamux1 58 0x400 0x1>,
+				       <&dmamux1 59 0x400 0x1>,
+				       <&dmamux1 60 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+				access-controllers = <&etzpc 19>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		timers15: timer@44006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44006000 0x400>;
-			interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM15_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 105 0x400 0x1>,
-			       <&dmamux1 106 0x400 0x1>,
-			       <&dmamux1 107 0x400 0x1>,
-			       <&dmamux1 108 0x400 0x1>;
-			dma-names = "ch1", "up", "trig", "com";
-			status = "disabled";
+				timer@4 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			timer@14 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <14>;
-				status = "disabled";
+			timers6: timer@40004000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40004000 0x400>;
+				interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM6_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 69 0x400 0x1>;
+				dma-names = "up";
+				access-controllers = <&etzpc 20>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				timer@5 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
 			};
-		};
 
-		timers16: timer@44007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44007000 0x400>;
-			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM16_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 109 0x400 0x1>,
-			       <&dmamux1 110 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
+			timers7: timer@40005000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40005000 0x400>;
+				interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM7_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 70 0x400 0x1>;
+				dma-names = "up";
+				access-controllers = <&etzpc 21>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				timer@6 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
 			};
-			timer@15 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <15>;
-				status = "disabled";
+
+			timers12: timer@40006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40006000 0x400>;
+				interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM12_K>;
+				clock-names = "int";
+				access-controllers = <&etzpc 22>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
 			};
-		};
 
-		timers17: timer@44008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44008000 0x400>;
-			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM17_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 111 0x400 0x1>,
-			       <&dmamux1 112 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
+			timers13: timer@40007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40007000 0x400>;
+				interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM13_K>;
+				clock-names = "int";
+				access-controllers = <&etzpc 23>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
 			};
 
-			timer@16 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <16>;
-				status = "disabled";
+			timers14: timer@40008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40008000 0x400>;
+				interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM14_K>;
+				clock-names = "int";
+				access-controllers = <&etzpc 24>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
 			};
-		};
 
-		spi5: spi@44009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44009000 0x400>;
-			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI5_K>;
-			resets = <&rcc SPI5_R>;
-			dmas = <&dmamux1 85 0x400 0x05>,
-			       <&dmamux1 86 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			lptimer1: timer@40009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x40009000 0x400>;
+				interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM1_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 25>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		sai1: sai@4400a000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400a000 0x400>;
-			reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
-			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI1_R>;
-			status = "disabled";
+				trigger@0 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
 
-			sai1a: audio-controller@4400a004 {
+			i2s2: audio-controller@4000b000 {
+				compatible = "st,stm32h7-i2s";
 				#sound-dai-cells = <0>;
+				reg = <0x4000b000 0x400>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 39 0x400 0x01>,
+				       <&dmamux1 40 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 27>;
+				status = "disabled";
+			};
 
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x4 0x20>;
-				clocks = <&rcc SAI1_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 87 0x400 0x01>;
+			spi2: spi@4000b000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x4000b000 0x400>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI2_K>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&dmamux1 39 0x400 0x01>,
+				       <&dmamux1 40 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 27>;
 				status = "disabled";
 			};
 
-			sai1b: audio-controller@4400a024 {
+			i2s3: audio-controller@4000c000 {
+				compatible = "st,stm32h7-i2s";
 				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI1_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 88 0x400 0x01>;
+				reg = <0x4000c000 0x400>;
+				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 61 0x400 0x01>,
+				       <&dmamux1 62 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 28>;
 				status = "disabled";
 			};
-		};
 
-		sai2: sai@4400b000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400b000 0x400>;
-			reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
-			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI2_R>;
-			status = "disabled";
+			spi3: spi@4000c000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x4000c000 0x400>;
+				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI3_K>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&dmamux1 61 0x400 0x01>,
+				       <&dmamux1 62 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 28>;
+				status = "disabled";
+			};
 
-			sai2a: audio-controller@4400b004 {
+			spdifrx: audio-controller@4000d000 {
+				compatible = "st,stm32h7-spdifrx";
 				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x4 0x20>;
-				clocks = <&rcc SAI2_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 89 0x400 0x01>;
+				reg = <0x4000d000 0x400>;
+				clocks = <&rcc SPDIF_K>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 93 0x400 0x01>,
+				       <&dmamux1 94 0x400 0x01>;
+				dma-names = "rx", "rx-ctrl";
+				access-controllers = <&etzpc 29>;
+				status = "disabled";
+			};
+
+			usart2: serial@4000e000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4000e000 0x400>;
+				interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART2_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 43 0x400 0x15>,
+				       <&dmamux1 44 0x400 0x11>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 30>;
+				status = "disabled";
+			};
+
+			usart3: serial@4000f000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4000f000 0x400>;
+				interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART3_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 45 0x400 0x15>,
+				       <&dmamux1 46 0x400 0x11>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 31>;
+				status = "disabled";
+			};
+
+			uart4: serial@40010000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40010000 0x400>;
+				interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART4_K>;
+				wakeup-source;
+				dmas = <&dmamux1 63 0x400 0x15>,
+				       <&dmamux1 64 0x400 0x11>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				access-controllers = <&etzpc 32>;
+				status = "disabled";
+			};
+
+			uart5: serial@40011000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40011000 0x400>;
+				interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART5_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 65 0x400 0x15>,
+				       <&dmamux1 66 0x400 0x11>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 33>;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40012000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40012000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 21 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C1_K>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 33 0x400 0x1>,
+				       <&dmamux1 34 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x1>;
+				wakeup-source;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 34>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40013000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40013000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C2_K>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 35 0x400 0x1>,
+				       <&dmamux1 36 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x2>;
+				wakeup-source;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 35>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40014000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40014000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 23 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C3_K>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 73 0x400 0x1>,
+				       <&dmamux1 74 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x4>;
+				wakeup-source;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 36>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40015000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40015000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 25 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C5_K>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 115 0x400 0x1>,
+				       <&dmamux1 116 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x10>;
+				wakeup-source;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 37>;
 				status = "disabled";
 			};
 
-			sai2b: audio-controller@4400b024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI2_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 90 0x400 0x01>;
+			cec: cec@40016000 {
+				compatible = "st,stm32-cec";
+				reg = <0x40016000 0x400>;
+				interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CEC_K>, <&rcc CEC>;
+				clock-names = "cec", "hdmi-cec";
+				access-controllers = <&etzpc 38>;
 				status = "disabled";
 			};
-		};
 
-		sai3: sai@4400c000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400c000 0x400>;
-			reg = <0x4400c000 0x4>, <0x4400c3f0 0x10>;
-			interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI3_R>;
-			status = "disabled";
+			dac: dac@40017000 {
+				compatible = "st,stm32h7-dac-core";
+				reg = <0x40017000 0x400>;
+				clocks = <&rcc DAC12>;
+				clock-names = "pclk";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&etzpc 39>;
+				status = "disabled";
 
-			sai3a: audio-controller@4400c004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x04 0x20>;
-				clocks = <&rcc SAI3_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 113 0x400 0x01>;
+				dac1: dac@1 {
+					compatible = "st,stm32-dac";
+					#io-channel-cells = <1>;
+					reg = <1>;
+					status = "disabled";
+				};
+
+				dac2: dac@2 {
+					compatible = "st,stm32-dac";
+					#io-channel-cells = <1>;
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			uart7: serial@40018000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40018000 0x400>;
+				interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART7_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 79 0x400 0x15>,
+				       <&dmamux1 80 0x400 0x11>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 40>;
 				status = "disabled";
 			};
 
-			sai3b: audio-controller@4400c024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI3_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 114 0x400 0x01>;
+			uart8: serial@40019000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40019000 0x400>;
+				interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART8_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 81 0x400 0x15>,
+				       <&dmamux1 82 0x400 0x11>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 41>;
 				status = "disabled";
 			};
-		};
 
-		dfsdm: dfsdm@4400d000 {
-			compatible = "st,stm32mp1-dfsdm";
-			reg = <0x4400d000 0x800>;
-			clocks = <&rcc DFSDM_K>;
-			clock-names = "dfsdm";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
+			timers1: timer@44000000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44000000 0x400>;
+				interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc TIM1_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 11 0x400 0x1>,
+				       <&dmamux1 12 0x400 0x1>,
+				       <&dmamux1 13 0x400 0x1>,
+				       <&dmamux1 14 0x400 0x1>,
+				       <&dmamux1 15 0x400 0x1>,
+				       <&dmamux1 16 0x400 0x1>,
+				       <&dmamux1 17 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4",
+					    "up", "trig", "com";
+				access-controllers = <&etzpc 48>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			dfsdm0: filter@0 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <0>;
-				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 101 0x400 0x01>;
-				dma-names = "rx";
-				status = "disabled";
+				timer@0 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			dfsdm1: filter@1 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <1>;
-				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 102 0x400 0x01>;
-				dma-names = "rx";
-				status = "disabled";
+			timers8: timer@44001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44001000 0x400>;
+				interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc TIM8_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 47 0x400 0x1>,
+				       <&dmamux1 48 0x400 0x1>,
+				       <&dmamux1 49 0x400 0x1>,
+				       <&dmamux1 50 0x400 0x1>,
+				       <&dmamux1 51 0x400 0x1>,
+				       <&dmamux1 52 0x400 0x1>,
+				       <&dmamux1 53 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4",
+					    "up", "trig", "com";
+				access-controllers = <&etzpc 49>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@7 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			dfsdm2: filter@2 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <2>;
-				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 103 0x400 0x01>;
-				dma-names = "rx";
+			usart6: serial@44003000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x44003000 0x400>;
+				interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART6_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 71 0x400 0x15>,
+				       <&dmamux1 72 0x400 0x11>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 51>;
 				status = "disabled";
 			};
 
-			dfsdm3: filter@3 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <3>;
-				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 104 0x400 0x01>;
-				dma-names = "rx";
+			i2s1: audio-controller@44004000 {
+				compatible = "st,stm32h7-i2s";
+				#sound-dai-cells = <0>;
+				reg = <0x44004000 0x400>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 37 0x400 0x01>,
+				       <&dmamux1 38 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 52>;
 				status = "disabled";
 			};
 
-			dfsdm4: filter@4 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <4>;
-				interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 91 0x400 0x01>;
-				dma-names = "rx";
+			spi1: spi@44004000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44004000 0x400>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI1_K>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&dmamux1 37 0x400 0x01>,
+				       <&dmamux1 38 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 52>;
 				status = "disabled";
 			};
 
-			dfsdm5: filter@5 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <5>;
-				interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 92 0x400 0x01>;
-				dma-names = "rx";
+			spi4: spi@44005000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44005000 0x400>;
+				interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI4_K>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 53>;
 				status = "disabled";
 			};
-		};
 
-		dma1: dma-controller@48000000 {
-			compatible = "st,stm32-dma";
-			reg = <0x48000000 0x400>;
-			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc DMA1>;
-			resets = <&rcc DMA1_R>;
-			#dma-cells = <4>;
-			st,mem2mem;
-			dma-requests = <8>;
-		};
+			timers15: timer@44006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44006000 0x400>;
+				interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM15_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 105 0x400 0x1>,
+				       <&dmamux1 106 0x400 0x1>,
+				       <&dmamux1 107 0x400 0x1>,
+				       <&dmamux1 108 0x400 0x1>;
+				dma-names = "ch1", "up", "trig", "com";
+				access-controllers = <&etzpc 54>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		dma2: dma-controller@48001000 {
-			compatible = "st,stm32-dma";
-			reg = <0x48001000 0x400>;
-			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc DMA2>;
-			resets = <&rcc DMA2_R>;
-			#dma-cells = <4>;
-			st,mem2mem;
-			dma-requests = <8>;
-		};
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		dmamux1: dma-router@48002000 {
-			compatible = "st,stm32h7-dmamux";
-			reg = <0x48002000 0x40>;
-			#dma-cells = <3>;
-			dma-requests = <128>;
-			dma-masters = <&dma1 &dma2>;
-			dma-channels = <16>;
-			clocks = <&rcc DMAMUX>;
-			resets = <&rcc DMAMUX_R>;
-		};
+				timer@14 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
 
-		adc: adc@48003000 {
-			compatible = "st,stm32mp1-adc-core";
-			reg = <0x48003000 0x400>;
-			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
-			clock-names = "bus", "adc";
-			interrupt-controller;
-			st,syscfg = <&syscfg>;
-			#interrupt-cells = <1>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
+			timers16: timer@44007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44007000 0x400>;
+				interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM16_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 109 0x400 0x1>,
+				       <&dmamux1 110 0x400 0x1>;
+				dma-names = "ch1", "up";
+				access-controllers = <&etzpc 55>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			adc1: adc@0 {
-				compatible = "st,stm32mp1-adc";
-				#io-channel-cells = <1>;
-				reg = <0x0>;
-				interrupt-parent = <&adc>;
-				interrupts = <0>;
-				dmas = <&dmamux1 9 0x400 0x01>;
-				dma-names = "rx";
-				status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@44008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44008000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM17_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 111 0x400 0x1>,
+				       <&dmamux1 112 0x400 0x1>;
+				dma-names = "ch1", "up";
+				access-controllers = <&etzpc 56>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
 			};
 
-			adc2: adc@100 {
-				compatible = "st,stm32mp1-adc";
-				#io-channel-cells = <1>;
-				reg = <0x100>;
-				interrupt-parent = <&adc>;
-				interrupts = <1>;
-				dmas = <&dmamux1 10 0x400 0x01>;
-				dma-names = "rx";
+			spi5: spi@44009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44009000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI5_K>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&dmamux1 85 0x400 0x01>,
+				       <&dmamux1 86 0x400 0x01>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 57>;
 				status = "disabled";
 			};
-		};
 
-		sdmmc3: mmc@48004000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x48004000 0x400>;
-			interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SDMMC3_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC3_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
+			sai1: sai@4400a000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400a000 0x400>;
+				reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				access-controllers = <&etzpc 58>;
+				status = "disabled";
+
+				sai1a: audio-controller@4400a004 {
+					#sound-dai-cells = <0>;
+
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					clocks = <&rcc SAI1_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 87 0x400 0x01>;
+					status = "disabled";
+				};
 
-		usbotg_hs: usb-otg@49000000 {
-			compatible = "st,stm32mp15-hsotg", "snps,dwc2";
-			reg = <0x49000000 0x10000>;
-			clocks = <&rcc USBO_K>, <&usbphyc>;
-			clock-names = "otg", "utmi";
-			resets = <&rcc USBO_R>;
-			reset-names = "dwc2";
-			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
-			g-rx-fifo-size = <512>;
-			g-np-tx-fifo-size = <32>;
-			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
-			dr_mode = "otg";
-			otg-rev = <0x200>;
-			usb33d-supply = <&usb33>;
-			status = "disabled";
-		};
+				sai1b: audio-controller@4400a024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI1_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 88 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-		hwspinlock: hwspinlock@4c000000 {
-			compatible = "st,stm32-hwspinlock";
-			#hwlock-cells = <1>;
-			reg = <0x4c000000 0x400>;
-			clocks = <&rcc HSEM>;
-			clock-names = "hwspinlock";
-		};
+			sai2: sai@4400b000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400b000 0x400>;
+				reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				access-controllers = <&etzpc 59>;
+				status = "disabled";
+
+				sai2a: audio-controller@4400b004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					clocks = <&rcc SAI2_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 89 0x400 0x01>;
+					status = "disabled";
+				};
 
-		ipcc: mailbox@4c001000 {
-			compatible = "st,stm32mp1-ipcc";
-			#mbox-cells = <1>;
-			reg = <0x4c001000 0x400>;
-			st,proc-id = <0>;
-			interrupts-extended =
-				<&exti 61 1>,
-				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "rx", "tx";
-			clocks = <&rcc IPCC>;
-			wakeup-source;
-			status = "disabled";
-		};
+				sai2b: audio-controller@4400b024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI2_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 90 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-		dcmi: dcmi@4c006000 {
-			compatible = "st,stm32-dcmi";
-			reg = <0x4c006000 0x400>;
-			interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc CAMITF_R>;
-			clocks = <&rcc DCMI>;
-			clock-names = "mclk";
-			dmas = <&dmamux1 75 0x400 0x01>;
-			dma-names = "tx";
-			status = "disabled";
-		};
+			sai3: sai@4400c000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400c000 0x400>;
+				reg = <0x4400c000 0x4>, <0x4400c3f0 0x10>;
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				access-controllers = <&etzpc 60>;
+				status = "disabled";
+
+				sai3a: audio-controller@4400c004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x04 0x20>;
+					clocks = <&rcc SAI3_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 113 0x400 0x01>;
+					status = "disabled";
+				};
 
-		rcc: rcc@50000000 {
-			compatible = "st,stm32mp1-rcc", "syscon";
-			reg = <0x50000000 0x1000>;
-			#clock-cells = <1>;
-			#reset-cells = <1>;
+				sai3b: audio-controller@4400c024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI3_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 114 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-			clock-names = "hse", "hsi", "csi", "lse", "lsi";
-			clocks = <&clk_hse>, <&clk_hsi>, <&clk_csi>,
-				 <&clk_lse>, <&clk_lsi>;
-		};
+			dfsdm: dfsdm@4400d000 {
+				compatible = "st,stm32mp1-dfsdm";
+				reg = <0x4400d000 0x800>;
+				clocks = <&rcc DFSDM_K>;
+				clock-names = "dfsdm";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&etzpc 61>;
+				status = "disabled";
 
-		pwr_regulators: pwr@50001000 {
-			compatible = "st,stm32mp1,pwr-reg";
-			reg = <0x50001000 0x10>;
+				dfsdm0: filter@0 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <0>;
+					interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 101 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			reg11: reg11 {
-				regulator-name = "reg11";
-				regulator-min-microvolt = <1100000>;
-				regulator-max-microvolt = <1100000>;
-			};
+				dfsdm1: filter@1 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <1>;
+					interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 102 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			reg18: reg18 {
-				regulator-name = "reg18";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-			};
+				dfsdm2: filter@2 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <2>;
+					interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 103 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			usb33: usb33 {
-				regulator-name = "usb33";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
+				dfsdm3: filter@3 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <3>;
+					interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 104 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				dfsdm4: filter@4 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <4>;
+					interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 91 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				dfsdm5: filter@5 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <5>;
+					interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 92 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 			};
-		};
 
-		pwr_mcu: pwr_mcu@50001014 {
-			compatible = "st,stm32mp151-pwr-mcu", "syscon";
-			reg = <0x50001014 0x4>;
-		};
+			dma1: dma-controller@48000000 {
+				compatible = "st,stm32-dma";
+				reg = <0x48000000 0x400>;
+				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc DMA1>;
+				resets = <&rcc DMA1_R>;
+				#dma-cells = <4>;
+				st,mem2mem;
+				dma-requests = <8>;
+				access-controllers = <&etzpc 88>;
+			};
+
+			dma2: dma-controller@48001000 {
+				compatible = "st,stm32-dma";
+				reg = <0x48001000 0x400>;
+				interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc DMA2>;
+				resets = <&rcc DMA2_R>;
+				#dma-cells = <4>;
+				st,mem2mem;
+				dma-requests = <8>;
+				access-controllers = <&etzpc 89>;
+			};
+
+			dmamux1: dma-router@48002000 {
+				compatible = "st,stm32h7-dmamux";
+				reg = <0x48002000 0x40>;
+				#dma-cells = <3>;
+				dma-requests = <128>;
+				dma-masters = <&dma1 &dma2>;
+				dma-channels = <16>;
+				clocks = <&rcc DMAMUX>;
+				resets = <&rcc DMAMUX_R>;
+				access-controllers = <&etzpc 90>;
+			};
+
+			adc: adc@48003000 {
+				compatible = "st,stm32mp1-adc-core";
+				reg = <0x48003000 0x400>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				st,syscfg = <&syscfg>;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&etzpc 72>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp1-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc>;
+					interrupts = <0>;
+					dmas = <&dmamux1 9 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-		exti: interrupt-controller@5000d000 {
-			compatible = "st,stm32mp1-exti", "syscon";
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			reg = <0x5000d000 0x400>;
-		};
+				adc2: adc@100 {
+					compatible = "st,stm32mp1-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x100>;
+					interrupt-parent = <&adc>;
+					interrupts = <1>;
+					dmas = <&dmamux1 10 0x400 0x01>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@13 {
+						reg = <13>;
+						label = "vrefint";
+					};
+					channel@14 {
+						reg = <14>;
+						label = "vddcore";
+					};
+				};
+			};
 
-		syscfg: syscon@50020000 {
-			compatible = "st,stm32mp157-syscfg", "syscon";
-			reg = <0x50020000 0x400>;
-			clocks = <&rcc SYSCFG>;
-		};
+			sdmmc3: mmc@48004000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00253180>;
+				reg = <0x48004000 0x400>;
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC3_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&etzpc 86>;
+				status = "disabled";
+			};
+
+			usbotg_hs: usb-otg@49000000 {
+				compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+				reg = <0x49000000 0x10000>;
+				clocks = <&rcc USBO_K>, <&usbphyc>;
+				clock-names = "otg", "utmi";
+				resets = <&rcc USBO_R>;
+				reset-names = "dwc2";
+				interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+				g-rx-fifo-size = <512>;
+				g-np-tx-fifo-size = <32>;
+				g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				usb33d-supply = <&usb33>;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 85>;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@4c006000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x4c006000 0x400>;
+				interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CAMITF_R>;
+				clocks = <&rcc DCMI>;
+				clock-names = "mclk";
+				dmas = <&dmamux1 75 0x400 0x01>;
+				dma-names = "tx";
+				access-controllers = <&etzpc 70>;
+				status = "disabled";
+			};
+
+			lptimer2: timer@50021000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50021000 0x400>;
+				interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM2_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 64>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		lptimer2: timer@50021000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50021000 0x400>;
-			interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM2_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+				trigger@1 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			trigger@1 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <1>;
-				status = "disabled";
+			lptimer3: timer@50022000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50022000 0x400>;
+				interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM3_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 65>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			counter {
-				compatible = "st,stm32-lptimer-counter";
+			lptimer4: timer@50023000 {
+				compatible = "st,stm32-lptimer";
+				reg = <0x50023000 0x400>;
+				interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM4_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 66>;
 				status = "disabled";
-			};
-		};
 
-		lptimer3: timer@50022000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50022000 0x400>;
-			interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM3_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			trigger@2 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <2>;
+			lptimer5: timer@50024000 {
+				compatible = "st,stm32-lptimer";
+				reg = <0x50024000 0x400>;
+				interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM5_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 67>;
 				status = "disabled";
-			};
-		};
 
-		lptimer4: timer@50023000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50023000 0x400>;
-			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM4_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
+			vrefbuf: vrefbuf@50025000 {
+				compatible = "st,stm32-vrefbuf";
+				reg = <0x50025000 0x8>;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <2500000>;
+				clocks = <&rcc VREF>;
+				access-controllers = <&etzpc 69>;
 				status = "disabled";
 			};
-		};
 
-		lptimer5: timer@50024000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50024000 0x400>;
-			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM5_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+			sai4: sai@50027000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x50027000 0x400>;
+				reg = <0x50027000 0x4>, <0x500273f0 0x10>;
+				interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				access-controllers = <&etzpc 68>;
+				status = "disabled";
+
+				sai4a: audio-controller@50027004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x04 0x20>;
+					clocks = <&rcc SAI4_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 99 0x400 0x01>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				sai4b: audio-controller@50027024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI4_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 100 0x400 0x01>;
+					status = "disabled";
+				};
 			};
-		};
 
-		vrefbuf: vrefbuf@50025000 {
-			compatible = "st,stm32-vrefbuf";
-			reg = <0x50025000 0x8>;
-			regulator-min-microvolt = <1500000>;
-			regulator-max-microvolt = <2500000>;
-			clocks = <&rcc VREF>;
-			status = "disabled";
-		};
+			hash1: hash@54002000 {
+				compatible = "st,stm32f756-hash";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&mdma1 31 0x2 0x1000a02 0x0 0x0>;
+				dma-names = "in";
+				dma-maxburst = <2>;
+				access-controllers = <&etzpc 8>;
+				status = "disabled";
+			};
+
+			rng1: rng@54003000 {
+				compatible = "st,stm32-rng";
+				reg = <0x54003000 0x400>;
+				clocks = <&rcc RNG1_K>;
+				resets = <&rcc RNG1_R>;
+				access-controllers = <&etzpc 7>;
+				status = "disabled";
+			};
+
+			fmc: memory-controller@58002000 {
+				#address-cells = <2>;
+				#size-cells = <1>;
+				compatible = "st,stm32mp1-fmc2-ebi";
+				reg = <0x58002000 0x1000>;
+				clocks = <&rcc FMC_K>;
+				resets = <&rcc FMC_R>;
+				access-controllers = <&etzpc 91>;
+				status = "disabled";
+
+				ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+					 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+					 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+					 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+					 <4 0 0x80000000 0x10000000>; /* NAND */
+
+				nand-controller@4,0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "st,stm32mp1-fmc2-nfc";
+					reg = <4 0x00000000 0x1000>,
+					      <4 0x08010000 0x1000>,
+					      <4 0x08020000 0x1000>,
+					      <4 0x01000000 0x1000>,
+					      <4 0x09010000 0x1000>,
+					      <4 0x09020000 0x1000>;
+					interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
+					       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
+					       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
+					dma-names = "tx", "rx", "ecc";
+					status = "disabled";
+				};
+			};
 
-		sai4: sai@50027000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x50027000 0x400>;
-			reg = <0x50027000 0x4>, <0x500273f0 0x10>;
-			interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI4_R>;
-			status = "disabled";
+			qspi: spi@58003000 {
+				compatible = "st,stm32f469-qspi";
+				reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+				reg-names = "qspi", "qspi_mm";
+				interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
+				       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
+				dma-names = "tx", "rx";
+				clocks = <&rcc QSPI_K>;
+				resets = <&rcc QSPI_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&etzpc 92>;
+				status = "disabled";
+			};
+
+			ethernet0: ethernet@5800a000 {
+				compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
+				reg = <0x5800a000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti 70 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "eth-ck",
+					      "ptp_ref",
+					      "ethstp";
+				clocks = <&rcc ETHMAC>,
+					 <&rcc ETHTX>,
+					 <&rcc ETHRX>,
+					 <&rcc ETHCK_K>,
+					 <&rcc ETHPTP_K>,
+					 <&rcc ETHSTP>;
+				st,syscon = <&syscfg 0x4>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,en-tx-lpi-clockgating;
+				snps,axi-config = <&stmmac_axi_config_0>;
+				snps,tso;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				access-controllers = <&etzpc 94>;
+				status = "disabled";
+
+				stmmac_axi_config_0: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+			};
 
-			sai4a: audio-controller@50027004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x04 0x20>;
-				clocks = <&rcc SAI4_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 99 0x400 0x01>;
+			usart1: serial@5c000000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x5c000000 0x400>;
+				interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART1_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				access-controllers = <&etzpc 3>;
 				status = "disabled";
 			};
 
-			sai4b: audio-controller@50027024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI4_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 100 0x400 0x01>;
+			spi6: spi@5c001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x5c001000 0x400>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI6_K>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 35 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				access-controllers = <&etzpc 4>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@5c002000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x5c002000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C4_K>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&mdma1 36 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 37 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x8>;
+				wakeup-source;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 5>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@5c009000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x5c009000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C6_K>;
+				resets = <&rcc I2C6_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&mdma1 38 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 39 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x20>;
+				wakeup-source;
+				i2c-analog-filter;
+				access-controllers = <&etzpc 12>;
 				status = "disabled";
 			};
 		};
 
-		dts: thermal@50028000 {
-			compatible = "st,stm32-thermal";
-			reg = <0x50028000 0x100>;
-			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc TMPSENS>;
-			clock-names = "pclk";
-			#thermal-sensor-cells = <0>;
-			status = "disabled";
-		};
-
-		hash1: hash@54002000 {
-			compatible = "st,stm32f756-hash";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc HASH1>;
-			resets = <&rcc HASH1_R>;
-			dmas = <&mdma1 31 0x2 0x1000A02 0x0 0x0>;
-			dma-names = "in";
-			dma-maxburst = <2>;
-			status = "disabled";
-		};
-
-		rng1: rng@54003000 {
-			compatible = "st,stm32-rng";
-			reg = <0x54003000 0x400>;
-			clocks = <&rcc RNG1_K>;
-			resets = <&rcc RNG1_R>;
-			status = "disabled";
-		};
-
-		mdma1: dma-controller@58000000 {
-			compatible = "st,stm32h7-mdma";
-			reg = <0x58000000 0x1000>;
-			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc MDMA>;
-			resets = <&rcc MDMA_R>;
-			#dma-cells = <5>;
-			dma-channels = <32>;
-			dma-requests = <48>;
-		};
-
-		fmc: memory-controller@58002000 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp1-fmc2-ebi";
-			reg = <0x58002000 0x1000>;
-			clocks = <&rcc FMC_K>;
-			resets = <&rcc FMC_R>;
-			status = "disabled";
-
-			ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
-				 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
-				 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
-				 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
-				 <4 0 0x80000000 0x10000000>; /* NAND */
-
-			nand-controller@4,0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "st,stm32mp1-fmc2-nfc";
-				reg = <4 0x00000000 0x1000>,
-				      <4 0x08010000 0x1000>,
-				      <4 0x08020000 0x1000>,
-				      <4 0x01000000 0x1000>,
-				      <4 0x09010000 0x1000>,
-				      <4 0x09020000 0x1000>;
-				interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
-				       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
-				       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
-				dma-names = "tx", "rx", "ecc";
-				status = "disabled";
-			};
-		};
-
-		qspi: spi@58003000 {
-			compatible = "st,stm32f469-qspi";
-			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
-			reg-names = "qspi", "qspi_mm";
-			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
-			       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
-			dma-names = "tx", "rx";
-			clocks = <&rcc QSPI_K>;
-			resets = <&rcc QSPI_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
-
-		sdmmc1: mmc@58005000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x58005000 0x1000>;
-			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SDMMC1_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC1_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
-
-		sdmmc2: mmc@58007000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x58007000 0x1000>;
-			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SDMMC2_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC2_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
-
-		crc1: crc@58009000 {
-			compatible = "st,stm32f7-crc";
-			reg = <0x58009000 0x400>;
-			clocks = <&rcc CRC1>;
-			status = "disabled";
-		};
-
-		ethernet0: ethernet@5800a000 {
-			compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
-			reg = <0x5800a000 0x2000>;
-			reg-names = "stmmaceth";
-			interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "macirq";
-			clock-names = "stmmaceth",
-				      "mac-clk-tx",
-				      "mac-clk-rx",
-				      "eth-ck",
-				      "ptp_ref",
-				      "ethstp";
-			clocks = <&rcc ETHMAC>,
-				 <&rcc ETHTX>,
-				 <&rcc ETHRX>,
-				 <&rcc ETHCK_K>,
-				 <&rcc ETHPTP_K>,
-				 <&rcc ETHSTP>;
-			st,syscon = <&syscfg 0x4>;
-			snps,mixed-burst;
-			snps,pbl = <2>;
-			snps,en-tx-lpi-clockgating;
-			snps,axi-config = <&stmmac_axi_config_0>;
-			snps,tso;
-			status = "disabled";
-
-			stmmac_axi_config_0: stmmac-axi-config {
-				snps,wr_osr_lmt = <0x7>;
-				snps,rd_osr_lmt = <0x7>;
-				snps,blen = <0 0 0 0 16 8 4>;
-			};
-		};
-
-		usbh_ohci: usb@5800c000 {
-			compatible = "generic-ohci";
-			reg = <0x5800c000 0x1000>;
-			clocks = <&usbphyc>, <&rcc USBH>;
-			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
-			status = "disabled";
-		};
-
-		usbh_ehci: usb@5800d000 {
-			compatible = "generic-ehci";
-			reg = <0x5800d000 0x1000>;
-			clocks = <&usbphyc>, <&rcc USBH>;
-			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
-			companion = <&usbh_ohci>;
-			status = "disabled";
-		};
-
-		ltdc: display-controller@5a001000 {
-			compatible = "st,stm32-ltdc";
-			reg = <0x5a001000 0x400>;
-			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LTDC_PX>;
-			clock-names = "lcd";
-			resets = <&rcc LTDC_R>;
-			status = "disabled";
-
-			port {
-				#address-cells = <1>;
-				#size-cells = <0>;
-			};
-		};
-
-		iwdg2: watchdog@5a002000 {
-			compatible = "st,stm32mp1-iwdg";
-			reg = <0x5a002000 0x400>;
-			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
-			clock-names = "pclk", "lsi";
-			status = "disabled";
-		};
-
-		usbphyc: usbphyc@5a006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			#clock-cells = <0>;
-			compatible = "st,stm32mp1-usbphyc";
-			reg = <0x5a006000 0x1000>;
-			clocks = <&rcc USBPHY_K>;
-			resets = <&rcc USBPHY_R>;
-			vdda1v1-supply = <&reg11>;
-			vdda1v8-supply = <&reg18>;
-			status = "disabled";
-
-			usbphyc_port0: usb-phy@0 {
-				#phy-cells = <0>;
-				reg = <0>;
-			};
-
-			usbphyc_port1: usb-phy@1 {
-				#phy-cells = <1>;
-				reg = <1>;
-			};
-		};
-
-		usart1: serial@5c000000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x5c000000 0x400>;
-			interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART1_K>;
-			wakeup-source;
-			status = "disabled";
-		};
-
-		spi6: spi@5c001000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x5c001000 0x400>;
-			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI6_K>;
-			resets = <&rcc SPI6_R>;
-			dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
-			       <&mdma1 35 0x0 0x40002 0x0 0x0>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
-
-		i2c4: i2c@5c002000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x5c002000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C4_K>;
-			resets = <&rcc I2C4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x8>;
-			wakeup-source;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
-		rtc: rtc@5c004000 {
-			compatible = "st,stm32mp1-rtc";
-			reg = <0x5c004000 0x400>;
-			clocks = <&rcc RTCAPB>, <&rcc RTC>;
-			clock-names = "pclk", "rtc_ck";
-			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
-			status = "disabled";
-		};
-
-		bsec: efuse@5c005000 {
-			compatible = "st,stm32mp15-bsec";
-			reg = <0x5c005000 0x400>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-			part_number_otp: part_number_otp@4 {
-				reg = <0x4 0x1>;
-			};
-			ts_cal1: calib@5c {
-				reg = <0x5c 0x2>;
-			};
-			ts_cal2: calib@5e {
-				reg = <0x5e 0x2>;
-			};
-		};
-
-		i2c6: i2c@5c009000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x5c009000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C6_K>;
-			resets = <&rcc I2C6_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x20>;
-			wakeup-source;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
 		tamp: tamp@5c00a000 {
 			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
-			reg = <0x5c00a000 0x400>;
-		};
-
-		/*
-		 * Break node order to solve dependency probe issue between
-		 * pinctrl and exti.
-		 */
-		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
-			compatible = "st,stm32mp157-pinctrl";
-			ranges = <0 0x50002000 0xa400>;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
-
-			gpioa: gpio@50002000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x0 0x400>;
-				clocks = <&rcc GPIOA>;
-				st,bank-name = "GPIOA";
-				status = "disabled";
-			};
-
-			gpiob: gpio@50003000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x1000 0x400>;
-				clocks = <&rcc GPIOB>;
-				st,bank-name = "GPIOB";
-				status = "disabled";
-			};
-
-			gpioc: gpio@50004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x2000 0x400>;
-				clocks = <&rcc GPIOC>;
-				st,bank-name = "GPIOC";
-				status = "disabled";
-			};
-
-			gpiod: gpio@50005000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x3000 0x400>;
-				clocks = <&rcc GPIOD>;
-				st,bank-name = "GPIOD";
-				status = "disabled";
-			};
-
-			gpioe: gpio@50006000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x4000 0x400>;
-				clocks = <&rcc GPIOE>;
-				st,bank-name = "GPIOE";
-				status = "disabled";
-			};
-
-			gpiof: gpio@50007000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x5000 0x400>;
-				clocks = <&rcc GPIOF>;
-				st,bank-name = "GPIOF";
-				status = "disabled";
-			};
-
-			gpiog: gpio@50008000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x6000 0x400>;
-				clocks = <&rcc GPIOG>;
-				st,bank-name = "GPIOG";
-				status = "disabled";
-			};
-
-			gpioh: gpio@50009000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x7000 0x400>;
-				clocks = <&rcc GPIOH>;
-				st,bank-name = "GPIOH";
-				status = "disabled";
-			};
-
-			gpioi: gpio@5000a000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x8000 0x400>;
-				clocks = <&rcc GPIOI>;
-				st,bank-name = "GPIOI";
-				status = "disabled";
-			};
-
-			gpioj: gpio@5000b000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x9000 0x400>;
-				clocks = <&rcc GPIOJ>;
-				st,bank-name = "GPIOJ";
-				status = "disabled";
-			};
-
-			gpiok: gpio@5000c000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0xa000 0x400>;
-				clocks = <&rcc GPIOK>;
-				st,bank-name = "GPIOK";
-				status = "disabled";
+			reg = <0x5c00a000 0x400>;
+			ranges;
+
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				reg = <0x5c00a100 0x80>;
+
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+					wakeup_sec: tamp-bkp@0 {
+						reg = <0x0 0x4>;
+					};
+
+					m4_security_perimeter_exti1: tamp-bkp@4 {
+						/* see cortex-m4 wake up feature */
+						reg = <0x4 0x4>;
+					};
+
+					m4_security_perimeter_exti2: tamp-bkp@8 {
+						/* see cortex-m4 wake up feature */
+						reg = <0x8 0x4>;
+					};
+
+					m4_security_perimeter_exti3: tamp-bkp@c {
+						/* see cortex-m4 wtake up feature */
+						reg = <0xc 0x4>;
+					};
+
+					magic_number: tamp-bkp@10 {
+						/* see ddr and cpu wake up management feature */
+						reg = <0x10 0x4>;
+					};
+
+					branch_address: tamp-bkp@14 {
+						/* see ddr and cpu wake up management feature */
+						reg = <0x14 0x4>;
+					};
+
+					fwu_info: tamp-bkp@28 {
+						/* see firmware update info feature */
+						reg = <0x28 0x4>;
+					};
+
+					copro_rsc_tbl_address: tamp-bkp@44 {
+						/* see cortex-m4 management feature */
+						reg = <0x44 0x4>;
+					};
+
+					cortex_m_state: tamp-bkp@48 {
+						/* see cortex-m4 management feature */
+						reg = <0x48 0x4>;
+					};
+
+					boot_mode: tamp-bkp@50 {
+						/* see boot mode selection feature */
+						reg = <0x50 0x4>;
+					};
+
+					boot_counter: tamp-bkp@54 {
+						/* see boot counter feature */
+						reg = <0x54 0x4>;
+					};
+
+					m4_wakeup_area_start: tamp-bkp@58 {
+						/* see cortex-m4 wake up feature */
+						reg = <0x58 0x4>;
+					};
+
+					m4_wakeup_area_length: tamp-bkp@5c {
+						/* see cortex-m4 wake up feature */
+						reg = <0x5c 0x4>;
+					};
+
+					m4_wakeup_area_hash: tamp-bkp@60 {
+						/* SHA-0x100 value see Cortex-M4 wake up feature */
+						reg = <0x60 0x20>;
+					};
+				};
 			};
-		};
 
-		pinctrl_z: pinctrl@54004000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp157-z-pinctrl";
-			ranges = <0 0x54004000 0x400>;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
-
-			gpioz: gpio@54004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0 0x400>;
-				clocks = <&rcc GPIOZ>;
-				st,bank-name = "GPIOZ";
-				st,bank-ioport = <11>;
-				status = "disabled";
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
 			};
 		};
 	};
@@ -1853,12 +2291,17 @@
 			      <0x30000000 0x40000>,
 			      <0x38000000 0x10000>;
 			resets = <&rcc MCU_R>;
-			st,syscfg-holdboot = <&rcc 0x10C 0x1>;
-			st,syscfg-tz = <&rcc 0x000 0x1>;
+			reset-names = "mcu_rst";
+			st,syscfg-holdboot = <&rcc 0x10c 0x1>;
 			st,syscfg-pdds = <&pwr_mcu 0x0 0x1>;
-			st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
-			st,syscfg-m4-state = <&tamp 0x148 0xFFFFFFFF>;
+			st,syscfg-rsc-tbl = <&tamp 0x144 0xffffffff>;
+			st,syscfg-cm-state = <&tamp 0x148 0xffffffff>;
 			status = "disabled";
+
+			m4_system_resources {
+				compatible = "rproc-srm-core";
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp153.dtsi b/arch/arm/dts/stm32mp153.dtsi
index 486084e0b8..e9ddf67cd3 100644
--- a/arch/arm/dts/stm32mp153.dtsi
+++ b/arch/arm/dts/stm32mp153.dtsi
@@ -10,9 +10,10 @@
 	cpus {
 		cpu1: cpu@1 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <1>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
 		};
 	};
 
@@ -28,32 +29,34 @@
 			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
 			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
 	};
+};
 
-	soc {
-		m_can1: can@4400e000 {
-			compatible = "bosch,m_can";
-			reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
-			reg-names = "m_can", "message_ram";
-			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
-			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
-			status = "disabled";
-		};
+&etzpc {
+	m_can1: can@4400e000 {
+		compatible = "bosch,m_can";
+		reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+		access-controllers = <&etzpc 62>;
+		status = "disabled";
+	};
 
-		m_can2: can@4400f000 {
-			compatible = "bosch,m_can";
-			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
-			reg-names = "m_can", "message_ram";
-			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
-			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
-			status = "disabled";
-		};
+	m_can2: can@4400f000 {
+		compatible = "bosch,m_can";
+		reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+		access-controllers = <&etzpc 62>;
+		status = "disabled";
 	};
 };
diff --git a/arch/arm/dts/stm32mp157.dtsi b/arch/arm/dts/stm32mp157.dtsi
index 54e73ccea4..97cd24227c 100644
--- a/arch/arm/dts/stm32mp157.dtsi
+++ b/arch/arm/dts/stm32mp157.dtsi
@@ -20,17 +20,28 @@
 		dsi: dsi@5a000000 {
 			compatible = "st,stm32-dsi";
 			reg = <0x5a000000 0x800>;
-			clocks = <&rcc DSI_K>, <&clk_hse>, <&rcc DSI_PX>;
+			clocks = <&rcc DSI>, <&clk_hse>, <&rcc DSI_PX>;
 			clock-names = "pclk", "ref", "px_clk";
+			phy-dsi-supply = <&reg18>;
 			resets = <&rcc DSI_R>;
 			reset-names = "apb";
-			#address-cells = <1>;
-			#size-cells = <0>;
 			status = "disabled";
 
 			ports {
 				#address-cells = <1>;
 				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					dsi_in: endpoint {
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dsi_out: endpoint {
+					};
+				};
 			};
 		};
 	};
diff --git a/arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi
deleted file mode 100644
index 20728f27ee..0000000000
--- a/arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,55 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include "stm32mp15-scmi-u-boot.dtsi"
-
-/ {
-	aliases {
-		i2c3 = &i2c4;
-		usb0 = &usbotg_hs;
-	};
-
-	config {
-		u-boot,boot-led = "heartbeat";
-		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "u-boot-env";
-		st,adc_usb_pd = <&adc1 18>, <&adc1 19>;
-		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-	};
-
-	led {
-		red {
-			label = "error";
-			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
-		};
-	};
-};
-
-&adc {
-	status = "okay";
-};
-
-&uart4 {
-	bootph-all;
-};
-
-&uart4_pins_a {
-	bootph-all;
-	pins1 {
-		bootph-all;
-	};
-	pins2 {
-		bootph-all;
-		/* pull-up on rx to avoid floating level */
-		bias-pull-up;
-	};
-};
-
-&usbotg_hs {
-	u-boot,force-b-session-valid;
-};
diff --git a/arch/arm/dts/stm32mp157a-dk1-scmi.dts b/arch/arm/dts/stm32mp157a-dk1-scmi.dtsi
similarity index 79%
rename from arch/arm/dts/stm32mp157a-dk1-scmi.dts
rename to arch/arm/dts/stm32mp157a-dk1-scmi.dtsi
index e539cc80be..34fcf8c155 100644
--- a/arch/arm/dts/stm32mp157a-dk1-scmi.dts
+++ b/arch/arm/dts/stm32mp157a-dk1-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157a-dk1.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157A-DK1 SCMI Discovery Board";
-	compatible = "st,stm32mp157a-dk1-scmi", "st,stm32mp157a-dk1", "st,stm32mp157";
-
 	reserved-memory {
 		optee@de000000 {
 			reg = <0xde000000 0x2000000>;
@@ -30,7 +24,7 @@
 };
 
 &dsi {
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -47,10 +41,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
diff --git a/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
index 2623cebf21..849fdbd930 100644
--- a/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
@@ -1,11 +1,9 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-u-boot.dtsi"
-#include "stm32mp15-ddr3-1x4Gb-1066-binG.dtsi"
+#include "stm32mp15-scmi-u-boot.dtsi"
 
 / {
 	aliases {
@@ -16,44 +14,16 @@
 	config {
 		u-boot,boot-led = "heartbeat";
 		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "fip";
+		u-boot,mmc-env-partition = "u-boot-env";
 		st,adc_usb_pd = <&adc1 18>, <&adc1 19>;
 		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 	};
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE) || defined(CONFIG_SPL)
-	config {
-		u-boot,mmc-env-partition = "ssbl";
-	};
-#endif
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	/* only needed for boot with TF-A, witout FIP support */
-	firmware {
-		optee {
-			compatible = "linaro,optee-tz";
-			method = "smc";
-		};
-	};
-
-	reserved-memory {
-		bootph-pre-ram;
-
-		optee@de000000 {
-			reg = <0xde000000 0x02000000>;
-			no-map;
-			bootph-pre-ram;
-		};
-	};
-#endif
-
 	led {
-		red {
+		led-red {
 			label = "error";
 			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
 		};
 	};
 };
@@ -62,131 +32,6 @@
 	status = "okay";
 };
 
-&clk_hse {
-	st,digbypass;
-};
-
-&i2c4 {
-	bootph-all;
-};
-
-&i2c4_pins_a {
-	bootph-all;
-	pins {
-		bootph-all;
-	};
-};
-
-&pmic {
-	bootph-all;
-};
-
-&rcc {
-	st,clksrc = <
-		CLK_MPU_PLL1P
-		CLK_AXI_PLL2P
-		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
-		CLK_MCO1_DISABLED
-		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
-		CLK_CKPER_HSE
-		CLK_FMC_ACLK
-		CLK_QSPI_ACLK
-		CLK_ETH_DISABLED
-		CLK_SDMMC12_PLL4P
-		CLK_DSI_DSIPLL
-		CLK_STGEN_HSE
-		CLK_USBPHY_HSE
-		CLK_SPI2S1_PLL3Q
-		CLK_SPI2S23_PLL3Q
-		CLK_SPI45_HSI
-		CLK_SPI6_HSI
-		CLK_I2C46_HSI
-		CLK_SDMMC3_PLL4P
-		CLK_USBO_USBPHY
-		CLK_ADC_CKPER
-		CLK_CEC_LSE
-		CLK_I2C12_HSI
-		CLK_I2C35_HSI
-		CLK_UART1_HSI
-		CLK_UART24_HSI
-		CLK_UART35_HSI
-		CLK_UART6_HSI
-		CLK_UART78_HSI
-		CLK_SPDIF_PLL4P
-		CLK_FDCAN_PLL4R
-		CLK_SAI1_PLL3Q
-		CLK_SAI2_PLL3Q
-		CLK_SAI3_PLL3Q
-		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
-		CLK_RNG2_LSI
-		CLK_LPTIM1_PCLK1
-		CLK_LPTIM23_PCLK3
-		CLK_LPTIM45_LSE
-	>;
-
-	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
-	pll2: st,pll@1 {
-		compatible = "st,stm32mp1-pll";
-		reg = <1>;
-		cfg = < 2 65 1 0 0 PQR(1,1,1) >;
-		frac = < 0x1400 >;
-		bootph-all;
-	};
-
-	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
-	pll3: st,pll@2 {
-		compatible = "st,stm32mp1-pll";
-		reg = <2>;
-		cfg = < 1 33 1 16 36 PQR(1,1,1) >;
-		frac = < 0x1a04 >;
-		bootph-all;
-	};
-
-	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
-	pll4: st,pll@3 {
-		compatible = "st,stm32mp1-pll";
-		reg = <3>;
-		cfg = < 3 98 5 7 7 PQR(1,1,1) >;
-		bootph-all;
-	};
-};
-
-&sdmmc1 {
-	bootph-pre-ram;
-};
-
-&sdmmc1_b4_pins_a {
-	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
-		bootph-pre-ram;
-	};
-};
-
 &uart4 {
 	bootph-all;
 };
diff --git a/arch/arm/dts/stm32mp157a-dk1.dts b/arch/arm/dts/stm32mp157a-dk1.dts
index 0da3667ab1..e262d22d4f 100644
--- a/arch/arm/dts/stm32mp157a-dk1.dts
+++ b/arch/arm/dts/stm32mp157a-dk1.dts
@@ -7,9 +7,11 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157a-dk1-scmi.dtsi"
 
 / {
 	model = "STMicroelectronics STM32MP157A-DK1 Discovery Board";
diff --git a/arch/arm/dts/stm32mp157a-ed1-scmi.dtsi b/arch/arm/dts/stm32mp157a-ed1-scmi.dtsi
new file mode 100644
index 0000000000..283f63f85d
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ed1-scmi.dtsi
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15-scmi.dtsi"
+
+/ {
+	reserved-memory {
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi
new file mode 100644
index 0000000000..a447929c9f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ed1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157a-ed1.dts b/arch/arm/dts/stm32mp157a-ed1.dts
new file mode 100644
index 0000000000..7722b32828
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ed1.dts
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157a-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter";
+	compatible = "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/dts/stm32mp157a-ev1-scmi.dtsi b/arch/arm/dts/stm32mp157a-ev1-scmi.dtsi
new file mode 100644
index 0000000000..0c79a2b3ed
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ev1-scmi.dtsi
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	reserved-memory {
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&m_can1 {
+	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..7a8d2ae584
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ev1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157a-ev1.dts b/arch/arm/dts/stm32mp157a-ev1.dts
new file mode 100644
index 0000000000..f70d077207
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ev1.dts
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157a-ed1.dts"
+#include "stm32mp157a-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/media/video-interfaces.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter on eval mother";
+	compatible = "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+		status = "okay";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+		status = "okay";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+		status = "okay";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		status = "okay";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <MEDIA_BUS_TYPE_PARALLEL>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	panel_dsi: panel@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&dsi_in {
+	remote-endpoint = <&ltdc_ep0_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&dsi_panel_in>;
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		AVDD-supply = <&v2v8>;
+		DOVDD-supply = <&v2v8>;
+		DVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts b/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
index fae656edd8..c91f45da83 100644
--- a/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
+++ b/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
@@ -81,8 +81,8 @@
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
+
 			remote-endpoint = <&panel_in>;
 		};
 	};
diff --git a/arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi
deleted file mode 100644
index ae93497cd5..0000000000
--- a/arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,13 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include "stm32mp157a-dk1-scmi-u-boot.dtsi"
-
-/ {
-	fwu-mdata {
-		compatible = "u-boot,fwu-mdata-gpt";
-		fwu-mdata-store = <&sdmmc1>;
-	};
-};
diff --git a/arch/arm/dts/stm32mp157c-dk2-scmi.dts b/arch/arm/dts/stm32mp157c-dk2-scmi.dtsi
similarity index 78%
rename from arch/arm/dts/stm32mp157c-dk2-scmi.dts
rename to arch/arm/dts/stm32mp157c-dk2-scmi.dtsi
index 97e4f94b0a..0b8bba427c 100644
--- a/arch/arm/dts/stm32mp157c-dk2-scmi.dts
+++ b/arch/arm/dts/stm32mp157c-dk2-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-dk2.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157C-DK2 SCMI Discovery Board";
-	compatible = "st,stm32mp157c-dk2-scmi", "st,stm32mp157c-dk2", "st,stm32mp157";
-
 	reserved-memory {
 		optee@de000000 {
 			reg = <0xde000000 0x2000000>;
@@ -35,8 +29,7 @@
 };
 
 &dsi {
-	phy-dsi-supply = <&scmi_reg18>;
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -53,10 +46,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
@@ -83,3 +88,7 @@
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi b/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi
index 24f86209db..329c48723a 100644
--- a/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi
@@ -1,6 +1,6 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
 #include "stm32mp157a-dk1-u-boot.dtsi"
@@ -11,3 +11,7 @@
 		fwu-mdata-store = <&sdmmc1>;
 	};
 };
+
+&sdmmc2 {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/stm32mp157c-dk2.dts b/arch/arm/dts/stm32mp157c-dk2.dts
index ab13e340f4..d8992a6efa 100644
--- a/arch/arm/dts/stm32mp157c-dk2.dts
+++ b/arch/arm/dts/stm32mp157c-dk2.dts
@@ -11,6 +11,8 @@
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157c-dk2-scmi.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C-DK2 Discovery Board";
@@ -22,7 +24,21 @@
 	};
 
 	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
 		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
 	};
 };
 
@@ -31,30 +47,16 @@
 };
 
 &dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
 	status = "okay";
-	phy-dsi-supply = <&reg18>;
-
-	ports {
-		port@0 {
-			reg = <0>;
-			dsi_in: endpoint {
-				remote-endpoint = <&ltdc_ep1_out>;
-			};
-		};
 
-		port@1 {
-			reg = <1>;
-			dsi_out: endpoint {
-				remote-endpoint = <&panel_in>;
-			};
-		};
-	};
-
-	panel@0 {
+	panel_otm8009a: panel-otm8009a@0 {
 		compatible = "orisetech,otm8009a";
 		reg = <0>;
 		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
 		power-supply = <&v3v3>;
+		default-on;
 		status = "okay";
 
 		port {
@@ -65,23 +67,37 @@
 	};
 };
 
+&dsi_in {
+	remote-endpoint = <&ltdc_ep1_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&panel_in>;
+};
+
 &i2c1 {
 	touchscreen@38 {
 		compatible = "focaltech,ft6236";
 		reg = <0x38>;
 		interrupts = <2 2>;
 		interrupt-parent = <&gpiof>;
-		interrupt-controller;
 		touchscreen-size-x = <480>;
 		touchscreen-size-y = <800>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		panel = <&panel_otm8009a>;
 		status = "okay";
 	};
 };
 
 &ltdc {
+	default-on;
 	status = "okay";
 
 	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		ltdc_ep1_out: endpoint@1 {
 			reg = <1>;
 			remote-endpoint = <&dsi_in>;
@@ -89,10 +105,48 @@
 	};
 };
 
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	cap-sdio-irq;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+/* Bluetooth */
 &usart2 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart2_pins_c>;
 	pinctrl-1 = <&usart2_sleep_pins_c>;
 	pinctrl-2 = <&usart2_idle_pins_c>;
-	status = "disabled";
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
 };
diff --git a/arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi
deleted file mode 100644
index 4d763bd3a2..0000000000
--- a/arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,45 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include "stm32mp15-scmi-u-boot.dtsi"
-
-/ {
-	aliases {
-		i2c3 = &i2c4;
-	};
-
-	config {
-		u-boot,boot-led = "heartbeat";
-		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "u-boot-env";
-		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-	};
-
-	led {
-		red {
-			label = "error";
-			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
-		};
-	};
-};
-
-&uart4 {
-	bootph-all;
-};
-
-&uart4_pins_a {
-	bootph-all;
-	pins1 {
-		bootph-all;
-	};
-	pins2 {
-		bootph-all;
-		/* pull-up on rx to avoid floating level */
-		bias-pull-up;
-	};
-};
diff --git a/arch/arm/dts/stm32mp157c-ed1-scmi.dts b/arch/arm/dts/stm32mp157c-ed1-scmi.dtsi
similarity index 74%
rename from arch/arm/dts/stm32mp157c-ed1-scmi.dts
rename to arch/arm/dts/stm32mp157c-ed1-scmi.dtsi
index 9cf0a44d2f..a26929e696 100644
--- a/arch/arm/dts/stm32mp157c-ed1-scmi.dts
+++ b/arch/arm/dts/stm32mp157c-ed1-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-ed1.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157C-ED1 SCMI eval daughter";
-	compatible = "st,stm32mp157c-ed1-scmi", "st,stm32mp157c-ed1", "st,stm32mp157";
-
 	reserved-memory {
 		optee@fe000000 {
 			reg = <0xfe000000 0x2000000>;
@@ -35,7 +29,7 @@
 };
 
 &dsi {
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -52,10 +46,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
@@ -82,3 +88,12 @@
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
index b8288273dd..3fbca8bebd 100644
--- a/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
@@ -1,11 +1,9 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-u-boot.dtsi"
-#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+#include "stm32mp15-scmi-u-boot.dtsi"
 
 / {
 	aliases {
@@ -15,200 +13,19 @@
 	config {
 		u-boot,boot-led = "heartbeat";
 		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "fip";
+		u-boot,mmc-env-partition = "u-boot-env";
 		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 	};
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE) || defined(CONFIG_SPL)
-	config {
-		u-boot,mmc-env-partition = "ssbl";
-	};
-#endif
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	/* only needed for boot with TF-A, witout FIP support */
-	firmware {
-		optee {
-			compatible = "linaro,optee-tz";
-			method = "smc";
-		};
-	};
-
-	reserved-memory {
-		optee@fe000000 {
-			reg = <0xfe000000 0x02000000>;
-			no-map;
-		};
-	};
-#endif
-
 	led {
-		red {
+		led-red {
 			label = "error";
 			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
 		};
 	};
 };
 
-&clk_hse {
-	st,digbypass;
-};
-
-&i2c4 {
-	bootph-all;
-};
-
-&i2c4_pins_a {
-	bootph-all;
-	pins {
-		bootph-all;
-	};
-};
-
-&pmic {
-	bootph-all;
-};
-
-&rcc {
-	st,clksrc = <
-		CLK_MPU_PLL1P
-		CLK_AXI_PLL2P
-		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
-		CLK_MCO1_DISABLED
-		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
-		CLK_CKPER_HSE
-		CLK_FMC_ACLK
-		CLK_QSPI_ACLK
-		CLK_ETH_DISABLED
-		CLK_SDMMC12_PLL4P
-		CLK_DSI_DSIPLL
-		CLK_STGEN_HSE
-		CLK_USBPHY_HSE
-		CLK_SPI2S1_PLL3Q
-		CLK_SPI2S23_PLL3Q
-		CLK_SPI45_HSI
-		CLK_SPI6_HSI
-		CLK_I2C46_HSI
-		CLK_SDMMC3_PLL4P
-		CLK_USBO_USBPHY
-		CLK_ADC_CKPER
-		CLK_CEC_LSE
-		CLK_I2C12_HSI
-		CLK_I2C35_HSI
-		CLK_UART1_HSI
-		CLK_UART24_HSI
-		CLK_UART35_HSI
-		CLK_UART6_HSI
-		CLK_UART78_HSI
-		CLK_SPDIF_PLL4P
-		CLK_FDCAN_PLL4R
-		CLK_SAI1_PLL3Q
-		CLK_SAI2_PLL3Q
-		CLK_SAI3_PLL3Q
-		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
-		CLK_RNG2_LSI
-		CLK_LPTIM1_PCLK1
-		CLK_LPTIM23_PCLK3
-		CLK_LPTIM45_LSE
-	>;
-
-	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
-	pll2: st,pll@1 {
-		compatible = "st,stm32mp1-pll";
-		reg = <1>;
-		cfg = < 2 65 1 0 0 PQR(1,1,1) >;
-		frac = < 0x1400 >;
-		bootph-all;
-	};
-
-	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
-	pll3: st,pll@2 {
-		compatible = "st,stm32mp1-pll";
-		reg = <2>;
-		cfg = < 1 33 1 16 36 PQR(1,1,1) >;
-		frac = < 0x1a04 >;
-		bootph-all;
-	};
-
-	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
-	pll4: st,pll@3 {
-		compatible = "st,stm32mp1-pll";
-		reg = <3>;
-		cfg = < 3 98 5 7 7 PQR(1,1,1) >;
-		bootph-all;
-	};
-};
-
-&sdmmc1 {
-	bootph-pre-ram;
-};
-
-&sdmmc1_b4_pins_a {
-	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
-		bootph-pre-ram;
-	};
-};
-
-&sdmmc1_dir_pins_a {
-	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
-		bootph-pre-ram;
-	};
-};
-
-&sdmmc2 {
-	bootph-pre-ram;
-};
-
-&sdmmc2_b4_pins_a {
-	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
-		bootph-pre-ram;
-	};
-};
-
-&sdmmc2_d47_pins_a {
-	bootph-pre-ram;
-	pins {
-		bootph-pre-ram;
-	};
-};
-
 &uart4 {
 	bootph-all;
 };
diff --git a/arch/arm/dts/stm32mp157c-ed1.dts b/arch/arm/dts/stm32mp157c-ed1.dts
index 3541a17dce..849227aa47 100644
--- a/arch/arm/dts/stm32mp157c-ed1.dts
+++ b/arch/arm/dts/stm32mp157c-ed1.dts
@@ -9,6 +9,9 @@
 #include "stm32mp15xc.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157c-ed1-scmi.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
 
@@ -26,7 +29,7 @@
 
 	memory@c0000000 {
 		device_type = "memory";
-		reg = <0xC0000000 0x40000000>;
+		reg = <0xc0000000 0x40000000>;
 	};
 
 	reserved-memory {
@@ -58,6 +61,12 @@
 			no-map;
 		};
 
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -69,9 +78,33 @@
 			reg = <0x38000000 0x10000>;
 			no-map;
 		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
 	};
 
-	sd_switch: regulator-sd_switch {
+	sd_switch: regulator-sd-switch {
 		compatible = "regulator-gpio";
 		regulator-name = "sd_switch";
 		regulator-min-microvolt = <1800000>;
@@ -103,18 +136,33 @@
 	vref-supply = <&vdda>;
 	status = "disabled";
 	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		/* 16.5 ck_cycles sampling time */
-		st,min-sample-time-nsecs = <400>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
 	};
 };
 
-&cpu0{
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
 	cpu-supply = <&vddcore>;
 };
 
-&cpu1{
+&cpu1 {
 	cpu-supply = <&vddcore>;
 };
 
@@ -143,6 +191,10 @@
 	status = "okay";
 };
 
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
 &hash1 {
 	status = "okay";
 };
@@ -162,7 +214,7 @@
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -263,7 +315,7 @@
 				interrupts = <IT_CURLIM_LDO6 0>;
 			};
 
-			vref_ddr: vref_ddr {
+			vref_ddr: vref-ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 			};
@@ -273,16 +325,16 @@
 				interrupts = <IT_OCP_BOOST 0>;
 			};
 
-			vbus_otg: pwr_sw1 {
+			vbus_otg: pwr-sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr-sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
-			 };
+			};
 		};
 
 		onkey {
@@ -304,18 +356,14 @@
 	status = "okay";
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -324,10 +372,6 @@
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
diff --git a/arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi
deleted file mode 100644
index 9768db8de9..0000000000
--- a/arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,142 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include "stm32mp157c-ed1-scmi-u-boot.dtsi"
-
-/ {
-	aliases {
-		gpio26 = &stmfx_pinctrl;
-		i2c1 = &i2c2;
-		i2c4 = &i2c5;
-		pinctrl2 = &stmfx_pinctrl;
-		spi0 = &qspi;
-		usb0 = &usbotg_hs;
-	};
-
-	fwu-mdata {
-		compatible = "u-boot,fwu-mdata-gpt";
-		fwu-mdata-store = <&sdmmc1>;
-	};
-};
-
-&flash0 {
-	bootph-pre-ram;
-	partitions {
-		compatible = "fixed-partitions";
-		#address-cells = <1>;
-		#size-cells = <1>;
-		partition@0 {
-			label = "fsbl1";
-			reg = <0x00000000 0x00040000>;
-		};
-		partition@40000 {
-			label = "fsbl2";
-			reg = <0x00040000 0x00040000>;
-		};
-		partition@80000 {
-			label = "metadata1";
-			reg = <0x00080000 0x00040000>;
-		};
-		partition@c0000 {
-			label = "metadata2";
-			reg = <0x000c0000 0x00040000>;
-		};
-		partition@100000 {
-			label = "fip-a";
-			reg = <0x00100000 0x00400000>;
-		};
-		partition@500000 {
-			label = "fip-b";
-			reg = <0x00500000 0x00400000>;
-		};
-		partition@900000 {
-			label = "u-boot-env";
-			reg = <0x00900000 0x00080000>;
-		};
-		partition@980000 {
-			label = "nor-user";
-			reg = <0x00980000 0x03680000>;
-		};
-	};
-};
-
-&fmc {
-	nand-controller@4,0 {
-		nand@0 {
-			partitions {
-				compatible = "fixed-partitions";
-				#address-cells = <1>;
-				#size-cells = <1>;
-				partition@0 {
-					label = "fsbl1";
-					reg = <0x00000000 0x00080000>;
-				};
-				partition@80000 {
-					label = "fsbl2";
-					reg = <0x00080000 0x00080000>;
-				};
-				partition@100000 {
-					label = "metadata1";
-					reg = <0x00100000 0x00080000>;
-				};
-				partition@180000 {
-					label = "metadata2";
-					reg = <0x00180000 0x00080000>;
-				};
-				partition@200000 {
-					label = "fip-a1";
-					reg = <0x00200000 0x00400000>;
-				};
-				partition@600000 {
-					label = "fip-a2";
-					reg = <0x00600000 0x00400000>;
-				};
-				partition@a00000 {
-					label = "fip-b1";
-					reg = <0x00a00000 0x00400000>;
-				};
-				partition@e00000 {
-					label = "fip-b2";
-					reg = <0x00e00000 0x00400000>;
-				};
-				partition@1200000 {
-					label = "UBI";
-					reg = <0x01200000 0x3ee00000>;
-				};
-			};
-		};
-	};
-};
-
-&qspi {
-	bootph-pre-ram;
-};
-
-&qspi_clk_pins_a {
-	bootph-pre-ram;
-	pins {
-		bootph-pre-ram;
-	};
-};
-
-&qspi_bk1_pins_a {
-	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
-		bootph-pre-ram;
-	};
-};
-
-&qspi_bk2_pins_a {
-	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
-		bootph-pre-ram;
-	};
-};
diff --git a/arch/arm/dts/stm32mp157c-ev1-scmi.dts b/arch/arm/dts/stm32mp157c-ev1-scmi.dtsi
similarity index 78%
rename from arch/arm/dts/stm32mp157c-ev1-scmi.dts
rename to arch/arm/dts/stm32mp157c-ev1-scmi.dtsi
index 3b9dd6f4cc..b682649ebe 100644
--- a/arch/arm/dts/stm32mp157c-ev1-scmi.dts
+++ b/arch/arm/dts/stm32mp157c-ev1-scmi.dtsi
@@ -4,16 +4,7 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-ev1.dts"
-#include "stm32mp15-scmi.dtsi"
-
 / {
-	model = "STMicroelectronics STM32MP157C-EV1 SCMI eval daughter on eval mother";
-	compatible = "st,stm32mp157c-ev1-scmi", "st,stm32mp157c-ev1", "st,stm32mp157c-ed1",
-		     "st,stm32mp157";
-
 	reserved-memory {
 		optee@fe000000 {
 			reg = <0xfe000000 0x2000000>;
@@ -36,8 +27,7 @@
 };
 
 &dsi {
-	phy-dsi-supply = <&scmi_reg18>;
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -54,10 +44,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &m_can1 {
 	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 };
@@ -88,3 +90,7 @@
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
index 1f7fdbce53..ec850bd274 100644
--- a/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
@@ -1,6 +1,6 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
 #include "stm32mp157c-ed1-u-boot.dtsi"
@@ -28,7 +28,7 @@
 		#address-cells = <1>;
 		#size-cells = <1>;
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE) || defined(CONFIG_SPL)
+#if defined(CONFIG_STM32MP15X_STM32IMAGE) || defined(CONFIG_SPL)
 		partition@0 {
 			label = "fsbl1";
 			reg = <0x00000000 0x00040000>;
@@ -58,17 +58,29 @@
 			label = "fsbl2";
 			reg = <0x00040000 0x00040000>;
 		};
+		partition@80000 {
+			label = "metadata1";
+			reg = <0x00080000 0x00040000>;
+		};
+		partition@c0000 {
+			label = "metadata2";
+			reg = <0x000c0000 0x00040000>;
+		};
 		partition@100000 {
-			label = "fip";
-			reg = <0x00080000 0x00400000>;
+			label = "fip-a";
+			reg = <0x00100000 0x00400000>;
 		};
-		partition@480000 {
+		partition@500000 {
+			label = "fip-b";
+			reg = <0x00500000 0x00400000>;
+		};
+		partition@900000 {
 			label = "u-boot-env";
-			reg = <0x00480000 0x00080000>;
+			reg = <0x00900000 0x00080000>;
 		};
-		partition@500000 {
+		partition@980000 {
 			label = "nor-user";
-			reg = <0x00500000 0x03b00000>;
+			reg = <0x00980000 0x03680000>;
 		};
 #endif
 	};
@@ -82,7 +94,7 @@
 				#address-cells = <1>;
 				#size-cells = <1>;
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE) || defined(CONFIG_SPL)
+#if defined(CONFIG_STM32MP15X_STM32IMAGE) || defined(CONFIG_SPL)
 				partition@0 {
 					label = "fsbl";
 					reg = <0x00000000 0x00200000>;
@@ -101,20 +113,40 @@
 				};
 #else
 				partition@0 {
-					label = "fsbl";
-					reg = <0x00000000 0x00200000>;
+					label = "fsbl1";
+					reg = <0x00000000 0x00080000>;
+				};
+				partition@80000 {
+					label = "fsbl2";
+					reg = <0x00080000 0x00080000>;
+				};
+				partition@100000 {
+					label = "metadata1";
+					reg = <0x00100000 0x00080000>;
+				};
+				partition@180000 {
+					label = "metadata2";
+					reg = <0x00180000 0x00080000>;
 				};
 				partition@200000 {
-					label = "fip1";
+					label = "fip-a1";
 					reg = <0x00200000 0x00400000>;
 				};
 				partition@600000 {
-					label = "fip2";
+					label = "fip-a2";
 					reg = <0x00600000 0x00400000>;
 				};
+				partition@a00000 {
+					label = "fip-b1";
+					reg = <0x00a00000 0x00400000>;
+				};
+				partition@e00000 {
+					label = "fip-b2";
+					reg = <0x00e00000 0x00400000>;
+				};
 				partition@1200000 {
 					label = "UBI";
-					reg = <0x00a00000 0x3f600000>;
+					reg = <0x01200000 0x3ee00000>;
 				};
 #endif
 			};
@@ -135,20 +167,28 @@
 
 &qspi_bk1_pins_a {
 	bootph-pre-ram;
-	pins1 {
+	pins {
 		bootph-pre-ram;
 	};
-	pins2 {
+};
+
+&qspi_cs1_pins_a {
+	bootph-pre-ram;
+	pins {
 		bootph-pre-ram;
 	};
 };
 
 &qspi_bk2_pins_a {
 	bootph-pre-ram;
-	pins1 {
+	pins {
 		bootph-pre-ram;
 	};
-	pins2 {
+};
+
+&qspi_cs2_pins_a {
+	bootph-pre-ram;
+	pins {
 		bootph-pre-ram;
 	};
 };
diff --git a/arch/arm/dts/stm32mp157c-ev1.dts b/arch/arm/dts/stm32mp157c-ev1.dts
index ba8e9d9a42..8736d78ee9 100644
--- a/arch/arm/dts/stm32mp157c-ev1.dts
+++ b/arch/arm/dts/stm32mp157c-ev1.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "stm32mp157c-ed1.dts"
+#include "stm32mp157c-ev1-scmi.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/media/video-interfaces.h>
@@ -16,11 +17,21 @@
 
 	aliases {
 		serial1 = &usart3;
+		serial4 = &usart1;
 		ethernet0 = &ethernet0;
 	};
 
 	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
 		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
 	};
 
 	clocks {
@@ -31,6 +42,58 @@
 		};
 	};
 
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+		status = "okay";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+		status = "okay";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
 	joystick {
 		compatible = "gpio-keys";
 		pinctrl-0 = <&joystick_pins>;
@@ -71,7 +134,46 @@
 		compatible = "gpio-backlight";
 		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
 		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+		status = "okay";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
 		status = "okay";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
 	};
 };
 
@@ -86,6 +188,14 @@
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&dcmi_pins_a>;
 	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
 
 	port {
 		dcmi_0: endpoint {
@@ -95,31 +205,125 @@
 			hsync-active = <0>;
 			vsync-active = <0>;
 			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
 		};
 	};
 };
 
-&dsi {
-	phy-dsi-supply = <&reg18>;
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
 	status = "okay";
 
-	ports {
-		port@0 {
-			reg = <0>;
-			dsi_in: endpoint {
-				remote-endpoint = <&ltdc_ep0_out>;
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
 			};
 		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
 
-		port@1 {
-			reg = <1>;
-			dsi_out: endpoint {
-				remote-endpoint = <&dsi_panel_in>;
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
 			};
 		};
 	};
 
-	panel-dsi@0 {
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	default-on;
+	status = "okay";
+
+	panel_dsi: panel@0 {
 		compatible = "raydium,rm68200";
 		reg = <0>;
 		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
@@ -135,6 +339,14 @@
 	};
 };
 
+&dsi_in {
+	remote-endpoint = <&ltdc_ep0_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&dsi_panel_in>;
+};
+
 &ethernet0 {
 	status = "okay";
 	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
@@ -178,14 +390,61 @@
 	pinctrl-1 = <&i2c2_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
 	ov5640: camera@3c {
 		compatible = "ovti,ov5640";
 		reg = <0x3c>;
 		clocks = <&clk_ext_camera>;
 		clock-names = "xclk";
+		AVDD-supply = <&v2v8>;
 		DOVDD-supply = <&v2v8>;
+		DVDD-supply = <&v2v8>;
 		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
 		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
 		rotation = <180>;
@@ -199,6 +458,7 @@
 				hsync-active = <0>;
 				vsync-active = <0>;
 				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
 			};
 		};
 	};
@@ -218,12 +478,41 @@
 			#interrupt-cells = <2>;
 			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
 
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
 			joystick_pins: joystick-pins {
 				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
 				bias-pull-down;
 			};
 		};
 	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
 };
 
 &i2c5 {
@@ -232,15 +521,17 @@
 	pinctrl-1 = <&i2c5_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 };
 
 &ltdc {
+	default-on;
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&dsi_in>;
 		};
 	};
@@ -289,6 +580,65 @@
 	};
 };
 
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
 &sdmmc3 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc3_b4_pins_a>;
@@ -301,17 +651,41 @@
 	status = "disabled";
 };
 
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
 &spi1 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
 	status = "disabled";
 };
 
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
 &timers2 {
 	/* spare dmas for other usage (un-delete to enable pwm capture) */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm2_pins_a>;
 		pinctrl-1 = <&pwm2_sleep_pins_a>;
@@ -327,6 +701,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm8_pins_a>;
 		pinctrl-1 = <&pwm8_sleep_pins_a>;
@@ -342,6 +719,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
 		pinctrl-1 = <&pwm12_sleep_pins_a>;
@@ -353,6 +733,16 @@
 	};
 };
 
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
 &usart3 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart3_pins_b>;
diff --git a/arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi b/arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi
new file mode 100644
index 0000000000..41f36278b6
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2022
+ */
+
+#include "stm32mp157a-dk1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157d-dk1.dts b/arch/arm/dts/stm32mp157d-dk1.dts
new file mode 100644
index 0000000000..0fbaeccc73
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-dk1.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157a-dk1-scmi.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 Discovery Board";
+	compatible = "st,stm32mp157d-dk1", "st,stm32mp157";
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
diff --git a/arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi
new file mode 100644
index 0000000000..a447929c9f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ed1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157d-ed1.dts b/arch/arm/dts/stm32mp157d-ed1.dts
new file mode 100644
index 0000000000..068e598b13
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ed1.dts
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157a-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter";
+	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..7a8d2ae584
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ev1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157d-ev1.dts b/arch/arm/dts/stm32mp157d-ev1.dts
new file mode 100644
index 0000000000..78c790bdfc
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ev1.dts
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157d-ed1.dts"
+#include "stm32mp157a-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/media/video-interfaces.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter on eval mother";
+	compatible = "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+		status = "okay";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+		status = "okay";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+		status = "okay";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		status = "okay";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <MEDIA_BUS_TYPE_PARALLEL>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	panel_dsi: panel@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&dsi_in {
+	remote-endpoint = <&ltdc_ep0_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&dsi_panel_in>;
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		AVDD-supply = <&v2v8>;
+		DOVDD-supply = <&v2v8>;
+		DVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi b/arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi
new file mode 100644
index 0000000000..53133e98ba
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2022
+ */
+
+#include "stm32mp157a-dk1-u-boot.dtsi"
+
+&sdmmc2 {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/stm32mp157f-dk2.dts b/arch/arm/dts/stm32mp157f-dk2.dts
new file mode 100644
index 0000000000..523d7ef309
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-dk2.dts
@@ -0,0 +1,163 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157c-dk2-scmi.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 Discovery Board";
+	compatible = "st,stm32mp157f-dk2", "st,stm32mp157";
+
+	aliases {
+		serial3 = &usart2;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&ddrperfm {
+	status = "okay";
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	panel_otm8009a: panel-otm8009a@0 {
+		compatible = "orisetech,otm8009a";
+		reg = <0>;
+		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		default-on;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&dsi_in {
+	remote-endpoint = <&ltdc_ep1_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&panel_in>;
+};
+
+&hdp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdp2_gpo &hdp2_pins_a>;
+	pinctrl-1 = <&hdp2_sleep_pins_a>;
+	status = "disabled";
+};
+
+&i2c1 {
+	touchscreen@38 {
+		compatible = "focaltech,ft6236";
+		reg = <0x38>;
+		interrupts = <2 2>;
+		interrupt-parent = <&gpiof>;
+		interrupt-controller;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <800>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		panel = <&panel_otm8009a>;
+		status = "okay";
+	};
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	cap-sdio-irq;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_c>;
+	pinctrl-1 = <&usart2_sleep_pins_c>;
+	pinctrl-2 = <&usart2_idle_pins_c>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi
new file mode 100644
index 0000000000..a447929c9f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ed1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157f-ed1.dts b/arch/arm/dts/stm32mp157f-ed1.dts
new file mode 100644
index 0000000000..fbfb25cd65
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ed1.dts
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157c-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter";
+	compatible = "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..7a8d2ae584
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ev1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157f-ev1.dts b/arch/arm/dts/stm32mp157f-ev1.dts
new file mode 100644
index 0000000000..74cea13fcf
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ev1.dts
@@ -0,0 +1,811 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157f-ed1.dts"
+#include "stm32mp157c-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/media/video-interfaces.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter on eval mother";
+	compatible = "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+		status = "okay";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+		status = "okay";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+		status = "okay";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		status = "okay";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <MEDIA_BUS_TYPE_PARALLEL>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	default-on;
+	status = "okay";
+
+	panel_dsi: panel@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&dsi_in {
+	remote-endpoint = <&ltdc_ep0_out>;
+};
+
+&dsi_out {
+	remote-endpoint = <&dsi_panel_in>;
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		AVDD-supply = <&v2v8>;
+		DOVDD-supply = <&v2v8>;
+		DVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				dai-format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp15xa.dtsi b/arch/arm/dts/stm32mp15xa.dtsi
new file mode 100644
index 0000000000..f56c44a122
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/dts/stm32mp15xc.dtsi b/arch/arm/dts/stm32mp15xc.dtsi
index b06a55a2fa..55ca2814f8 100644
--- a/arch/arm/dts/stm32mp15xc.dtsi
+++ b/arch/arm/dts/stm32mp15xc.dtsi
@@ -4,15 +4,19 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
-/ {
-	soc {
-		cryp1: cryp@54001000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54001000 0x400>;
-			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
-		};
+#include "stm32mp15xa.dtsi"
+
+&etzpc {
+	cryp1: cryp@54001000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x54001000 0x400>;
+		interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&mdma1 29 0x0 0x400202 0x0 0x0>,
+		       <&mdma1 30 0x3 0x400808 0x0 0x0>;
+		dma-names = "in", "out";
+		access-controllers = <&etzpc 9>;
+		status = "disabled";
 	};
 };
diff --git a/arch/arm/dts/stm32mp15xd.dtsi b/arch/arm/dts/stm32mp15xd.dtsi
new file mode 100644
index 0000000000..a5feeec2e4
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xd.dtsi
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&cpu_thermal {
+	trips {
+		cpu-crit {
+			temperature = <100000>;
+			hysteresis = <1000>;
+			type = "critical";
+		};
+
+		cpu_alert: cpu-alert {
+			temperature = <90000>;
+			hysteresis = <10000>;
+			type = "passive";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu_alert>;
+			cooling-device = <&cpu0 1 1>;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15xf.dtsi b/arch/arm/dts/stm32mp15xf.dtsi
new file mode 100644
index 0000000000..8134f7ec62
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xf.dtsi
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15xd.dtsi"
+
+&etzpc {
+	cryp1: cryp@54001000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x54001000 0x400>;
+		interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		access-controllers = <&etzpc 9>;
+		dmas = <&mdma1 29 0x0 0x400202 0x0 0x0>,
+		       <&mdma1 30 0x3 0x400808 0x0 0x0>;
+		dma-names = "in", "out";
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi b/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi
index d3b85a8764..6573b8e5b0 100644
--- a/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi
@@ -82,15 +82,19 @@
 	status = "okay";
 
 	adc1: adc@0 {
-		st,min-sample-time-nsecs = <5000>;
-		st,adc-channels = <0>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 
 	adc2: adc@100 {
-		st,adc-channels = <1>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
diff --git a/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi b/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi
index f12941b05f..2f70b0690d 100644
--- a/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi
@@ -134,20 +134,14 @@
 
 &qspi_bk1_pins_a {
 	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
+	pins {
 		bootph-pre-ram;
 	};
 };
 
-&qspi_bk2_pins_a {
+&qspi_cs1_pins_a {
 	bootph-pre-ram;
-	pins1 {
-		bootph-pre-ram;
-	};
-	pins2 {
+	pins {
 		bootph-pre-ram;
 	};
 };
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi
index 61e17f44ce..19fcff6c3a 100644
--- a/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi
@@ -114,15 +114,35 @@
 	status = "okay";
 
 	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 
 	adc2: adc@100 {
-		st,adc-channels = <0 1 2>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
@@ -275,11 +295,7 @@
 	status = "okay";
 
 	port {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&adv7513_in>;
 		};
 	};
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi
index eb905ad282..552b35db3c 100644
--- a/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi
@@ -98,10 +98,14 @@
 
 &qspi_bk1_pins_a {
 	bootph-pre-ram;
-	pins1 {
+	pins {
 		bootph-pre-ram;
 	};
-	pins2 {
+};
+
+&qspi_cs1_pins_a {
+	bootph-pre-ram;
+	pins {
 		bootph-pre-ram;
 	};
 };
diff --git a/arch/arm/dts/stm32mp15xx-dkx.dtsi b/arch/arm/dts/stm32mp15xx-dkx.dtsi
index f4de6c0b75..5fae7937c7 100644
--- a/arch/arm/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dkx.dtsi
@@ -6,9 +6,12 @@
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
 
 / {
 	aliases {
+		ethernet0 = &ethernet0;
 		serial0 = &uart4;
 		serial1 = &usart3;
 		serial2 = &uart7;
@@ -48,6 +51,12 @@
 			no-map;
 		};
 
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -59,6 +68,33 @@
 			reg = <0x38000000 0x10000>;
 			no-map;
 		};
+
+		gpu_reserved: gpu@d4000000 {
+			reg = <0xd4000000 0x4000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&sii9022_out>;
+			};
+		};
 	};
 
 	led {
@@ -93,31 +129,47 @@
 
 &adc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+	pinctrl-0 = <&adc12_usb_cc_pins_a>;
 	vdd-supply = <&vdd>;
 	vdda-supply = <&vdd>;
 	vref-supply = <&vrefbuf>;
-	status = "disabled";
+	status = "okay";
 	adc1: adc@0 {
+		status = "okay";
 		/*
 		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in18 & in19.
 		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
 		 * 5 * (56 + 47kOhms) * 5pF => 2.5us.
 		 * Use arbitrary margin here (e.g. 5us).
 		 */
-		st,min-sample-time-nsecs = <5000>;
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 6 13 18 19>;
-		status = "okay";
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 	adc2: adc@100 {
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 2 6 18 19>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		/* USB Type-C CC1 & CC2 */
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
 &cec {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&cec_pins_b>;
@@ -125,20 +177,20 @@
 	status = "okay";
 };
 
-&crc1 {
-	status = "okay";
+&cpu0 {
+	cpu-supply = <&vddcore>;
 };
 
-&dts {
-	status = "okay";
+&cpu1 {
+	cpu-supply = <&vddcore>;
 };
 
-&cpu0{
-	cpu-supply = <&vddcore>;
+&crc1 {
+	status = "okay";
 };
 
-&cpu1{
-	cpu-supply = <&vddcore>;
+&dts {
+	status = "okay";
 };
 
 &ethernet0 {
@@ -149,6 +201,8 @@
 	phy-mode = "rgmii-id";
 	max-speed = <1000>;
 	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
 
 	mdio {
 		#address-cells = <1>;
@@ -160,6 +214,10 @@
 	};
 };
 
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
 &hash1 {
 	status = "okay";
 };
@@ -196,6 +254,13 @@
 				};
 			};
 
+			port@1 {
+				reg = <1>;
+				sii9022_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
 			port@3 {
 				reg = <3>;
 				sii9022_tx_endpoint: endpoint {
@@ -278,7 +343,7 @@
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -382,7 +447,7 @@
 				interrupts = <IT_CURLIM_LDO6 0>;
 			};
 
-			vref_ddr: vref_ddr {
+			vref_ddr: vref-ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 			};
@@ -392,12 +457,12 @@
 				interrupts = <IT_OCP_BOOST 0>;
 			};
 
-			vbus_otg: pwr_sw1 {
+			vbus_otg: pwr-sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
 			};
 
-			vbus_sw: pwr_sw2 {
+			vbus_sw: pwr-sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
@@ -443,7 +508,7 @@
 	i2s2_port: port {
 		i2s2_endpoint: endpoint {
 			remote-endpoint = <&sii9022_tx_endpoint>;
-			format = "i2s";
+			dai-format = "i2s";
 			mclk-fs = <256>;
 		};
 	};
@@ -453,11 +518,6 @@
 	status = "okay";
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
 &ltdc {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&ltdc_pins_a>;
@@ -465,8 +525,7 @@
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&sii9022_in>;
 		};
 	};
@@ -474,11 +533,12 @@
 
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -487,10 +547,6 @@
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
@@ -563,11 +619,28 @@
 	status = "disabled";
 };
 
+&spi4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi4_pins_b>;
+	pinctrl-1 = <&spi4_sleep_pins_b>;
+	status = "disabled";
+};
+
+&spi5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi5_pins_a>;
+	pinctrl-1 = <&spi5_sleep_pins_a>;
+	status = "disabled";
+};
+
 &timers1 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm1_pins_a>;
 		pinctrl-1 = <&pwm1_sleep_pins_a>;
@@ -583,6 +656,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm3_pins_a>;
 		pinctrl-1 = <&pwm3_sleep_pins_a>;
@@ -598,6 +674,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm4_pins_a &pwm4_pins_b>;
 		pinctrl-1 = <&pwm4_sleep_pins_a &pwm4_sleep_pins_b>;
@@ -613,6 +692,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm5_pins_a>;
 		pinctrl-1 = <&pwm5_sleep_pins_a>;
@@ -628,6 +710,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	timer@5 {
 		status = "okay";
 	};
@@ -637,6 +722,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
 		pinctrl-1 = <&pwm12_sleep_pins_a>;
diff --git a/arch/arm/dts/stm32mp21-pinctrl.dtsi b/arch/arm/dts/stm32mp21-pinctrl.dtsi
new file mode 100644
index 0000000000..b22a2c0797
--- /dev/null
+++ b/arch/arm/dts/stm32mp21-pinctrl.dtsi
@@ -0,0 +1,613 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	eth1_rmii_pins_a: eth1-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('A', 13, AF10)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('F', 8, AF9)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 2, AF10)>, /* ETH_MDIO */
+				 <STM32_PINMUX('F', 0, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+
+	};
+
+	eth1_rmii_sleep_pins_a: eth1-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('F', 0, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 11, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	goodix_pins_a: goodix-0 {
+		/*
+		 * touchscreen reset needs to be configured
+		 * via the pinctrl not the driver (a pull-down resistor
+		 * has been soldered onto the reset line which forces
+		 * the touchscreen to reset state).
+		 */
+		pins1 {
+			pinmux = <STM32_PINMUX('I', 8, GPIO)>;
+			output-high;
+			bias-pull-up;
+		};
+		/*
+		 * Interrupt line must have a pull-down resistor
+		 * in order to freeze the i2c address at 0x5D
+		 */
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 4, GPIO)>;
+			bias-pull-down;
+		};
+	};
+
+	i2c2_pins_a: i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('D', 15, AF6)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_a: i2c2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('D', 15, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i3c1_pins_a: i3c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 13, AF10)>, /* I3C1_SCL */
+				 <STM32_PINMUX('A', 2, AF8)>; /* I3C1_SDA */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c1_init_pins_a: i3c1-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, AF10)>; /* I3C1_SCL */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 2, AF8)>; /* I3C1_SDA */
+			drive-push-pull;
+			bias-pull-up;
+			slew-rate = <1>;
+		};
+	};
+
+	i3c1_sleep_pins_a: i3c1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* I3C1_SCL */
+				 <STM32_PINMUX('A', 2, ANALOG)>; /* I3C1_SDA */
+		};
+	};
+
+	i3c2_pins_a: i3c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 12, AF4)>, /* I3C2_SCL */
+				 <STM32_PINMUX('G', 0, AF4)>; /* I3C2_SDA */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c2_init_pins_a: i3c2-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 12, AF4)>; /* I3C2_SCL */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 0, AF4)>; /* I3C2_SDA */
+			drive-push-pull;
+			bias-pull-up;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c2_sleep_pins_a: i3c2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 12, ANALOG)>, /* I3C2_SCL */
+				 <STM32_PINMUX('G', 0, ANALOG)>; /* I3C2_SDA */
+		};
+	};
+
+	i3c3_pins_a: i3c3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 12, AF3)>, /* I3C3_SCL */
+				 <STM32_PINMUX('G', 0, AF3)>; /* I3C3_SDA */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c3_init_pins_a: i3c3-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 12, AF3)>; /* I3C3_SCL */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 0, AF3)>; /* I3C3_SDA */
+			drive-push-pull;
+			bias-pull-up;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c3_sleep_pins_a: i3c3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 12, ANALOG)>, /* I3C3_SCL */
+				 <STM32_PINMUX('G', 0, ANALOG)>; /* I3C3_SDA */
+		};
+	};
+
+	ltdc_pins_a: ltdc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, AF13)>, /* LCD_CLK */
+				 <STM32_PINMUX('G',  2, AF13)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I',  6, AF13)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('C',  5, AF14)>, /* LCD_DE */
+				 <STM32_PINMUX('C', 11, AF13)>, /* LCD_R2 */
+				 <STM32_PINMUX('A',  1, AF11)>, /* LCD_R3 */
+				 <STM32_PINMUX('B', 15, AF13)>, /* LCD_R4 */
+				 <STM32_PINMUX('G',  5, AF13)>, /* LCD_R5 */
+				 <STM32_PINMUX('A', 10, AF12)>, /* LCD_R6 */
+				 <STM32_PINMUX('G',  7, AF13)>, /* LCD_R7 */
+				 <STM32_PINMUX('G',  8, AF13)>, /* LCD_G2 */
+				 <STM32_PINMUX('G',  9, AF13)>, /* LCD_G3 */
+				 <STM32_PINMUX('G', 10, AF13)>, /* LCD_G4 */
+				 <STM32_PINMUX('G', 11, AF13)>, /* LCD_G5 */
+				 <STM32_PINMUX('G', 12, AF13)>, /* LCD_G6 */
+				 <STM32_PINMUX('C',  0, AF13)>, /* LCD_G7 */
+				 <STM32_PINMUX('G', 15, AF13)>, /* LCD_B2 */
+				 <STM32_PINMUX('I',  0, AF13)>, /* LCD_B3 */
+				 <STM32_PINMUX('I',  1, AF13)>, /* LCD_B4 */
+				 <STM32_PINMUX('A',  7, AF10)>, /* LCD_B5 */
+				 <STM32_PINMUX('F',  5, AF13)>, /* LCD_B6 */
+				 <STM32_PINMUX('I',  4, AF13)>; /* LCD_B7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ltdc_sleep_pins_a: ltdc-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>, /* LCD_CLK */
+				 <STM32_PINMUX('G',  2, ANALOG)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I',  6, ANALOG)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('C',  5, ANALOG)>, /* LCD_DE */
+				 <STM32_PINMUX('C', 11, ANALOG)>, /* LCD_R2 */
+				 <STM32_PINMUX('A',  1, ANALOG)>, /* LCD_R3 */
+				 <STM32_PINMUX('B', 15, ANALOG)>, /* LCD_R4 */
+				 <STM32_PINMUX('G',  5, ANALOG)>, /* LCD_R5 */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* LCD_R6 */
+				 <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_R7 */
+				 <STM32_PINMUX('G',  8, ANALOG)>, /* LCD_G2 */
+				 <STM32_PINMUX('G',  9, ANALOG)>, /* LCD_G3 */
+				 <STM32_PINMUX('G', 10, ANALOG)>, /* LCD_G4 */
+				 <STM32_PINMUX('G', 11, ANALOG)>, /* LCD_G5 */
+				 <STM32_PINMUX('G', 12, ANALOG)>, /* LCD_G6 */
+				 <STM32_PINMUX('C',  0, ANALOG)>, /* LCD_G7 */
+				 <STM32_PINMUX('G', 15, ANALOG)>, /* LCD_B2 */
+				 <STM32_PINMUX('I',  0, ANALOG)>, /* LCD_B3 */
+				 <STM32_PINMUX('I',  1, ANALOG)>, /* LCD_B4 */
+				 <STM32_PINMUX('A',  7, ANALOG)>, /* LCD_B5 */
+				 <STM32_PINMUX('F',  5, ANALOG)>, /* LCD_B6 */
+				 <STM32_PINMUX('I',  4, ANALOG)>; /* LCD_B7 */
+		};
+	};
+
+	mdf_cck0_pins_a: mdf-cck0-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 3, AF5)>; /* MDF1_CCK0 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_cck0_sleep_pins_a: mdf-cck0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 3, ANALOG)>; /* MDF1_CCK0 */
+		};
+	};
+
+	mdf_sdi3_pins_a: mdf-sdi3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 3, AF5)>; /* MDF1_SDI3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_sdi3_sleep_pins_a: mdf-sdi3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 3, ANALOG)>; /* MDF1_SDI3 */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>; /* SDMMC1_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 4, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('E', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_pins_a: sdmmc2-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>; /* SDMMC2_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_sleep_pins_a: sdmmc2-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 14, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('E', 15, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_sleep_pins_a: sdmmc2-d47-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, ANALOG)>; /* SDMMC2_D7 */
+		};
+	};
+
+	sdmmc3_b4_pins_a: sdmmc3-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('D', 14, AF12)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_od_pins_a: sdmmc3-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('D', 14, AF12)>; /* SDMMC3_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_sleep_pins_a: sdmmc3-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('D', 13, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('B', 13, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('D', 12, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	spi1_pins_a: spi1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 11, AF2)>, /* SPI1_SCK */
+				 <STM32_PINMUX('I', 5, AF3)>; /* SPI1_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 1, AF2)>; /* SPI1_MISO */
+			bias-disable;
+		};
+	};
+
+	spi1_sleep_pins_a: spi1-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 11, ANALOG)>, /* SPI1_SCK */
+				 <STM32_PINMUX('I', 5, ANALOG)>, /* SPI1_MOSI */
+				 <STM32_PINMUX('D', 1, ANALOG)>; /* SPI1_MISO */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, AF6)>, /* USART1_TX */
+				 <STM32_PINMUX('B', 9, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 10, AF6)>, /* USART1_RX */
+				 <STM32_PINMUX('B', 11, AF6)>; /* USART1_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('B', 11, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 9, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 10, AF6)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* USART1_RTS */
+				 <STM32_PINMUX('B', 9, ANALOG)>, /* USART1_CTS_NSS */
+				 <STM32_PINMUX('B', 10, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>; /* USART2_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('A', 8, ANALOG)>; /* USART2_RX */
+		};
+	};
+
+	uart4_pins_a: uart4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 7, AF4)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 8, AF4)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	uart4_idle_pins_a: uart4-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 7, ANALOG)>; /* UART4_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 8, AF4)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	uart4_sleep_pins_a: uart4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, ANALOG)>, /* UART4_TX */
+				 <STM32_PINMUX('H', 8, ANALOG)>; /* UART4_RX */
+		};
+	};
+
+	usart6_pins_a: usart6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, AF3)>, /* USART6_TX */
+				 <STM32_PINMUX('C', 3, AF6)>;  /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF6)>, /* USART6_RX */
+				 <STM32_PINMUX('F', 15, AF3)>; /* USART6_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart6_idle_pins_a: usart6-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('F', 15, ANALOG)>; /* USART6_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 3, AF6)>; /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('H', 9, AF6)>; /* USART6_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart6_sleep_pins_a: usart6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('C', 3, ANALOG)>,  /* USART6_RTS */
+				 <STM32_PINMUX('F', 15, ANALOG)>, /* USART6_CTS_NSS */
+				 <STM32_PINMUX('H', 9, ANALOG)>; /* USART6_RX */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp21-u-boot.dtsi b/arch/arm/dts/stm32mp21-u-boot.dtsi
new file mode 100644
index 0000000000..d432363023
--- /dev/null
+++ b/arch/arm/dts/stm32mp21-u-boot.dtsi
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ */
+
+/ {
+	aliases {
+		gpio0 = &gpioa;
+		gpio1 = &gpiob;
+		gpio2 = &gpioc;
+		gpio3 = &gpiod;
+		gpio4 = &gpioe;
+		gpio5 = &gpiof;
+		gpio6 = &gpiog;
+		gpio7 = &gpioh;
+		gpio8 = &gpioi;
+		gpio25 = &gpioz;
+		pinctrl0 = &pinctrl;
+		pinctrl1 = &pinctrl_z;
+	};
+
+	firmware {
+		optee {
+			bootph-all;
+		};
+
+		scmi {
+			bootph-all;
+		};
+	};
+
+	/* need PSCI for sysreset during board_f */
+	psci {
+		bootph-all;
+	};
+
+	soc@0 {
+		bootph-all;
+	};
+};
+
+&bsec {
+	bootph-all;
+};
+
+&gpioa {
+	bootph-all;
+};
+
+&gpiob {
+	bootph-all;
+};
+
+&gpioc {
+	bootph-all;
+};
+
+&gpiod {
+	bootph-all;
+};
+
+&gpioe {
+	bootph-all;
+};
+
+&gpiof {
+	bootph-all;
+};
+
+&gpiog {
+	bootph-all;
+};
+
+&gpioh {
+	bootph-all;
+};
+
+&gpioi {
+	bootph-all;
+};
+
+&gpioz {
+	bootph-all;
+};
+
+/* pre-reloc probe = reserve video frame buffer in video_reserve() */
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+	clock-names = "bus", "lcd";
+	bootph-all;
+};
+
+&pinctrl {
+	bootph-all;
+};
+
+&rcc {
+	bootph-all;
+};
+
+&rifsc {
+	bootph-all;
+};
+
+&scmi_clk {
+	bootph-all;
+};
+
+&syscfg {
+	bootph-all;
+};
diff --git a/arch/arm/dts/stm32mp211.dtsi b/arch/arm/dts/stm32mp211.dtsi
new file mode 100644
index 0000000000..748f66f9de
--- /dev/null
+++ b/arch/arm/dts/stm32mp211.dtsi
@@ -0,0 +1,2692 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/arm/coresight-cti-dt.h>
+#include <dt-bindings/clock/st,stm32mp21-rcc.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/reset/st,stm32mp21-rcc.h>
+#include <dt-bindings/regulator/st,stm32mp21-regulator.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			power-domains = <&CPU_PD0>;
+			power-domain-names = "psci";
+			#cooling-cells = <2>;
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a35-pmu";
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xbc000000>;
+		status = "disabled";
+	};
+
+	cs_replicator: replicator {
+		compatible = "arm,coresight-static-replicator";
+		clocks = <&scmi_clk CK_SCMI_SYSATB>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				replicator_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				replicator_out_port0: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				replicator_out_port1: endpoint {
+					remote-endpoint = <&tpiu_in_port>;
+				};
+			};
+		};
+	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_vddio1: regulator@0 {
+						reg = <VOLTD_SCMI_VDDIO1>;
+						regulator-name = "vddio1";
+					};
+					scmi_vddio2: regulator@1 {
+						reg = <VOLTD_SCMI_VDDIO2>;
+						regulator-name = "vddio2";
+					};
+					scmi_vddio3: regulator@2 {
+						reg = <VOLTD_SCMI_VDDIO3>;
+						regulator-name = "vddio3";
+					};
+					scmi_vdda18adc: regulator@7 {
+						reg = <VOLTD_SCMI_ADC>;
+						regulator-name = "vdda18adc";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x0 0x4ac10000 0x0 0x1000>,
+		      <0x0 0x4ac20000 0x0 0x2000>,
+		      <0x0 0x4ac40000 0x0 0x2000>,
+		      <0x0 0x4ac60000 0x0 0x2000>;
+		#address-cells = <1>;
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+
+		CPU_PD0: power-domain-cpu0 {
+			#power-domain-cells = <0>;
+			power-domains = <&CLUSTER_PD>;
+		};
+
+		CLUSTER_PD: power-domain-cluster {
+			#power-domain-cells = <0>;
+			power-domains = <&RET_PD>;
+		};
+
+		RET_PD: power-domain-retention {
+			#power-domain-cells = <0>;
+		};
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 0>;
+
+			trips {
+				cpu_alert: cpu-alert {
+					temperature = <110000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+
+				cpu-crit {
+					temperature = <122000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 1 1>;
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		arm,no-tick-in-suspend;
+	};
+
+	usb2_phy1: usb2-phy1 {
+		compatible      = "st,stm32mp21-usb2phy";
+		#phy-cells      = <0>;
+		st,syscfg       = <&syscfg 0x2400>;
+		clocks          = <&rcc CK_KER_USB2PHY1>;
+		resets          = <&rcc USB2PHY1_R>;
+		status          = "disabled";
+	};
+
+	usb2_phy2: usb2-phy2 {
+		compatible      = "st,stm32mp21-usb2phy";
+		#phy-cells      = <0>;
+		st,syscfg       = <&syscfg 0x2800>;
+		clocks          = <&rcc CK_KER_USB2PHY2EN>;
+		resets          = <&rcc USB2PHY2_R>;
+		status          = "disabled";
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <2>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x0 0x80000000>;
+		dma-ranges = <0x0 0x0 0x80000000 0x1 0x0>;
+
+		hpdma: dma-controller@40400000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40400000 0x0 0x1000>;
+			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA1>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+			st,syscfg-arcr = <&syscfg 0x2050 0x1>;
+		};
+
+		hpdma2: dma-controller@40410000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40410000 0x0 0x1000>;
+			interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA2>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+			st,syscfg-arcr = <&syscfg 0x2050 0x2>;
+		};
+
+		hpdma3: dma-controller@40420000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40420000 0x0 0x1000>;
+			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA3>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+			st,syscfg-arcr = <&syscfg 0x2050 0x4>;
+		};
+
+		ipcc1: mailbox@40490000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x40490000 0x0 0x400>;
+			st,proc-id = <0>;
+			interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi_clk CK_SCMI_IPCC1>;
+			status = "disabled";
+		};
+
+		rifsc: bus@42080000 {
+			compatible = "st,stm32mp25-rifsc", "simple-bus";
+			reg = <0x42080000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <2>;
+			#access-controller-cells = <1>;
+			ranges;
+			dma-ranges;
+
+			i2s2: audio-controller@400b0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400b0000 0x0 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI2>, <&rcc CK_KER_SPI2>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 34 0x43 0x12>,
+					<&hpdma 35 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 23>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			timers2: timer@40000000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40000000 0x0 0x400>;
+				interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM2>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 1>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@1 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+			};
+
+			timers3: timer@40010000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40010000 0x0 0x400>;
+				interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM3>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 2>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@2 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			timers4: timer@40020000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40020000 0x0 0x400>;
+				interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM4>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 3>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@3 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+
+			};
+
+			timers5: timer@40030000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40030000 0x0 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM5>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 4>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@4 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+
+			};
+
+			timers6: timer@40040000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40040000 0x0 0x400>;
+				interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM6>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 5>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				timer@5 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
+			};
+
+			timers7: timer@40050000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40050000 0x0 0x400>;
+				interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM7>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 6>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
+			};
+
+			timers12: timer@40060000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40060000 0x0 0x400>;
+				interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM12>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 10>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@40070000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40070000 0x0 0x400>;
+				interrupts = <GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM13>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 11>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@40080000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40080000 0x0 0x400>;
+				interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM14>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 12>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			lptimer1: timer@40090000 {
+				compatible = "st,stm32mp21-lptimer";
+				reg = <0x40090000 0x0 0x400>;
+				interrupts-extended = <&exti1 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM1>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 17>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp21-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@0 {
+					compatible = "st,stm32mp21-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@400a0000 {
+				compatible = "st,stm32mp21-lptimer";
+				reg = <0x400a0000 0x0 0x400>;
+				interrupts-extended = <&exti1 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM2>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 18>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp21-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32mp21-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+			};
+
+			spi2: spi@400b0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400b0000 0x0 0x400>;
+				interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI2>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 34 0x40 0x3012>,
+				       <&hpdma 35 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 23>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2s3: audio-controller@400c0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400c0000 0x0 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI3>, <&rcc CK_KER_SPI3>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 36 0x43 0x12>,
+					<&hpdma 37 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 24>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi3: spi@400c0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400c0000 0x0 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI3>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 36 0x40 0x3012>,
+				       <&hpdma 37 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 24>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spdifrx: audio-controller@400d0000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x400d0000 0x0 0x400>;
+				clocks = <&rcc CK_KER_SPDIFRX>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 48 0x43 0x212>,
+					<&hpdma 49 0x43 0x212>;
+				dma-names = "rx", "rx-ctrl";
+				access-controllers = <&rifsc 30>;
+				status = "disabled";
+			};
+
+			usart2: serial@400e0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400e0000 0x0 0x400>;
+				interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART2>;
+				dmas = <&hpdma 11 0x40 0x12>,
+				       <&hpdma 12 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 32>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			usart3: serial@400f0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400f0000 0x0 0x400>;
+				interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART3>;
+				dmas = <&hpdma 13 0x40 0x12>,
+				       <&hpdma 14 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 33>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			uart4: serial@40100000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40100000 0x0 0x400>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART4>;
+				dmas = <&hpdma 15 0x40 0x12>,
+				       <&hpdma 16 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 34>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			uart5: serial@40110000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40110000 0x0 0x400>;
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART5>;
+				dmas = <&hpdma 17 0x40 0x12>,
+				       <&hpdma 18 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 35>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40170000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40170000 0x0 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C1>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 23 0x40 0x3012>,
+				       <&hpdma 24 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 41>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40180000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40180000 0x0 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C2>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 26 0x40 0x3012>,
+				       <&hpdma 27 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 42>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c1: i3c@40190000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x40190000 0x0 0x400>;
+				interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C1>;
+				resets = <&rcc I3C1_R>;
+				access-controllers = <&rifsc 114>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c2: i3c@401a0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401a0000 0x0 0x400>;
+				interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C2>;
+				resets = <&rcc I3C2_R>;
+				access-controllers = <&rifsc 115>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers10: timer@401c0000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x401c0000 0x0 0x400>;
+				interrupts = <GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM10>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 8>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@9 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <9>;
+					status = "disabled";
+				};
+			};
+
+			timers11: timer@401d0000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x401d0000 0x0 0x400>;
+				interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM11>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 9>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@10 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <10>;
+					status = "disabled";
+				};
+			};
+
+			timers1: timer@40200000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40200000 0x0 0x400>;
+				interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM1>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 0>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@0 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+			};
+
+			timers8: timer@40210000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40210000 0x0 0x400>;
+				interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM8>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 7>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@7 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+			};
+
+			usart6: serial@40220000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40220000 0x0 0x400>;
+				interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART6>;
+				dmas = <&hpdma 19 0x40 0x12>,
+				       <&hpdma 20 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 36>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2s1: audio-controller@40230000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x40230000 0x0 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI1>, <&rcc CK_KER_SPI1>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 32 0x43 0x12>,
+					<&hpdma 33 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 22>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi1: spi@40230000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40230000 0x0 0x400>;
+				interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI1>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 32 0x40 0x3012>,
+				       <&hpdma 33 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 22>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi4: spi@40240000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40240000 0x0 0x400>;
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI4>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&hpdma 38 0x40 0x3012>,
+				       <&hpdma 39 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 25>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers15: timer@40250000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40250000 0x0 0x400>;
+				interrupts = <GIC_SPI 165 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM15>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 13>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@40260000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40260000 0x0 0x400>;
+				interrupts = <GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM16>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 14>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@40270000 {
+				compatible = "st,stm32mp21-timers";
+				reg = <0x40270000 0x0 0x400>;
+				interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM17>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 15>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32mp21-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			spi5: spi@40280000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40280000 0x0 0x400>;
+				interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI5>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&hpdma 40 0x40 0x3012>,
+				       <&hpdma 41 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 26>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sai1: sai@40290000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40290000 0x0 0x4>, <0x4029a3f0 0x0 0x10>;
+				ranges = <0 0x40290000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI1>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				access-controllers = <&rifsc 49>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai1a: audio-controller@40290004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 50 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai1b: audio-controller@40290024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 51 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai2: sai@402a0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402a0000 0x0 0x4>, <0x402aa3f0 0x0 0x10>;
+				ranges = <0 0x402a0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI2>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				access-controllers = <&rifsc 50>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai2a: audio-controller@402a0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 52 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai2b: audio-controller@402a0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 53 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai3: sai@402b0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402b0000 0x0 0x4>, <0x402ba3f0 0x0 0x10>;
+				ranges = <0 0x402b0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI3>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				access-controllers = <&rifsc 51>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai3a: audio-controller@402b0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 54 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai3b: audio-controller@502b0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 55 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			usart1: serial@40330000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40330000 0x0 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART1>;
+				dmas = <&hpdma 9 0x40 0x12>,
+				       <&hpdma 10 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 31>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sai4: sai@40340000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40340000 0x0 0x4>, <0x4034a3f0 0x0 0x10>;
+				ranges = <0 0x40340000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI4>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				access-controllers = <&rifsc 52>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai4a: audio-controller@40340004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 56 0x63 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai4b: audio-controller@40340024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 57 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			mdf1: mdf@404d0000 {
+				compatible = "st,stm32mp25-mdf";
+				ranges = <0 0x404d0000 0x1000>;
+				reg = <0x404d0000 0x0 0x8>, <0x404d0ff0 0x0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_KER_MDF1>;
+				clock-names = "ker_ck";
+				clock-ranges;
+				resets = <&rcc MDF1_R>;
+				reset-names = "mdf";
+				access-controllers = <&rifsc 54>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+
+				sitf0: sitf@80 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x80 0x4>;
+					status = "disabled";
+				};
+
+				sitf1: sitf@100 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x100 0x4>;
+					status = "disabled";
+				};
+
+				sitf2: sitf@180 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x180 0x4>;
+					status = "disabled";
+				};
+
+				sitf3: sitf@200 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x200 0x4>;
+					status = "disabled";
+				};
+
+				filter0: filter@84 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x84 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 44 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter1: filter@104 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x104 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 45 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter2: filter@184 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x184 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 46 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter3: filter@204 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x204 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 47 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+			};
+
+			uart7: serial@40370000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40370000 0x0 0x400>;
+				interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART7>;
+				dmas = <&hpdma 21 0x40 0x12>,
+				       <&hpdma 22 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 37>;
+				status = "disabled";
+			};
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0x40430000 0x0 0x400>;
+				interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 2 0x62 0x00003121>,
+				       <&hpdma 2 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1000>;
+				clocks = <&scmi_clk CK_SCMI_OSPI1>;
+				resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+				access-controllers = <&rifsc 74>;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@404a0000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x404a0000 0x0 0x400>;
+				interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPSSI_R>;
+				clocks = <&rcc CK_BUS_DCMIPSSI>;
+				clock-names = "mclk";
+				dmas = <&hpdma 105 0x60 0x3012>;
+				dma-names = "tx";
+				access-controllers = <&rifsc 88>;
+				status = "disabled";
+			};
+
+			crc: crc@404c0000 {
+				compatible = "st,stm32f7-crc";
+				reg = <0x404c0000 0x0 0x400>;
+				clocks = <&rcc CK_BUS_CRC>;
+				access-controllers = <&rifsc 109>;
+				status = "disabled";
+			};
+
+			adc_1: adc@404e0000 {
+				compatible = "st,stm32mp21-adc-core";
+				reg = <0x404e0000 0x0 0x400>;
+				interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC1>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 58>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp21-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_1>;
+					interrupts = <0>;
+					dmas = <&hpdma 58 0x40 0x12>;
+					dma-names = "rx";
+					st,adc-trigger-sel = <0>;
+					status = "disabled";
+
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+				};
+			};
+
+			adc_2: adc@404f0000 {
+				compatible = "st,stm32mp21-adc-core";
+				reg = <0x404f0000 0x0 0x400>;
+				interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC2>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 59>;
+				status = "disabled";
+
+				adc2: adc@0 {
+					compatible = "st,stm32mp21-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_2>;
+					interrupts = <0>;
+					dmas = <&hpdma 59 0x40 0x12>;
+					dma-names = "rx";
+					st,adc-trigger-sel = <1>;
+					status = "disabled";
+
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+				};
+			};
+
+			hash1: hash@42030400 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x42030400 0x0 0x400>;
+				interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&hpdma 6 0x40 0x3021>;
+				dma-names = "in";
+				access-controllers = <&rifsc 96>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			iwdg1: watchdog@44010000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44010000 0x0 0x400>;
+				interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG1>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				access-controllers = <&rifsc 100>;
+				status = "disabled";
+			};
+
+			iwdg2: watchdog@44020000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44020000 0x0 0x400>;
+				interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				access-controllers = <&rifsc 101>;
+				status = "disabled";
+			};
+
+			spi6: spi@46020000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x46020000 0x0 0x400>;
+				interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI6>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&hpdma 42 0x40 0x3012>,
+				       <&hpdma 43 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 27>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@46040000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x46040000 0x0 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C3>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 29 0x40 0x3012>,
+				       <&hpdma 30 0x40 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 43>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c3: i3c@46080000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x46080000 0x0 0x400>;
+				interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C3>;
+				resets = <&rcc I3C3_R>;
+				access-controllers = <&rifsc 116>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			csi: csi@48020000 {
+				compatible = "st,stm32mp25-csi";
+				reg = <0x48020000 0x0 0x2000>;
+				interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CSI_R>;
+				clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>,
+					 <&rcc CK_KER_CSIPHY>;
+				clock-names = "pclk", "txesc", "csi2phy";
+				access-controllers = <&rifsc 86>;
+				status = "disabled";
+			};
+
+			lptimer3: timer@46050000 {
+				compatible = "st,stm32mp21-lptimer";
+				reg = <0x46050000 0x0 0x400>;
+				interrupts-extended = <&exti2 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM3>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 19>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp21-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32mp21-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			lptimer4: timer@46060000 {
+				compatible = "st,stm32mp21-lptimer";
+				reg = <0x46060000 0x0 0x400>;
+				interrupts-extended = <&exti2 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM4>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 20>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp21-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@3 {
+					compatible = "st,stm32mp21-lptimer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+			};
+
+			lptimer5: timer@46070000 {
+				compatible = "st,stm32mp21-lptimer";
+				reg = <0x46070000 0x0 0x400>;
+				interrupts-extended = <&exti2 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM5>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 21>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp21-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp21-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp21-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@4 {
+					compatible = "st,stm32mp21-lptimer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+			};
+
+			ddrperfm: perf@480c0000 {
+				compatible = "st,stm32mp25-ddr-pmu";
+				reg = <0x480c0000 0x0 0x400>;
+				clocks = <&rcc CK_BUS_DDRPERFM>;
+				resets = <&rcc DDRPERFM_R>;
+				access-controllers = <&rifsc 67>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@48220000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48220000 0x0 0x400>, <0x44230400 0x0 0x8>;
+				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC1>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 76>;
+				st,syscfg-arcr = <&syscfg 0x40c 0x1>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@48230000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48230000 0x0 0x400>, <0x44230800 0x0 0x8>;
+				interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC2>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 77>;
+				st,syscfg-arcr = <&syscfg 0x80c 0x1>;
+				status = "disabled";
+			};
+
+			sdmmc3: mmc@48240000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48240000 0x0 0x400>, <0x44230c00 0x0 0x8>;
+				interrupts = <GIC_SPI 179 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC3>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 78>;
+				st,syscfg-arcr = <&syscfg 0xc0c 0x1>;
+				status = "disabled";
+			};
+
+			usbh: usb@482e0000 {
+				compatible = "st,stm32mp21-usbh";
+				st,syscfg = <&syscfg 0x2420>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x482e0000 0x482e0000 0x20000>;
+				access-controllers = <&rifsc 63>;
+				status = "disabled";
+
+				usbh_ohci: usb@482e0000 {
+					compatible = "generic-ohci";
+					reg = <0x482e0000 0x1000>;
+					clocks = <&rcc CK_BUS_USBHOHCI>;
+					resets = <&rcc USBH_R>;
+					interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+				};
+
+				usbh_ehci: usb@482f0000 {
+					compatible = "generic-ehci";
+					reg = <0x482f0000 0x1000>;
+					clocks = <&rcc CK_BUS_USBHEHCI>;
+					resets = <&rcc USBH_R>;
+					interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+					companion = <&usbh_ohci>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+				};
+			};
+
+			usbotg_hs: usb@48300000 {
+				compatible = "st,stm32mp21-hsotg", "snps,dwc2";
+				reg = <0x48300000 0x0 0x10000>;
+				clocks = <&rcc CK_BUS_OTG>;
+				clock-names = "otg";
+				resets = <&rcc OTG_R>;
+				reset-names = "dwc2";
+				interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH>;
+				access-controllers = <&rifsc 66>;
+				g-rx-fifo-size = <1024>;
+				g-np-tx-fifo-size = <64>;
+				g-tx-fifo-size = <512 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				phys = <&usb2_phy2>;
+				phy-names = "usb2-phy";
+				st,syscfg = <&syscfg 0x2824>;
+				status = "disabled";
+			};
+		};
+
+		risaf1: risaf@420a0000 {
+			compatible = "st,stm32mp25-risaf";
+			reg = <0x420a0000 0x0 0x1000>;
+			clocks = <&rcc CK_BUS_BKPSRAM>;
+			st,mem-map = <0x0 0x42000000 0x0 0x2000>;
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32mp25-risaf-enc";
+			reg = <0x420d0000 0x0 0x1000>;
+			clocks = <&rcc CK_BUS_RISAF4>;
+			st,mem-map = <0x0 0x80000000 0x1 0x00000000>;
+		};
+
+		risab1: risab@420f0000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x420f0000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa000000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab2: risab@42100000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42100000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa020000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab3: risab@42110000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42110000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0x0a060000 0x10000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab5: risab@42130000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42130000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0x0a040000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		hdp: pinctrl@44090000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x44090000 0x0 0x400>;
+			clocks = <&rcc CK_BUS_HDP>;
+			status = "disabled";
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		dts: thermal-sensor@44070000 {
+			compatible = "moortec,mr75203";
+			reg = <0x44070000 0x0 0x80>,
+			      <0x44070080 0x0 0x180>,
+			      <0x44070200 0x0 0x200>,
+			      <0x44070400 0x0 0xc00>;
+			reg-names = "common", "ts", "pd", "vm";
+			clocks = <&rcc CK_KER_DTS>;
+			resets = <&rcc DTS_R>;
+			#thermal-sensor-cells = <1>;
+		};
+
+		rcc: clock-controller@44200000 {
+			compatible = "st,stm32mp21-rcc";
+			reg = <0x44200000 0x0 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clocks =
+				<&scmi_clk CK_SCMI_HSE>,
+				<&scmi_clk CK_SCMI_HSI>,
+				<&scmi_clk CK_SCMI_MSI>,
+				<&scmi_clk CK_SCMI_LSE>,
+				<&scmi_clk CK_SCMI_LSI>,
+				<&scmi_clk CK_SCMI_HSE_DIV2>,
+				<&scmi_clk CK_SCMI_ICN_HS_MCU>,
+				<&scmi_clk CK_SCMI_ICN_LS_MCU>,
+				<&scmi_clk CK_SCMI_ICN_SDMMC>,
+				<&scmi_clk CK_SCMI_ICN_DDR>,
+				<&scmi_clk CK_SCMI_ICN_DISPLAY>,
+				<&scmi_clk CK_SCMI_ICN_HSL>,
+				<&scmi_clk CK_SCMI_ICN_NIC>,
+				<&scmi_clk CK_SCMI_FLEXGEN_07>,
+				<&scmi_clk CK_SCMI_FLEXGEN_08>,
+				<&scmi_clk CK_SCMI_FLEXGEN_09>,
+				<&scmi_clk CK_SCMI_FLEXGEN_10>,
+				<&scmi_clk CK_SCMI_FLEXGEN_11>,
+				<&scmi_clk CK_SCMI_FLEXGEN_12>,
+				<&scmi_clk CK_SCMI_FLEXGEN_13>,
+				<&scmi_clk CK_SCMI_FLEXGEN_14>,
+				<&scmi_clk CK_SCMI_FLEXGEN_16>,
+				<&scmi_clk CK_SCMI_FLEXGEN_17>,
+				<&scmi_clk CK_SCMI_FLEXGEN_18>,
+				<&scmi_clk CK_SCMI_FLEXGEN_19>,
+				<&scmi_clk CK_SCMI_FLEXGEN_20>,
+				<&scmi_clk CK_SCMI_FLEXGEN_21>,
+				<&scmi_clk CK_SCMI_FLEXGEN_22>,
+				<&scmi_clk CK_SCMI_FLEXGEN_23>,
+				<&scmi_clk CK_SCMI_FLEXGEN_24>,
+				<&scmi_clk CK_SCMI_FLEXGEN_25>,
+				<&scmi_clk CK_SCMI_FLEXGEN_26>,
+				<&scmi_clk CK_SCMI_FLEXGEN_27>,
+				<&scmi_clk CK_SCMI_FLEXGEN_29>,
+				<&scmi_clk CK_SCMI_FLEXGEN_30>,
+				<&scmi_clk CK_SCMI_FLEXGEN_31>,
+				<&scmi_clk CK_SCMI_FLEXGEN_33>,
+				<&scmi_clk CK_SCMI_FLEXGEN_36>,
+				<&scmi_clk CK_SCMI_FLEXGEN_37>,
+				<&scmi_clk CK_SCMI_FLEXGEN_38>,
+				<&scmi_clk CK_SCMI_FLEXGEN_39>,
+				<&scmi_clk CK_SCMI_FLEXGEN_40>,
+				<&scmi_clk CK_SCMI_FLEXGEN_41>,
+				<&scmi_clk CK_SCMI_FLEXGEN_42>,
+				<&scmi_clk CK_SCMI_FLEXGEN_43>,
+				<&scmi_clk CK_SCMI_FLEXGEN_44>,
+				<&scmi_clk CK_SCMI_FLEXGEN_45>,
+				<&scmi_clk CK_SCMI_FLEXGEN_46>,
+				<&scmi_clk CK_SCMI_FLEXGEN_47>,
+				<&scmi_clk CK_SCMI_FLEXGEN_48>,
+				<&scmi_clk CK_SCMI_FLEXGEN_50>,
+				<&scmi_clk CK_SCMI_FLEXGEN_51>,
+				<&scmi_clk CK_SCMI_FLEXGEN_52>,
+				<&scmi_clk CK_SCMI_FLEXGEN_53>,
+				<&scmi_clk CK_SCMI_FLEXGEN_54>,
+				<&scmi_clk CK_SCMI_FLEXGEN_55>,
+				<&scmi_clk CK_SCMI_FLEXGEN_56>,
+				<&scmi_clk CK_SCMI_FLEXGEN_57>,
+				<&scmi_clk CK_SCMI_FLEXGEN_58>,
+				<&scmi_clk CK_SCMI_FLEXGEN_61>,
+				<&scmi_clk CK_SCMI_FLEXGEN_62>,
+				<&scmi_clk CK_SCMI_FLEXGEN_63>,
+				<&scmi_clk CK_SCMI_ICN_APB1>,
+				<&scmi_clk CK_SCMI_ICN_APB2>,
+				<&scmi_clk CK_SCMI_ICN_APB3>,
+				<&scmi_clk CK_SCMI_ICN_APB4>,
+				<&scmi_clk CK_SCMI_ICN_APB5>,
+				<&scmi_clk CK_SCMI_ICN_APBDBG>,
+				<&scmi_clk CK_SCMI_TIMG1>,
+				<&scmi_clk CK_SCMI_TIMG2>;
+			access-controllers = <&rifsc 156>;
+		};
+
+		pwr: syscon@44210000 {
+			compatible = "st,stm32mp21-pwr", "syscon";
+			reg = <0x44210000 0x0 0x0400>;
+		};
+
+		exti1: interrupt-controller@44220000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x44220000 0x0 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 0   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 211 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 95  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 97  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 99  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<&intc GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,						/* EXTI_50 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<&intc GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 96  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 206 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x0 0x10000>;
+		};
+
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp215-pinctrl";
+			ranges = <0 0x44240000 0x80400>;
+			interrupt-parent = <&exti1>;
+			interrupts-extended =
+				<&exti1  0 0>, <&exti1  1 0>, <&exti1  2 0>, <&exti1  3 0>,
+				<&exti1  4 0>, <&exti1  5 0>, <&exti1  6 0>, <&exti1  7 0>,
+				<&exti1  8 0>, <&exti1  9 0>, <&exti1 10 0>, <&exti1 11 0>,
+				<&exti1 12 0>, <&exti1 13 0>, <&exti1 14 0>, <&exti1 15 0>,
+				<&exti2  0 0>, <&exti2  1 0>, <&exti2  2 0>, <&exti2  3 0>,
+				<&exti2  4 0>, <&exti2  5 0>, <&exti2  6 0>, <&exti2  7 0>,
+				<&exti2  8 0>, <&exti2  9 0>, <&exti2 10 0>, <&exti2 11 0>,
+				<&exti2 12 0>, <&exti2 13 0>, <&exti2 14 0>, <&exti2 15 0>;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+		};
+
+		exti2: interrupt-controller@442d0000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x442d0000 0x0 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 15  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 16  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 17  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 18  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 19  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 20  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 21  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 22  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 25  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 26  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 27  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 28  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 29  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 30  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 11  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 12  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 13  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 5   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 4   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 2   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 201 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_50 */
+				<&intc GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 204 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		rtc: rtc@46000000 {
+			compatible = "st,stm32mp25-rtc";
+			reg = <0x46000000 0x0 0x400>;
+			clocks = <&scmi_clk CK_SCMI_RTC>,
+				 <&scmi_clk CK_SCMI_RTCCK>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti2 17 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <2>;
+			reg = <0x46010000 0x0 0x400>;
+			ranges;
+
+			nvram: nvram@46010100 {
+				compatible = "st,stm32mp25-tamp-nvram";
+				reg = <0x46010100 0x0 0x200>;
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+					boot_mode: tamp-bkp@180 {
+						reg = <0x180 0x4>;
+					};
+					rsc_tbl_addr: tamp-bkp@184 {
+						reg = <0x184 0x4>;
+					};
+					rsc_tbl_size: tamp-bkp@188 {
+						reg = <0x188 0x4>;
+					};
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp215-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+		};
+
+		fmc: memory-controller@48200000 {
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x0 0x400>;
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+			#address-cells = <2>;
+			#size-cells = <1>;
+			clocks = <&scmi_clk CK_SCMI_FMC>;
+			resets = <&scmi_reset RST_SCMI_FMC>;
+			status = "disabled";
+
+			nand-controller@4,0 {
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 0 0x62 0x00003121>,
+				       <&hpdma 0 0x62 0x00003112>,
+				       <&hpdma 1 0x42 0x00013113>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		a35ss_syscfg: syscon@48802000  {
+			compatible = "st,stm32mp25-a35ss-syscfg", "syscon";
+			reg = <0x48802000 0x0 0xac>;
+			status = "disabled";
+		};
+
+		cs_funnel: funnel@4a010000 {
+			compatible = "arm,coresight-dynamic-funnel", "arm,primecell";
+			reg = <0x4a010000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					funnel_in_port0: endpoint {
+						remote-endpoint = <&etm0_out_port>;
+					};
+				};
+
+				port@2 {
+					reg = <2>;
+					funnel_in_port2: endpoint {
+						remote-endpoint = <&stm_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					funnel_out_port: endpoint {
+						remote-endpoint = <&etf_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etf: etf@4a020000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a020000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					etf_in_port: endpoint {
+						remote-endpoint = <&funnel_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					etf_out_port: endpoint {
+						remote-endpoint = <&replicator_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_tpiu: tpiu@4a040000 {
+			compatible = "arm,coresight-tpiu", "arm,primecell";
+			reg = <0x4a040000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_TPIU>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					tpiu_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port1>;
+					};
+				};
+			};
+		};
+
+		cs_stm: stm@4a070000 {
+			compatible = "arm,coresight-stm", "arm,primecell";
+			reg = <0x4a070000 0x0 0x1000>,
+			      <0x4a800000 0x0 0x400000>;
+			reg-names = "stm-base", "stm-stimulus-base";
+			clocks = <&scmi_clk CK_SCMI_BUS_STM>, <&scmi_clk CK_SCMI_KER_STM>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			out-ports {
+				port {
+					stm_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port2>;
+					};
+				};
+			};
+		};
+
+		cs_cti0: cti@4a080000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a080000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0 1>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <0 1>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etr>;
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-in-sigs = <2 3>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <2 3>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etf>;
+			};
+
+			trig-conns@2 {
+				reg = <2>;
+				arm,trig-out-sigs = <4 5>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_tpiu>;
+			};
+
+			trig-conns@3 {
+				reg = <3>;
+				arm,trig-in-sigs = <4 5 6 7>;
+				arm,trig-in-types = <STM_TOUT_SPTE
+						     STM_TOUT_SW
+						     STM_TOUT_HETE
+						     STM_ASYNCOUT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cti1: cti@4a090000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a090000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0>;
+				arm,trig-in-types = <GEN_IO>;
+				arm,trig-out-sigs = <0>;
+				arm,trig-out-types = <GEN_IO>;
+				arm,trig-conn-name = "dbtrgio";
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-out-sigs = <1 2>;
+				arm,trig-out-types = <STM_HWEVENT
+						      STM_HWEVENT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cpu_debug0: cpu-debug@4a210000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a210000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		cs_cti_cpu0: cti@4a220000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a220000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu0>;
+			arm,cs-dev-assoc = <&cs_etm0>;
+			status = "disabled";
+		};
+
+		cs_etm0: etm@4a240000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a240000 0x0 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu0>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm0_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port0>;
+					};
+				};
+			};
+		};
+	};
+
+	soc1: soc@1 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x80000000>;
+
+		dcmipp: dcmipp@48030000 {
+			compatible = "st,stm32mp25-dcmipp";
+			reg = <0x48030000 0x1000>;
+			interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc DCMIPP_R>;
+			clocks = <&rcc CK_BUS_DCMIPP>, <&rcc CK_KER_CSI>;
+			clock-names = "kclk", "mclk";
+			access-controllers = <&rifsc 87>;
+			status = "disabled";
+		};
+
+		eth1: eth1@482c0000 {
+			compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+			reg = <0x482c0000 0x4000>;
+			reg-names = "stmmaceth";
+			interrupts-extended = <&intc GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,
+					      <&exti1 68 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq",
+					  "eth_wake_irq";
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ptp_ref",
+				      "ethstp",
+				      "eth-ck";
+			clocks = <&rcc CK_ETH1_MAC>,
+				 <&rcc CK_ETH1_TX>,
+				 <&rcc CK_ETH1_RX>,
+				 <&rcc CK_KER_ETH1PTP>,
+				 <&rcc CK_ETH1_STP>,
+				 <&rcc CK_KER_ETH1>;
+			st,syscon = <&syscfg 0x3000 0xffffffff>;
+			snps,mixed-burst;
+			snps,pbl = <2>;
+			snps,txqos = <7>;
+			snps,rxqos = <7>;
+			snps,axi-config = <&stmmac_axi_config_1>;
+			snps,tso;
+			access-controllers = <&rifsc 60>;
+			power-domains = <&CLUSTER_PD>;
+			wakeup-source;
+			status = "disabled";
+			snps,mtl-rx-config = <&mtl_rx_setup_1>;
+			snps,mtl-tx-config = <&mtl_tx_setup_1>;
+
+			stmmac_axi_config_1: stmmac-axi-config {
+				snps,wr_osr_lmt = <0x7>;
+				snps,rd_osr_lmt = <0x7>;
+				snps,blen = <0 0 0 0 16 8 4>;
+			};
+
+			mtl_rx_setup_1: rx-queues-config {
+				snps,rx-queues-to-use = <2>;
+				queue0 {};
+				queue1 {};
+			};
+
+			mtl_tx_setup_1: tx-queues-config {
+				snps,tx-queues-to-use = <4>;
+				queue0 {};
+				queue1 {};
+				queue2 {};
+				queue3 {};
+			};
+		};
+
+		cs_etr: etr@4a030000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a030000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_BUS_ETR>, <&scmi_clk CK_SCMI_KER_ETR>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					etr_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port0>;
+					};
+				};
+			};
+		};
+	};
+
+	mlahb: ahb@2 {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0xfffffffc>;
+		dma-ranges = <0x0 0x0 0x0 0xfffffffc>;
+
+		m33_rproc: m33@0 {
+			compatible = "st,stm32mp2-m33";
+			reg = <0 0>;
+			resets = <&scmi_reset RST_SCMI_C2_R>,
+				 <&scmi_reset RST_SCMI_C2_HOLDBOOT_R>;
+			reset-names = "mcu_rst", "hold_boot";
+			st,syscfg-cm-state = <&pwr 0x204 0x0000000c>;
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			nvmem-cells = <&rsc_tbl_addr>, <&rsc_tbl_size>;
+			nvmem-cell-names = "rsc-tbl-addr", "rsc-tbl-size";
+
+			status = "disabled";
+		};
+	};
+
+};
diff --git a/arch/arm/dts/stm32mp213.dtsi b/arch/arm/dts/stm32mp213.dtsi
new file mode 100644
index 0000000000..fc9bd0c831
--- /dev/null
+++ b/arch/arm/dts/stm32mp213.dtsi
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp211.dtsi"
+
+/ {
+	soc@1 {
+		eth2: eth2@482d0000 {
+			compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+			reg = <0x482d0000 0x4000>;
+			reg-names = "stmmaceth";
+			interrupts-extended = <&intc GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
+					      <&exti1 70 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq",
+				  "eth_wake_irq";
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ptp_ref",
+				      "ethstp",
+				      "eth-ck";
+			clocks = <&rcc CK_ETH2_MAC>,
+				 <&rcc CK_ETH2_TX>,
+				 <&rcc CK_ETH2_RX>,
+				 <&rcc CK_KER_ETH2PTP>,
+				 <&rcc CK_ETH2_STP>,
+				 <&rcc CK_KER_ETH2>;
+			st,syscon = <&syscfg 0x3400 0xffffffff>;
+			snps,mixed-burst;
+			snps,pbl = <2>;
+			snps,txqos = <7>;
+			snps,rxqos = <7>;
+			snps,axi-config = <&stmmac_axi_config_2>;
+			snps,tso;
+			access-controllers = <&rifsc 61>;
+			power-domains = <&CLUSTER_PD>;
+			wakeup-source;
+			status = "disabled";
+			snps,mtl-rx-config = <&mtl_rx_setup_2>;
+			snps,mtl-tx-config = <&mtl_tx_setup_2>;
+
+			stmmac_axi_config_2: stmmac-axi-config {
+				snps,wr_osr_lmt = <0x7>;
+				snps,rd_osr_lmt = <0x7>;
+				snps,blen = <0 0 0 0 16 8 4>;
+			};
+
+			mtl_rx_setup_2: rx-queues-config {
+				snps,rx-queues-to-use = <2>;
+				queue0 {};
+				queue1 {};
+			};
+
+			mtl_tx_setup_2: tx-queues-config {
+				snps,tx-queues-to-use = <4>;
+				queue0 {};
+				queue1 {};
+				queue2 {};
+				queue3 {};
+			};
+		};
+	};
+};
+
+&rifsc {
+	m_can1: can@402d0000 {
+		compatible = "bosch,m_can";
+		reg = <0x402d0000 0x0 0x400>, <0x40310000 0x0 0x1400>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+		access-controllers = <&rifsc 56>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	m_can2: can@402e0000 {
+		compatible = "bosch,m_can";
+		reg = <0x402e0000 0x0 0x400>, <0x40310000 0x0 0x2800>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+		access-controllers = <&rifsc 56>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp215.dtsi b/arch/arm/dts/stm32mp215.dtsi
new file mode 100644
index 0000000000..8f25051bfe
--- /dev/null
+++ b/arch/arm/dts/stm32mp215.dtsi
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp213.dtsi"
+
+&soc1 {
+	ltdc: display-controller@48010000 {
+		compatible = "st,stm32mp21-ltdc";
+		reg = <0x48010000 0x400>;
+		st,syscon = <&syscfg>;
+		interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+		clock-names = "bus", "lcd";
+		resets = <&rcc LTDC_R>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+		access-controllers = <&rifsc 80>;
+		access-controller-names = "cmn";
+
+		l1l2 {
+			access-controllers = <&rifsc 119>;
+			access-controller-names = "l1l2";
+		};
+		l3 {
+			access-controllers = <&rifsc 120>;
+			access-controller-names = "l3";
+		};
+		rot {
+			access-controllers = <&rifsc 121>;
+			access-controller-names = "rot";
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp215f-dk-ca35tdcid-resmem.dtsi b/arch/arm/dts/stm32mp215f-dk-ca35tdcid-resmem.dtsi
new file mode 100644
index 0000000000..372ee9961b
--- /dev/null
+++ b/arch/arm/dts/stm32mp215f-dk-ca35tdcid-resmem.dtsi
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * stm32mp215f reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 10/2/2024 3:58:35 PM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a060000 {
+			reg = <0x0 0xa060000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a061000 {
+			reg = <0x0 0xa061000 0x0 0x8000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a05f000 {
+			reg = <0x0 0xa05f000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp215f-dk-u-boot.dtsi b/arch/arm/dts/stm32mp215f-dk-u-boot.dtsi
new file mode 100644
index 0000000000..830a7e7588
--- /dev/null
+++ b/arch/arm/dts/stm32mp215f-dk-u-boot.dtsi
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ */
+
+#include "stm32mp21-u-boot.dtsi"
+
+/ {
+	config {
+		u-boot,boot-led = "led-blue";
+		u-boot,mmc-env-partition = "u-boot-env";
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&usart2 {
+	bootph-all;
+};
+
+&usart2_pins_a {
+	bootph-all;
+	pins1 {
+		bootph-all;
+	};
+	pins2 {
+		bootph-all;
+	};
+};
diff --git a/arch/arm/dts/stm32mp215f-dk.dts b/arch/arm/dts/stm32mp215f-dk.dts
new file mode 100644
index 0000000000..98e548a035
--- /dev/null
+++ b/arch/arm/dts/stm32mp215f-dk.dts
@@ -0,0 +1,547 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/input/input.h>
+#include "stm32mp215.dtsi"
+#include "stm32mp21xf.dtsi"
+#include "stm32mp21-pinctrl.dtsi"
+#include "stm32mp21xxan-pinctrl.dtsi"
+#include "stm32mp215f-dk-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP215F-DK Discovery Board";
+	compatible = "st,stm32mp215f-dk", "st,stm32mp215";
+
+	aliases {
+		ethernet0 = &eth1;
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &uart4;
+		serial3 = &usart1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc CK_KER_LTDC>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint1>;
+			};
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpioc 4 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpiof 7 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioz 3 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>;
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiof 9 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	panel_rgb: panel-rgb {
+		compatible = "panel-dpi";
+		enable-gpios = <&gpiog 4 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_backlight>;
+		power-supply = <&scmi_v3v3>;
+		data-mapping = "bgr666";
+		status = "okay";
+
+		width-mm = <105>;
+		height-mm = <67>;
+
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&ltdc_out_rgb>;
+			};
+		};
+
+		panel-timing {
+			clock-frequency = <10000000>;
+			hactive = <480>;
+			vactive = <272>;
+			hsync-len = <52>;
+			hfront-porch = <10>;
+			hback-porch = <10>;
+			vsync-len = <10>;
+			vfront-porch = <10>;
+			vback-porch = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <1>;
+		};
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP21-DK";
+		dais = <&mdf1_port0 &mdf1_port1>;
+		status = "okay";
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&cs_cpu_debug0 {
+	status = "okay";
+};
+
+&cs_cti0 {
+	status = "okay";
+};
+
+&cs_cti1 {
+	status = "okay";
+};
+
+&cs_cti_cpu0 {
+	status = "okay";
+};
+
+&cs_etf {
+	status = "okay";
+};
+
+&cs_etm0 {
+	status = "okay";
+};
+
+&cs_etr {
+	status = "okay";
+};
+
+&cs_funnel {
+	status = "okay";
+};
+
+&cs_replicator {
+	status = "okay";
+};
+
+&cs_stm {
+	status = "okay";
+};
+
+&cs_tpiu {
+	status = "okay";
+};
+
+&csi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_vdda_1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&ddrperfm {
+	st,dram-type = <0>;
+	status = "okay";
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rmii_pins_a>;
+	pinctrl-1 = <&eth1_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	st,ext-phyclk;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios =  <&gpioh 11 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <1000>;
+			reset-deassert-us = <30000>;
+			reg = <0>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	status = "okay";
+
+	goodix: goodix-ts@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&goodix_pins_a>;
+		interrupt-parent = <&gpiof>;
+		interrupts = <4 IRQ_TYPE_EDGE_FALLING>;
+		AVDD28-supply = <&scmi_v3v3>;
+		VDDIO-supply = <&scmi_v3v3>;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <272>;
+		status = "okay" ;
+	};
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		reset-gpios = <&gpiod 5 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpiod 0 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+};
+
+&i3c1 {
+	pinctrl-names = "default", "init", "sleep";
+	pinctrl-0 = <&i3c1_pins_a>;
+	pinctrl-1 = <&i3c1_init_pins_a>;
+	pinctrl-2 = <&i3c1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&i3c2 {
+	pinctrl-names = "default", "init", "sleep";
+	pinctrl-0 = <&i3c2_pins_a>;
+	pinctrl-1 = <&i3c2_init_pins_a>;
+	pinctrl-2 = <&i3c2_sleep_pins_a>;
+	status = "disabled";
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	default-on;
+	status = "okay";
+
+	port {
+		ltdc_out_rgb: endpoint {
+			remote-endpoint = <&panel_in_rgb>;
+		};
+	};
+};
+
+&mdf1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdf_cck0_pins_a>;
+	pinctrl-1 = <&mdf_cck0_sleep_pins_a>;
+	#clock-cells = <1>;
+	clock-output-names = "cck0";
+	clock-frequency = <1536000>;
+	status = "okay";
+
+	sitf3: sitf@200 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&mdf_sdi3_pins_a>;
+		pinctrl-1 = <&mdf_sdi3_sleep_pins_a>;
+		st,sitf-mode = "spi";
+		clocks = <&mdf1 0>;
+		status = "okay";
+	};
+
+	filter0: filter@84  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf3 0>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm0: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter0 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+			mdf1_port0: port {
+				mdf_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	filter1: filter@104  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf3 1>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm1: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter1 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port1: port {
+				mdf_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&scmi_regu {
+	scmi_vddcore: regulator@5  {
+		reg = <VOLTD_SCMI_STPMIC_BUCK1>;
+		regulator-name = "vddcore";
+	};
+	scmi_vdd3v3_usb: regulator@15  {
+		reg = <VOLTD_SCMI_STPMIC_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_vdd_flash: regulator@16  {
+		reg = <VOLTD_SCMI_STPMIC_LDO5>;
+		regulator-name = "vdd_flash";
+	};
+	scmi_vdda_1v8: regulator@17  {
+		reg = <VOLTD_SCMI_STPMIC_LDO6>;
+		regulator-name = "vdda_1v8";
+	};
+	scmi_v3v3: regulator@21  {
+		reg = <VOLTD_SCMI_STPMIC_GPO1>;
+		regulator-name = "v3v3";
+	};
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x0>, <&ipcc1 0x1>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_flash>;
+	vqmmc-supply = <&scmi_vddio1>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_v3v3>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&uart4 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_idle_pins_a>;
+	pinctrl-2 = <&uart4_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+/* Bluetooth */
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbotg_hs {
+	role-switch-default-mode = "peripheral";
+	dr_mode = "peripheral";
+	usb-role-switch;
+	status = "okay";
+};
diff --git a/arch/arm/dts/stm32mp21xc.dtsi b/arch/arm/dts/stm32mp21xc.dtsi
new file mode 100644
index 0000000000..0471458af4
--- /dev/null
+++ b/arch/arm/dts/stm32mp21xc.dtsi
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x0 0x400>;
+		interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 98>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp21xf.dtsi b/arch/arm/dts/stm32mp21xf.dtsi
new file mode 100644
index 0000000000..0471458af4
--- /dev/null
+++ b/arch/arm/dts/stm32mp21xf.dtsi
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x0 0x400>;
+		interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 98>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp21xxal-pinctrl.dtsi b/arch/arm/dts/stm32mp21xxal-pinctrl.dtsi
new file mode 100644
index 0000000000..6a2bf584e7
--- /dev/null
+++ b/arch/arm/dts/stm32mp21xxal-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AL>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <13>;
+		gpio-ranges = <&pinctrl 1 17 3>, <&pinctrl 5 21 3>, <&pinctrl 9 25 7>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 80 14>, <&pinctrl 15 95 1>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 96 6>, <&pinctrl 7 103 9>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <9>;
+		gpio-ranges = <&pinctrl 4 116 2>, <&pinctrl 7 119 7>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <6>;
+		gpio-ranges = <&pinctrl 0 128 2>, <&pinctrl 4 132 3>, <&pinctrl 8 136 1>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <3>;
+		gpio-ranges = <&pinctrl_z 0 400 2>, <&pinctrl_z 3 403 1>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp21xxam-pinctrl.dtsi b/arch/arm/dts/stm32mp21xxam-pinctrl.dtsi
new file mode 100644
index 0000000000..e97c971b1e
--- /dev/null
+++ b/arch/arm/dts/stm32mp21xxam-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AM>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <13>;
+		gpio-ranges = <&pinctrl 1 17 3>, <&pinctrl 5 21 3>, <&pinctrl 9 25 7>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 80 14>, <&pinctrl 15 95 1>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 96 6>, <&pinctrl 7 103 9>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <9>;
+		gpio-ranges = <&pinctrl 4 116 2>, <&pinctrl 7 119 7>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <6>;
+		gpio-ranges = <&pinctrl 0 128 2>, <&pinctrl 4 132 3>, <&pinctrl 8 136 1>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <3>;
+		gpio-ranges = <&pinctrl_z 0 400 2>, <&pinctrl_z 3 403 1>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp21xxan-pinctrl.dtsi b/arch/arm/dts/stm32mp21xxan-pinctrl.dtsi
new file mode 100644
index 0000000000..d1f421073c
--- /dev/null
+++ b/arch/arm/dts/stm32mp21xxan-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AN>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <13>;
+		gpio-ranges = <&pinctrl 1 17 3>, <&pinctrl 5 21 3>, <&pinctrl 9 25 7>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 80 14>, <&pinctrl 15 95 1>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 96 6>, <&pinctrl 7 103 9>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <9>;
+		gpio-ranges = <&pinctrl 4 116 2>, <&pinctrl 7 119 7>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <6>;
+		gpio-ranges = <&pinctrl 0 128 2>, <&pinctrl 4 132 3>, <&pinctrl 8 136 1>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <3>;
+		gpio-ranges = <&pinctrl_z 0 400 2>, <&pinctrl_z 3 403 1>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp21xxao-pinctrl.dtsi b/arch/arm/dts/stm32mp21xxao-pinctrl.dtsi
new file mode 100644
index 0000000000..ec76fdb1f9
--- /dev/null
+++ b/arch/arm/dts/stm32mp21xxao-pinctrl.dtsi
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AO>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 0 12>, <&pinctrl 13 13 3>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <5>;
+		gpio-ranges = <&pinctrl 11 27 5>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 64 10>, <&pinctrl 11 75 3>, <&pinctrl 15 79 1>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <15>;
+		gpio-ranges = <&pinctrl 0 80 14>, <&pinctrl 15 95 1>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <9>;
+		gpio-ranges = <&pinctrl 0 96 6>, <&pinctrl 7 103 1>, <&pinctrl 11 107 2>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <7>;
+		gpio-ranges = <&pinctrl 4 116 2>, <&pinctrl 9 121 5>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <3>;
+		gpio-ranges = <&pinctrl 0 128 2>, <&pinctrl 4 132 1>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp23-u-boot.dtsi b/arch/arm/dts/stm32mp23-u-boot.dtsi
new file mode 100644
index 0000000000..0f9c405290
--- /dev/null
+++ b/arch/arm/dts/stm32mp23-u-boot.dtsi
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2024
+ */
+
+/ {
+	aliases {
+		gpio0 = &gpioa;
+		gpio1 = &gpiob;
+		gpio2 = &gpioc;
+		gpio3 = &gpiod;
+		gpio4 = &gpioe;
+		gpio5 = &gpiof;
+		gpio6 = &gpiog;
+		gpio7 = &gpioh;
+		gpio8 = &gpioi;
+		gpio9 = &gpioj;
+		gpio10 = &gpiok;
+		gpio25 = &gpioz;
+		pinctrl0 = &pinctrl;
+		pinctrl1 = &pinctrl_z;
+	};
+
+	clocks {
+		txbyteclk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+		};
+	};
+
+	firmware {
+		optee {
+			bootph-all;
+		};
+
+		scmi {
+			bootph-all;
+		};
+	};
+
+	/* need PSCI for sysreset during board_f */
+	psci {
+		bootph-all;
+	};
+
+	soc@0 {
+		bootph-all;
+	};
+};
+
+&bsec {
+	bootph-all;
+};
+
+&gpioa {
+	bootph-all;
+};
+
+&gpiob {
+	bootph-all;
+};
+
+&gpioc {
+	bootph-all;
+};
+
+&gpiod {
+	bootph-all;
+};
+
+&gpioe {
+	bootph-all;
+};
+
+&gpiof {
+	bootph-all;
+};
+
+&gpiog {
+	bootph-all;
+};
+
+&gpioh {
+	bootph-all;
+};
+
+&gpioi {
+	bootph-all;
+};
+
+&gpioj {
+	bootph-all;
+};
+
+&gpiok {
+	bootph-all;
+};
+
+&gpioz {
+	bootph-all;
+};
+
+/* pre-reloc probe = reserve video frame buffer in video_reserve() */
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+	clock-names = "bus", "lcd";
+	bootph-all;
+};
+
+&pinctrl {
+	bootph-all;
+};
+
+&rcc {
+	bootph-all;
+};
+
+&rifsc {
+	bootph-all;
+};
+
+&scmi_clk {
+	bootph-all;
+};
+
+&syscfg {
+	bootph-all;
+};
diff --git a/arch/arm/dts/stm32mp231.dtsi b/arch/arm/dts/stm32mp231.dtsi
new file mode 100644
index 0000000000..08b816a70e
--- /dev/null
+++ b/arch/arm/dts/stm32mp231.dtsi
@@ -0,0 +1,3022 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/arm/coresight-cti-dt.h>
+#include <dt-bindings/clock/st,stm32mp25-rcc.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include <dt-bindings/reset/st,stm32mp25-rcc.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD0>;
+			power-domain-names = "psci";
+			#cooling-cells = <2>;
+		};
+
+		idle-states {
+			entry-method = "psci";
+
+			CPU_PWRDN: cpu-power-down {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00000001>;
+				local-timer-stop;
+				entry-latency-us = <300>;
+				exit-latency-us = <500>;
+				min-residency-us = <1000>;
+			};
+		};
+
+		domain-idle-states {
+			STOP1: domain-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000011>;
+				entry-latency-us = <400>;
+				exit-latency-us = <1200>;
+				min-residency-us = <1500>;
+			};
+
+			LP_STOP1: domain-lp-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x0000021>;
+				entry-latency-us = <500>;
+				exit-latency-us = <2000>;
+				min-residency-us = <3000>;
+			};
+
+			LPLV_STOP1: domain-lplv-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000211>;
+				entry-latency-us = <500>;
+				exit-latency-us = <3000>;
+				min-residency-us = <4000>;
+			};
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a35-pmu";
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xbc000000>;
+		status = "disabled";
+	};
+
+	clocks {
+		clk_rcbsec: clk-rcbsec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+	};
+
+	cs_replicator: replicator {
+		compatible = "arm,coresight-static-replicator";
+		clocks = <&scmi_clk CK_SCMI_SYSATB>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				replicator_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				replicator_out_port0: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				replicator_out_port1: endpoint {
+					remote-endpoint = <&tpiu_in_port>;
+				};
+			};
+		};
+	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+
+			scmi_devpd: protocol@11 {
+				reg = <0x11>;
+				#power-domain-cells = <1>;
+			};
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_vddio1: regulator@0 {
+						reg = <VOLTD_SCMI_VDDIO1>;
+						regulator-name = "vddio1";
+					};
+					scmi_vddio2: regulator@1 {
+						reg = <VOLTD_SCMI_VDDIO2>;
+						regulator-name = "vddio2";
+					};
+					scmi_vddio3: regulator@2 {
+						reg = <VOLTD_SCMI_VDDIO3>;
+						regulator-name = "vddio3";
+					};
+					scmi_vddio4: regulator@3 {
+						reg = <VOLTD_SCMI_VDDIO4>;
+						regulator-name = "vddio4";
+					};
+					scmi_vdd33ucpd: regulator@5 {
+						reg = <VOLTD_SCMI_UCPD>;
+						regulator-name = "vdd33ucpd";
+					};
+					scmi_vdda18adc: regulator@7 {
+						reg = <VOLTD_SCMI_ADC>;
+						regulator-name = "vdda18adc";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		interrupt-parent = <&intc>;
+		reg = <0x0 0x4ac10000 0x0 0x1000>,
+		      <0x0 0x4ac20000 0x0 0x2000>,
+		      <0x0 0x4ac40000 0x0 0x2000>,
+		      <0x0 0x4ac60000 0x0 0x2000>;
+		interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		v2m0: v2m@48090000 {
+			compatible = "arm,gic-v2m-frame";
+			reg = <0x0 0x48090000 0x0 0x1000>;
+			msi-controller;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+
+		CPU_PD0: power-domain-cpu0 {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+
+		CLUSTER_PD: power-domain-cluster {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&STOP1>, <&LP_STOP1>;
+			power-domains = <&RET_PD>;
+		};
+
+		RET_PD: power-domain-retention {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&LPLV_STOP1>;
+		};
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 1>;
+
+			trips {
+				cpu_alert: cpu-alert {
+					temperature = <110000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+
+				cpu-crit {
+					temperature = <122000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 1 1>;
+				};
+			};
+		};
+
+		soc-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 0>;
+
+			trips {
+				soc-crit {
+					temperature = <122000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		arm,no-tick-in-suspend;
+	};
+
+	usb2_phy1: usb2-phy1 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2400>;
+		clocks          = <&rcc CK_KER_USB2PHY1>;
+		resets          = <&rcc USB2PHY1_R>;
+		status          = "disabled";
+	};
+
+	usb2_phy2: usb2-phy2 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2800>;
+		clocks          = <&rcc CK_KER_USB2PHY2EN>;
+		resets          = <&rcc USB2PHY2_R>;
+		status          = "disabled";
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x80000000>;
+
+		hpdma: dma-controller@40400000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40400000 0x1000>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA1>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma2: dma-controller@40410000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40410000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA2>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma3: dma-controller@40420000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40420000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA3>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		ipcc1: mailbox@40490000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x40490000 0x400>;
+			st,proc-id = <0>;
+			interrupts = <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi_clk CK_SCMI_IPCC1>;
+			status = "disabled";
+		};
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+			access-controllers = <&rifsc 111>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 2 0x62 0x00003121>,
+				       <&hpdma 2 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1000>;
+				clocks = <&scmi_clk CK_SCMI_OSPI1>;
+				resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+				access-controllers = <&rifsc 74>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 3 0x62 0x00003121>,
+				       <&hpdma 3 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1400>;
+				clocks = <&scmi_clk CK_SCMI_OSPI2>;
+				resets = <&scmi_reset RST_SCMI_OSPI2>, <&scmi_reset RST_SCMI_OSPI2DLL>;
+				access-controllers = <&rifsc 75>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		rifsc: bus@42080000 {
+			compatible = "st,stm32mp25-rifsc", "simple-bus";
+			reg = <0x42080000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			#access-controller-cells = <1>;
+			ranges;
+			st,mem-map = <0x200c0000 0x2000 0x200c2000 0x2000 0x200c4000 0x4000>;
+
+			timers2: timer@40000000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM2>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 1>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@1 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers3: timer@40010000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40010000 0x400>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM3>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 2>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@2 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers4: timer@40020000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40020000 0x400>;
+				interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM4>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 3>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@3 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers5: timer@40030000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40030000 0x400>;
+				interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM5>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 4>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@4 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers6: timer@40040000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40040000 0x400>;
+				interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM6>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 5>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@5 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
+			};
+
+			timers7: timer@40050000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40050000 0x400>;
+				interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM7>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 6>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
+			};
+
+			timers12: timer@40060000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40060000 0x400>;
+				interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM12>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 10>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@40070000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40070000 0x400>;
+				interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM13>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 11>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@40080000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40080000 0x400>;
+				interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM14>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 12>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			lptimer1: timer@40090000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x40090000 0x400>;
+				interrupts-extended = <&exti1 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM1>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 17>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@0 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@400a0000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x400a0000 0x400>;
+				interrupts-extended = <&exti1 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM2>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 18>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+			};
+
+			i2s2: audio-controller@400b0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400b0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI2>, <&rcc CK_KER_SPI2>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x43 0x12>,
+					<&hpdma 52 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 23>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi2: spi@400b0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400b0000 0x400>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI2>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x20 0x00003012>,
+				       <&hpdma 52 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 23>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2s3: audio-controller@400c0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400c0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI3>, <&rcc CK_KER_SPI3>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x43 0x12>,
+					<&hpdma 54 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 24>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi3: spi@400c0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400c0000 0x400>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI3>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x20 0x00003012>,
+				       <&hpdma 54 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 24>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spdifrx: audio-controller@400d0000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x400d0000 0x400>;
+				clocks = <&rcc CK_KER_SPDIFRX>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 71 0x43 0x212>,
+					<&hpdma 72 0x43 0x212>;
+				dma-names = "rx", "rx-ctrl";
+				access-controllers = <&rifsc 30>;
+				status = "disabled";
+			};
+
+			usart2: serial@400e0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400e0000 0x400>;
+				interrupts-extended = <&exti1 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART2>;
+				dmas = <&hpdma 11 0x20 0x10012>,
+				       <&hpdma 12 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 32>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			usart3: serial@400f0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400f0000 0x400>;
+				interrupts-extended = <&exti1 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART3>;
+				dmas = <&hpdma 13 0x20 0x10012>,
+				       <&hpdma 14 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 33>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart4: serial@40100000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40100000 0x400>;
+				interrupts-extended = <&exti1 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART4>;
+				dmas = <&hpdma 15 0x20 0x10012>,
+				       <&hpdma 16 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 34>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart5: serial@40110000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40110000 0x400>;
+				interrupts-extended = <&exti1 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART5>;
+				dmas = <&hpdma 17 0x20 0x10012>,
+				       <&hpdma 18 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 35>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40120000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40120000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C1>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 27 0x20 0x00003012>,
+				       <&hpdma 28 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 41>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40130000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40130000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C2>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 30 0x20 0x00003012>,
+				       <&hpdma 31 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 42>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c7: i2c@40180000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40180000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C7>;
+				resets = <&rcc I2C7_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 45 0x20 0x00003012>,
+				       <&hpdma 46 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 47>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c1: i3c@40190000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x40190000 0x400>;
+				interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C1>;
+				resets = <&rcc I3C1_R>;
+				access-controllers = <&rifsc 114>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c2: i3c@401a0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401a0000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C2>;
+				resets = <&rcc I3C2_R>;
+				access-controllers = <&rifsc 115>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers10: timer@401c0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401c0000 0x400>;
+				interrupts = <GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM10>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 8>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@9 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <9>;
+					status = "disabled";
+				};
+			};
+
+			timers11: timer@401d0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401d0000 0x400>;
+				interrupts = <GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM11>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 9>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@10 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <10>;
+					status = "disabled";
+				};
+			};
+
+			timers1: timer@40200000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40200000 0x400>;
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM1>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 0>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@0 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers8: timer@40210000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40210000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM8>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 7>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@7 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart6: serial@40220000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40220000 0x400>;
+				interrupts-extended = <&exti1 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART6>;
+				dmas = <&hpdma 19 0x20 0x10012>,
+				       <&hpdma 20 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 36>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2s1: audio-controller@40230000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x40230000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI1>, <&rcc CK_KER_SPI1>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x43 0x12>,
+					<&hpdma 50 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 22>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi1: spi@40230000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40230000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI1>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x20 0x00003012>,
+				       <&hpdma 50 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 22>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi4: spi@40240000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40240000 0x400>;
+				interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI4>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&hpdma 55 0x20 0x00003012>,
+				       <&hpdma 56 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 25>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers15: timer@40250000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40250000 0x400>;
+				interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM15>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 13>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@40260000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40260000 0x400>;
+				interrupts = <GIC_SPI 194 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM16>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 14>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@40270000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40270000 0x400>;
+				interrupts = <GIC_SPI 195 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM17>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 15>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			spi5: spi@40280000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40280000 0x400>;
+				interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI5>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&hpdma 57 0x20 0x00003012>,
+				       <&hpdma 58 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 26>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sai1: sai@40290000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40290000 0x4>, <0x4029a3f0 0x10>;
+				ranges = <0 0x40290000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI1>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				access-controllers = <&rifsc 49>;
+				status = "disabled";
+
+				sai1a: audio-controller@40290004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 73 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai1b: audio-controller@40290024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 74 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai2: sai@402a0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402a0000 0x4>, <0x402aa3f0 0x10>;
+				ranges = <0 0x402a0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI2>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				access-controllers = <&rifsc 50>;
+				status = "disabled";
+
+				sai2a: audio-controller@402a0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 75 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai2b: audio-controller@402a0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 76 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai3: sai@402b0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402b0000 0x4>, <0x402ba3f0 0x10>;
+				ranges = <0 0x402b0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI3>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				access-controllers = <&rifsc 51>;
+				status = "disabled";
+
+				sai3a: audio-controller@402b0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 77 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai3b: audio-controller@502b0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 78 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			usart1: serial@40330000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40330000 0x400>;
+				interrupts-extended = <&exti1 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART1>;
+				dmas = <&hpdma 9 0x20 0x10012>,
+				       <&hpdma 10 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 31>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			sai4: sai@40340000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40340000 0x4>, <0x4034a3f0 0x10>;
+				ranges = <0 0x40340000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI4>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				access-controllers = <&rifsc 52>;
+				status = "disabled";
+
+				sai4a: audio-controller@40340004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 79 0x63 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai4b: audio-controller@40340024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 80 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			uart7: serial@40370000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40370000 0x400>;
+				interrupts-extended = <&exti1 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART7>;
+				dmas = <&hpdma 21 0x20 0x10012>,
+				       <&hpdma 22 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 37>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@404a0000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x404a0000 0x400>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CCI_R>;
+				clocks = <&rcc CK_BUS_CCI>;
+				clock-names = "mclk";
+				dmas = <&hpdma 137 0x60 0x00003012>;
+				dma-names = "tx";
+				access-controllers = <&rifsc 88>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			crc: crc@404c0000 {
+				compatible = "st,stm32f7-crc";
+				reg = <0x404c0000 0x400>;
+				clocks = <&rcc CK_BUS_CRC>;
+				access-controllers = <&rifsc 109>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			adc_12: adc@404e0000 {
+				compatible = "st,stm32mp23-adc-core";
+				reg = <0x404e0000 0x400>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC12>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 58>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp23-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <0>;
+					dmas = <&hpdma 81 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					st,adc-trigger-sel = <0>;
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+				};
+
+				adc2: adc@100 {
+					compatible = "st,stm32mp23-adc";
+					reg = <0x100>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <1>;
+					dmas = <&hpdma 82 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					st,adc-trigger-sel = <0>;
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			mdf1: mdf@404d0000 {
+				compatible = "st,stm32mp25-mdf";
+				ranges = <0 0x404d0000 0x1000>;
+				reg = <0x404d0000 0x8>, <0x404d0ff0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_KER_MDF1>;
+				clock-names = "ker_ck";
+				clock-ranges;
+				resets = <&rcc MDF1_R>;
+				reset-names = "mdf";
+				access-controllers = <&rifsc 54>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+
+				sitf0: sitf@80 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x80 0x4>;
+					status = "disabled";
+				};
+
+				sitf1: sitf@100 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x100 0x4>;
+					status = "disabled";
+				};
+
+				sitf2: sitf@180 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x180 0x4>;
+					status = "disabled";
+				};
+
+				sitf3: sitf@200 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x200 0x4>;
+					status = "disabled";
+				};
+
+				filter0: filter@84 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x84 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 63 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter1: filter@104 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x104 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 64 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter2: filter@184 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x184 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 65 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter3: filter@204 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x204 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 66 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+			};
+
+			adc_3: adc@404f0000 {
+				compatible = "st,stm32mp23-adc-core";
+				reg = <0x404f0000 0x400>;
+				interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC3>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 59>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc3: adc@0 {
+					compatible = "st,stm32mp23-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_3>;
+					interrupts = <0>;
+					dmas = <&hpdma 83 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					st,adc-trigger-sel = <1>;
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			hash: hash@42010000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x42010000 0x400>;
+				interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_HASH>;
+				resets = <&rcc HASH_R>;
+				dmas = <&hpdma 6 0x40 0x3021>;
+				dma-names = "in";
+				access-controllers = <&rifsc 95>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			rng: rng@42020000 {
+				compatible = "st,stm32mp25-rng";
+				reg = <0x42020000 0x400>;
+				clocks = <&clk_rcbsec>, <&rcc CK_BUS_RNG>;
+				clock-names = "rng_clk", "rng_hclk";
+				resets = <&rcc RNG_R>;
+				access-controllers = <&rifsc 92>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			iwdg1: watchdog@44010000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44010000 0x400>;
+				interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG1>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				access-controllers = <&rifsc 98>;
+				status = "disabled";
+			};
+
+			iwdg2: watchdog@44020000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44020000 0x400>;
+				interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				access-controllers = <&rifsc 99>;
+				status = "disabled";
+			};
+
+			spi8: spi@46020000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x46020000 0x400>;
+				interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI8>;
+				resets = <&rcc SPI8_R>;
+				dmas = <&hpdma 171 0x20 0x00003012>,
+				       <&hpdma 172 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 29>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lpuart1: serial@46030000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x46030000 0x400>;
+				interrupts-extended = <&exti2 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPUART1>;
+				dmas = <&hpdma 166 0x20 0x10012>,
+				       <&hpdma 167 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 40>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2c8: i2c@46040000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x46040000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C8>;
+				resets = <&rcc I2C8_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 168 0x20 0x00003012>,
+				       <&hpdma 169 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 48>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lptimer3: timer@46050000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46050000 0x400>;
+				interrupts-extended = <&exti2 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM3>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 19>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			lptimer4: timer@46060000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46060000 0x400>;
+				interrupts-extended = <&exti2 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM4>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 20>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@3 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+			};
+
+			lptimer5: timer@46070000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46070000 0x400>;
+				interrupts-extended = <&exti2 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM5>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 21>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@4 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+			};
+
+			i3c4: i3c@46080000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x46080000 0x400>;
+				interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C4>;
+				resets = <&rcc I3C4_R>;
+				access-controllers = <&rifsc 117>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ltdc: display-controller@48010000 {
+				compatible = "st,stm32mp25-ltdc";
+				reg = <0x48010000 0x400>;
+				st,syscon = <&syscfg>;
+				interrupts = <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+				clock-names = "bus", "lcd";
+				resets = <&rcc LTDC_R>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+				access-controllers = <&rifsc 80>;
+				access-controller-names = "cmn";
+
+				l1l2 {
+					access-controllers = <&rifsc 119>;
+					access-controller-names = "l1l2";
+				};
+				l3 {
+					access-controllers = <&rifsc 120>;
+					access-controller-names = "l3";
+				};
+				rot {
+					access-controllers = <&rifsc 121>;
+					access-controller-names = "rot";
+				};
+			};
+
+			csi: csi@48020000 {
+				compatible = "st,stm32mp25-csi";
+				reg = <0x48020000 0x2000>;
+				interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CSI_R>;
+				clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>,
+					 <&rcc CK_KER_CSIPHY>;
+				clock-names = "pclk", "txesc", "csi2phy";
+				access-controllers = <&rifsc 86>;
+				status = "disabled";
+			};
+
+			dcmipp: dcmipp@48030000 {
+				compatible = "st,stm32mp25-dcmipp";
+				reg = <0x48030000 0x1000>;
+				interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPP_R>;
+				clocks = <&rcc CK_BUS_DCMIPP>, <&rcc CK_KER_CSI>;
+				clock-names = "kclk", "mclk";
+				access-controllers = <&rifsc 87>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@48220000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48220000 0x400>, <0x44230400 0x8>;
+				interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC1>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 76>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@48230000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48230000 0x400>, <0x44230800 0x8>;
+				interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC2>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 77>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc3: mmc@48240000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48240000 0x400>, <0x44230c00 0x8>;
+				interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC3>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 78>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			eth1: eth1@482c0000 {
+				compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+				reg = <0x482c0000 0x4000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti1 68 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ptp_ref",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc CK_ETH1_MAC>,
+					 <&rcc CK_ETH1_TX>,
+					 <&rcc CK_ETH1_RX>,
+					 <&rcc CK_KER_ETH1PTP>,
+					 <&rcc CK_ETH1_STP>,
+					 <&rcc CK_KER_ETH1>;
+				st,syscon = <&syscfg 0x3000 0xffffffff>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,txqos = <7>;
+				snps,rxqos = <7>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				access-controllers = <&rifsc 60>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+				snps,mtl-rx-config = <&mtl_rx_setup_1>;
+				snps,mtl-tx-config = <&mtl_tx_setup_1>;
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+
+				mtl_rx_setup_1: rx-queues-config {
+					snps,rx-queues-to-use = <2>;
+					queue0 {};
+					queue1 {};
+				};
+
+				mtl_tx_setup_1: tx-queues-config {
+					snps,tx-queues-to-use = <4>;
+					queue0 {};
+					queue1 {};
+					queue2 {};
+					queue3 {};
+				};
+			};
+
+			usbh: usb@482e0000 {
+				compatible = "st,stm32mp25-usbh";
+				st,syscfg = <&syscfg 0x2420>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x482e0000 0x482e0000 0x20000>;
+				access-controllers = <&rifsc 63>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 43 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				usbh_ohci: usb@482e0000 {
+					compatible = "generic-ohci";
+					reg = <0x482e0000 0x1000>;
+					clocks = <&usb2_phy1>, <&rcc CK_BUS_USB2OHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+
+				usbh_ehci: usb@482f0000 {
+					compatible = "generic-ehci";
+					reg = <0x482f0000 0x1000>;
+					clocks = <&rcc CK_BUS_USB2EHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+					companion = <&usbh_ohci>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+			};
+
+			usb3dr: usb@48300000 {
+				compatible = "st,stm32mp25-dwc3";
+				st,syscfg = <&syscfg 0x4800>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x48300000 0x48300000 0x100000>;
+				access-controllers = <&rifsc 66>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 44 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				dwc3: usb@48300000 {
+					compatible = "snps,dwc3";
+					reg = <0x48300000 0x100000>;
+					interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+					clock-names = "ref", "bus_early", "suspend";
+					clocks = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DR>,
+						 <&rcc CK_KER_USB2PHY2>;
+					resets = <&rcc USB3DR_R>;
+					phys = <&usb2_phy2>;
+					phy-names = "usb2-phy";
+					wakeup-source;
+				};
+			};
+		};
+
+		risaf1: risaf@420a0000 {
+			compatible = "st,stm32mp25-risaf";
+			reg = <0x420a0000 0x1000>;
+			clocks = <&rcc CK_BUS_BKPSRAM>;
+			st,mem-map = <0x0 0x42000000 0x0 0x2000>;
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32mp25-risaf-enc";
+			reg = <0x420d0000 0x1000>;
+			clocks = <&rcc CK_BUS_RISAF4>;
+			st,mem-map = <0x0 0x80000000 0x1 0x00000000>;
+		};
+
+		risab1: risab@420f0000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x420f0000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa000000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab2: risab@42100000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42100000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa020000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab3: risab@42110000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42110000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa040000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab4: risab@42120000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42120000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa060000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab5: risab@42130000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42130000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa080000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab6: risab@42140000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42140000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa0a0000 0x20000>;
+			#access-controller-cells = <1>;
+			status = "disabled";
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+
+			vrefint: vrefin-cal@1b8 {
+				reg = <0x1b8 0x2>;
+			};
+
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		dts: thermal-sensor@44070000 {
+			compatible = "moortec,mr75203";
+			reg = <0x44070000 0x80>,
+			      <0x44070080 0x180>,
+			      <0x44070200 0x200>,
+			      <0x44070400 0xc00>;
+			reg-names = "common", "ts", "pd", "vm";
+			clocks = <&rcc CK_KER_DTS>;
+			resets = <&rcc DTS_R>;
+			#thermal-sensor-cells = <1>;
+		};
+
+		hdp: pinctrl@44090000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x44090000 0x400>;
+			clocks = <&rcc CK_BUS_HDP>;
+			status = "disabled";
+		};
+
+		rcc: clock-controller@44200000 {
+			compatible = "st,stm32mp25-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#access-controller-cells = <1>;
+			clocks =
+				<&scmi_clk CK_SCMI_HSE>,
+				<&scmi_clk CK_SCMI_HSI>,
+				<&scmi_clk CK_SCMI_MSI>,
+				<&scmi_clk CK_SCMI_LSE>,
+				<&scmi_clk CK_SCMI_LSI>,
+				<&scmi_clk CK_SCMI_HSE_DIV2>,
+				<&scmi_clk CK_SCMI_ICN_HS_MCU>,
+				<&scmi_clk CK_SCMI_ICN_LS_MCU>,
+				<&scmi_clk CK_SCMI_ICN_SDMMC>,
+				<&scmi_clk CK_SCMI_ICN_DDR>,
+				<&scmi_clk CK_SCMI_ICN_DISPLAY>,
+				<&scmi_clk CK_SCMI_ICN_HSL>,
+				<&scmi_clk CK_SCMI_ICN_NIC>,
+				<&scmi_clk CK_SCMI_ICN_VID>,
+				<&scmi_clk CK_SCMI_FLEXGEN_07>,
+				<&scmi_clk CK_SCMI_FLEXGEN_08>,
+				<&scmi_clk CK_SCMI_FLEXGEN_09>,
+				<&scmi_clk CK_SCMI_FLEXGEN_10>,
+				<&scmi_clk CK_SCMI_FLEXGEN_11>,
+				<&scmi_clk CK_SCMI_FLEXGEN_12>,
+				<&scmi_clk CK_SCMI_FLEXGEN_13>,
+				<&scmi_clk CK_SCMI_FLEXGEN_14>,
+				<&scmi_clk CK_SCMI_FLEXGEN_15>,
+				<&scmi_clk CK_SCMI_FLEXGEN_16>,
+				<&scmi_clk CK_SCMI_FLEXGEN_17>,
+				<&scmi_clk CK_SCMI_FLEXGEN_18>,
+				<&scmi_clk CK_SCMI_FLEXGEN_19>,
+				<&scmi_clk CK_SCMI_FLEXGEN_20>,
+				<&scmi_clk CK_SCMI_FLEXGEN_21>,
+				<&scmi_clk CK_SCMI_FLEXGEN_22>,
+				<&scmi_clk CK_SCMI_FLEXGEN_23>,
+				<&scmi_clk CK_SCMI_FLEXGEN_24>,
+				<&scmi_clk CK_SCMI_FLEXGEN_25>,
+				<&scmi_clk CK_SCMI_FLEXGEN_26>,
+				<&scmi_clk CK_SCMI_FLEXGEN_27>,
+				<&scmi_clk CK_SCMI_FLEXGEN_28>,
+				<&scmi_clk CK_SCMI_FLEXGEN_29>,
+				<&scmi_clk CK_SCMI_FLEXGEN_30>,
+				<&scmi_clk CK_SCMI_FLEXGEN_31>,
+				<&scmi_clk CK_SCMI_FLEXGEN_32>,
+				<&scmi_clk CK_SCMI_FLEXGEN_33>,
+				<&scmi_clk CK_SCMI_FLEXGEN_34>,
+				<&scmi_clk CK_SCMI_FLEXGEN_35>,
+				<&scmi_clk CK_SCMI_FLEXGEN_36>,
+				<&scmi_clk CK_SCMI_FLEXGEN_37>,
+				<&scmi_clk CK_SCMI_FLEXGEN_38>,
+				<&scmi_clk CK_SCMI_FLEXGEN_39>,
+				<&scmi_clk CK_SCMI_FLEXGEN_40>,
+				<&scmi_clk CK_SCMI_FLEXGEN_41>,
+				<&scmi_clk CK_SCMI_FLEXGEN_42>,
+				<&scmi_clk CK_SCMI_FLEXGEN_43>,
+				<&scmi_clk CK_SCMI_FLEXGEN_44>,
+				<&scmi_clk CK_SCMI_FLEXGEN_45>,
+				<&scmi_clk CK_SCMI_FLEXGEN_46>,
+				<&scmi_clk CK_SCMI_FLEXGEN_47>,
+				<&scmi_clk CK_SCMI_FLEXGEN_48>,
+				<&scmi_clk CK_SCMI_FLEXGEN_49>,
+				<&scmi_clk CK_SCMI_FLEXGEN_50>,
+				<&scmi_clk CK_SCMI_FLEXGEN_51>,
+				<&scmi_clk CK_SCMI_FLEXGEN_52>,
+				<&scmi_clk CK_SCMI_FLEXGEN_53>,
+				<&scmi_clk CK_SCMI_FLEXGEN_54>,
+				<&scmi_clk CK_SCMI_FLEXGEN_55>,
+				<&scmi_clk CK_SCMI_FLEXGEN_56>,
+				<&scmi_clk CK_SCMI_FLEXGEN_57>,
+				<&scmi_clk CK_SCMI_FLEXGEN_58>,
+				<&scmi_clk CK_SCMI_FLEXGEN_59>,
+				<&scmi_clk CK_SCMI_FLEXGEN_60>,
+				<&scmi_clk CK_SCMI_FLEXGEN_61>,
+				<&scmi_clk CK_SCMI_FLEXGEN_62>,
+				<&scmi_clk CK_SCMI_FLEXGEN_63>,
+				<&scmi_clk CK_SCMI_ICN_APB1>,
+				<&scmi_clk CK_SCMI_ICN_APB2>,
+				<&scmi_clk CK_SCMI_ICN_APB3>,
+				<&scmi_clk CK_SCMI_ICN_APB4>,
+				<&scmi_clk CK_SCMI_ICN_APBDBG>,
+				<&scmi_clk CK_SCMI_TIMG1>,
+				<&scmi_clk CK_SCMI_TIMG2>,
+				<&scmi_clk CK_SCMI_PLL3>,
+				<0>,
+				<&scmi_clk CK_SCMI_HSI_KER_CK>,
+				<&scmi_clk CK_SCMI_HSE_KER_CK>,
+				<&scmi_clk CK_SCMI_MSI_KER_CK>;
+			access-controllers = <&rifsc 156>;
+		};
+
+		pwr: syscon@44210000 {
+			compatible = "st,stm32mp25-pwr", "syscon";
+			reg = <0x44210000 0x0400>;
+		};
+
+		exti1: interrupt-controller@44220000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			power-domains = <&RET_PD>;
+			reg = <0x44220000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 0   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<&intc GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 209 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<&intc GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_80 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+			#clock-cells = <1>;
+		};
+
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			interrupt-parent = <&exti1>;
+			interrupts-extended =
+				<&exti1  0 0>, <&exti1  1 0>, <&exti1  2 0>, <&exti1  3 0>,
+				<&exti1  4 0>, <&exti1  5 0>, <&exti1  6 0>, <&exti1  7 0>,
+				<&exti1  8 0>, <&exti1  9 0>, <&exti1 10 0>, <&exti1 11 0>,
+				<&exti1 12 0>, <&exti1 13 0>, <&exti1 14 0>, <&exti1 15 0>,
+				<&exti2  0 0>, <&exti2  1 0>, <&exti2  2 0>, <&exti2  3 0>,
+				<&exti2  4 0>, <&exti2  5 0>, <&exti2  6 0>, <&exti2  7 0>,
+				<&exti2  8 0>, <&exti2  9 0>, <&exti2 10 0>, <&exti2 11 0>,
+				<&exti2 12 0>, <&exti2 13 0>, <&exti2 14 0>, <&exti2 15 0>;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		rtc: rtc@46000000 {
+			compatible = "st,stm32mp25-rtc";
+			reg = <0x46000000 0x400>;
+			clocks = <&scmi_clk CK_SCMI_RTC>,
+				 <&scmi_clk CK_SCMI_RTCCK>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti2 17 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x46010000 0x400>;
+			ranges;
+
+			nvram: nvram@46010100 {
+				compatible = "st,stm32mp25-tamp-nvram";
+				reg = <0x46010100 0x200>;
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+					boot_mode: tamp-bkp@180 {
+						reg = <0x180 0x4>;
+					};
+					rsc_tbl_addr: tamp-bkp@184 {
+						reg = <0x184 0x4>;
+					};
+					rsc_tbl_size: tamp-bkp@188 {
+						reg = <0x188 0x4>;
+					};
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			interrupt-parent = <&exti1>;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+		};
+
+		exti2: interrupt-controller@46230000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x46230000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 17  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 18  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 19  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 20  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 21  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 22  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 25  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 26  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 27  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 28  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 29  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 30  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 12  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 13  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 14  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 15  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 11  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 5   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 4   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 2   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
+		};
+
+		ddrperfm: perf@48041000 {
+			compatible = "st,stm32mp25-ddr-pmu";
+			reg = <0x48041000 0x400>;
+			access-controllers = <&rcc 104>;
+			status = "disabled";
+		};
+
+		fmc: memory-controller@48200000 {
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+			#address-cells = <2>;
+			#size-cells = <1>;
+			clocks = <&scmi_clk CK_SCMI_FMC>;
+			resets = <&scmi_reset RST_SCMI_FMC>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+
+			nand-controller@4,0 {
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 0 0x62 0x00003101>,
+				       <&hpdma 0 0x62 0x00003110>,
+				       <&hpdma 1 0x22 0x00003113>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		a35ss_syscfg: syscon@48802000  {
+			compatible = "st,stm32mp25-a35ss-syscfg", "syscon";
+			reg = <0x48802000 0xac>;
+			status = "disabled";
+		};
+
+		cs_funnel: funnel@4a020000 {
+			compatible = "arm,coresight-dynamic-funnel", "arm,primecell";
+			reg = <0x4a020000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					funnel_in_port0: endpoint {
+						remote-endpoint = <&etm0_out_port>;
+					};
+				};
+
+				port@2 {
+					reg = <2>;
+					funnel_in_port2: endpoint {
+						remote-endpoint = <&stm_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					funnel_out_port: endpoint {
+						remote-endpoint = <&etf_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etf: etf@4a030000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a030000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					etf_in_port: endpoint {
+						remote-endpoint = <&funnel_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					etf_out_port: endpoint {
+						remote-endpoint = <&replicator_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etr: etr@4a040000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a040000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_BUS_ETR>, <&scmi_clk CK_SCMI_KER_ETR>;
+			clock-names = "apb_pclk", "atclk";
+			arm,max-burst-size = <3>;
+			arm,scatter-gather;
+			status = "disabled";
+
+			in-ports {
+				port {
+					etr_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port0>;
+					};
+				};
+			};
+		};
+
+		cs_tpiu: tpiu@4a050000 {
+			compatible = "arm,coresight-tpiu", "arm,primecell";
+			reg = <0x4a050000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_TPIU>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					tpiu_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port1>;
+					};
+				};
+			};
+		};
+
+		cs_stm: stm@4a080000 {
+			compatible = "arm,coresight-stm", "arm,primecell";
+			reg = <0x4a080000 0x1000>,
+			      <0x4a800000 0x400000>;
+			reg-names = "stm-base", "stm-stimulus-base";
+			clocks = <&scmi_clk CK_SCMI_BUS_STM>, <&scmi_clk CK_SCMI_KER_STM>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			out-ports {
+				port {
+					stm_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port2>;
+					};
+				};
+			};
+		};
+
+		cs_cti0: cti@4a090000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a090000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0 1>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <0 1>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etr>;
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-in-sigs = <2 3>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <2 3>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etf>;
+			};
+
+			trig-conns@2 {
+				reg = <2>;
+				arm,trig-out-sigs = <4 5>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_tpiu>;
+			};
+
+			trig-conns@3 {
+				reg = <3>;
+				arm,trig-in-sigs = <4 5 6 7>;
+				arm,trig-in-types = <STM_TOUT_SPTE
+						     STM_TOUT_SW
+						     STM_TOUT_HETE
+						     STM_ASYNCOUT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cti1: cti@4a0a0000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a0a0000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0>;
+				arm,trig-in-types = <GEN_IO>;
+				arm,trig-out-sigs = <0>;
+				arm,trig-out-types = <GEN_IO>;
+				arm,trig-conn-name = "dbtrgio";
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-out-sigs = <1 2>;
+				arm,trig-out-types = <STM_HWEVENT
+						      STM_HWEVENT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cpu_debug0: cpu-debug@4a210000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a210000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		cs_cti_cpu0: cti@4a220000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a220000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu0>;
+			arm,cs-dev-assoc = <&cs_etm0>;
+			status = "disabled";
+		};
+
+		cs_etm0: etm@4a240000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a240000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu0>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm0_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port0>;
+					};
+				};
+			};
+		};
+	};
+
+	mlahb: ahb@1 {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0xfffffffc>;
+		dma-ranges = <0x0 0x0 0x0 0xfffffffc>;
+
+		m33_rproc: m33@0 {
+			compatible = "st,stm32mp2-m33";
+			reg = <0 0>;
+			resets = <&scmi_reset RST_SCMI_C2_R>,
+				 <&scmi_reset RST_SCMI_C2_HOLDBOOT_R>;
+			reset-names = "mcu_rst", "hold_boot";
+			st,syscfg-cm-state = <&pwr 0x204 0x0000000c>;
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			nvmem-cells = <&rsc_tbl_addr>, <&rsc_tbl_size>;
+			nvmem-cell-names = "rsc-tbl-addr", "rsc-tbl-size";
+
+			status = "disabled";
+		};
+	};
+
+};
diff --git a/arch/arm/dts/stm32mp233.dtsi b/arch/arm/dts/stm32mp233.dtsi
new file mode 100644
index 0000000000..952cda24cf
--- /dev/null
+++ b/arch/arm/dts/stm32mp233.dtsi
@@ -0,0 +1,172 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp231.dtsi"
+
+/ {
+	cpus {
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD1>;
+			power-domain-names = "psci";
+		};
+	};
+
+	arm-pmu {
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>;
+	};
+
+	psci {
+		CPU_PD1: power-domain-cpu1 {
+			#power-domain-cells = <0>;
+			domain-idle-states =  <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+	};
+
+	timer {
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	soc@0 {
+		cs_cpu_debug1: cpu-debug@4a310000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a310000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+		};
+
+		cs_cti_cpu1: cti@4a320000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a320000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			arm,cs-dev-assoc = <&cs_etm1>;
+			status = "disabled";
+		};
+
+		cs_etm1: etm@4a340000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a340000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm1_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port1>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&cs_funnel {
+	in-ports {
+		port@1 {
+			reg = <1>;
+			funnel_in_port1: endpoint {
+				remote-endpoint = <&etm1_out_port>;
+			};
+		};
+	};
+};
+
+&intc {
+	interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+};
+
+&optee {
+	interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+};
+
+&rifsc {
+	m_can1: can@402d0000 {
+		compatible = "bosch,m_can";
+		reg = <0x402d0000 0x400>, <0x40310000 0x1400>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+		access-controllers = <&rifsc 56>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	eth2: eth2@482d0000 {
+		compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+		reg = <0x482d0000 0x4000>;
+		reg-names = "stmmaceth";
+		interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+				      <&exti1 70 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq",
+				  "eth_wake_irq";
+		clock-names = "stmmaceth",
+			      "mac-clk-tx",
+			      "mac-clk-rx",
+			      "ptp_ref",
+			      "ethstp",
+			      "eth-ck";
+		clocks = <&rcc CK_ETH2_MAC>,
+			 <&rcc CK_ETH2_TX>,
+			 <&rcc CK_ETH2_RX>,
+			 <&rcc CK_KER_ETH2PTP>,
+			 <&rcc CK_ETH2_STP>,
+			 <&rcc CK_KER_ETH2>;
+		st,syscon = <&syscfg 0x3400 0xffffffff>;
+		snps,mixed-burst;
+		snps,pbl = <2>;
+		snps,txqos = <7>;
+		snps,rxqos = <7>;
+		snps,axi-config = <&stmmac_axi_config_2>;
+		snps,tso;
+		access-controllers = <&rifsc 61>;
+		power-domains = <&CLUSTER_PD>;
+		wakeup-source;
+		status = "disabled";
+		snps,mtl-rx-config = <&mtl_rx_setup_2>;
+		snps,mtl-tx-config = <&mtl_tx_setup_2>;
+
+		stmmac_axi_config_2: stmmac-axi-config {
+			snps,wr_osr_lmt = <0x7>;
+			snps,rd_osr_lmt = <0x7>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		mtl_rx_setup_2: rx-queues-config {
+			snps,rx-queues-to-use = <2>;
+			queue0 {};
+			queue1 {};
+		};
+
+		mtl_tx_setup_2: tx-queues-config {
+			snps,tx-queues-to-use = <4>;
+			queue0 {};
+			queue1 {};
+			queue2 {};
+			queue3 {};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp235.dtsi b/arch/arm/dts/stm32mp235.dtsi
new file mode 100644
index 0000000000..06226a51f3
--- /dev/null
+++ b/arch/arm/dts/stm32mp235.dtsi
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/power/st,stm32mp25-power.h>
+#include "stm32mp233.dtsi"
+
+/ {
+	thermal-zones {
+		cpu-thermal {
+			trips {
+				gpu_alert: gpu-alert {
+					temperature = <110000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+			};
+
+			cooling-maps {
+				map1 {
+					trip = <&gpu_alert>;
+					cooling-device = <&gpu 1 6>;
+				};
+			};
+		};
+	};
+};
+
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>, <&syscfg 0>, <&lvds 0>;
+	clock-names = "bus", "ref", "lcd", "lvds";
+};
+
+&rcc {
+	clocks =
+		<&scmi_clk CK_SCMI_HSE>,
+		<&scmi_clk CK_SCMI_HSI>,
+		<&scmi_clk CK_SCMI_MSI>,
+		<&scmi_clk CK_SCMI_LSE>,
+		<&scmi_clk CK_SCMI_LSI>,
+		<&scmi_clk CK_SCMI_HSE_DIV2>,
+		<&scmi_clk CK_SCMI_ICN_HS_MCU>,
+		<&scmi_clk CK_SCMI_ICN_LS_MCU>,
+		<&scmi_clk CK_SCMI_ICN_SDMMC>,
+		<&scmi_clk CK_SCMI_ICN_DDR>,
+		<&scmi_clk CK_SCMI_ICN_DISPLAY>,
+		<&scmi_clk CK_SCMI_ICN_HSL>,
+		<&scmi_clk CK_SCMI_ICN_NIC>,
+		<&scmi_clk CK_SCMI_ICN_VID>,
+		<&scmi_clk CK_SCMI_FLEXGEN_07>,
+		<&scmi_clk CK_SCMI_FLEXGEN_08>,
+		<&scmi_clk CK_SCMI_FLEXGEN_09>,
+		<&scmi_clk CK_SCMI_FLEXGEN_10>,
+		<&scmi_clk CK_SCMI_FLEXGEN_11>,
+		<&scmi_clk CK_SCMI_FLEXGEN_12>,
+		<&scmi_clk CK_SCMI_FLEXGEN_13>,
+		<&scmi_clk CK_SCMI_FLEXGEN_14>,
+		<&scmi_clk CK_SCMI_FLEXGEN_15>,
+		<&scmi_clk CK_SCMI_FLEXGEN_16>,
+		<&scmi_clk CK_SCMI_FLEXGEN_17>,
+		<&scmi_clk CK_SCMI_FLEXGEN_18>,
+		<&scmi_clk CK_SCMI_FLEXGEN_19>,
+		<&scmi_clk CK_SCMI_FLEXGEN_20>,
+		<&scmi_clk CK_SCMI_FLEXGEN_21>,
+		<&scmi_clk CK_SCMI_FLEXGEN_22>,
+		<&scmi_clk CK_SCMI_FLEXGEN_23>,
+		<&scmi_clk CK_SCMI_FLEXGEN_24>,
+		<&scmi_clk CK_SCMI_FLEXGEN_25>,
+		<&scmi_clk CK_SCMI_FLEXGEN_26>,
+		<&scmi_clk CK_SCMI_FLEXGEN_27>,
+		<&scmi_clk CK_SCMI_FLEXGEN_28>,
+		<&scmi_clk CK_SCMI_FLEXGEN_29>,
+		<&scmi_clk CK_SCMI_FLEXGEN_30>,
+		<&scmi_clk CK_SCMI_FLEXGEN_31>,
+		<&scmi_clk CK_SCMI_FLEXGEN_32>,
+		<&scmi_clk CK_SCMI_FLEXGEN_33>,
+		<&scmi_clk CK_SCMI_FLEXGEN_34>,
+		<&scmi_clk CK_SCMI_FLEXGEN_35>,
+		<&scmi_clk CK_SCMI_FLEXGEN_36>,
+		<&scmi_clk CK_SCMI_FLEXGEN_37>,
+		<&scmi_clk CK_SCMI_FLEXGEN_38>,
+		<&scmi_clk CK_SCMI_FLEXGEN_39>,
+		<&scmi_clk CK_SCMI_FLEXGEN_40>,
+		<&scmi_clk CK_SCMI_FLEXGEN_41>,
+		<&scmi_clk CK_SCMI_FLEXGEN_42>,
+		<&scmi_clk CK_SCMI_FLEXGEN_43>,
+		<&scmi_clk CK_SCMI_FLEXGEN_44>,
+		<&scmi_clk CK_SCMI_FLEXGEN_45>,
+		<&scmi_clk CK_SCMI_FLEXGEN_46>,
+		<&scmi_clk CK_SCMI_FLEXGEN_47>,
+		<&scmi_clk CK_SCMI_FLEXGEN_48>,
+		<&scmi_clk CK_SCMI_FLEXGEN_49>,
+		<&scmi_clk CK_SCMI_FLEXGEN_50>,
+		<&scmi_clk CK_SCMI_FLEXGEN_51>,
+		<&scmi_clk CK_SCMI_FLEXGEN_52>,
+		<&scmi_clk CK_SCMI_FLEXGEN_53>,
+		<&scmi_clk CK_SCMI_FLEXGEN_54>,
+		<&scmi_clk CK_SCMI_FLEXGEN_55>,
+		<&scmi_clk CK_SCMI_FLEXGEN_56>,
+		<&scmi_clk CK_SCMI_FLEXGEN_57>,
+		<&scmi_clk CK_SCMI_FLEXGEN_58>,
+		<&scmi_clk CK_SCMI_FLEXGEN_59>,
+		<&scmi_clk CK_SCMI_FLEXGEN_60>,
+		<&scmi_clk CK_SCMI_FLEXGEN_61>,
+		<&scmi_clk CK_SCMI_FLEXGEN_62>,
+		<&scmi_clk CK_SCMI_FLEXGEN_63>,
+		<&scmi_clk CK_SCMI_ICN_APB1>,
+		<&scmi_clk CK_SCMI_ICN_APB2>,
+		<&scmi_clk CK_SCMI_ICN_APB3>,
+		<&scmi_clk CK_SCMI_ICN_APB4>,
+		<&scmi_clk CK_SCMI_ICN_APBDBG>,
+		<&scmi_clk CK_SCMI_TIMG1>,
+		<&scmi_clk CK_SCMI_TIMG2>,
+		<&scmi_clk CK_SCMI_PLL3>,
+		<&dsi>,
+		<&scmi_clk CK_SCMI_HSI_KER_CK>,
+		<&scmi_clk CK_SCMI_HSE_KER_CK>,
+		<&scmi_clk CK_SCMI_MSI_KER_CK>;
+};
+
+&rifsc {
+	dsi: dsi@48000000 {
+		compatible = "st,stm32mp25-dsi";
+		reg = <0x48000000 0x800>;
+		#clock-cells = <0>;
+		clocks = <&rcc CK_BUS_DSI>, <&rcc CK_KER_DSIPHY>,
+			 <&rcc CK_KER_LTDC>;
+		clock-names = "pclk", "ref", "px_clk";
+		resets = <&rcc DSI_R>;
+		reset-names = "apb";
+		access-controllers = <&rifsc 81>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	lvds: lvds@48060000 {
+		#clock-cells = <0>;
+		compatible = "st,stm32mp25-lvds";
+		reg = <0x48060000 0x2000>;
+		clocks = <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>, <&syscfg 0>;
+		clock-names = "pclk", "ref", "pixclk";
+		resets = <&rcc LVDS_R>;
+		access-controllers = <&rifsc 84>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	vdec: vdec@480d0000 {
+		compatible = "st,stm32mp25-vdec";
+		reg = <0x480d0000 0x3c8>;
+		resets = <&rcc VDEC_R>;
+		interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_VDEC>;
+		access-controllers = <&rifsc 89>;
+		power-domains = <&CLUSTER_PD>;
+	};
+
+	gpu: gpu@48280000 {
+		compatible = "vivante,gc";
+		reg = <0x48280000 0x800>;
+		interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+		resets = <&rcc GPU_R>;
+		clock-names = "bus", "core";
+		clocks = <&rcc CK_BUS_GPU>, <&rcc CK_KER_GPU>;
+		power-domains = <&scmi_devpd PD_SCMI_GPU>, <&CLUSTER_PD>;
+		access-controllers = <&rifsc 79>;
+		status = "disabled";
+
+		throttle,max_state = <6>;
+		#cooling-cells = <2>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp235f-dk-ca35tdcid-resmem.dtsi b/arch/arm/dts/stm32mp235f-dk-ca35tdcid-resmem.dtsi
new file mode 100644
index 0000000000..059fb15297
--- /dev/null
+++ b/arch/arm/dts/stm32mp235f-dk-ca35tdcid-resmem.dtsi
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * stm32mp235f reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 5/16/2024 11:06:19 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp235f-dk-u-boot.dtsi b/arch/arm/dts/stm32mp235f-dk-u-boot.dtsi
new file mode 100644
index 0000000000..7346a720c6
--- /dev/null
+++ b/arch/arm/dts/stm32mp235f-dk-u-boot.dtsi
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ */
+
+#include "stm32mp23-u-boot.dtsi"
+
+/ {
+	config {
+		u-boot,boot-led = "led-blue";
+		u-boot,mmc-env-partition = "u-boot-env";
+		st,stm32prog-gpios = <&gpioc 11 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&dwc3 {
+	phys = <&usb2_phy2>;
+	phy-names = "usb2-phy";
+	dr_mode = "peripheral";
+	maximum-speed = "high-speed";
+	/delete-node/ port;
+};
+
+&i2c_rpmsg {
+	/delete-node/ typec@35;
+};
+
+&sdmmc3 {
+	status = "disabled";
+};
+
+&usart2 {
+	bootph-all;
+};
+
+&usart2_pins_a {
+	bootph-all;
+	pins1 {
+		bootph-all;
+	};
+	pins2 {
+		bootph-all;
+	};
+};
diff --git a/arch/arm/dts/stm32mp235f-dk.dts b/arch/arm/dts/stm32mp235f-dk.dts
new file mode 100644
index 0000000000..6bc923b7f2
--- /dev/null
+++ b/arch/arm/dts/stm32mp235f-dk.dts
@@ -0,0 +1,747 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+#include "stm32mp235.dtsi"
+#include "stm32mp23xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxak-pinctrl.dtsi"
+#include "stm32mp235f-dk-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP235F-DK Discovery Board";
+	compatible = "st,stm32mp235f-dk", "st,stm32mp235";
+
+	aliases {
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &usart1;
+		ethernet0 = &eth1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_ext_cec: clk-ext-cec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpioc 5 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpioc 11 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioh 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+		hdmi-pwr-supply = <&scmi_v5v_hdmi>;
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv7535_out>;
+			};
+		};
+	};
+
+	imx335_2v9: imx335-2v9 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-avdd";
+		regulator-min-microvolt = <2900000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-always-on;
+	};
+
+	imx335_1v8: imx335-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-ovdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	imx335_1v2: imx335-1v2 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-dvdd";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-always-on;
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpioi 4 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <0>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP23-DK";
+		dais = <&i2s2_port>;
+		status = "okay";
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpiog 8 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&cs_cpu_debug0 {
+	status = "okay";
+};
+
+&cs_cpu_debug1 {
+	status = "okay";
+};
+
+&cs_cti0 {
+	status = "okay";
+};
+
+&cs_cti1 {
+	status = "okay";
+};
+
+&cs_cti_cpu0 {
+	status = "okay";
+};
+
+&cs_cti_cpu1 {
+	status = "okay";
+};
+
+&cs_etf {
+	status = "okay";
+};
+
+&cs_etm0 {
+	status = "okay";
+};
+
+&cs_etm1 {
+	status = "okay";
+};
+
+&cs_etr {
+	status = "okay";
+};
+
+&cs_funnel {
+	status = "okay";
+};
+
+&cs_replicator {
+	status = "okay";
+};
+
+&cs_stm {
+	status = "okay";
+};
+
+&cs_tpiu {
+	status = "okay";
+};
+
+&csi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv7535_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_b>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_b>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioa 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_b>;
+	pinctrl-1 = <&i2c2_sleep_pins_b>;
+	i2c-scl-rising-time-ns = <108>;
+	i2c-scl-falling-time-ns = <12>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		avdd-supply = <&imx335_2v9>;
+		ovdd-supply = <&imx335_1v8>;
+		dvdd-supply = <&imx335_1v2>;
+		reset-gpios = <&gpiob 1 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpiob 11 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv7535: hdmi@3d {
+		compatible = "adi,adv7535";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		status = "okay";
+		adi,dsi-lanes = <4>;
+		clocks = <&clk_ext_cec>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiob>;
+		interrupts = <4 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiob 6 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv7535_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv7535_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv7535_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpioi 0 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <100000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_b>;
+	pinctrl-1 = <&i2s2_sleep_pins_b>;
+	status = "okay";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv7535_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+/* use LPTIMER with tick broadcast for suspend mode */
+&lptimer3 {
+	status = "okay";
+	timer {
+		status = "okay";
+	};
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	status = "okay";
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_v5v_hdmi: regulator@21 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO5>;
+		regulator-name = "v5v_hdmi";
+	};
+	scmi_v5v_vconn: regulator@22 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO6>;
+		regulator-name = "v5v_vconn";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_b>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_b>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	status = "okay";
+};
+
+/* Wifi */
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	cap-sdio-irq;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		status = "disabled";
+	};
+};
+
+/* Bluetooth */
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpiog 4 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&scmi_v3v3>;
+		vddio-supply = <&scmi_v3v3>;
+	};
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		maximum-speed = "high-speed";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp23xc.dtsi b/arch/arm/dts/stm32mp23xc.dtsi
new file mode 100644
index 0000000000..f3d5cb3a06
--- /dev/null
+++ b/arch/arm/dts/stm32mp23xc.dtsi
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 96>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp23xf.dtsi b/arch/arm/dts/stm32mp23xf.dtsi
new file mode 100644
index 0000000000..f3d5cb3a06
--- /dev/null
+++ b/arch/arm/dts/stm32mp23xf.dtsi
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 96>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp25-pinctrl.dtsi b/arch/arm/dts/stm32mp25-pinctrl.dtsi
new file mode 100644
index 0000000000..a6ed7566aa
--- /dev/null
+++ b/arch/arm/dts/stm32mp25-pinctrl.dtsi
@@ -0,0 +1,1014 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	eth1_mdio_pins_a: eth1-mdio-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 2, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	eth1_mdio_sleep_pins_a: eth1-mdio-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 2, ANALOG)>; /* ETH_MDIO */
+		};
+	};
+
+	eth1_rgmii_pins_a: eth1-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_sleep_pins_a: eth1-rgmii-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 9, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 14, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth1_rgmii_pins_b: eth1-rgmii-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, AF10)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 10, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_sleep_pins_b: eth1-rgmii-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 9, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth2_rgmii_pins_a: eth2-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 7, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, AF10)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 5, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('G', 0, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins5 {
+			pinmux = <STM32_PINMUX('F', 6, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth2_rgmii_sleep_pins_a: eth2-rgmii-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 0, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('F', 6, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth3_rgmii_pins_a: eth3-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF14)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, AF14)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, AF14)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, AF14)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, AF14)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 2, AF14)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-delay = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('A', 9, AF14)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, AF14)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, AF14)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, AF14)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, AF14)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 5, AF14)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth3_rgmii_sleep_pins_a: eth3-rgmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 2, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 5, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	i2c2_pins_a: i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('B', 4, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_a: i2c2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('B', 4, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2c2_pins_b: i2c2-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_b: i2c2-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2s2_pins_a: i2s2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('K', 1, AF2)>, /* I2S2_SDO */
+				 <STM32_PINMUX('I', 14, AF2)>, /* I2S2_WS */
+				 <STM32_PINMUX('B', 0, AF2)>; /* I2S2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	i2s2_sleep_pins_a: i2s2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 1, ANALOG)>, /* I2S2_SDO */
+				 <STM32_PINMUX('I', 14, ANALOG)>, /* I2S2_WS */
+				 <STM32_PINMUX('B', 0, ANALOG)>; /* I2S2_CK */
+		};
+	};
+
+	i2s2_pins_b: i2s2-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 2, AF2)>, /* I2S2_SDO */
+				<STM32_PINMUX('B', 3, AF2)>, /* I2S2_WS */
+				<STM32_PINMUX('B', 0, AF2)>; /* I2S2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	i2s2_sleep_pins_b: i2s2-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 2, ANALOG)>, /* I2S2_SDO */
+				<STM32_PINMUX('B', 3, ANALOG)>, /* I2S2_WS */
+				<STM32_PINMUX('B', 0, ANALOG)>; /* I2S2_CK */
+		};
+	};
+
+	m_can1_pins_a: m-can1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 11, AF7)>; /* CAN1_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 12, AF7)>; /* CAN1_RX */
+			bias-disable;
+		};
+	};
+
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, ANALOG)>, /* CAN3_TX */
+				 <STM32_PINMUX('G', 12, ANALOG)>; /* CAN3_RX */
+		};
+	};
+
+	m_can3_pins_a: m-can3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 14, AF7)>; /* CAN3_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 12, AF7)>; /* CAN3_RX */
+			bias-disable;
+		};
+	};
+
+	m_can3_sleep_pins_a: m-can3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 14, ANALOG)>, /* CAN3_TX */
+				 <STM32_PINMUX('I', 12, ANALOG)>; /* CAN3_RX */
+		};
+	};
+
+	mdf_cck0_pins_a: mdf-cck0-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 7, AF5)>; /* MDF1_CCK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_cck0_sleep_pins_a: mdf-cck0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 7, ANALOG)>; /* MDF1_CCK */
+		};
+	};
+
+	mdf_sdi6_pins_a: mdf-sdi6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF5)>; /* MDF1_SDI6 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_sdi6_sleep_pins_a: mdf-sdi6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>; /* MDF1_SDI6 */
+		};
+	};
+
+	ospi_port1_clk_pins_a: ospi-port1-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, AF10)>; /* OSPI1_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	ospi_port1_clk_sleep_pins_a: ospi-port1-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, ANALOG)>; /* OSPI1_CLK */
+		};
+	};
+
+	ospi_port1_cs0_pins_a: ospi-port1-cs0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, AF10)>; /* OSPI_NCS0 */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_cs0_sleep_pins_a: ospi-port1-cs0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, ANALOG)>; /* OSPI_NCS0 */
+		};
+	};
+
+	ospi_port1_io03_pins_a: ospi-port1-io03-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF10)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, AF10)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, AF10)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, AF10)>; /* OSPI_IO3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_io03_sleep_pins_a: ospi-port1-io03-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, ANALOG)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, ANALOG)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, ANALOG)>; /* OSPI_IO3 */
+		};
+	};
+
+	pcie_pins_a: pcie-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, AF4)>;
+			bias-disable;
+		};
+	};
+
+	pcie_init_pins_a: pcie-init-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, GPIO)>;
+			output-low;
+		};
+	};
+
+	pcie_sleep_pins_a: pcie-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, ANALOG)>;
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1a_pins_a: sai1a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 9, AF3)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('D', 8, AF3)>, /* SAI1_FS_A */
+				 <STM32_PINMUX('D', 10, AF3)>; /* SAI1_SCK_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 11, AF3)>; /* SAI1_MCLK_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	sai1a_sleep_pins_a: sai1a-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 9, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('D', 8, ANALOG)>, /* SAI1_FS_A */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('D', 11, ANALOG)>; /* SAI1_MCLK_A */
+		};
+	};
+
+	sai1b_pins_a: sai1b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF4)>; /* SAI1_SD_B */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sai1b_sleep_pins_a: sai1b-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>; /* SAI1_SD_B */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_pins_b: sdmmc1-b4-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>; /* SDMMC1_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_b: sdmmc1-b4-od-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 4, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('E', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_pins_a: sdmmc2-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>; /* SDMMC2_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_sleep_pins_a: sdmmc2-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 14, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('E', 15, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_sleep_pins_a: sdmmc2-d47-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, ANALOG)>; /* SDMMC2_D7 */
+		};
+	};
+
+	sdmmc3_b4_pins_a: sdmmc3-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_od_pins_a: sdmmc3-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>; /* SDMMC3_D3 */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <0>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_sleep_pins_a: sdmmc3-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('D', 13, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('I', 11, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('B', 13, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('D', 12, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	spi3_pins_a: spi3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 7, AF1)>, /* SPI3_SCK */
+				 <STM32_PINMUX('B', 8, AF1)>; /* SPI3_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 10, AF1)>; /* SPI3_MISO */
+			bias-disable;
+		};
+	};
+
+	spi3_sleep_pins_a: spi3-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 7, ANALOG)>, /* SPI3_SCK */
+				 <STM32_PINMUX('B', 8, ANALOG)>, /* SPI3_MOSI */
+				 <STM32_PINMUX('B', 10, ANALOG)>; /* SPI3_MISO */
+		};
+	};
+
+	spi6_pins_a: spi6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF3)>, /* SPI6_SCK */
+				 <STM32_PINMUX('C', 7, AF3)>; /* SPI6_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF3)>; /* SPI6_MISO */
+			bias-disable;
+		};
+	};
+
+	spi6_sleep_pins_a: spi6-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI6_SCK */
+				 <STM32_PINMUX('C', 7, ANALOG)>, /* SPI6_MOSI */
+				 <STM32_PINMUX('C', 4, ANALOG)>; /* SPI6_MISO */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, AF6)>, /* USART1_TX */
+				<STM32_PINMUX('I', 2, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 15, AF6)>, /* USART1_RX */
+				<STM32_PINMUX('I', 3, AF6)>; /* USART1_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				<STM32_PINMUX('I', 3, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 2, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('G', 15, AF6)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				<STM32_PINMUX('I', 2, ANALOG)>, /* USART1_RTS */
+				<STM32_PINMUX('I', 3, ANALOG)>, /* USART1_CTS_NSS */
+				<STM32_PINMUX('G', 15, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>; /* USART2_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('A', 8, ANALOG)>; /* USART2_RX */
+		};
+	};
+
+	usart6_pins_a: usart6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, AF3)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, AF3)>;  /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>, /* USART6_RX */
+				 <STM32_PINMUX('F', 15, AF3)>; /* USART6_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart6_idle_pins_a: usart6-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('F', 15, ANALOG)>; /* USART6_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 5, AF3)>; /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>; /* USART6_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart6_sleep_pins_a: usart6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, ANALOG)>,  /* USART6_RTS */
+				 <STM32_PINMUX('F', 15, ANALOG)>, /* USART6_CTS_NSS */
+				 <STM32_PINMUX('F', 14, ANALOG)>; /* USART6_RX */
+		};
+	};
+};
+
+&pinctrl_z {
+	i2c8_pins_a: i2c8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF8)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, AF8)>; /* I2C8_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c8_sleep_pins_a: i2c8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I2C8_SDA */
+		};
+	};
+
+	i3c4_pins_a: i3c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF11)>, /* I3C4_SCL */
+				 <STM32_PINMUX('Z', 3, AF11)>; /* I3C4_SDA */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c4_init_pins_a: i3c4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 4, AF11)>; /* I3C4_SCL */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 3, AF11)>; /* I3C4_SDA */
+			drive-push-pull;
+			bias-pull-up;
+			slew-rate = <1>;
+		};
+	};
+
+	i3c4_sleep_pins_a: i3c4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I3C4_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I3C4_SDA */
+		};
+	};
+
+	lpuart1_pins_a: lpuart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, AF6)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 5, AF6)>; /* LPUART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 8, AF6)>, /* LPUART1_RX */
+				 <STM32_PINMUX('Z', 6, AF6)>; /* LPUART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	lpuart1_idle_pins_a: lpuart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* LPUART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 5, AF6)>; /* LPUART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('Z', 8, AF6)>; /* LPUART1_RX */
+			bias-pull-up;
+		};
+	};
+
+	lpuart1_sleep_pins_a: lpuart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 5, ANALOG)>, /* LPUART1_RTS */
+				 <STM32_PINMUX('Z', 6, ANALOG)>, /* LPUART1_CTS_NSS */
+				 <STM32_PINMUX('Z', 8, ANALOG)>; /* LPUART1_RX */
+		};
+	};
+
+	spi8_pins_a: spi8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 2, AF3)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 0, AF3)>; /* SPI8_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 1, AF3)>; /* SPI8_MISO */
+			bias-disable;
+		};
+	};
+
+	spi8_sleep_pins_a: spi8-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 2, ANALOG)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI8_MOSI */
+				 <STM32_PINMUX('Z', 1, ANALOG)>; /* SPI8_MISO */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp25-u-boot.dtsi b/arch/arm/dts/stm32mp25-u-boot.dtsi
new file mode 100644
index 0000000000..8e04780f52
--- /dev/null
+++ b/arch/arm/dts/stm32mp25-u-boot.dtsi
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2023
+ */
+
+/ {
+	aliases {
+		gpio0 = &gpioa;
+		gpio1 = &gpiob;
+		gpio2 = &gpioc;
+		gpio3 = &gpiod;
+		gpio4 = &gpioe;
+		gpio5 = &gpiof;
+		gpio6 = &gpiog;
+		gpio7 = &gpioh;
+		gpio8 = &gpioi;
+		gpio9 = &gpioj;
+		gpio10 = &gpiok;
+		gpio25 = &gpioz;
+		pinctrl0 = &pinctrl;
+		pinctrl1 = &pinctrl_z;
+	};
+
+	clocks {
+		txbyteclk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+		};
+	};
+
+	firmware {
+		optee {
+			bootph-all;
+		};
+
+		scmi {
+			bootph-all;
+		};
+	};
+
+	/* need PSCI for sysreset during board_f */
+	psci {
+		bootph-all;
+	};
+
+	soc@0 {
+		bootph-all;
+	};
+};
+
+&bsec {
+	bootph-all;
+};
+
+&gpioa {
+	bootph-all;
+};
+
+&gpiob {
+	bootph-all;
+};
+
+&gpioc {
+	bootph-all;
+};
+
+&gpiod {
+	bootph-all;
+};
+
+&gpioe {
+	bootph-all;
+};
+
+&gpiof {
+	bootph-all;
+};
+
+&gpiog {
+	bootph-all;
+};
+
+&gpioh {
+	bootph-all;
+};
+
+&gpioi {
+	bootph-all;
+};
+
+&gpioj {
+	bootph-all;
+};
+
+&gpiok {
+	bootph-all;
+};
+
+&gpioz {
+	bootph-all;
+};
+
+/* pre-reloc probe = reserve video frame buffer in video_reserve() */
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+	clock-names = "bus", "lcd";
+	bootph-all;
+};
+
+&pinctrl {
+	bootph-all;
+};
+
+&rcc {
+	bootph-all;
+};
+
+&rifsc {
+	bootph-all;
+};
+
+&scmi_clk {
+	bootph-all;
+};
+
+&syscfg {
+	bootph-all;
+};
diff --git a/arch/arm/dts/stm32mp251.dtsi b/arch/arm/dts/stm32mp251.dtsi
new file mode 100644
index 0000000000..925e8c73ff
--- /dev/null
+++ b/arch/arm/dts/stm32mp251.dtsi
@@ -0,0 +1,3373 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/arm/coresight-cti-dt.h>
+#include <dt-bindings/clock/st,stm32mp25-rcc.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include <dt-bindings/reset/st,stm32mp25-rcc.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD0>;
+			power-domain-names = "psci";
+			#cooling-cells = <2>;
+		};
+
+		idle-states {
+			entry-method = "psci";
+
+			CPU_PWRDN: cpu-power-down {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00000001>;
+				local-timer-stop;
+				entry-latency-us = <300>;
+				exit-latency-us = <500>;
+				min-residency-us = <1000>;
+			};
+		};
+
+		domain-idle-states {
+			STOP1: domain-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000011>;
+				entry-latency-us = <400>;
+				exit-latency-us = <1200>;
+				min-residency-us = <1500>;
+			};
+
+			LP_STOP1: domain-lp-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x0000021>;
+				entry-latency-us = <500>;
+				exit-latency-us = <2000>;
+				min-residency-us = <3000>;
+			};
+
+			LPLV_STOP1: domain-lplv-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000211>;
+				entry-latency-us = <500>;
+				exit-latency-us = <3000>;
+				min-residency-us = <4000>;
+			};
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a35-pmu";
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xbc000000>;
+		status = "disabled";
+	};
+
+	clocks {
+		clk_rcbsec: clk-rcbsec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+	};
+
+	cs_replicator: replicator {
+		compatible = "arm,coresight-static-replicator";
+		clocks = <&scmi_clk CK_SCMI_SYSATB>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				replicator_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				replicator_out_port0: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				replicator_out_port1: endpoint {
+					remote-endpoint = <&tpiu_in_port>;
+				};
+			};
+		};
+	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+
+			scmi_devpd: protocol@11 {
+				reg = <0x11>;
+				#power-domain-cells = <1>;
+			};
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_vddio1: regulator@0 {
+						reg = <VOLTD_SCMI_VDDIO1>;
+						regulator-name = "vddio1";
+					};
+					scmi_vddio2: regulator@1 {
+						reg = <VOLTD_SCMI_VDDIO2>;
+						regulator-name = "vddio2";
+					};
+					scmi_vddio3: regulator@2 {
+						reg = <VOLTD_SCMI_VDDIO3>;
+						regulator-name = "vddio3";
+					};
+					scmi_vddio4: regulator@3 {
+						reg = <VOLTD_SCMI_VDDIO4>;
+						regulator-name = "vddio4";
+					};
+					scmi_vdd33ucpd: regulator@5 {
+						reg = <VOLTD_SCMI_UCPD>;
+						regulator-name = "vdd33ucpd";
+					};
+					scmi_vdda18adc: regulator@7 {
+						reg = <VOLTD_SCMI_ADC>;
+						regulator-name = "vdda18adc";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		interrupt-parent = <&intc>;
+		reg = <0x0 0x4ac10000 0x0 0x1000>,
+		      <0x0 0x4ac20000 0x0 0x2000>,
+		      <0x0 0x4ac40000 0x0 0x2000>,
+		      <0x0 0x4ac60000 0x0 0x2000>;
+		interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		v2m0: v2m@48090000 {
+			compatible = "arm,gic-v2m-frame";
+			reg = <0x0 0x48090000 0x0 0x1000>;
+			msi-controller;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+
+		CPU_PD0: power-domain-cpu0 {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+
+		CLUSTER_PD: power-domain-cluster {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&STOP1>, <&LP_STOP1>;
+			power-domains = <&RET_PD>;
+		};
+
+		RET_PD: power-domain-retention {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&LPLV_STOP1>;
+		};
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 1>;
+
+			trips {
+				cpu_alert: cpu-alert {
+					temperature = <110000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+
+				cpu-crit {
+					temperature = <122000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 1 1>;
+				};
+			};
+		};
+
+		soc-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 0>;
+
+			trips {
+				soc-crit {
+					temperature = <122000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		arm,no-tick-in-suspend;
+	};
+
+	usb2_phy1: usb2-phy1 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2400>;
+		clocks          = <&rcc CK_KER_USB2PHY1>;
+		resets          = <&rcc USB2PHY1_R>;
+		status          = "disabled";
+	};
+
+	usb2_phy2: usb2-phy2 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2800>;
+		clocks          = <&rcc CK_KER_USB2PHY2EN>;
+		resets          = <&rcc USB2PHY2_R>;
+		status          = "disabled";
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x80000000>;
+
+		hpdma: dma-controller@40400000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40400000 0x1000>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA1>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma2: dma-controller@40410000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40410000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA2>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma3: dma-controller@40420000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40420000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA3>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		ipcc1: mailbox@40490000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x40490000 0x400>;
+			st,proc-id = <0>;
+			interrupts = <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi_clk CK_SCMI_IPCC1>;
+			status = "disabled";
+		};
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+			access-controllers = <&rifsc 111>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 2 0x62 0x00003121>,
+				       <&hpdma 2 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1000>;
+				clocks = <&scmi_clk CK_SCMI_OSPI1>;
+				resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+				access-controllers = <&rifsc 74>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 3 0x62 0x00003121>,
+				       <&hpdma 3 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1400>;
+				clocks = <&scmi_clk CK_SCMI_OSPI2>;
+				resets = <&scmi_reset RST_SCMI_OSPI2>, <&scmi_reset RST_SCMI_OSPI2DLL>;
+				access-controllers = <&rifsc 75>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		rifsc: bus@42080000 {
+			compatible = "st,stm32mp25-rifsc", "simple-bus";
+			reg = <0x42080000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			#access-controller-cells = <1>;
+			ranges;
+			st,mem-map = <0x200c0000 0x2000 0x200c2000 0x2000 0x200c4000 0x4000>;
+
+			timers2: timer@40000000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM2>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 1>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@1 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers3: timer@40010000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40010000 0x400>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM3>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 2>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@2 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers4: timer@40020000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40020000 0x400>;
+				interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM4>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 3>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@3 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers5: timer@40030000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40030000 0x400>;
+				interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM5>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 4>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@4 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers6: timer@40040000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40040000 0x400>;
+				interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM6>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 5>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@5 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
+			};
+
+			timers7: timer@40050000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40050000 0x400>;
+				interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM7>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 6>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
+			};
+
+			timers12: timer@40060000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40060000 0x400>;
+				interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM12>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 10>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@40070000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40070000 0x400>;
+				interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM13>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 11>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@40080000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40080000 0x400>;
+				interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM14>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 12>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			lptimer1: timer@40090000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x40090000 0x400>;
+				interrupts-extended = <&exti1 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM1>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 17>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@0 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@400a0000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x400a0000 0x400>;
+				interrupts-extended = <&exti1 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM2>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 18>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+			};
+
+			i2s2: audio-controller@400b0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400b0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI2>, <&rcc CK_KER_SPI2>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x43 0x12>,
+					<&hpdma 52 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 23>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi2: spi@400b0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400b0000 0x400>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI2>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x20 0x00003012>,
+				       <&hpdma 52 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 23>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2s3: audio-controller@400c0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400c0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI3>, <&rcc CK_KER_SPI3>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x43 0x12>,
+					<&hpdma 54 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 24>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi3: spi@400c0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400c0000 0x400>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI3>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x20 0x00003012>,
+				       <&hpdma 54 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 24>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spdifrx: audio-controller@400d0000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x400d0000 0x400>;
+				clocks = <&rcc CK_KER_SPDIFRX>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 71 0x43 0x212>,
+					<&hpdma 72 0x43 0x212>;
+				dma-names = "rx", "rx-ctrl";
+				access-controllers = <&rifsc 30>;
+				status = "disabled";
+			};
+
+			usart2: serial@400e0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400e0000 0x400>;
+				interrupts-extended = <&exti1 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART2>;
+				dmas = <&hpdma 11 0x20 0x10012>,
+				       <&hpdma 12 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 32>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			usart3: serial@400f0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400f0000 0x400>;
+				interrupts-extended = <&exti1 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART3>;
+				dmas = <&hpdma 13 0x20 0x10012>,
+				       <&hpdma 14 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 33>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart4: serial@40100000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40100000 0x400>;
+				interrupts-extended = <&exti1 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART4>;
+				dmas = <&hpdma 15 0x20 0x10012>,
+				       <&hpdma 16 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 34>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart5: serial@40110000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40110000 0x400>;
+				interrupts-extended = <&exti1 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART5>;
+				dmas = <&hpdma 17 0x20 0x10012>,
+				       <&hpdma 18 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 35>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40120000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40120000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C1>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 27 0x20 0x00003012>,
+				       <&hpdma 28 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 41>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40130000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40130000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C2>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 30 0x20 0x00003012>,
+				       <&hpdma 31 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 42>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40140000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40140000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C3>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 33 0x20 0x00003012>,
+				       <&hpdma 34 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 43>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@40150000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40150000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C4>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 36 0x20 0x00003012>,
+				       <&hpdma 37 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 44>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40160000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40160000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C5>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 39 0x20 0x00003012>,
+				       <&hpdma 40 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 45>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@40170000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40170000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C6>;
+				resets = <&rcc I2C6_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 42 0x20 0x00003012>,
+				       <&hpdma 43 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 46>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c7: i2c@40180000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40180000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C7>;
+				resets = <&rcc I2C7_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 45 0x20 0x00003012>,
+				       <&hpdma 46 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 47>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c1: i3c@40190000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x40190000 0x400>;
+				interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C1>;
+				resets = <&rcc I3C1_R>;
+				access-controllers = <&rifsc 114>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c2: i3c@401a0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401a0000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C2>;
+				resets = <&rcc I3C2_R>;
+				access-controllers = <&rifsc 115>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c3: i3c@401b0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401b0000 0x400>;
+				interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C3>;
+				resets = <&rcc I3C3_R>;
+				access-controllers = <&rifsc 116>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers10: timer@401c0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401c0000 0x400>;
+				interrupts = <GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM10>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 8>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@9 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <9>;
+					status = "disabled";
+				};
+			};
+
+			timers11: timer@401d0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401d0000 0x400>;
+				interrupts = <GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM11>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 9>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@10 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <10>;
+					status = "disabled";
+				};
+			};
+
+			timers1: timer@40200000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40200000 0x400>;
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM1>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 0>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@0 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers8: timer@40210000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40210000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM8>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 7>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@7 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart6: serial@40220000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40220000 0x400>;
+				interrupts-extended = <&exti1 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART6>;
+				dmas = <&hpdma 19 0x20 0x10012>,
+				       <&hpdma 20 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 36>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2s1: audio-controller@40230000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x40230000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI1>, <&rcc CK_KER_SPI1>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x43 0x12>,
+					<&hpdma 50 0x43 0x21>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 22>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi1: spi@40230000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40230000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI1>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x20 0x00003012>,
+				       <&hpdma 50 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 22>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi4: spi@40240000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40240000 0x400>;
+				interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI4>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&hpdma 55 0x20 0x00003012>,
+				       <&hpdma 56 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 25>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers15: timer@40250000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40250000 0x400>;
+				interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM15>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 13>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@40260000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40260000 0x400>;
+				interrupts = <GIC_SPI 194 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM16>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 14>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@40270000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40270000 0x400>;
+				interrupts = <GIC_SPI 195 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM17>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 15>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			spi5: spi@40280000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40280000 0x400>;
+				interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI5>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&hpdma 57 0x20 0x00003012>,
+				       <&hpdma 58 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 26>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sai1: sai@40290000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40290000 0x4>, <0x4029a3f0 0x10>;
+				ranges = <0 0x40290000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI1>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				access-controllers = <&rifsc 49>;
+				status = "disabled";
+
+				sai1a: audio-controller@40290004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 73 0x43 0x21>;
+					dma-names = "tx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai1b: audio-controller@40290024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 74 0x43 0x12>;
+					dma-names = "rx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai2: sai@402a0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402a0000 0x4>, <0x402aa3f0 0x10>;
+				ranges = <0 0x402a0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI2>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				access-controllers = <&rifsc 50>;
+				status = "disabled";
+
+				sai2a: audio-controller@402a0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 75 0x43 0x21>;
+					dma-names = "tx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai2b: audio-controller@402a0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 76 0x43 0x12>;
+					dma-names = "rx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai3: sai@402b0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402b0000 0x4>, <0x402ba3f0 0x10>;
+				ranges = <0 0x402b0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI3>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				access-controllers = <&rifsc 51>;
+				status = "disabled";
+
+				sai3a: audio-controller@402b0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 77 0x43 0x21>;
+					dma-names = "tx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai3b: audio-controller@502b0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 78 0x43 0x12>;
+					dma-names = "rx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			uart9: serial@402c0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x402c0000 0x400>;
+				interrupts-extended = <&exti1 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART9>;
+				dmas = <&hpdma 25 0x20 0x10012>,
+				       <&hpdma 26 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 39>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			timers20: timer@40320000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40320000 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM20>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 16>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@19 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <19>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart1: serial@40330000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40330000 0x400>;
+				interrupts-extended = <&exti1 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART1>;
+				dmas = <&hpdma 9 0x20 0x10012>,
+				       <&hpdma 10 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 31>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			sai4: sai@40340000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40340000 0x4>, <0x4034a3f0 0x10>;
+				ranges = <0 0x40340000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI4>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				access-controllers = <&rifsc 52>;
+				status = "disabled";
+
+				sai4a: audio-controller@40340004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 79 0x63 0x21>;
+					dma-names = "tx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai4b: audio-controller@40340024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 80 0x43 0x12>;
+					dma-names = "rx";
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			spi6: spi@40350000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40350000 0x400>;
+				interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI6>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&hpdma 59 0x20 0x00003012>,
+				       <&hpdma 60 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 27>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi7: spi@40360000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40360000 0x400>;
+				interrupts = <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI7>;
+				resets = <&rcc SPI7_R>;
+				dmas = <&hpdma 61 0x20 0x00003012>,
+				       <&hpdma 62 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 28>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			uart7: serial@40370000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40370000 0x400>;
+				interrupts-extended = <&exti1 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART7>;
+				dmas = <&hpdma 21 0x20 0x10012>,
+				       <&hpdma 22 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 37>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart8: serial@40380000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40380000 0x400>;
+				interrupts-extended = <&exti1 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART8>;
+				dmas = <&hpdma 23 0x20 0x10012>,
+				       <&hpdma 24 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 38>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@404a0000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x404a0000 0x400>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CCI_R>;
+				clocks = <&rcc CK_BUS_CCI>;
+				clock-names = "mclk";
+				dmas = <&hpdma 137 0x60 0x00003012>;
+				dma-names = "tx";
+				access-controllers = <&rifsc 88>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			crc: crc@404c0000 {
+				compatible = "st,stm32f7-crc";
+				reg = <0x404c0000 0x400>;
+				clocks = <&rcc CK_BUS_CRC>;
+				access-controllers = <&rifsc 109>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			adc_12: adc@404e0000 {
+				compatible = "st,stm32mp25-adc-core";
+				reg = <0x404e0000 0x400>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC12>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 58>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <0>;
+					dmas = <&hpdma 81 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					st,adc-trigger-sel = <0>;
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+				};
+
+				adc2: adc@100 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x100>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <1>;
+					dmas = <&hpdma 82 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					st,adc-trigger-sel = <0>;
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			mdf1: mdf@404d0000 {
+				compatible = "st,stm32mp25-mdf";
+				ranges = <0 0x404d0000 0x1000>;
+				reg = <0x404d0000 0x8>, <0x404d0ff0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_KER_MDF1>;
+				clock-names = "ker_ck";
+				clock-ranges;
+				resets = <&rcc MDF1_R>;
+				reset-names = "mdf";
+				access-controllers = <&rifsc 54>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+
+				sitf0: sitf@80 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x80 0x4>;
+					status = "disabled";
+				};
+
+				sitf1: sitf@100 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x100 0x4>;
+					status = "disabled";
+				};
+
+				sitf2: sitf@180 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x180 0x4>;
+					status = "disabled";
+				};
+
+				sitf3: sitf@200 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x200 0x4>;
+					status = "disabled";
+				};
+
+				sitf4: sitf@280 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x280 0x4>;
+					status = "disabled";
+				};
+
+				sitf5: sitf@300 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x300 0x4>;
+					status = "disabled";
+				};
+
+				sitf6: sitf@380 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x380 0x4>;
+					status = "disabled";
+				};
+
+				sitf7: sitf@400 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x400 0x4>;
+					status = "disabled";
+				};
+
+				filter0: filter@84 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x84 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 63 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter1: filter@104 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x104 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 64 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter2: filter@184 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x184 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 65 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter3: filter@204 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x204 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 66 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter4: filter@284 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x284 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 67 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter5: filter@304 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x304 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 68 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter6: filter@384 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x384 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 69 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter7: filter@404 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x404 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 70 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+			};
+
+			adc_3: adc@404f0000 {
+				compatible = "st,stm32mp25-adc-core";
+				reg = <0x404f0000 0x400>;
+				interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC3>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 59>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc3: adc@0 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_3>;
+					interrupts = <0>;
+					dmas = <&hpdma 83 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					st,adc-trigger-sel = <1>;
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			hash: hash@42010000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x42010000 0x400>;
+				interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_HASH>;
+				resets = <&rcc HASH_R>;
+				dmas = <&hpdma 6 0x40 0x3021>;
+				dma-names = "in";
+				access-controllers = <&rifsc 95>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			rng: rng@42020000 {
+				compatible = "st,stm32mp25-rng";
+				reg = <0x42020000 0x400>;
+				clocks = <&clk_rcbsec>, <&rcc CK_BUS_RNG>;
+				clock-names = "rng_clk", "rng_hclk";
+				resets = <&rcc RNG_R>;
+				access-controllers = <&rifsc 92>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			iwdg1: watchdog@44010000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44010000 0x400>;
+				interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG1>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				access-controllers = <&rifsc 98>;
+				status = "disabled";
+			};
+
+			iwdg2: watchdog@44020000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44020000 0x400>;
+				interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				access-controllers = <&rifsc 99>;
+				status = "disabled";
+			};
+
+			spi8: spi@46020000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x46020000 0x400>;
+				interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI8>;
+				resets = <&rcc SPI8_R>;
+				dmas = <&hpdma 171 0x20 0x00003012>,
+				       <&hpdma 172 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 29>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lpuart1: serial@46030000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x46030000 0x400>;
+				interrupts-extended = <&exti2 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPUART1>,
+					 <&rcc CK_LPUART1_AM>;
+				dmas = <&hpdma 166 0x20 0x10012>,
+				       <&hpdma 167 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 40>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2c8: i2c@46040000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x46040000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C8>;
+				resets = <&rcc I2C8_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 168 0x20 0x00003012>,
+				       <&hpdma 169 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				access-controllers = <&rifsc 48>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lptimer3: timer@46050000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46050000 0x400>;
+				interrupts-extended = <&exti2 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM3>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 19>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			lptimer4: timer@46060000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46060000 0x400>;
+				interrupts-extended = <&exti2 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM4>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 20>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@3 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+			};
+
+			lptimer5: timer@46070000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46070000 0x400>;
+				interrupts-extended = <&exti2 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM5>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				access-controllers = <&rifsc 21>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@4 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+			};
+
+			i3c4: i3c@46080000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x46080000 0x400>;
+				interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C4>;
+				resets = <&rcc I3C4_R>;
+				access-controllers = <&rifsc 117>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ltdc: display-controller@48010000 {
+				compatible = "st,stm32mp25-ltdc";
+				reg = <0x48010000 0x400>;
+				st,syscon = <&syscfg>;
+				interrupts = <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+				clock-names = "bus", "lcd";
+				resets = <&rcc LTDC_R>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+				access-controllers = <&rifsc 80>;
+				access-controller-names = "cmn";
+
+				l1l2 {
+					access-controllers = <&rifsc 119>;
+					access-controller-names = "l1l2";
+				};
+				l3 {
+					access-controllers = <&rifsc 120>;
+					access-controller-names = "l3";
+				};
+				rot {
+					access-controllers = <&rifsc 121>;
+					access-controller-names = "rot";
+				};
+			};
+
+			csi: csi@48020000 {
+				compatible = "st,stm32mp25-csi";
+				reg = <0x48020000 0x2000>;
+				interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CSI_R>;
+				clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>,
+					 <&rcc CK_KER_CSIPHY>;
+				clock-names = "pclk", "txesc", "csi2phy";
+				access-controllers = <&rifsc 86>;
+				status = "disabled";
+			};
+
+			dcmipp: dcmipp@48030000 {
+				compatible = "st,stm32mp25-dcmipp";
+				reg = <0x48030000 0x1000>;
+				interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPP_R>;
+				clocks = <&rcc CK_BUS_DCMIPP>, <&rcc CK_KER_CSI>;
+				clock-names = "kclk", "mclk";
+				access-controllers = <&rifsc 87>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			combophy: phy@480c0000 {
+				compatible = "st,stm32mp25-combophy";
+				reg = <0x480c0000 0x1000>;
+				#phy-cells = <1>;
+				clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
+				clock-names = "apb-clk", "ker-clk";
+				resets = <&rcc USB3PCIEPHY_R>;
+				reset-names = "phy-rst";
+				st,syscfg = <&syscfg>;
+				access-controllers = <&rifsc 67>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 45 IRQ_TYPE_EDGE_FALLING>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@48220000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48220000 0x400>, <0x44230400 0x8>;
+				interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC1>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 76>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@48230000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48230000 0x400>, <0x44230800 0x8>;
+				interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC2>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 77>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc3: mmc@48240000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48240000 0x400>, <0x44230c00 0x8>;
+				interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC3>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				access-controllers = <&rifsc 78>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			eth1: eth1@482c0000 {
+				compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+				reg = <0x482c0000 0x4000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti1 68 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ptp_ref",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc CK_ETH1_MAC>,
+					 <&rcc CK_ETH1_TX>,
+					 <&rcc CK_ETH1_RX>,
+					 <&rcc CK_KER_ETH1PTP>,
+					 <&rcc CK_ETH1_STP>,
+					 <&rcc CK_KER_ETH1>;
+				st,syscon = <&syscfg 0x3000 0xffffffff>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,txqos = <7>;
+				snps,rxqos = <7>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				access-controllers = <&rifsc 60>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+				snps,mtl-rx-config = <&mtl_rx_setup_1>;
+				snps,mtl-tx-config = <&mtl_tx_setup_1>;
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+
+				mtl_rx_setup_1: rx-queues-config {
+					snps,rx-queues-to-use = <2>;
+					queue0 {};
+					queue1 {};
+				};
+
+				mtl_tx_setup_1: tx-queues-config {
+					snps,tx-queues-to-use = <4>;
+					queue0 {};
+					queue1 {};
+					queue2 {};
+					queue3 {};
+				};
+			};
+
+			usbh: usb@482e0000 {
+				compatible = "st,stm32mp25-usbh";
+				st,syscfg = <&syscfg 0x2420>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x482e0000 0x482e0000 0x20000>;
+				access-controllers = <&rifsc 63>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 43 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				usbh_ohci: usb@482e0000 {
+					compatible = "generic-ohci";
+					reg = <0x482e0000 0x1000>;
+					clocks = <&usb2_phy1>, <&rcc CK_BUS_USB2OHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+
+				usbh_ehci: usb@482f0000 {
+					compatible = "generic-ehci";
+					reg = <0x482f0000 0x1000>;
+					clocks = <&rcc CK_BUS_USB2EHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+					companion = <&usbh_ohci>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+			};
+
+			usb3dr: usb@48300000 {
+				compatible = "st,stm32mp25-dwc3";
+				st,syscfg = <&syscfg 0x4800>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x48300000 0x48300000 0x100000>;
+				access-controllers = <&rifsc 66>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 44 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				dwc3: usb@48300000 {
+					compatible = "snps,dwc3";
+					reg = <0x48300000 0x100000>;
+					interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+					clock-names = "ref", "bus_early", "suspend";
+					clocks = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DR>,
+						 <&rcc CK_KER_USB2PHY2>;
+					resets = <&rcc USB3DR_R>;
+					phys = <&usb2_phy2>;
+					phy-names = "usb2-phy";
+					wakeup-source;
+				};
+			};
+
+			pcie_ep: pcie-ep@48400000 {
+				compatible = "st,stm32mp25-pcie-ep", "snps,dw-pcie-ep";
+				num-lanes = <1>;
+				reg = <0x48400000 0x400000>,
+				      <0x10000000 0x8000000>;
+				reg-names = "dbi", "addr_space";
+				st,syscfg = <&syscfg>;
+				clocks = <&rcc CK_BUS_PCIE>;
+				clock-names = "core";
+				resets = <&rcc PCIE_R>;
+				reset-names = "pcie";
+				phys = <&combophy PHY_TYPE_PCIE>;
+				phy-names = "pcie-phy";
+				access-controllers = <&rifsc 68>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			pcie_rc: pcie@48400000 {
+				compatible = "st,stm32mp25-pcie-rc", "snps,dw-pcie";
+				device_type = "pci";
+				num-lanes = <1>;
+				reg = <0x48400000 0x400000>,
+				      <0x10000000 0x10000>;
+				reg-names = "dbi", "config";
+				st,syscfg = <&syscfg>;
+				#interrupt-cells = <1>;
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &intc 0 0 GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 2 &intc 0 0 GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 3 &intc 0 0 GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 4 &intc 0 0 GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>;
+				interrupts = <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "aer_msi", "pme_msi";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges = <0x01000000 0 0x10010000 0x10010000 0 0x10000>,
+					 <0x02000000 0 0x10020000 0x10020000 0 0x7fe0000>,
+					 <0x42000000 0 0x18000000 0x18000000 0 0x8000000>;
+				bus-range = <0x00 0xff>;
+				clocks = <&rcc CK_BUS_PCIE>;
+				clock-names = "core";
+				resets = <&rcc PCIE_R>;
+				reset-names = "pcie";
+				phys = <&combophy PHY_TYPE_PCIE>;
+				phy-names = "pcie-phy";
+
+				msi-parent = <&v2m0>;
+				access-controllers = <&rifsc 68>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		risaf1: risaf@420a0000 {
+			compatible = "st,stm32mp25-risaf";
+			reg = <0x420a0000 0x1000>;
+			clocks = <&rcc CK_BUS_BKPSRAM>;
+			st,mem-map = <0x0 0x42000000 0x0 0x2000>;
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32mp25-risaf-enc";
+			reg = <0x420d0000 0x1000>;
+			clocks = <&rcc CK_BUS_RISAF4>;
+			st,mem-map = <0x0 0x80000000 0x1 0x00000000>;
+		};
+
+		risab1: risab@420f0000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x420f0000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa000000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab2: risab@42100000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42100000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa020000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab3: risab@42110000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42110000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa040000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab4: risab@42120000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42120000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa060000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab5: risab@42130000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42130000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa080000 0x20000>;
+			#access-controller-cells = <1>;
+		};
+
+		risab6: risab@42140000 {
+			compatible = "st,stm32mp25-risab";
+			reg = <0x42140000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_ICN_LS_MCU>;
+			st,mem-map = <0xa0a0000 0x20000>;
+			#access-controller-cells = <1>;
+			status = "disabled";
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+
+			vrefint: vrefin-cal@1b8 {
+				reg = <0x1b8 0x2>;
+			};
+
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		dts: thermal-sensor@44070000 {
+			compatible = "moortec,mr75203";
+			reg = <0x44070000 0x80>,
+			      <0x44070080 0x180>,
+			      <0x44070200 0x200>,
+			      <0x44070400 0xc00>;
+			reg-names = "common", "ts", "pd", "vm";
+			clocks = <&rcc CK_KER_DTS>;
+			resets = <&rcc DTS_R>;
+			#thermal-sensor-cells = <1>;
+		};
+
+		hdp: pinctrl@44090000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x44090000 0x400>;
+			clocks = <&rcc CK_BUS_HDP>;
+			status = "disabled";
+		};
+
+		rcc: clock-controller@44200000 {
+			compatible = "st,stm32mp25-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#access-controller-cells = <1>;
+			clocks =
+				<&scmi_clk CK_SCMI_HSE>,
+				<&scmi_clk CK_SCMI_HSI>,
+				<&scmi_clk CK_SCMI_MSI>,
+				<&scmi_clk CK_SCMI_LSE>,
+				<&scmi_clk CK_SCMI_LSI>,
+				<&scmi_clk CK_SCMI_HSE_DIV2>,
+				<&scmi_clk CK_SCMI_ICN_HS_MCU>,
+				<&scmi_clk CK_SCMI_ICN_LS_MCU>,
+				<&scmi_clk CK_SCMI_ICN_SDMMC>,
+				<&scmi_clk CK_SCMI_ICN_DDR>,
+				<&scmi_clk CK_SCMI_ICN_DISPLAY>,
+				<&scmi_clk CK_SCMI_ICN_HSL>,
+				<&scmi_clk CK_SCMI_ICN_NIC>,
+				<&scmi_clk CK_SCMI_ICN_VID>,
+				<&scmi_clk CK_SCMI_FLEXGEN_07>,
+				<&scmi_clk CK_SCMI_FLEXGEN_08>,
+				<&scmi_clk CK_SCMI_FLEXGEN_09>,
+				<&scmi_clk CK_SCMI_FLEXGEN_10>,
+				<&scmi_clk CK_SCMI_FLEXGEN_11>,
+				<&scmi_clk CK_SCMI_FLEXGEN_12>,
+				<&scmi_clk CK_SCMI_FLEXGEN_13>,
+				<&scmi_clk CK_SCMI_FLEXGEN_14>,
+				<&scmi_clk CK_SCMI_FLEXGEN_15>,
+				<&scmi_clk CK_SCMI_FLEXGEN_16>,
+				<&scmi_clk CK_SCMI_FLEXGEN_17>,
+				<&scmi_clk CK_SCMI_FLEXGEN_18>,
+				<&scmi_clk CK_SCMI_FLEXGEN_19>,
+				<&scmi_clk CK_SCMI_FLEXGEN_20>,
+				<&scmi_clk CK_SCMI_FLEXGEN_21>,
+				<&scmi_clk CK_SCMI_FLEXGEN_22>,
+				<&scmi_clk CK_SCMI_FLEXGEN_23>,
+				<&scmi_clk CK_SCMI_FLEXGEN_24>,
+				<&scmi_clk CK_SCMI_FLEXGEN_25>,
+				<&scmi_clk CK_SCMI_FLEXGEN_26>,
+				<&scmi_clk CK_SCMI_FLEXGEN_27>,
+				<&scmi_clk CK_SCMI_FLEXGEN_28>,
+				<&scmi_clk CK_SCMI_FLEXGEN_29>,
+				<&scmi_clk CK_SCMI_FLEXGEN_30>,
+				<&scmi_clk CK_SCMI_FLEXGEN_31>,
+				<&scmi_clk CK_SCMI_FLEXGEN_32>,
+				<&scmi_clk CK_SCMI_FLEXGEN_33>,
+				<&scmi_clk CK_SCMI_FLEXGEN_34>,
+				<&scmi_clk CK_SCMI_FLEXGEN_35>,
+				<&scmi_clk CK_SCMI_FLEXGEN_36>,
+				<&scmi_clk CK_SCMI_FLEXGEN_37>,
+				<&scmi_clk CK_SCMI_FLEXGEN_38>,
+				<&scmi_clk CK_SCMI_FLEXGEN_39>,
+				<&scmi_clk CK_SCMI_FLEXGEN_40>,
+				<&scmi_clk CK_SCMI_FLEXGEN_41>,
+				<&scmi_clk CK_SCMI_FLEXGEN_42>,
+				<&scmi_clk CK_SCMI_FLEXGEN_43>,
+				<&scmi_clk CK_SCMI_FLEXGEN_44>,
+				<&scmi_clk CK_SCMI_FLEXGEN_45>,
+				<&scmi_clk CK_SCMI_FLEXGEN_46>,
+				<&scmi_clk CK_SCMI_FLEXGEN_47>,
+				<&scmi_clk CK_SCMI_FLEXGEN_48>,
+				<&scmi_clk CK_SCMI_FLEXGEN_49>,
+				<&scmi_clk CK_SCMI_FLEXGEN_50>,
+				<&scmi_clk CK_SCMI_FLEXGEN_51>,
+				<&scmi_clk CK_SCMI_FLEXGEN_52>,
+				<&scmi_clk CK_SCMI_FLEXGEN_53>,
+				<&scmi_clk CK_SCMI_FLEXGEN_54>,
+				<&scmi_clk CK_SCMI_FLEXGEN_55>,
+				<&scmi_clk CK_SCMI_FLEXGEN_56>,
+				<&scmi_clk CK_SCMI_FLEXGEN_57>,
+				<&scmi_clk CK_SCMI_FLEXGEN_58>,
+				<&scmi_clk CK_SCMI_FLEXGEN_59>,
+				<&scmi_clk CK_SCMI_FLEXGEN_60>,
+				<&scmi_clk CK_SCMI_FLEXGEN_61>,
+				<&scmi_clk CK_SCMI_FLEXGEN_62>,
+				<&scmi_clk CK_SCMI_FLEXGEN_63>,
+				<&scmi_clk CK_SCMI_ICN_APB1>,
+				<&scmi_clk CK_SCMI_ICN_APB2>,
+				<&scmi_clk CK_SCMI_ICN_APB3>,
+				<&scmi_clk CK_SCMI_ICN_APB4>,
+				<&scmi_clk CK_SCMI_ICN_APBDBG>,
+				<&scmi_clk CK_SCMI_TIMG1>,
+				<&scmi_clk CK_SCMI_TIMG2>,
+				<&scmi_clk CK_SCMI_PLL3>,
+				<0>,
+				<&scmi_clk CK_SCMI_HSI_KER_CK>,
+				<&scmi_clk CK_SCMI_HSE_KER_CK>,
+				<&scmi_clk CK_SCMI_MSI_KER_CK>;
+			access-controllers = <&rifsc 156>;
+		};
+
+		pwr: syscon@44210000 {
+			compatible = "st,stm32mp25-pwr", "syscon";
+			reg = <0x44210000 0x0400>;
+		};
+
+		exti1: interrupt-controller@44220000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			power-domains = <&RET_PD>;
+			reg = <0x44220000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 0   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<&intc GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 209 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<&intc GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_80 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+			#clock-cells = <1>;
+		};
+
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			interrupt-parent = <&exti1>;
+			interrupts-extended =
+				<&exti1  0 0>, <&exti1  1 0>, <&exti1  2 0>, <&exti1  3 0>,
+				<&exti1  4 0>, <&exti1  5 0>, <&exti1  6 0>, <&exti1  7 0>,
+				<&exti1  8 0>, <&exti1  9 0>, <&exti1 10 0>, <&exti1 11 0>,
+				<&exti1 12 0>, <&exti1 13 0>, <&exti1 14 0>, <&exti1 15 0>,
+				<&exti2  0 0>, <&exti2  1 0>, <&exti2  2 0>, <&exti2  3 0>,
+				<&exti2  4 0>, <&exti2  5 0>, <&exti2  6 0>, <&exti2  7 0>,
+				<&exti2  8 0>, <&exti2  9 0>, <&exti2 10 0>, <&exti2 11 0>,
+				<&exti2 12 0>, <&exti2 13 0>, <&exti2 14 0>, <&exti2 15 0>;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		rtc: rtc@46000000 {
+			compatible = "st,stm32mp25-rtc";
+			reg = <0x46000000 0x400>;
+			clocks = <&scmi_clk CK_SCMI_RTC>,
+				 <&scmi_clk CK_SCMI_RTCCK>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti2 17 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x46010000 0x400>;
+			ranges;
+
+			nvram: nvram@46010100 {
+				compatible = "st,stm32mp25-tamp-nvram";
+				reg = <0x46010100 0x200>;
+				nvmem-layout {
+					compatible = "fixed-layout";
+					#address-cells = <1>;
+					#size-cells = <1>;
+					boot_mode: tamp-bkp@180 {
+						reg = <0x180 0x4>;
+					};
+					rsc_tbl_addr: tamp-bkp@184 {
+						reg = <0x184 0x4>;
+					};
+					rsc_tbl_size: tamp-bkp@188 {
+						reg = <0x188 0x4>;
+					};
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			interrupt-parent = <&exti1>;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+		};
+
+		exti2: interrupt-controller@46230000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x46230000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 17  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 18  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 19  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 20  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 21  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 22  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 25  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 26  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 27  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 28  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 29  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 30  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 12  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 13  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 14  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 15  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 11  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 5   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 4   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 2   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
+		};
+
+		ipcc2: mailbox@46250000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x46250000 0x400>;
+			st,proc-id = <1>;
+			interrupts-extended = <&exti2 34 0>,
+					      <&intc GIC_SPI 176 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi_clk CK_SCMI_IPCC2>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		ddrperfm: perf@48041000 {
+			compatible = "st,stm32mp25-ddr-pmu";
+			reg = <0x48041000 0x400>;
+			access-controllers = <&rcc 104>;
+			status = "disabled";
+		};
+
+		fmc: memory-controller@48200000 {
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+			#address-cells = <2>;
+			#size-cells = <1>;
+			clocks = <&scmi_clk CK_SCMI_FMC>;
+			resets = <&scmi_reset RST_SCMI_FMC>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+
+			nand-controller@4,0 {
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 0 0x62 0x00003101>,
+				       <&hpdma 0 0x62 0x00003110>,
+				       <&hpdma 1 0x22 0x00003113>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		a35ss_syscfg: syscon@48802000  {
+			compatible = "st,stm32mp25-a35ss-syscfg", "syscon";
+			reg = <0x48802000 0xac>;
+			status = "disabled";
+		};
+
+		cs_funnel: funnel@4a020000 {
+			compatible = "arm,coresight-dynamic-funnel", "arm,primecell";
+			reg = <0x4a020000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					funnel_in_port0: endpoint {
+						remote-endpoint = <&etm0_out_port>;
+					};
+				};
+
+				port@2 {
+					reg = <2>;
+					funnel_in_port2: endpoint {
+						remote-endpoint = <&stm_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					funnel_out_port: endpoint {
+						remote-endpoint = <&etf_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etf: etf@4a030000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a030000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					etf_in_port: endpoint {
+						remote-endpoint = <&funnel_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					etf_out_port: endpoint {
+						remote-endpoint = <&replicator_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etr: etr@4a040000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a040000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_BUS_ETR>, <&scmi_clk CK_SCMI_KER_ETR>;
+			clock-names = "apb_pclk", "atclk";
+			arm,max-burst-size = <3>;
+			arm,scatter-gather;
+			status = "disabled";
+
+			in-ports {
+				port {
+					etr_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port0>;
+					};
+				};
+			};
+		};
+
+		cs_tpiu: tpiu@4a050000 {
+			compatible = "arm,coresight-tpiu", "arm,primecell";
+			reg = <0x4a050000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_TPIU>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					tpiu_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port1>;
+					};
+				};
+			};
+		};
+
+		cs_stm: stm@4a080000 {
+			compatible = "arm,coresight-stm", "arm,primecell";
+			reg = <0x4a080000 0x1000>,
+			      <0x4a800000 0x400000>;
+			reg-names = "stm-base", "stm-stimulus-base";
+			clocks = <&scmi_clk CK_SCMI_BUS_STM>, <&scmi_clk CK_SCMI_KER_STM>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			out-ports {
+				port {
+					stm_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port2>;
+					};
+				};
+			};
+		};
+
+		cs_cti0: cti@4a090000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a090000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0 1>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <0 1>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etr>;
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-in-sigs = <2 3>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <2 3>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etf>;
+			};
+
+			trig-conns@2 {
+				reg = <2>;
+				arm,trig-out-sigs = <4 5>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_tpiu>;
+			};
+
+			trig-conns@3 {
+				reg = <3>;
+				arm,trig-in-sigs = <4 5 6 7>;
+				arm,trig-in-types = <STM_TOUT_SPTE
+						     STM_TOUT_SW
+						     STM_TOUT_HETE
+						     STM_ASYNCOUT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cti1: cti@4a0a0000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a0a0000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0>;
+				arm,trig-in-types = <GEN_IO>;
+				arm,trig-out-sigs = <0>;
+				arm,trig-out-types = <GEN_IO>;
+				arm,trig-conn-name = "dbtrgio";
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-out-sigs = <1 2>;
+				arm,trig-out-types = <STM_HWEVENT
+						      STM_HWEVENT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cpu_debug0: cpu-debug@4a210000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a210000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		cs_cti_cpu0: cti@4a220000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a220000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu0>;
+			arm,cs-dev-assoc = <&cs_etm0>;
+			status = "disabled";
+		};
+
+		cs_etm0: etm@4a240000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a240000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu0>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm0_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port0>;
+					};
+				};
+			};
+		};
+	};
+
+	mlahb: ahb@1 {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0xfffffffc>;
+		dma-ranges = <0x0 0x0 0x0 0xfffffffc>;
+
+		m33_rproc: m33@0 {
+			compatible = "st,stm32mp2-m33";
+			reg = <0 0>;
+			resets = <&scmi_reset RST_SCMI_C2_R>,
+				 <&scmi_reset RST_SCMI_C2_HOLDBOOT_R>;
+			reset-names = "mcu_rst", "hold_boot";
+			st,syscfg-cm-state = <&pwr 0x204 0x0000000c>;
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			nvmem-cells = <&rsc_tbl_addr>, <&rsc_tbl_size>;
+			nvmem-cell-names = "rsc-tbl-addr", "rsc-tbl-size";
+
+			status = "disabled";
+		};
+	};
+
+	ahbsr: ahb@2 {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0xfffffffc>;
+		dma-ranges = <0x0 0x0 0x0 0xfffffffc>;
+
+		m0_rproc: m0@0 {
+			compatible = "st,stm32mp2-m0";
+			reg = <0 0>;
+			clocks = <&rcc CK_CPU3>;
+			resets = <&rcc C3_R>;
+			reset-names = "mcu_rst";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+
+			status = "disabled";
+		};
+	};
+
+};
diff --git a/arch/arm/dts/stm32mp253.dtsi b/arch/arm/dts/stm32mp253.dtsi
new file mode 100644
index 0000000000..f1a9a854d7
--- /dev/null
+++ b/arch/arm/dts/stm32mp253.dtsi
@@ -0,0 +1,202 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp251.dtsi"
+
+/ {
+	cpus {
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD1>;
+			power-domain-names = "psci";
+		};
+	};
+
+	arm-pmu {
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>;
+	};
+
+	psci {
+		CPU_PD1: power-domain-cpu1 {
+			#power-domain-cells = <0>;
+			domain-idle-states =  <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+	};
+
+	timer {
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	soc@0 {
+		cs_cpu_debug1: cpu-debug@4a310000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a310000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+		};
+
+		cs_cti_cpu1: cti@4a320000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a320000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			arm,cs-dev-assoc = <&cs_etm1>;
+			status = "disabled";
+		};
+
+		cs_etm1: etm@4a340000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a340000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm1_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port1>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&cs_funnel {
+	in-ports {
+		port@1 {
+			reg = <1>;
+			funnel_in_port1: endpoint {
+				remote-endpoint = <&etm1_out_port>;
+			};
+		};
+	};
+};
+
+&intc {
+	interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+};
+
+&optee {
+	interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+};
+
+&rifsc {
+	m_can1: can@402d0000 {
+		compatible = "bosch,m_can";
+		reg = <0x402d0000 0x400>, <0x40310000 0xd50>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+		access-controllers = <&rifsc 56>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	m_can2: can@402e0000 {
+		compatible = "bosch,m_can";
+		reg = <0x402e0000 0x400>, <0x40310000 0x1aa0>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0xd50 0 0 32 0 0 2 2>;
+		access-controllers = <&rifsc 56>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	m_can3: can@402f0000 {
+		compatible = "bosch,m_can";
+		reg = <0x402f0000 0x400>, <0x40310000 0x2800>;
+		reg-names = "m_can", "message_ram";
+		interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "int0", "int1";
+		clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+		clock-names = "hclk", "cclk";
+		bosch,mram-cfg = <0x1aa0 0 0 32 0 0 2 2>;
+		access-controllers = <&rifsc 56>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	eth2: eth2@482d0000 {
+		compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+		reg = <0x482d0000 0x4000>;
+		reg-names = "stmmaceth";
+		interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+				      <&exti1 70 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq",
+				  "eth_wake_irq";
+		clock-names = "stmmaceth",
+			      "mac-clk-tx",
+			      "mac-clk-rx",
+			      "ptp_ref",
+			      "ethstp",
+			      "eth-ck";
+		clocks = <&rcc CK_ETH2_MAC>,
+			 <&rcc CK_ETH2_TX>,
+			 <&rcc CK_ETH2_RX>,
+			 <&rcc CK_KER_ETH2PTP>,
+			 <&rcc CK_ETH2_STP>,
+			 <&rcc CK_KER_ETH2>;
+		st,syscon = <&syscfg 0x3400 0xffffffff>;
+		snps,mixed-burst;
+		snps,pbl = <2>;
+		snps,txqos = <7>;
+		snps,rxqos = <7>;
+		snps,axi-config = <&stmmac_axi_config_2>;
+		snps,tso;
+		access-controllers = <&rifsc 61>;
+		power-domains = <&CLUSTER_PD>;
+		wakeup-source;
+		status = "disabled";
+		snps,mtl-rx-config = <&mtl_rx_setup_2>;
+		snps,mtl-tx-config = <&mtl_tx_setup_2>;
+
+		stmmac_axi_config_2: stmmac-axi-config {
+			snps,wr_osr_lmt = <0x7>;
+			snps,rd_osr_lmt = <0x7>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		mtl_rx_setup_2: rx-queues-config {
+			snps,rx-queues-to-use = <2>;
+			queue0 {};
+			queue1 {};
+		};
+
+		mtl_tx_setup_2: tx-queues-config {
+			snps,tx-queues-to-use = <4>;
+			queue0 {};
+			queue1 {};
+			queue2 {};
+			queue3 {};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp255.dtsi b/arch/arm/dts/stm32mp255.dtsi
new file mode 100644
index 0000000000..ce5c53b156
--- /dev/null
+++ b/arch/arm/dts/stm32mp255.dtsi
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/power/st,stm32mp25-power.h>
+#include "stm32mp253.dtsi"
+
+/ {
+	thermal-zones {
+		cpu-thermal {
+			trips {
+				gpu_alert: gpu-alert {
+					temperature = <110000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+			};
+
+			cooling-maps {
+				map1 {
+					trip = <&gpu_alert>;
+					cooling-device = <&gpu 1 6>;
+				};
+			};
+		};
+	};
+};
+
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>, <&syscfg 0>, <&lvds 0>;
+	clock-names = "bus", "ref", "lcd", "lvds";
+};
+
+&rcc {
+	clocks =
+		<&scmi_clk CK_SCMI_HSE>,
+		<&scmi_clk CK_SCMI_HSI>,
+		<&scmi_clk CK_SCMI_MSI>,
+		<&scmi_clk CK_SCMI_LSE>,
+		<&scmi_clk CK_SCMI_LSI>,
+		<&scmi_clk CK_SCMI_HSE_DIV2>,
+		<&scmi_clk CK_SCMI_ICN_HS_MCU>,
+		<&scmi_clk CK_SCMI_ICN_LS_MCU>,
+		<&scmi_clk CK_SCMI_ICN_SDMMC>,
+		<&scmi_clk CK_SCMI_ICN_DDR>,
+		<&scmi_clk CK_SCMI_ICN_DISPLAY>,
+		<&scmi_clk CK_SCMI_ICN_HSL>,
+		<&scmi_clk CK_SCMI_ICN_NIC>,
+		<&scmi_clk CK_SCMI_ICN_VID>,
+		<&scmi_clk CK_SCMI_FLEXGEN_07>,
+		<&scmi_clk CK_SCMI_FLEXGEN_08>,
+		<&scmi_clk CK_SCMI_FLEXGEN_09>,
+		<&scmi_clk CK_SCMI_FLEXGEN_10>,
+		<&scmi_clk CK_SCMI_FLEXGEN_11>,
+		<&scmi_clk CK_SCMI_FLEXGEN_12>,
+		<&scmi_clk CK_SCMI_FLEXGEN_13>,
+		<&scmi_clk CK_SCMI_FLEXGEN_14>,
+		<&scmi_clk CK_SCMI_FLEXGEN_15>,
+		<&scmi_clk CK_SCMI_FLEXGEN_16>,
+		<&scmi_clk CK_SCMI_FLEXGEN_17>,
+		<&scmi_clk CK_SCMI_FLEXGEN_18>,
+		<&scmi_clk CK_SCMI_FLEXGEN_19>,
+		<&scmi_clk CK_SCMI_FLEXGEN_20>,
+		<&scmi_clk CK_SCMI_FLEXGEN_21>,
+		<&scmi_clk CK_SCMI_FLEXGEN_22>,
+		<&scmi_clk CK_SCMI_FLEXGEN_23>,
+		<&scmi_clk CK_SCMI_FLEXGEN_24>,
+		<&scmi_clk CK_SCMI_FLEXGEN_25>,
+		<&scmi_clk CK_SCMI_FLEXGEN_26>,
+		<&scmi_clk CK_SCMI_FLEXGEN_27>,
+		<&scmi_clk CK_SCMI_FLEXGEN_28>,
+		<&scmi_clk CK_SCMI_FLEXGEN_29>,
+		<&scmi_clk CK_SCMI_FLEXGEN_30>,
+		<&scmi_clk CK_SCMI_FLEXGEN_31>,
+		<&scmi_clk CK_SCMI_FLEXGEN_32>,
+		<&scmi_clk CK_SCMI_FLEXGEN_33>,
+		<&scmi_clk CK_SCMI_FLEXGEN_34>,
+		<&scmi_clk CK_SCMI_FLEXGEN_35>,
+		<&scmi_clk CK_SCMI_FLEXGEN_36>,
+		<&scmi_clk CK_SCMI_FLEXGEN_37>,
+		<&scmi_clk CK_SCMI_FLEXGEN_38>,
+		<&scmi_clk CK_SCMI_FLEXGEN_39>,
+		<&scmi_clk CK_SCMI_FLEXGEN_40>,
+		<&scmi_clk CK_SCMI_FLEXGEN_41>,
+		<&scmi_clk CK_SCMI_FLEXGEN_42>,
+		<&scmi_clk CK_SCMI_FLEXGEN_43>,
+		<&scmi_clk CK_SCMI_FLEXGEN_44>,
+		<&scmi_clk CK_SCMI_FLEXGEN_45>,
+		<&scmi_clk CK_SCMI_FLEXGEN_46>,
+		<&scmi_clk CK_SCMI_FLEXGEN_47>,
+		<&scmi_clk CK_SCMI_FLEXGEN_48>,
+		<&scmi_clk CK_SCMI_FLEXGEN_49>,
+		<&scmi_clk CK_SCMI_FLEXGEN_50>,
+		<&scmi_clk CK_SCMI_FLEXGEN_51>,
+		<&scmi_clk CK_SCMI_FLEXGEN_52>,
+		<&scmi_clk CK_SCMI_FLEXGEN_53>,
+		<&scmi_clk CK_SCMI_FLEXGEN_54>,
+		<&scmi_clk CK_SCMI_FLEXGEN_55>,
+		<&scmi_clk CK_SCMI_FLEXGEN_56>,
+		<&scmi_clk CK_SCMI_FLEXGEN_57>,
+		<&scmi_clk CK_SCMI_FLEXGEN_58>,
+		<&scmi_clk CK_SCMI_FLEXGEN_59>,
+		<&scmi_clk CK_SCMI_FLEXGEN_60>,
+		<&scmi_clk CK_SCMI_FLEXGEN_61>,
+		<&scmi_clk CK_SCMI_FLEXGEN_62>,
+		<&scmi_clk CK_SCMI_FLEXGEN_63>,
+		<&scmi_clk CK_SCMI_ICN_APB1>,
+		<&scmi_clk CK_SCMI_ICN_APB2>,
+		<&scmi_clk CK_SCMI_ICN_APB3>,
+		<&scmi_clk CK_SCMI_ICN_APB4>,
+		<&scmi_clk CK_SCMI_ICN_APBDBG>,
+		<&scmi_clk CK_SCMI_TIMG1>,
+		<&scmi_clk CK_SCMI_TIMG2>,
+		<&scmi_clk CK_SCMI_PLL3>,
+		<&dsi>,
+		<&scmi_clk CK_SCMI_HSI_KER_CK>,
+		<&scmi_clk CK_SCMI_HSE_KER_CK>,
+		<&scmi_clk CK_SCMI_MSI_KER_CK>;
+};
+
+&rifsc {
+	dsi: dsi@48000000 {
+		compatible = "st,stm32mp25-dsi";
+		reg = <0x48000000 0x800>;
+		#clock-cells = <0>;
+		clocks = <&rcc CK_BUS_DSI>, <&rcc CK_KER_DSIPHY>,
+			 <&rcc CK_KER_LTDC>;
+		clock-names = "pclk", "ref", "px_clk";
+		resets = <&rcc DSI_R>;
+		reset-names = "apb";
+		access-controllers = <&rifsc 81>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	lvds: lvds@48060000 {
+		#clock-cells = <0>;
+		compatible = "st,stm32mp25-lvds";
+		reg = <0x48060000 0x2000>;
+		clocks = <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>, <&syscfg 0>;
+		clock-names = "pclk", "ref", "pixclk";
+		resets = <&rcc LVDS_R>;
+		access-controllers = <&rifsc 84>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	vdec: vdec@480d0000 {
+		compatible = "st,stm32mp25-vdec";
+		reg = <0x480d0000 0x3c8>;
+		resets = <&rcc VDEC_R>;
+		interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_VDEC>;
+		access-controllers = <&rifsc 89>;
+		power-domains = <&CLUSTER_PD>;
+	};
+
+	venc: venc@480e0000 {
+		compatible = "st,stm32mp25-venc";
+		reg = <0x480e0000 0x800>;
+		resets = <&rcc VENC_R>;
+		interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_VENC>;
+		access-controllers = <&rifsc 90>;
+		power-domains = <&CLUSTER_PD>;
+	};
+
+	gpu: gpu@48280000 {
+		compatible = "vivante,gc";
+		reg = <0x48280000 0x800>;
+		interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+		resets = <&rcc GPU_R>;
+		clock-names = "bus", "core";
+		clocks = <&rcc CK_BUS_GPU>, <&rcc CK_KER_GPU>;
+		power-domains = <&scmi_devpd PD_SCMI_GPU>, <&CLUSTER_PD>;
+		access-controllers = <&rifsc 79>;
+		status = "disabled";
+
+		throttle,max_state = <6>;
+		#cooling-cells = <2>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp257.dtsi b/arch/arm/dts/stm32mp257.dtsi
new file mode 100644
index 0000000000..b9823fd079
--- /dev/null
+++ b/arch/arm/dts/stm32mp257.dtsi
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp255.dtsi"
+
+&rifsc {
+	switch0: ttt-sw@4c000000 {
+		#address-cells  = <1>;
+		#size-cells     = <1>;
+		compatible = "st,stm32-deip";
+		clock-names = "ethsw-bus-clk", "ethsw-clk",
+			      "ethswacmcfg-bus-clk", "ethswacmmsg-bus-clk";
+		clocks = <&rcc CK_BUS_ETHSW>,
+			 <&rcc CK_KER_ETHSW>,
+			 <&rcc CK_BUS_ETHSWACMCFG>,
+			 <&rcc CK_BUS_ETHSWACMMSG>;
+		st,syscon = <&syscfg 0x3800>;
+		ranges = <0x4c000000 0x4c000000 0x2000000>,
+			 <0x4b000000 0x4b000000 0xc0000>;
+		access-controllers = <&rifsc 70>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+
+		deip_sw0: deip-sw@4c000000 {
+			compatible =  "ttt,deip-sw";
+			reg = <0x4c000000 0x2000000>;
+			interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		acm@4b000000 {
+			compatible = "ttt,acm-4.0";
+			reg = <0x4b000000 0x00400>,
+			      <0x4b010000 0x10000>,
+			      <0x4b030000 0x10000>,
+			      <0x4b050000 0x10000>,
+			      <0x4b060000 0x20000>,
+			      <0x4b080000 0x40000>;
+			reg-names = "CommonRegister",
+				    "Bypass1",
+				    "Bypass0",
+				    "Redundancy",
+				    "Scheduler",
+				    "Messagebuffer";
+			buffers = <32>;
+			ptp_worker = <&deip_sw0>;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi b/arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi
new file mode 100644
index 0000000000..243df32b68
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi
@@ -0,0 +1,185 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 3/6/2024 11:20:05 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm0_cube_fw: cm0-cube-fw@200C0000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x200C0000 0x0 0x4000>;
+			no-map;
+		};
+
+		cm0_cube_data: cm0-cube-data@200C4000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x200C4000 0x0 0x2000>;
+			no-map;
+		};
+
+		ipc_shmem_2: ipc-shmem-2@200C6000{
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x200C6000 0x0 0x2000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-dk-u-boot.dtsi b/arch/arm/dts/stm32mp257f-dk-u-boot.dtsi
new file mode 100644
index 0000000000..74a8c61e4f
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-dk-u-boot.dtsi
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+
+#include "stm32mp25-u-boot.dtsi"
+
+/ {
+	config {
+		u-boot,boot-led = "led-blue";
+		u-boot,mmc-env-partition = "u-boot-env";
+		st,stm32prog-gpios = <&gpioc 11 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&dwc3 {
+	phys = <&usb2_phy2>;
+	phy-names = "usb2-phy";
+	dr_mode = "peripheral";
+	maximum-speed = "high-speed";
+	/delete-node/ port;
+};
+
+&i2c_rpmsg {
+	/delete-node/ typec@35;
+};
+
+&sdmmc3 {
+	status = "disabled";
+};
+
+&usart2 {
+	bootph-all;
+};
+
+&usart2_pins_a {
+	bootph-all;
+	pins1 {
+		bootph-all;
+	};
+	pins2 {
+		bootph-all;
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-dk.dts b/arch/arm/dts/stm32mp257f-dk.dts
new file mode 100644
index 0000000000..c41c573761
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-dk.dts
@@ -0,0 +1,890 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxak-pinctrl.dtsi"
+#include "stm32mp257f-dk-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-DK Discovery Board";
+	compatible = "st,stm32mp257f-dk", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &usart1;
+		ethernet0 = &eth1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>,
+				 <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_ext_cec: clk-ext-cec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "okay";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "okay";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint1>;
+			};
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpioc 5 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpioc 11 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioh 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+		hdmi-pwr-supply = <&scmi_v5v_hdmi>;
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv7535_out>;
+			};
+		};
+	};
+
+	imx335_2v9: imx335-2v9 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-avdd";
+		regulator-min-microvolt = <2900000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-always-on;
+	};
+
+	imx335_1v8: imx335-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-ovdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	imx335_1v2: imx335-1v2 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-dvdd";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-always-on;
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x0>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpioi 4 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		default-on;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-DK";
+		dais = <&i2s2_port &mdf1_port0 &mdf1_port1>;
+		status = "okay";
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpiog 8 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&ahbsr {
+	mbox_client: mailbox-client@1 {
+		compatible = "mbox-cdev";
+		reg = <1 0>;
+		memory-region =  <&ipc_shmem_2>;
+		mboxes = <&ipcc2 0>;
+		mbox-names = "rx-tx";
+		status = "okay";
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&combophy {
+	st,ssc-on;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&cs_cpu_debug0 {
+	status = "okay";
+};
+
+&cs_cpu_debug1 {
+	status = "okay";
+};
+
+&cs_cti0 {
+	status = "okay";
+};
+
+&cs_cti1 {
+	status = "okay";
+};
+
+&cs_cti_cpu0 {
+	status = "okay";
+};
+
+&cs_cti_cpu1 {
+	status = "okay";
+};
+
+&cs_etf {
+	status = "okay";
+};
+
+&cs_etm0 {
+	status = "okay";
+};
+
+&cs_etm1 {
+	status = "okay";
+};
+
+&cs_etr {
+	status = "okay";
+};
+
+&cs_funnel {
+	status = "okay";
+};
+
+&cs_replicator {
+	status = "okay";
+};
+
+&cs_stm {
+	status = "okay";
+};
+
+&cs_tpiu {
+	status = "okay";
+};
+
+&csi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv7535_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_b>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_b>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioa 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_b>;
+	pinctrl-1 = <&i2c2_sleep_pins_b>;
+	i2c-scl-rising-time-ns = <108>;
+	i2c-scl-falling-time-ns = <12>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		avdd-supply = <&imx335_2v9>;
+		ovdd-supply = <&imx335_1v8>;
+		dvdd-supply = <&imx335_1v2>;
+		reset-gpios = <&gpiob 1 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpiob 11 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv7535: hdmi@3d {
+		compatible = "adi,adv7535";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		status = "okay";
+		adi,dsi-lanes = <4>;
+		clocks = <&clk_ext_cec>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiob>;
+		interrupts = <4 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiob 6 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv7535_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv7535_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv7535_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpioi 0 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <100000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_b>;
+	pinctrl-1 = <&i2s2_sleep_pins_b>;
+	status = "okay";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv7535_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&ipcc2 {
+	status = "okay";
+};
+
+/* use LPTIMER with tick broadcast for suspend mode */
+&lptimer3 {
+	status = "okay";
+	timer {
+		status = "okay";
+	};
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	default-on;
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m0_rproc {
+	mboxes = <&ipcc2 0>, <&ipcc2 1>, <&ipcc2 2>;
+	mbox-names = "rx", "tx", "shutdown";
+	memory-region = <&cm0_cube_fw>, <&cm0_cube_data>;
+	clocks = <&rcc CK_CPU3>,
+		 <&rcc CK_CPU3_AM>,
+		 <&scmi_clk CK_SCMI_IPCC2>,
+		 <&scmi_clk CK_SCMI_IPCC2_AM>;
+	status = "okay";
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&mdf1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdf_cck0_pins_a>;
+	pinctrl-1 = <&mdf_cck0_sleep_pins_a>;
+	#clock-cells = <1>;
+	clock-output-names = "cck0";
+	clock-frequency = <1536000>;
+	status = "okay";
+
+	sitf6: sitf@380 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&mdf_sdi6_pins_a>;
+		pinctrl-1 = <&mdf_sdi6_sleep_pins_a>;
+		st,sitf-mode = "spi";
+		clocks = <&mdf1 0>;
+		status = "okay";
+	};
+
+	filter0: filter@84  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf6 0>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm0: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter0 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port0: port {
+				mdf_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	filter1: filter@104  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf6 1>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm1: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter1 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port1: port {
+				mdf_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_v5v_hdmi: regulator@21 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO5>;
+		regulator-name = "v5v_hdmi";
+	};
+	scmi_v5v_vconn: regulator@22 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO6>;
+		regulator-name = "v5v_vconn";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_b>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_b>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	status = "okay";
+};
+
+/* Wifi */
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	cap-sdio-irq;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		status = "disabled";
+	};
+};
+
+&spi6 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi6_pins_a>;
+	pinctrl-1 = <&spi6_sleep_pins_a>;
+	status = "disabled";
+};
+
+/* Bluetooth */
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpiog 4 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&scmi_v3v3>;
+		vddio-supply = <&scmi_v3v3>;
+	};
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ehci: usb@482f0000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		/* onboard HUB */
+		hub@1 {
+			compatible = "usb424,2514";
+			reg = <1>;
+			vdd-supply = <&scmi_v3v3>;
+		};
+	};
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		phys            = <&usb2_phy2>, <&combophy PHY_TYPE_USB3>;
+		phy-names       = "usb2-phy", "usb3-phy";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi b/arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
new file mode 100644
index 0000000000..58266b81c7
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 7/4/2023 9:06:24 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm0_cube_fw: cm0-cube-fw@200C0000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x200C0000 0x0 0x4000>;
+			no-map;
+		};
+
+		cm0_cube_data: cm0-cube-data@200C4000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x200C4000 0x0 0x2000>;
+			no-map;
+		};
+
+		ipc_shmem_2: ipc-shmem-2@200C6000{
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x200C6000 0x0 0x2000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..62bb801258
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ */
+
+#include "stm32mp25-u-boot.dtsi"
+
+/ {
+	aliases {
+		spi0 = &ospi1;
+	};
+
+	config {
+		u-boot,boot-led = "led-blue";
+		u-boot,mmc-env-partition = "u-boot-env";
+		st,stm32prog-gpios = <&gpioc 11 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&dwc3 {
+	dr_mode = "peripheral";
+	/delete-node/ port;
+};
+
+&flash0 {
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "fsbla1";
+			reg = <0x00000000 0x00040000>;
+		};
+		partition@40000 {
+			label = "fsbla2";
+			reg = <0x00040000 0x00040000>;
+		};
+		partition@80000 {
+			label = "metadata1";
+			reg = <0x00080000 0x00040000>;
+		};
+		partition@C0000 {
+			label = "metadata2";
+			reg = <0x000C0000 0x00040000>;
+		};
+		partition@100000 {
+			label = "fip-a";
+			reg = <0x00100000 0x00400000>;
+		};
+		partition@500000 {
+			label = "fip-b";
+			reg = <0x00500000 0x00400000>;
+		};
+		partition@900000 {
+			label = "u-boot-env";
+			reg = <0x00900000 0x00080000>;
+		};
+		partition@980000 {
+			label = "nor-user";
+			reg = <0x00980000 0x03680000>;
+		};
+	};
+};
+
+
+&i2c_rpmsg {
+       /delete-node/ typec@35;
+};
+
+&usart2 {
+	bootph-all;
+};
+
+&usart2_pins_a {
+	bootph-all;
+	pins1 {
+		bootph-all;
+	};
+	pins2 {
+		bootph-all;
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-ev1.dts b/arch/arm/dts/stm32mp257f-ev1.dts
new file mode 100644
index 0000000000..af6775d0ad
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-ev1.dts
@@ -0,0 +1,913 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+#include "stm32mp257f-ev1-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-EV1 Evaluation Board";
+	compatible = "st,stm32mp257f-ev1", "st,stm32mp257";
+
+	aliases {
+		ethernet0 = &eth2;
+		ethernet1 = &eth1;
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &lpuart1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>,
+				 <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		cec_clock: cec-clock {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <12000000>;
+		};
+
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		pad_clk: pad-clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpiod 2 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpiog 8 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			wakeup-source;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			label = "heartbeat";
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioj 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv753x_out>;
+			};
+		};
+	};
+
+	imx335_2v9: imx335-2v9 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-avdd";
+		regulator-min-microvolt = <2900000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-always-on;
+	};
+
+	imx335_1v8: imx335-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-ovdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	imx335_1v2: imx335-1v2 {
+		compatible = "regulator-fixed";
+		regulator-name = "imx335-dvdd";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-always-on;
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x0>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpiog 15 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 5 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-EV1";
+		dais = <&i2s2_port>;
+		status = "disabled";
+	};
+
+	vdiv_ana0: voltage-divider-ana0 {
+		compatible = "voltage-divider";
+		io-channels = <&adc1 0>;
+		output-ohms = <560000>;
+		full-ohms = <1030000>;
+		status = "disabled";
+	};
+};
+
+&adc_12 {
+	/* Don't need a pinctrl for ANA0 dedicated pin e.g. Channel@0 */
+	vdda-supply = <&scmi_v1v8>;
+	vref-supply = <&scmi_v1v8>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&ahbsr {
+	mbox_client: mailbox-client@1 {
+		compatible = "mbox-cdev";
+		reg = <1 0>;
+		memory-region =  <&ipc_shmem_2>;
+		mboxes = <&ipcc2 0>;
+		mbox-names = "rx-tx";
+		status = "okay";
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&combophy {
+	clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>, <&pad_clk>;
+	clock-names = "apb-clk", "ker-clk", "pad-clk";
+	st,rx_equalizer = <1>;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&cs_cpu_debug0 {
+	status = "okay";
+};
+
+&cs_cpu_debug1 {
+	status = "okay";
+};
+
+&cs_cti0 {
+	status = "okay";
+};
+
+&cs_cti1 {
+	status = "okay";
+};
+
+&cs_cti_cpu0 {
+	status = "okay";
+};
+
+&cs_cti_cpu1 {
+	status = "okay";
+};
+
+&cs_etf {
+	status = "okay";
+};
+
+&cs_etm0 {
+	status = "okay";
+};
+
+&cs_etm1 {
+	status = "okay";
+};
+
+&cs_etr {
+	status = "okay";
+};
+
+&cs_funnel {
+	status = "okay";
+};
+
+&cs_replicator {
+	status = "okay";
+};
+
+&cs_stm {
+	status = "okay";
+};
+
+&cs_tpiu {
+	status = "okay";
+};
+
+&csi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv753x_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_a &eth1_mdio_pins_a>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_a &eth1_mdio_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-clk-sel;
+	snps,ext-systime;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@4 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioj 9 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <4>;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rgmii_pins_a>;
+	pinctrl-1 = <&eth2_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth2>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth2: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpiog 6 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <13>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		avdd-supply = <&imx335_2v9>;
+		ovdd-supply = <&imx335_1v8>;
+		dvdd-supply = <&imx335_1v2>;
+		reset-gpios = <&gpioi 7 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpioi 0 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv753x: hdmi@3d {
+		/*
+		 * With MB1232 board, use "adi,adv7533" (1080p30)
+		 * With MB1752 board, use "adi,adv7535" (1080p60)
+		 */
+		compatible = "adi,adv7533";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		clocks = <&cec_clock>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiod>;
+		interrupts = <10 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+		adi,dsi-lanes = <4>;
+		reset-gpios = <&gpiog 14 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv753x_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv753x_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv753x_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiog 14 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <57>;
+	i2c-scl-falling-time-ns = <7>;
+	clock-frequency = <400000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_a>;
+	pinctrl-1 = <&i2s2_sleep_pins_a>;
+	status = "disabled";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv753x_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&ipcc2 {
+	status = "okay";
+};
+
+/* use LPTIMER with tick broadcast for suspend mode */
+&lptimer3 {
+	status = "okay";
+	timer {
+		status = "okay";
+	};
+};
+
+&lpuart1 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&lpuart1_pins_a>;
+	pinctrl-1 = <&lpuart1_idle_pins_a>;
+	pinctrl-2 = <&lpuart1_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&ltdc {
+	default-on;
+	rotation-memory = <&ltdc_sec_rotation>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	default-on;
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m0_rproc {
+	mboxes = <&ipcc2 0>, <&ipcc2 1>, <&ipcc2 2>;
+	mbox-names = "rx", "tx", "shutdown";
+	memory-region = <&cm0_cube_fw>, <&cm0_cube_data>;
+	clocks = <&rcc CK_CPU3>,
+		 <&rcc CK_CPU3_AM>,
+		 <&rcc CK_LPUART1_C3>,
+		 <&rcc CK_KER_LPUART1>,
+		 <&rcc CK_LPUART1_AM>,
+		 <&scmi_clk CK_SCMI_IPCC2>,
+		 <&scmi_clk CK_SCMI_IPCC2_AM>;
+	status = "okay";
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&m_can3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can3_pins_a>;
+	pinctrl-1 = <&m_can3_sleep_pins_a>;
+	status = "okay";
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+		status = "okay";
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&ommanager {
+	memory-region = <&mm_ospi1>;
+	memory-region-names = "mm_ospi1";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ospi_port1_clk_pins_a
+		     &ospi_port1_io03_pins_a
+		     &ospi_port1_cs0_pins_a>;
+	pinctrl-1 = <&ospi_port1_clk_sleep_pins_a
+		     &ospi_port1_io03_sleep_pins_a
+		     &ospi_port1_cs0_sleep_pins_a>;
+	status = "okay";
+
+	spi@40430000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		memory-region = <&mm_ospi1>;
+		status = "okay";
+
+		flash0: flash@0 {
+			compatible = "jedec,spi-nor";
+			reg = <0>;
+			spi-rx-bus-width = <4>;
+			spi-tx-bus-width = <4>;
+			spi-max-frequency = <84000000>;
+		};
+	};
+};
+
+&pcie_ep {
+	pinctrl-names = "default", "init";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	status = "disabled";
+};
+
+&pcie_rc {
+	pinctrl-names = "default", "init", "sleep";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	pinctrl-2 = <&pcie_sleep_pins_a>;
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	wakeup-source;
+	wake-gpios = <&gpioh 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	status = "disabled";
+};
+
+&spi3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi3_pins_a>;
+	pinctrl-1 = <&spi3_sleep_pins_a>;
+	status = "disabled";
+};
+
+&spi8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi8_pins_a>;
+	pinctrl-1 = <&spi8_sleep_pins_a>;
+	status = "disabled";
+};
+
+&switch0 {
+	status = "disabled";
+	pinctrl-0 = <&eth1_rgmii_pins_a>, <&eth3_rgmii_pins_a>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_a>, <&eth3_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii";
+	st,ethsw-internal-125;
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ehci: usb@482f0000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		/* onboard HUB */
+		hub@1 {
+			compatible = "usb424,2514";
+			reg = <1>;
+			vdd-supply = <&scmi_v3v3>;
+		};
+	};
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		maximum-speed = "high-speed";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xc.dtsi b/arch/arm/dts/stm32mp25xc.dtsi
new file mode 100644
index 0000000000..2f6bbb9d4d
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xc.dtsi
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 96>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	cryp2: crypto@42040000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42040000 0x1000>;
+		interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP2>;
+		resets = <&rcc CRYP2_R>;
+		dmas = <&hpdma 140 0x40 0x3021 0x0>,
+		       <&hpdma 141 0x43 0x3012 0x0>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 97>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xf.dtsi b/arch/arm/dts/stm32mp25xf.dtsi
new file mode 100644
index 0000000000..2f6bbb9d4d
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xf.dtsi
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 96>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	cryp2: crypto@42040000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42040000 0x1000>;
+		interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP2>;
+		resets = <&rcc CRYP2_R>;
+		dmas = <&hpdma 140 0x40 0x3021 0x0>,
+		       <&hpdma 141 0x43 0x3012 0x0>;
+		dma-names = "in", "out";
+		access-controllers = <&rifsc 97>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxai-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxai-pinctrl.dtsi
new file mode 100644
index 0000000000..abdbc7aebc
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxai-pinctrl.dtsi
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AI>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@442d0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@442e0000 {
+		status = "okay";
+		ngpios = <8>;
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxaj-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxaj-pinctrl.dtsi
new file mode 100644
index 0000000000..036b0946cc
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxaj-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AJ>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxak-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxak-pinctrl.dtsi
new file mode 100644
index 0000000000..2e0d4d349d
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxak-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AK>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxal-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxal-pinctrl.dtsi
new file mode 100644
index 0000000000..2406e97255
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxal-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AL>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index 87d1c77e8b..8db8bfd354 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -512,14 +512,6 @@ enum dcache_option {
 };
 #endif
 
-#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
-#define DCACHE_DEFAULT_OPTION	DCACHE_WRITETHROUGH
-#elif defined(CONFIG_SYS_ARM_CACHE_WRITEALLOC)
-#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEALLOC
-#elif defined(CONFIG_SYS_ARM_CACHE_WRITEBACK)
-#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEBACK
-#endif
-
 /* Size of an MMU section */
 enum {
 #ifdef CONFIG_ARMV7_LPAE
@@ -577,6 +569,14 @@ void psci_system_reset(void);
 
 #endif /* CONFIG_ARM64 */
 
+#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
+#define DCACHE_DEFAULT_OPTION	DCACHE_WRITETHROUGH
+#elif defined(CONFIG_SYS_ARM_CACHE_WRITEALLOC)
+#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEALLOC
+#elif defined(CONFIG_SYS_ARM_CACHE_WRITEBACK)
+#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEBACK
+#endif
+
 #ifndef __ASSEMBLY__
 /**
  * save_boot_params() - Save boot parameters before starting reset sequence
diff --git a/arch/arm/mach-stm32/Kconfig b/arch/arm/mach-stm32/Kconfig
index a44ebf2597..61ad8daab4 100644
--- a/arch/arm/mach-stm32/Kconfig
+++ b/arch/arm/mach-stm32/Kconfig
@@ -10,7 +10,6 @@ config STM32F4
 	select PINCTRL_STM32
 	select RAM
 	select STM32_RCC
-	select STM32_RESET
 	select STM32_SDRAM
 	select STM32_SERIAL
 	select STM32_TIMER
@@ -26,7 +25,6 @@ config STM32F7
 	select PINCTRL_STM32
 	select RAM
 	select STM32_RCC
-	select STM32_RESET
 	select STM32_SDRAM
 	select STM32_SERIAL
 	select STM32_TIMER
@@ -45,7 +43,6 @@ config STM32H7
 	select RAM
 	select REGMAP
 	select STM32_RCC
-	select STM32_RESET
 	select STM32_SDRAM
 	select STM32_SERIAL
 	select STM32_TIMER
diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index db47baba6d..e87eaee8b2 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -35,9 +35,9 @@ config ENV_SIZE
 
 choice
 	prompt "Select STMicroelectronics STM32MPxxx Soc"
-	default STM32MP15x
+	default STM32MP15X
 
-config STM32MP13x
+config STM32MP13X
 	bool "Support STMicroelectronics STM32MP13x Soc"
 	select ARM_SMCCC
 	select CPU_V7A
@@ -47,15 +47,15 @@ config STM32MP13x
 	select OF_BOARD_SETUP
 	select PINCTRL_STM32
 	select STM32_RCC
-	select STM32_RESET
 	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
 	select SYS_ARCH_TIMER
 	imply CMD_NVEDIT_INFO
 	help
 		support of STMicroelectronics SOC STM32MP13x family
 		STMicroelectronics MPU with core ARMv7
 
-config STM32MP15x
+config STM32MP15X
 	bool "Support STMicroelectronics STM32MP15x Soc"
 	select ARCH_SUPPORT_PSCI
 	select BINMAN
@@ -66,8 +66,8 @@ config STM32MP15x
 	select OF_BOARD_SETUP
 	select PINCTRL_STM32
 	select STM32_RCC
-	select STM32_RESET
 	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
 	select SUPPORT_SPL
 	select SYS_ARCH_TIMER
 	imply CMD_NVEDIT_INFO
@@ -76,6 +76,83 @@ config STM32MP15x
 		STM32MP157, STM32MP153 or STM32MP151
 		STMicroelectronics MPU with core ARMv7
 		dual core A7 for STM32MP157/3, monocore for STM32MP151
+
+config STM32MP21X
+	bool "Support STMicroelectronics STM32MP21X Soc"
+	select ARM64
+	select CLK_STM32MP21
+	select OF_BOARD
+	select OF_BOARD_SETUP
+	select PINCTRL_STM32
+	select STM32_RCC
+	select STM32_RESET
+	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
+	select SYS_ARCH_TIMER
+	select TFABOOT
+	imply CLK_SCMI
+	imply CMD_NVEDIT_INFO
+	imply DM_REGULATOR
+	imply DM_REGULATOR_SCMI
+	imply OPTEE
+	imply RESET_SCMI
+	imply SYSRESET_PSCI
+	imply TEE
+	imply VERSION_VARIABLE
+	help
+		Support of STMicroelectronics SOC STM32MP21X family
+		STMicroelectronics MPU with 1 A35 core and 1 M33 core
+
+config STM32MP23X
+	bool "Support STMicroelectronics STM32MP23x Soc"
+	select ARM64
+	select CLK_STM32MP25
+	select OF_BOARD
+	select OF_BOARD_SETUP
+	select PINCTRL_STM32
+	select STM32_RCC
+	select STM32_RESET
+	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
+	select SYS_ARCH_TIMER
+	select TFABOOT
+	imply CLK_SCMI
+	imply CMD_NVEDIT_INFO
+	imply DM_REGULATOR
+	imply DM_REGULATOR_SCMI
+	imply OPTEE
+	imply RESET_SCMI
+	imply SYSRESET_PSCI
+	imply TEE
+	imply VERSION_VARIABLE
+	help
+		Support of STMicroelectronics SOC STM32MP23x family
+		STMicroelectronics MPU with 2 * A53 core and 1 M33 core
+
+config STM32MP25X
+	bool "Support STMicroelectronics STM32MP25x Soc"
+	select ARM64
+	select CLK_STM32MP25
+	select OF_BOARD
+	select OF_BOARD_SETUP
+	select PINCTRL_STM32
+	select STM32_RCC
+	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
+	select SYS_ARCH_TIMER
+	select TFABOOT
+	imply CLK_SCMI
+	imply CMD_NVEDIT_INFO
+	imply DM_REGULATOR
+	imply DM_REGULATOR_SCMI
+	imply OPTEE
+	imply RESET_SCMI
+	imply SYSRESET_PSCI
+	imply TEE
+	imply VERSION_VARIABLE
+	help
+		Support of STMicroelectronics SOC STM32MP25x family
+		STMicroelectronics MPU with 2 * A53 core and 1 M33 core
 endchoice
 
 config NR_DRAM_BANKS
@@ -84,6 +161,7 @@ config NR_DRAM_BANKS
 config DDR_CACHEABLE_SIZE
 	hex "Size of the DDR marked cacheable in pre-reloc stage"
 	default 0x40000000
+	depends on STM32MP15X || STM32MP13X
 	help
 		Define the size of the DDR marked as cacheable in U-Boot
 		pre-reloc stage.
@@ -101,14 +179,6 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_MMC2
 	  Partition on the second MMC to load U-Boot from when the MMC is being
 	  used in raw mode
 
-config STM32_ETZPC
-	bool "STM32 Extended TrustZone Protection"
-	depends on STM32MP15x || STM32MP13x
-	default y
-	imply BOOTP_SERVERIP
-	help
-	  Say y to enable STM32 Extended TrustZone Protection
-
 config STM32_ECDSA_VERIFY
 	bool "STM32 ECDSA verification via the ROM API"
 	depends on SPL_ECDSA_VERIFY
@@ -118,6 +188,15 @@ config STM32_ECDSA_VERIFY
 	  ROM API provided on STM32MP.
 	  The ROM API is only available during SPL for now.
 
+config STM32MP_TAMP_NVMEM
+	bool "STM32 TAMP backup registers via NVMEM API"
+	select NVMEM
+	default y
+	help
+	  Say y to enable the uclass driver for TAMP Backup registers using the
+	  NVMEM API. It allows to access to boot mode or others shared information
+	  between software components/execution levels.
+
 config CMD_STM32KEY
 	bool "command stm32key to fuse public key hash"
 	help
@@ -128,6 +207,8 @@ config CMD_STM32KEY
 
 source "arch/arm/mach-stm32mp/Kconfig.13x"
 source "arch/arm/mach-stm32mp/Kconfig.15x"
-
+source "arch/arm/mach-stm32mp/Kconfig.21x"
+source "arch/arm/mach-stm32mp/Kconfig.23x"
+source "arch/arm/mach-stm32mp/Kconfig.25x"
 source "arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig"
 endif
diff --git a/arch/arm/mach-stm32mp/Kconfig.13x b/arch/arm/mach-stm32mp/Kconfig.13x
index acc02a5a18..2f6bb1ad49 100644
--- a/arch/arm/mach-stm32mp/Kconfig.13x
+++ b/arch/arm/mach-stm32mp/Kconfig.13x
@@ -1,17 +1,15 @@
-if STM32MP13x
+if STM32MP13X
 
 choice
 	prompt "STM32MP13x board select"
 	optional
 
-config TARGET_ST_STM32MP13x
+config TARGET_ST_STM32MP13X
 	bool "STMicroelectronics STM32MP13x boards"
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 		target the STMicroelectronics board with SOC STM32MP13x
 		managed by board/st/stm32mp1.
diff --git a/arch/arm/mach-stm32mp/Kconfig.15x b/arch/arm/mach-stm32mp/Kconfig.15x
index 1d32f8bf33..0dadf3bd25 100644
--- a/arch/arm/mach-stm32mp/Kconfig.15x
+++ b/arch/arm/mach-stm32mp/Kconfig.15x
@@ -1,6 +1,6 @@
-if STM32MP15x
+if STM32MP15X
 
-config STM32MP15x_STM32IMAGE
+config STM32MP15X_STM32IMAGE
 	bool "Support STM32 image for generated U-Boot image"
 	depends on TFABOOT
 	help
@@ -11,14 +11,12 @@ choice
 	prompt "STM32MP15x board select"
 	optional
 
-config TARGET_ST_STM32MP15x
+config TARGET_ST_STM32MP15X
 	bool "STMicroelectronics STM32MP15x boards"
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 		target the STMicroelectronics board with SOC STM32MP15x
 		managed by board/st/stm32mp1:
@@ -35,9 +33,7 @@ config TARGET_MICROGEA_STM32MP1
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 	  MicroGEA STM32MP1 is a STM32MP157A based Micro SOM.
 
@@ -59,9 +55,7 @@ config TARGET_ICORE_STM32MP1
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 	  i.Core STM32MP1 is an EDIMM SOM based on STM32MP157A.
 
diff --git a/arch/arm/mach-stm32mp/Kconfig.21x b/arch/arm/mach-stm32mp/Kconfig.21x
new file mode 100644
index 0000000000..aff32849c5
--- /dev/null
+++ b/arch/arm/mach-stm32mp/Kconfig.21x
@@ -0,0 +1,43 @@
+if STM32MP21X
+
+choice
+	prompt "STM32MP21X board select"
+	optional
+
+config TARGET_ST_STM32MP21X
+	bool "STMicroelectronics STM32MP21X boards"
+	imply BOOTSTAGE
+	imply CMD_BOOTSTAGE
+	help
+		target the STMicroelectronics board with SOC STM32MP21X
+		managed by board/st/stm32mp2
+		The difference between board are managed with devicetree
+
+endchoice
+
+config TEXT_BASE
+	default 0x84000000
+
+config PRE_CON_BUF_ADDR
+	default 0x84800000
+
+config PRE_CON_BUF_SZ
+	default 4096
+
+config BOOTSTAGE_STASH_ADDR
+	default 0x87000000
+
+if DEBUG_UART
+
+config DEBUG_UART_BOARD_INIT
+	default y
+
+# debug on USART2 by default
+config DEBUG_UART_BASE
+	default 0x400e0000
+
+endif
+
+source "board/st/stm32mp2/Kconfig"
+
+endif
diff --git a/arch/arm/mach-stm32mp/Kconfig.23x b/arch/arm/mach-stm32mp/Kconfig.23x
new file mode 100644
index 0000000000..7adb8ed8e5
--- /dev/null
+++ b/arch/arm/mach-stm32mp/Kconfig.23x
@@ -0,0 +1,43 @@
+if STM32MP23X
+
+choice
+	prompt "STM32MP23x board select"
+	optional
+
+config TARGET_ST_STM32MP23X
+	bool "STMicroelectronics STM32MP23x boards"
+	imply BOOTSTAGE
+	imply CMD_BOOTSTAGE
+	help
+		target the STMicroelectronics board with SOC STM32MP23x
+		managed by board/st/stm32mp2
+		The difference between board are managed with devicetree
+
+endchoice
+
+config TEXT_BASE
+	default 0x84000000
+
+config PRE_CON_BUF_ADDR
+	default 0x84800000
+
+config PRE_CON_BUF_SZ
+	default 4096
+
+config BOOTSTAGE_STASH_ADDR
+	default 0x87000000
+
+if DEBUG_UART
+
+config DEBUG_UART_BOARD_INIT
+	default y
+
+# debug on USART2 by default
+config DEBUG_UART_BASE
+	default 0x400e0000
+
+endif
+
+source "board/st/stm32mp2/Kconfig"
+
+endif
diff --git a/arch/arm/mach-stm32mp/Kconfig.25x b/arch/arm/mach-stm32mp/Kconfig.25x
new file mode 100644
index 0000000000..2c0f691f8b
--- /dev/null
+++ b/arch/arm/mach-stm32mp/Kconfig.25x
@@ -0,0 +1,43 @@
+if STM32MP25X
+
+choice
+	prompt "STM32MP25x board select"
+	optional
+
+config TARGET_ST_STM32MP25X
+	bool "STMicroelectronics STM32MP25x boards"
+	imply BOOTSTAGE
+	imply CMD_BOOTSTAGE
+	help
+		target the STMicroelectronics board with SOC STM32MP25x
+		managed by board/st/stm32mp2
+		The difference between board are managed with devicetree
+
+endchoice
+
+config TEXT_BASE
+	default 0x84000000
+
+config PRE_CON_BUF_ADDR
+	default 0x84800000
+
+config PRE_CON_BUF_SZ
+	default 4096
+
+config BOOTSTAGE_STASH_ADDR
+	default 0x87000000
+
+if DEBUG_UART
+
+config DEBUG_UART_BOARD_INIT
+	default y
+
+# debug on USART2 by default
+config DEBUG_UART_BASE
+	default 0x400e0000
+
+endif
+
+source "board/st/stm32mp2/Kconfig"
+
+endif
diff --git a/arch/arm/mach-stm32mp/Makefile b/arch/arm/mach-stm32mp/Makefile
index a19b2797c8..db74f3a92d 100644
--- a/arch/arm/mach-stm32mp/Makefile
+++ b/arch/arm/mach-stm32mp/Makefile
@@ -1,26 +1,25 @@
 # SPDX-License-Identifier: GPL-2.0+
 #
-# Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+# Copyright (C) 2018-2024, STMicroelectronics - All Rights Reserved
 #
 
-obj-y += cpu.o
 obj-y += dram_init.o
 obj-y += syscon.o
 obj-y += bsec.o
+obj-y += etzpc.o
+obj-y += soc.o
 
-obj-$(CONFIG_STM32MP13x) += stm32mp13x.o
-obj-$(CONFIG_STM32MP15x) += stm32mp15x.o
+obj-$(CONFIG_STM32MP13X) += stm32mp1/
+obj-$(CONFIG_STM32MP15X) += stm32mp1/
+obj-$(CONFIG_STM32MP21X) += stm32mp2/
+obj-$(CONFIG_STM32MP23X) += stm32mp2/
+obj-$(CONFIG_STM32MP25X) += stm32mp2/
+
+obj-$(CONFIG_STM32MP_TAMP_NVMEM) += nvram.o
 
 obj-$(CONFIG_STM32_ECDSA_VERIFY) += ecdsa_romapi.o
-ifdef CONFIG_SPL_BUILD
-obj-y += spl.o
-obj-y += tzc400.o
-else
+ifndef CONFIG_SPL_BUILD
 obj-y += cmd_stm32prog/
 obj-$(CONFIG_CMD_STM32KEY) += cmd_stm32key.o
-obj-$(CONFIG_ARMV7_PSCI) += psci.o
 obj-$(CONFIG_TFABOOT) += boot_params.o
 endif
-
-obj-$(CONFIG_$(SPL_)STM32MP15_PWR) += pwr_regulator.o
-obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
diff --git a/arch/arm/mach-stm32mp/bsec.c b/arch/arm/mach-stm32mp/bsec.c
index 0dc1e5c3fd..0cdbfa68ec 100644
--- a/arch/arm/mach-stm32mp/bsec.c
+++ b/arch/arm/mach-stm32mp/bsec.c
@@ -19,7 +19,6 @@
 #include <linux/arm-smccc.h>
 #include <linux/iopoll.h>
 
-#define BSEC_OTP_MAX_VALUE		95
 #define BSEC_OTP_UPPER_START		32
 #define BSEC_TIMEOUT_US			10000
 
@@ -109,7 +108,7 @@
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_lock(u32 address, u32 otp)
+static bool bsec_read_lock(void __iomem *address, u32 otp)
 {
 	u32 bit;
 	u32 bank;
@@ -117,7 +116,7 @@ static bool bsec_read_lock(u32 address, u32 otp)
 	bit = 1 << (otp & OTP_LOCK_MASK);
 	bank = ((otp >> OTP_LOCK_BANK_SHIFT) & OTP_LOCK_MASK) * sizeof(u32);
 
-	return !!(readl(address + bank) & bit);
+	return !!(readl((address + bank)) & bit);
 }
 
 /**
@@ -126,7 +125,7 @@ static bool bsec_read_lock(u32 address, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error, -EAGAIN or -ENOTSUPP
  */
-static u32 bsec_check_error(u32 base, u32 otp)
+static u32 bsec_check_error(void __iomem *base, u32 otp)
 {
 	u32 bit;
 	u32 bank;
@@ -148,7 +147,7 @@ static u32 bsec_check_error(u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_SR_lock(u32 base, u32 otp)
+static bool bsec_read_SR_lock(void __iomem *base, u32 otp)
 {
 	return bsec_read_lock(base + BSEC_SRLOCK_OFF, otp);
 }
@@ -159,7 +158,7 @@ static bool bsec_read_SR_lock(u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_SP_lock(u32 base, u32 otp)
+static bool bsec_read_SP_lock(void __iomem *base, u32 otp)
 {
 	return bsec_read_lock(base + BSEC_SPLOCK_OFF, otp);
 }
@@ -170,7 +169,7 @@ static bool bsec_read_SP_lock(u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_SW_lock(u32 base, u32 otp)
+static bool bsec_read_SW_lock(void __iomem *base, u32 otp)
 {
 	return bsec_read_lock(base + BSEC_SWLOCK_OFF, otp);
 }
@@ -181,7 +180,7 @@ static bool bsec_read_SW_lock(u32 base, u32 otp)
  * @power: true to power up , false to power down
  * Return: 0 if succeed
  */
-static int bsec_power_safmem(u32 base, bool power)
+static int bsec_power_safmem(void __iomem *base, bool power)
 {
 	u32 val;
 	u32 mask;
@@ -207,7 +206,7 @@ static int bsec_power_safmem(u32 base, bool power)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_shadow_register(struct udevice *dev, u32 base, u32 otp)
+static int bsec_shadow_register(struct udevice *dev, void __iomem *base, u32 otp)
 {
 	u32 val;
 	int ret;
@@ -252,7 +251,8 @@ static int bsec_shadow_register(struct udevice *dev, u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_read_shadow(struct udevice *dev, u32 base, u32 *val, u32 otp)
+static int bsec_read_shadow(struct udevice *dev, void __iomem *base, u32 *val,
+			    u32 otp)
 {
 	*val = readl(base + BSEC_OTP_DATA_OFF + otp * sizeof(u32));
 
@@ -267,7 +267,7 @@ static int bsec_read_shadow(struct udevice *dev, u32 base, u32 *val, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_write_shadow(struct udevice *dev, u32 base, u32 val, u32 otp)
+static int bsec_write_shadow(struct udevice *dev, void __iomem *base, u32 val, u32 otp)
 {
 	/* check if programming of otp is locked */
 	if (bsec_read_SW_lock(base, otp))
@@ -287,7 +287,7 @@ static int bsec_write_shadow(struct udevice *dev, u32 base, u32 val, u32 otp)
  * after the function the otp data is not refreshed in shadow
  * Return: 0 if no error
  */
-static int bsec_program_otp(struct udevice *dev, long base, u32 val, u32 otp)
+static int bsec_program_otp(struct udevice *dev, void __iomem *base, u32 val, u32 otp)
 {
 	u32 ret;
 	bool power_up = false;
@@ -337,7 +337,7 @@ static int bsec_program_otp(struct udevice *dev, long base, u32 val, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_permanent_lock_otp(struct udevice *dev, long base, uint32_t otp)
+static int bsec_permanent_lock_otp(struct udevice *dev, void __iomem *base, uint32_t otp)
 {
 	int ret;
 	bool power_up = false;
@@ -391,13 +391,18 @@ static int bsec_permanent_lock_otp(struct udevice *dev, long base, uint32_t otp)
 
 /* BSEC MISC driver *******************************************************/
 struct stm32mp_bsec_plat {
-	u32 base;
+	void __iomem *base;
 };
 
 struct stm32mp_bsec_priv {
 	struct udevice *tee;
 };
 
+struct stm32mp_bsec_drvdata {
+	int size;
+	bool ta;
+};
+
 static int stm32mp_bsec_read_otp(struct udevice *dev, u32 *val, u32 otp)
 {
 	struct stm32mp_bsec_plat *plat;
@@ -607,6 +612,7 @@ static int stm32mp_bsec_read(struct udevice *dev, int offset,
 			     void *buf, int size)
 {
 	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	struct stm32mp_bsec_drvdata *data = (struct stm32mp_bsec_drvdata *)dev_get_driver_data(dev);
 	int ret;
 	int i;
 	bool shadow = true, lock = false;
@@ -640,7 +646,7 @@ static int stm32mp_bsec_read(struct udevice *dev, int offset,
 
 	otp = offs / sizeof(u32);
 
-	for (i = otp; i < (otp + nb_otp) && i <= BSEC_OTP_MAX_VALUE; i++) {
+	for (i = otp; i < (otp + nb_otp) && i < data->size; i++) {
 		u32 *addr = &((u32 *)buf)[i - otp];
 
 		if (lock)
@@ -663,6 +669,7 @@ static int stm32mp_bsec_write(struct udevice *dev, int offset,
 			      const void *buf, int size)
 {
 	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	struct stm32mp_bsec_drvdata *data = (struct stm32mp_bsec_drvdata *)dev_get_driver_data(dev);
 	int ret = 0;
 	int i;
 	bool shadow = true, lock = false;
@@ -696,7 +703,7 @@ static int stm32mp_bsec_write(struct udevice *dev, int offset,
 
 	otp = offs / sizeof(u32);
 
-	for (i = otp; i < otp + nb_otp && i <= BSEC_OTP_MAX_VALUE; i++) {
+	for (i = otp; i < otp + nb_otp && i < data->size; i++) {
 		u32 *val = &((u32 *)buf)[i - otp];
 
 		if (lock)
@@ -723,13 +730,14 @@ static int stm32mp_bsec_of_to_plat(struct udevice *dev)
 {
 	struct stm32mp_bsec_plat *plat = dev_get_plat(dev);
 
-	plat->base = (u32)dev_read_addr_ptr(dev);
+	plat->base = dev_read_addr_ptr(dev);
 
 	return 0;
 }
 
 static int stm32mp_bsec_probe(struct udevice *dev)
 {
+	struct stm32mp_bsec_drvdata *data = (struct stm32mp_bsec_drvdata *)dev_get_driver_data(dev);
 	int otp;
 	struct stm32mp_bsec_plat *plat;
 	struct clk_bulk clk_bulk;
@@ -743,16 +751,22 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 	}
 
 	if (IS_ENABLED(CONFIG_OPTEE))
-		bsec_optee_open(dev);
+		ret = bsec_optee_open(dev);
+	else
+		ret = -ENOTSUPP;
+	/* failed if OP-TEE TA is required */
+	if (data->ta && !ret)
+		return ret;
 
 	/*
 	 * update unlocked shadow for OTP cleared by the rom code
 	 * only executed in SPL, it is done in TF-A for TFABOOT
 	 */
-	if (IS_ENABLED(CONFIG_SPL_BUILD)) {
+	if (IS_ENABLED(CONFIG_SPL_BUILD) && !data->ta) {
 		plat = dev_get_plat(dev);
 
-		for (otp = 57; otp <= BSEC_OTP_MAX_VALUE; otp++)
+		/* here 57 is the value for STM32MP15x ROM code, only MPU with SPL support*/
+		for (otp = 57; otp < data->size; otp++)
 			if (!bsec_read_SR_lock(plat->base, otp))
 				bsec_shadow_register(dev, plat->base, otp);
 	}
@@ -760,9 +774,25 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 	return 0;
 }
 
+static const struct stm32mp_bsec_drvdata stm32mp13_data = {
+	.size = 96,
+	.ta = true,
+};
+
+static const struct stm32mp_bsec_drvdata stm32mp15_data = {
+	.size = 96,
+	.ta = false,
+};
+
+static const struct stm32mp_bsec_drvdata stm32mp25_data = {
+	.size = 368, /* 384 but no access to HWKEY and STM32PRVKEY */
+	.ta = true,
+};
+
 static const struct udevice_id stm32mp_bsec_ids[] = {
-	{ .compatible = "st,stm32mp13-bsec" },
-	{ .compatible = "st,stm32mp15-bsec" },
+	{ .compatible = "st,stm32mp13-bsec", .data = (ulong)&stm32mp13_data},
+	{ .compatible = "st,stm32mp15-bsec", .data = (ulong)&stm32mp15_data},
+	{ .compatible = "st,stm32mp25-bsec", .data = (ulong)&stm32mp25_data},
 	{}
 };
 
diff --git a/arch/arm/mach-stm32mp/cmd_stm32key.c b/arch/arm/mach-stm32mp/cmd_stm32key.c
index 85be8e23bd..a516bd9e76 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32key.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32key.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
 /*
- * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2019-2024, STMicroelectronics - All Rights Reserved
  */
 
 #include <common.h>
@@ -14,12 +14,23 @@
 
 /*
  * Closed device: OTP0
- * STM32MP15x: bit 6 of OPT0
+ * STM32MP15x: bit 6 of OTP0
  * STM32MP13x: 0b111111 = 0x3F for OTP_SECURED closed device
+ * STM32MP2xx: bit 0 of OTP18
  */
-#define STM32_OTP_CLOSE_ID		0
-#define STM32_OTP_STM32MP13x_CLOSE_MASK	0x3F
-#define STM32_OTP_STM32MP15x_CLOSE_MASK	BIT(6)
+#define STM32MP1_OTP_CLOSE_ID				0
+#define STM32_OTP_STM32MP13X_CLOSE_MASK		GENMASK(5, 0)
+#define STM32_OTP_STM32MP15X_CLOSE_MASK		BIT(6)
+#define STM32MP2X_OTP_WORD8				8
+#define STM32_OTP_STM32MP2X_BOOTROM_CLOSE_MASK	GENMASK(7, 0)
+#define STM32MP2X_OTP_CLOSE_ID			18
+#define STM32_OTP_STM32MP2X_CLOSE_MASK		GENMASK(3, 0)
+#define STM32_OTP_STM32MP2X_PROVISIONING_DONE_MASK	GENMASK(7, 4)
+#define STM32MP2X_OTP_HWCONFIG			124
+#define STM32_OTP_STM32MP2X_DISABLE_SCAN_MASK	BIT(20)
+
+#define STM32MP2X_OTP_BOOTROM_CONF8	17
+#define STM32_OTP_STM32MP2X_OEM_KEY2_EN	BIT(8)
 
 /* PKH is the first element of the key list */
 #define STM32KEY_PKH 0
@@ -27,8 +38,9 @@
 struct stm32key {
 	char *name;
 	char *desc;
-	u8 start;
+	u16 start;
 	u8 size;
+	int (*post_process)(struct udevice *dev, const struct stm32key *key);
 };
 
 const struct stm32key stm32mp13_list[] = {
@@ -55,34 +67,205 @@ const struct stm32key stm32mp15_list[] = {
 	}
 };
 
+static int post_process_oem_key2(struct udevice *dev, const struct stm32key *key);
+static int post_process_edmk_128b(struct udevice *dev, const struct stm32key *key);
+
+const struct stm32key stm32mp21_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "OEM-KEY1",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm) for FSBLA or M",
+		.start = 152,
+		.size = 8,
+	},
+	{
+		.name = "OEM-KEY2",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm) for FSBLM",
+		.start = 160,
+		.size = 8,
+		.post_process = post_process_oem_key2,
+	},
+	{
+		.name = "FIP-EDMK",
+		.desc = "Encryption/Decryption Master Key for FIP",
+		.start = 260,
+		.size = 8,
+	},
+	{
+		.name = "EDMK1-128b",
+		.desc = "Encryption/Decryption Master 128b Key for FSBLA or M",
+		.start = 356,
+		.size = 4,
+		.post_process = post_process_edmk_128b,
+	},
+	{
+		.name = "EDMK1-256b",
+		.desc = "Encryption/Decryption Master 256b Key for FSBLA or M",
+		.start = 356,
+		.size = 8,
+	},
+	{
+		.name = "EDMK2-128b",
+		.desc = "Encryption/Decryption Master 128b Key for FSBLM",
+		.start = 348,
+		.size = 4,
+		.post_process = post_process_edmk_128b,
+	},
+	{
+		.name = "EDMK2-256b",
+		.desc = "Encryption/Decryption Master 256b Key for FSBLM",
+		.start = 348,
+		.size = 8,
+	},
+};
+
+const struct stm32key stm32mp2x_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "OEM-KEY1",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm) for FSBLA or M",
+		.start = 144,
+		.size = 8,
+	},
+	{
+		.name = "OEM-KEY2",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm) for FSBLM",
+		.start = 152,
+		.size = 8,
+		.post_process = post_process_oem_key2,
+	},
+	{
+		.name = "FIP-EDMK",
+		.desc = "Encryption/Decryption Master Key for FIP",
+		.start = 260,
+		.size = 8,
+	},
+	{
+		.name = "EDMK1",
+		.desc = "Encryption/Decryption Master Key for FSBLA or M",
+		.start = 364,
+		.size = 4,
+	},
+	{
+		.name = "EDMK2",
+		.desc = "Encryption/Decryption Master Key for FSBLM",
+		.start = 360,
+		.size = 4,
+	}
+};
+
+struct otp_close {
+	u32 word;
+	u32 mask_wr;
+	u32 mask_rd;
+	bool (*close_status_ops)(u32 value, u32 mask);
+};
+
+static bool compare_mask_exact(u32 value, u32 mask)
+{
+	return ((value & mask) == mask);
+}
+
+static bool compare_any_bits(u32 value, u32 mask)
+{
+	return ((value & mask) != 0);
+}
+
+const struct otp_close stm32mp13_close_state_otp[] = {
+	{
+		.word = STM32MP1_OTP_CLOSE_ID,
+		.mask_wr = STM32_OTP_STM32MP13X_CLOSE_MASK,
+		.mask_rd = STM32_OTP_STM32MP13X_CLOSE_MASK,
+		.close_status_ops = compare_mask_exact,
+	}
+};
+
+const struct otp_close stm32mp15_close_state_otp[] = {
+	{
+		.word = STM32MP1_OTP_CLOSE_ID,
+		.mask_wr = STM32_OTP_STM32MP15X_CLOSE_MASK,
+		.mask_rd = STM32_OTP_STM32MP15X_CLOSE_MASK,
+		.close_status_ops = compare_mask_exact,
+	}
+};
+
+const struct otp_close stm32mp2x_close_state_otp[] = {
+	{
+		.word = STM32MP2X_OTP_WORD8,
+		.mask_wr = STM32_OTP_STM32MP2X_BOOTROM_CLOSE_MASK,
+		.mask_rd = 0,
+		.close_status_ops = NULL
+	},
+	{
+		.word = STM32MP2X_OTP_CLOSE_ID,
+		.mask_wr = STM32_OTP_STM32MP2X_CLOSE_MASK |
+			   STM32_OTP_STM32MP2X_PROVISIONING_DONE_MASK,
+		.mask_rd = STM32_OTP_STM32MP2X_CLOSE_MASK,
+		.close_status_ops = compare_any_bits
+	},
+	{
+		.word = STM32MP2X_OTP_HWCONFIG,
+		.mask_wr = STM32_OTP_STM32MP2X_DISABLE_SCAN_MASK,
+		.mask_rd = 0,
+		.close_status_ops = NULL
+	},
+};
+
 /* index of current selected key in stm32key list, 0 = PKH by default */
 static u8 stm32key_index;
 
 static u8 get_key_nb(void)
 {
-	if (IS_ENABLED(CONFIG_STM32MP13x))
+	if (IS_ENABLED(CONFIG_STM32MP13X))
 		return ARRAY_SIZE(stm32mp13_list);
 
-	if (IS_ENABLED(CONFIG_STM32MP15x))
+	if (IS_ENABLED(CONFIG_STM32MP15X))
 		return ARRAY_SIZE(stm32mp15_list);
+
+	if (IS_ENABLED(CONFIG_STM32MP23X) || IS_ENABLED(CONFIG_STM32MP25X))
+		return ARRAY_SIZE(stm32mp2x_list);
+
+	if (IS_ENABLED(CONFIG_STM32MP21X))
+		return ARRAY_SIZE(stm32mp21_list);
 }
 
 static const struct stm32key *get_key(u8 index)
 {
-	if (IS_ENABLED(CONFIG_STM32MP13x))
+	if (IS_ENABLED(CONFIG_STM32MP13X))
 		return &stm32mp13_list[index];
 
-	if (IS_ENABLED(CONFIG_STM32MP15x))
+	if (IS_ENABLED(CONFIG_STM32MP15X))
 		return &stm32mp15_list[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP23X) || IS_ENABLED(CONFIG_STM32MP25X))
+		return &stm32mp2x_list[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP21X))
+		return &stm32mp21_list[index];
+}
+
+static u8 get_otp_close_state_nb(void)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return ARRAY_SIZE(stm32mp13_close_state_otp);
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return ARRAY_SIZE(stm32mp15_close_state_otp);
+
+	if (IS_ENABLED(CONFIG_STM32MP21X) || IS_ENABLED(CONFIG_STM32MP23X) ||
+	    IS_ENABLED(CONFIG_STM32MP25X))
+		return ARRAY_SIZE(stm32mp2x_close_state_otp);
 }
 
-static u32 get_otp_close_mask(void)
+static const struct otp_close *get_otp_close_state(u8 index)
 {
-	if (IS_ENABLED(CONFIG_STM32MP13x))
-		return STM32_OTP_STM32MP13x_CLOSE_MASK;
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return &stm32mp13_close_state_otp[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return &stm32mp15_close_state_otp[index];
 
-	if (IS_ENABLED(CONFIG_STM32MP15x))
-		return STM32_OTP_STM32MP15x_CLOSE_MASK;
+	if (IS_ENABLED(CONFIG_STM32MP21X) || IS_ENABLED(CONFIG_STM32MP23X) ||
+	    IS_ENABLED(CONFIG_STM32MP25X))
+		return &stm32mp2x_close_state_otp[index];
 }
 
 static int get_misc_dev(struct udevice **dev)
@@ -102,7 +285,7 @@ static void read_key_value(const struct stm32key *key, u32 addr)
 
 	for (i = 0; i < key->size; i++) {
 		printf("%s OTP %i: [%08x] %08x\n", key->name, key->start + i,
-		       addr, __be32_to_cpu(*(u32 *)addr));
+		       addr, __be32_to_cpu(*(u32 *)(long)addr));
 		addr += 4;
 	}
 }
@@ -157,26 +340,42 @@ static int read_key_otp(struct udevice *dev, const struct stm32key *key, bool pr
 
 static int read_close_status(struct udevice *dev, bool print, bool *closed)
 {
-	int word, ret, result;
-	u32 val, lock, mask;
-	bool status;
+	int ret, result, i;
+	const struct otp_close *otp_close = NULL;
+	u32 otp_close_nb = get_otp_close_state_nb();
+	u32 val, lock, mask, word = 0;
+	bool status = true;
+	bool tested_once = false;
 
 	result = 0;
-	word = STM32_OTP_CLOSE_ID;
-	ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
-	if (ret < 0)
-		result = ret;
-	if (ret != 4)
-		val = 0x0;
-
-	ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
-	if (ret < 0)
-		result = ret;
-	if (ret != 4)
-		lock = BSEC_LOCK_ERROR;
-
-	mask = get_otp_close_mask();
-	status = (val & mask) == mask;
+	for (i = 0; status && (i < otp_close_nb); i++) {
+		otp_close = get_otp_close_state(i);
+
+		if (!otp_close->close_status_ops)
+			continue;
+
+		mask = otp_close->mask_rd;
+		word = otp_close->word;
+
+		ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
+		if (ret < 0)
+			result = ret;
+		if (ret != 4)
+			val = 0x0;
+
+		ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
+		if (ret < 0)
+			result = ret;
+		if (ret != 4)
+			lock = BSEC_LOCK_ERROR;
+
+		status = otp_close->close_status_ops(val, mask);
+		tested_once = true;
+	}
+
+	if (!tested_once)
+		status = false;
+
 	if (closed)
 		*closed = status;
 	if (print)
@@ -185,13 +384,73 @@ static int read_close_status(struct udevice *dev, bool print, bool *closed)
 	return result;
 }
 
+static int write_close_status(struct udevice *dev)
+{
+	int i;
+	u32 val, word, ret;
+	const struct otp_close *otp_close = NULL;
+	u32 otp_num = get_otp_close_state_nb();
+
+	for (i = 0; i < otp_num; i++) {
+		otp_close = get_otp_close_state(i);
+		val = otp_close->mask_wr;
+		word = otp_close->word;
+		ret = misc_write(dev, STM32_BSEC_OTP(word), &val, 4);
+		if (ret != 4) {
+			log_err("Error: can't update OTP %d\n", word);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int post_process_oem_key2(struct udevice *dev, const struct stm32key *key)
+{
+	int ret;
+	u32 val;
+
+	ret = misc_read(dev, STM32_BSEC_OTP(STM32MP2X_OTP_BOOTROM_CONF8), &val, 4);
+	if (ret != 4) {
+		log_err("Error %d failed to read STM32MP2X_OTP_BOOTROM_CONF8\n", ret);
+		return -EIO;
+	}
+
+	val |= STM32_OTP_STM32MP2X_OEM_KEY2_EN;
+	ret = misc_write(dev, STM32_BSEC_OTP(STM32MP2X_OTP_BOOTROM_CONF8), &val, 4);
+	if (ret != 4) {
+		log_err("Error %d failed to write OEM_KEY2_ENABLE\n", ret);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int post_process_edmk_128b(struct udevice *dev, const struct stm32key *key)
+{
+	int ret, word, start_otp;
+	u32 val = BSEC_LOCK_PERM;
+
+	start_otp = key->start + key->size;
+
+	/* On MP21, when using a 128bit key, lock the unused OTPs. */
+	for (word = start_otp; word < (start_otp + 4); word++) {
+		ret = misc_write(dev, STM32_BSEC_LOCK(word), &val, 4);
+		if (ret != 4) {
+			log_err("Failed to lock unused OTP : %d\n", word);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int fuse_key_value(struct udevice *dev, const struct stm32key *key, u32 addr, bool print)
 {
 	u32 word, val;
 	int i, ret;
 
 	for (i = 0, word = key->start; i < key->size; i++, word++, addr += 4) {
-		val = __be32_to_cpu(*(u32 *)addr);
+		val = __be32_to_cpu(*(u32 *)(long)addr);
 		if (print)
 			printf("Fuse %s OTP %i : %08x\n", key->name, word, val);
 
@@ -229,7 +488,7 @@ static int confirm_prog(void)
 static void display_key_info(const struct stm32key *key)
 {
 	printf("%s : %s\n", key->name, key->desc);
-	printf("\tOTP%d..%d\n", key->start, key->start + key->size);
+	printf("\tOTP%d..%d\n", key->start, key->start + key->size - 1);
 }
 
 static int do_stm32key_list(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
@@ -361,6 +620,13 @@ static int do_stm32key_fuse(struct cmd_tbl *cmdtp, int flag, int argc, char *con
 	if (fuse_key_value(dev, key, addr, !yes))
 		return CMD_RET_FAILURE;
 
+	if (key->post_process) {
+		if (key->post_process(dev, key)) {
+			printf("Error: %s for post process\n", key->name);
+			return CMD_RET_FAILURE;
+		}
+	}
+
 	printf("%s updated !\n", key->name);
 
 	return CMD_RET_SUCCESS;
@@ -371,7 +637,6 @@ static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *co
 	const struct stm32key *key;
 	bool yes, lock, closed;
 	struct udevice *dev;
-	u32 val;
 	int ret;
 
 	yes = false;
@@ -407,12 +672,8 @@ static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *co
 	if (!yes && !confirm_prog())
 		return CMD_RET_FAILURE;
 
-	val = get_otp_close_mask();
-	ret = misc_write(dev, STM32_BSEC_OTP(STM32_OTP_CLOSE_ID), &val, 4);
-	if (ret != 4) {
-		printf("Error: can't update OTP %d\n", STM32_OTP_CLOSE_ID);
+	if (write_close_status(dev))
 		return CMD_RET_FAILURE;
-	}
 
 	printf("Device is closed !\n");
 
@@ -432,3 +693,25 @@ U_BOOT_CMD_WITH_SUBCMDS(stm32key, "Manage key on STM32", stm32key_help_text,
 	U_BOOT_SUBCMD_MKENT(read, 2, 0, do_stm32key_read),
 	U_BOOT_SUBCMD_MKENT(fuse, 3, 0, do_stm32key_fuse),
 	U_BOOT_SUBCMD_MKENT(close, 2, 0, do_stm32key_close));
+
+/*
+ * Check the "closed" state in product life cycle, when product secrets have
+ * been provisioned into the device, by SSP tools for example.
+ * On closed devices, authentication is mandatory.
+ */
+bool stm32mp_is_closed(void)
+{
+	struct udevice *dev;
+	bool closed;
+	int ret;
+
+	ret = get_misc_dev(&dev);
+	if (ret)
+		return false;
+
+	ret = read_close_status(dev, false, &closed);
+	if (ret)
+		return false;
+
+	return closed;
+}
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig b/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
index 8f91db4b46..490097e98b 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
@@ -17,6 +17,7 @@ config CMD_STM32PROG
 config CMD_STM32PROG_USB
 	bool "support stm32prog over USB"
 	depends on CMD_STM32PROG
+	depends on USB_GADGET_DOWNLOAD
 	default y
 	help
 		activate the command "stm32prog usb" for STM32MP soc family
@@ -26,6 +27,8 @@ config CMD_STM32PROG_USB
 config CMD_STM32PROG_SERIAL
 	bool "support stm32prog over UART"
 	depends on CMD_STM32PROG
+	imply DISABLE_CONSOLE
+	imply SILENT_CONSOLE
 	default y
 	help
 		activate the command "stm32prog serial" for STM32MP soc family
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
index c695cc1123..9f3bc19ded 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
@@ -180,11 +180,3 @@ U_BOOT_CMD(stm32prog, 5, 0, do_stm32prog,
 	   "  <size> = size of flashlayout (optional for image with STM32 header)\n"
 );
 
-
-bool stm32prog_get_fsbl_nor(void)
-{
-	if (stm32prog_data)
-		return stm32prog_data->fsbl_nor_detected;
-
-	return false;
-}
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
index 9ba94be804..1843667d14 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
@@ -13,6 +13,7 @@
 #include <part.h>
 #include <tee.h>
 #include <asm/arch/stm32mp1_smc.h>
+#include <asm/arch/sys_proto.h>
 #include <asm/global_data.h>
 #include <dm/device_compat.h>
 #include <dm/uclass.h>
@@ -789,8 +790,8 @@ static int init_device(struct stm32prog_data *data,
 			last_addr = (u64)(block_dev->lba - GPT_HEADER_SZ - 1) *
 				    block_dev->blksz;
 		}
-		log_debug("MMC %d: lba=%ld blksz=%ld\n", dev->dev_id,
-			  block_dev->lba, block_dev->blksz);
+		log_debug("MMC %d: lba=%lld blksz=%ld\n", dev->dev_id,
+			  (u64)block_dev->lba, block_dev->blksz);
 		log_debug(" available address = 0x%llx..0x%llx\n",
 			  first_addr, last_addr);
 		log_debug(" full_update = %d\n", dev->full_update);
@@ -1007,7 +1008,6 @@ static int treat_partition_list(struct stm32prog_data *data)
 		INIT_LIST_HEAD(&data->dev[j].part_list);
 	}
 
-	data->fsbl_nor_detected = false;
 	for (i = 0; i < data->part_nb; i++) {
 		part = &data->part_array[i];
 		part->alt_id = -1;
@@ -1052,15 +1052,6 @@ static int treat_partition_list(struct stm32prog_data *data)
 			stm32prog_err("Layout: too many device");
 			return -EINVAL;
 		}
-		switch (part->target)  {
-		case STM32PROG_NOR:
-			if (!data->fsbl_nor_detected &&
-			    !strncmp(part->name, "fsbl", 4))
-				data->fsbl_nor_detected = true;
-			/* fallthrough */
-		default:
-			break;
-		}
 		part->dev = &data->dev[j];
 		if (!IS_SELECT(part))
 			part->dev->full_update = false;
@@ -1228,7 +1219,10 @@ static int stm32prog_alt_add(struct stm32prog_data *data,
 	char multiplier,  type;
 
 	/* max 3 digit for sector size */
-	if (part->size > SZ_1M) {
+	if (part->size > SZ_1G) {
+		size = (u32)(part->size / SZ_1G);
+		multiplier = 'G';
+	} else if (part->size > SZ_1M) {
 		size = (u32)(part->size / SZ_1M);
 		multiplier = 'M';
 	} else if (part->size > SZ_1K) {
@@ -1353,7 +1347,7 @@ static int dfu_init_entities(struct stm32prog_data *data)
 
 	alt_nb = 1; /* number of virtual = CMD*/
 
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_OTP)) {
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_OTP) && !stm32mp_is_closed()) {
 		/* OTP_SIZE_SMC = 0 if SMC is not supported */
 		otp_size = OTP_SIZE_SMC;
 		/* check if PTA BSEC is supported */
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
index feba29501d..f8f382d2e5 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
 /*
- * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2020-2024, STMicroelectronics - All Rights Reserved
  */
 
 #ifndef _STM32PROG_H_
@@ -20,13 +20,19 @@
 #define DEFAULT_ADDRESS		0xFFFFFFFF
 
 #define CMD_SIZE		512
-/* SMC is only supported in SPMIN for STM32MP15x */
-#ifdef CONFIG_STM32MP15x
+/* SMC is only supported in SPMIN for STM32MP15X */
+#ifdef CONFIG_STM32MP15X
 #define OTP_SIZE_SMC		1024
 #else
 #define OTP_SIZE_SMC		0
 #endif
-#define OTP_SIZE_TA		776
+/* size of the OTP struct in NVMEM PTA */
+#define _OTP_SIZE_TA(otp)	(((otp) * 2 + 2) * 4)
+#if defined(CONFIG_STM32MP21X) || defined(CONFIG_STM32MP23X) || defined(CONFIG_STM32MP25X)
+#define OTP_SIZE_TA		_OTP_SIZE_TA(368)
+#else
+#define OTP_SIZE_TA		_OTP_SIZE_TA(96)
+#endif
 #define PMIC_SIZE		8
 
 enum stm32prog_target {
@@ -157,7 +163,6 @@ struct stm32prog_data {
 	struct stm32prog_dev_t	dev[STM32PROG_MAX_DEV];	/* array of device */
 	int			part_nb;	/* nb of partition */
 	struct stm32prog_part_t	*part_array;	/* array of partition */
-	bool			fsbl_nor_detected;
 
 	/* command internal information */
 	unsigned int		phase;
diff --git a/arch/arm/mach-stm32mp/dram_init.c b/arch/arm/mach-stm32mp/dram_init.c
index 7f37b0d2aa..b79cb689f3 100644
--- a/arch/arm/mach-stm32mp/dram_init.c
+++ b/arch/arm/mach-stm32mp/dram_init.c
@@ -7,6 +7,7 @@
 
 #include <common.h>
 #include <dm.h>
+#include <efi_loader.h>
 #include <image.h>
 #include <init.h>
 #include <lmb.h>
@@ -24,8 +25,16 @@ int dram_init(void)
 	int ret;
 
 	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
-	if (ret) {
-		log_debug("RAM init failed: %d\n", ret);
+	/* in case there is no RAM driver, retrieve DDR size from DT */
+	if (ret == -ENODEV) {
+		ret = fdtdec_setup_mem_size_base();
+		if (ret)
+			return ret;
+		if (gd->ram_size > STM32_DDR_SIZE)
+			return -EINVAL;
+		return 0;
+	} else if (ret) {
+		log_err("RAM init failed: %d\n", ret);
 		return ret;
 	}
 	ret = ram_get_info(dev, &ram);
@@ -33,7 +42,7 @@ int dram_init(void)
 		log_debug("Cannot get RAM size: %d\n", ret);
 		return ret;
 	}
-	log_debug("RAM init base=%lx, size=%x\n", ram.base, ram.size);
+	log_debug("RAM init base=%p, size=%zx\n", (void *)ram.base, ram.size);
 
 	gd->ram_size = ram.size;
 
@@ -49,9 +58,15 @@ phys_addr_t board_get_usable_ram_top(phys_size_t total_size)
 	if (!total_size)
 		return gd->ram_top;
 
+	/*
+	 * make sure U-Boot uses address space below 4GB boundaries even
+	 * if the effective available memory is bigger
+	 */
+	gd->ram_top = clamp_val((gd->ram_base + gd->ram_size), 0, SZ_4G - 1);
+
 	/* found enough not-reserved memory to relocated U-Boot */
 	lmb_init(&lmb);
-	lmb_add(&lmb, gd->ram_base, get_effective_memsize());
+	lmb_add(&lmb, gd->ram_base, gd->ram_top - gd->ram_base);
 	boot_fdt_add_mem_rsv_regions(&lmb, (void *)gd->fdt_blob);
 	/* add 8M for reserved memory for display, fdt, gd,... */
 	size = ALIGN(SZ_8M + CONFIG_SYS_MALLOC_LEN + total_size, MMU_SECTION_SIZE),
@@ -66,3 +81,14 @@ phys_addr_t board_get_usable_ram_top(phys_size_t total_size)
 
 	return reg + size;
 }
+
+void efi_add_known_memory(void)
+{
+	if (IS_ENABLED(CONFIG_EFI_LOADER))
+		/*
+		 * Memory over ram_top is reserved to OPTEE.
+		 * Declare to EFI only memory area below ram_top
+		 */
+		efi_add_memory_map(gd->ram_base, gd->ram_top - gd->ram_base,
+				   EFI_CONVENTIONAL_MEMORY);
+}
diff --git a/arch/arm/mach-stm32mp/etzpc.c b/arch/arm/mach-stm32mp/etzpc.c
new file mode 100644
index 0000000000..90b84b49e9
--- /dev/null
+++ b/arch/arm/mach-stm32mp/etzpc.c
@@ -0,0 +1,195 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SIMPLE_BUS
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <linux/bitfield.h>
+#include <mach/etzpc.h>
+
+/* ETZPC peripheral as firewall bus */
+/* ETZPC registers */
+#define ETZPC_DECPROT			0x10
+#define ETZPC_HWCFGR			0x3F0
+
+/* ETZPC miscellaneous */
+#define ETZPC_PROT_MASK			GENMASK(1, 0)
+#define ETZPC_PROT_A7NS			0x3
+#define ETZPC_DECPROT_SHIFT		1
+
+#define IDS_PER_DECPROT_REGS		16
+
+#define ETZPC_HWCFGR_NUM_PER_SEC	GENMASK(15, 8)
+#define ETZPC_HWCFGR_NUM_AHB_SEC	GENMASK(23, 16)
+
+/*
+ * struct stm32_etzpc_plat: Information about ETZPC device
+ *
+ * @base: Base address of ETZPC
+ * @max_entries: Number of securable peripherals in ETZPC
+ */
+struct stm32_etzpc_plat {
+	void *base;
+	unsigned int max_entries;
+};
+
+static int etzpc_parse_feature_domain(ofnode node, struct ofnode_phandle_args *args)
+{
+	int ret;
+
+	ret = ofnode_parse_phandle_with_args(node, "access-controllers",
+					     "#access-controller-cells", 0,
+					     0, args);
+	if (ret) {
+		log_debug("failed to parse access-controller (%d)\n", ret);
+		return ret;
+	}
+
+	if (args->args_count != 1) {
+		log_debug("invalid domain args_count: %d\n", args->args_count);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int etzpc_check_access(void *base, u32 id)
+{
+	u32 reg_offset, offset, sec_val;
+
+	/* Check access configuration, 16 peripherals per register */
+	reg_offset = ETZPC_DECPROT + 0x4 * (id / IDS_PER_DECPROT_REGS);
+	offset = (id % IDS_PER_DECPROT_REGS) << ETZPC_DECPROT_SHIFT;
+
+	/* Verify peripheral is non-secure and attributed to cortex A7 */
+	sec_val = (readl(base + reg_offset) >> offset) & ETZPC_PROT_MASK;
+	if (sec_val != ETZPC_PROT_A7NS) {
+		log_debug("Invalid bus configuration: reg_offset %#x, value %d\n",
+			  reg_offset, sec_val);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+int stm32_etzpc_check_access_by_id(ofnode device_node, u32 id)
+{
+	struct stm32_etzpc_plat *plat;
+	struct ofnode_phandle_args args;
+	struct udevice *dev;
+	int err;
+
+	err = etzpc_parse_feature_domain(device_node, &args);
+	if (err)
+		return err;
+
+	if (id == -1U)
+		id = args.args[0];
+
+	err = uclass_get_device_by_ofnode(UCLASS_NOP, args.node, &dev);
+	if (err || dev->driver != DM_DRIVER_GET(stm32_etzpc)) {
+		log_err("No device found\n");
+		return -EINVAL;
+	}
+
+	plat = dev_get_plat(dev);
+
+	if (id >= plat->max_entries) {
+		dev_err(dev, "Invalid sys bus ID for %s\n", ofnode_get_name(device_node));
+		return -EINVAL;
+	}
+
+	return etzpc_check_access(plat->base, id);
+}
+
+int stm32_etzpc_check_access(ofnode device_node)
+{
+	return stm32_etzpc_check_access_by_id(device_node, -1U);
+}
+
+static int stm32_etzpc_bind(struct udevice *dev)
+{
+	struct stm32_etzpc_plat *plat = dev_get_plat(dev);
+	struct ofnode_phandle_args args;
+	u32 nb_per, nb_master;
+	int ret = 0, err = 0;
+	ofnode node, parent;
+
+	plat->base = dev_read_addr_ptr(dev);
+	if (!plat->base) {
+		dev_err(dev, "can't get registers base address\n");
+		return -ENOENT;
+	}
+
+	/* Get number of etzpc entries*/
+	nb_per = FIELD_GET(ETZPC_HWCFGR_NUM_PER_SEC,
+			   readl(plat->base + ETZPC_HWCFGR));
+	nb_master = FIELD_GET(ETZPC_HWCFGR_NUM_AHB_SEC,
+			      readl(plat->base + ETZPC_HWCFGR));
+	plat->max_entries = nb_per + nb_master;
+
+	parent = dev_ofnode(dev);
+	for (node = ofnode_first_subnode(parent);
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node))
+			continue;
+
+		err = etzpc_parse_feature_domain(node, &args);
+		if (err) {
+			dev_err(dev, "%s failed to parse child on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		if (!ofnode_equal(args.node, parent)) {
+			dev_err(dev, "%s phandle to %s\n",
+				node_name, ofnode_get_name(args.node));
+			continue;
+		}
+
+		if (args.args[0] >= plat->max_entries) {
+			dev_err(dev, "Invalid sys bus ID for %s\n", node_name);
+			return -EINVAL;
+		}
+
+		err = etzpc_check_access(plat->base, args.args[0]);
+		if (err) {
+			dev_info(dev, "%s not allowed on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err) {
+			ret = err;
+			dev_err(dev, "%s failed to bind on bus (%d)\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_err(dev, "Some child failed to bind (%d)\n", ret);
+
+	return ret;
+}
+
+static const struct udevice_id stm32_etzpc_ids[] = {
+	{ .compatible = "st,stm32-etzpc" },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_etzpc) = {
+	.name = "stm32_etzpc",
+	.id = UCLASS_NOP,
+	.of_match = stm32_etzpc_ids,
+	.bind = stm32_etzpc_bind,
+	.plat_auto = sizeof(struct stm32_etzpc_plat),
+};
diff --git a/arch/arm/mach-stm32mp/fdt.c b/arch/arm/mach-stm32mp/fdt.c
deleted file mode 100644
index de5c5a55ea..0000000000
--- a/arch/arm/mach-stm32mp/fdt.c
+++ /dev/null
@@ -1,514 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
-/*
- * Copyright (C) 2019-2020, STMicroelectronics - All Rights Reserved
- */
-
-#define LOG_CATEGORY LOGC_ARCH
-
-#include <common.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <log.h>
-#include <tee.h>
-#include <asm/arch/sys_proto.h>
-#include <dt-bindings/pinctrl/stm32-pinfunc.h>
-#include <linux/io.h>
-
-#define ETZPC_DECPROT(n)	(STM32_ETZPC_BASE + 0x10 + 4 * (n))
-#define ETZPC_DECPROT_NB	6
-
-#define DECPROT_MASK		0x03
-#define NB_PROT_PER_REG		0x10
-#define DECPROT_NB_BITS		2
-
-#define DECPROT_SECURED		0x00
-#define DECPROT_WRITE_SECURE	0x01
-#define DECPROT_MCU_ISOLATION	0x02
-#define DECPROT_NON_SECURED	0x03
-
-#define ETZPC_RESERVED		0xffffffff
-
-#define STM32MP13_FDCAN_BASE	0x4400F000
-#define STM32MP13_ADC1_BASE	0x48003000
-#define STM32MP13_TSC_BASE	0x5000B000
-#define STM32MP13_CRYP_BASE	0x54002000
-#define STM32MP13_ETH2_BASE	0x5800E000
-#define STM32MP13_DCMIPP_BASE	0x5A000000
-#define STM32MP13_LTDC_BASE	0x5A010000
-
-#define STM32MP15_FDCAN_BASE	0x4400e000
-#define STM32MP15_CRYP2_BASE	0x4c005000
-#define STM32MP15_CRYP1_BASE	0x54001000
-#define STM32MP15_GPU_BASE	0x59000000
-#define STM32MP15_DSI_BASE	0x5a000000
-
-static const u32 stm32mp13_ip_addr[] = {
-	0x50025000,		/* 0 VREFBUF APB3 */
-	0x50021000,		/* 1 LPTIM2 APB3 */
-	0x50022000,		/* 2 LPTIM3 APB3 */
-	STM32MP13_LTDC_BASE,	/* 3 LTDC APB4 */
-	STM32MP13_DCMIPP_BASE,	/* 4 DCMIPP APB4 */
-	0x5A006000,		/* 5 USBPHYCTRL APB4 */
-	0x5A003000,		/* 6 DDRCTRLPHY APB4 */
-	ETZPC_RESERVED,		/* 7 Reserved*/
-	ETZPC_RESERVED,		/* 8 Reserved*/
-	ETZPC_RESERVED,		/* 9 Reserved*/
-	0x5C006000,		/* 10 TZC APB5 */
-	0x58001000,		/* 11 MCE APB5 */
-	0x5C000000,		/* 12 IWDG1 APB5 */
-	0x5C008000,		/* 13 STGENC APB5 */
-	ETZPC_RESERVED,		/* 14 Reserved*/
-	ETZPC_RESERVED,		/* 15 Reserved*/
-	0x4C000000,		/* 16 USART1 APB6 */
-	0x4C001000,		/* 17 USART2 APB6 */
-	0x4C002000,		/* 18 SPI4 APB6 */
-	0x4C003000,		/* 19 SPI5 APB6 */
-	0x4C004000,		/* 20 I2C3 APB6 */
-	0x4C005000,		/* 21 I2C4 APB6 */
-	0x4C006000,		/* 22 I2C5 APB6 */
-	0x4C007000,		/* 23 TIM12 APB6 */
-	0x4C008000,		/* 24 TIM13 APB6 */
-	0x4C009000,		/* 25 TIM14 APB6 */
-	0x4C00A000,		/* 26 TIM15 APB6 */
-	0x4C00B000,		/* 27 TIM16 APB6 */
-	0x4C00C000,		/* 28 TIM17 APB6 */
-	ETZPC_RESERVED,		/* 29 Reserved*/
-	ETZPC_RESERVED,		/* 30 Reserved*/
-	ETZPC_RESERVED,		/* 31 Reserved*/
-	STM32MP13_ADC1_BASE,	/* 32 ADC1 AHB2 */
-	0x48004000,		/* 33 ADC2 AHB2 */
-	0x49000000,		/* 34 OTG AHB2 */
-	ETZPC_RESERVED,		/* 35 Reserved*/
-	ETZPC_RESERVED,		/* 36 Reserved*/
-	STM32MP13_TSC_BASE,	/* 37 TSC AHB4 */
-	ETZPC_RESERVED,		/* 38 Reserved*/
-	ETZPC_RESERVED,		/* 39 Reserved*/
-	0x54004000,		/* 40 RNG AHB5 */
-	0x54003000,		/* 41 HASH AHB5 */
-	STM32MP13_CRYP_BASE,	/* 42 CRYPT AHB5 */
-	0x54005000,		/* 43 SAES AHB5 */
-	0x54006000,		/* 44 PKA AHB5 */
-	0x54000000,		/* 45 BKPSRAM AHB5 */
-	ETZPC_RESERVED,		/* 46 Reserved*/
-	ETZPC_RESERVED,		/* 47 Reserved*/
-	0x5800A000,		/* 48 ETH1 AHB6 */
-	STM32MP13_ETH2_BASE,	/* 49 ETH2 AHB6 */
-	0x58005000,		/* 50 SDMMC1 AHB6 */
-	0x58007000,		/* 51 SDMMC2 AHB6 */
-	ETZPC_RESERVED,		/* 52 Reserved*/
-	ETZPC_RESERVED,		/* 53 Reserved*/
-	0x58002000,		/* 54 FMC AHB6 */
-	0x58003000,		/* 55 QSPI AHB6 */
-	ETZPC_RESERVED,		/* 56 Reserved*/
-	ETZPC_RESERVED,		/* 57 Reserved*/
-	ETZPC_RESERVED,		/* 58 Reserved*/
-	ETZPC_RESERVED,		/* 59 Reserved*/
-	0x30000000,		/* 60 SRAM1 MLAHB */
-	0x30004000,		/* 61 SRAM2 MLAHB */
-	0x30006000,		/* 62 SRAM3 MLAHB */
-	ETZPC_RESERVED,		/* 63 Reserved*/
-	ETZPC_RESERVED,		/* 64 Reserved*/
-	ETZPC_RESERVED,		/* 65 Reserved*/
-	ETZPC_RESERVED,		/* 66 Reserved*/
-	ETZPC_RESERVED,		/* 67 Reserved*/
-	ETZPC_RESERVED,		/* 68 Reserved*/
-	ETZPC_RESERVED,		/* 69 Reserved*/
-	ETZPC_RESERVED,		/* 70 Reserved*/
-	ETZPC_RESERVED,		/* 71 Reserved*/
-	ETZPC_RESERVED,		/* 72 Reserved*/
-	ETZPC_RESERVED,		/* 73 Reserved*/
-	ETZPC_RESERVED,		/* 74 Reserved*/
-	ETZPC_RESERVED,		/* 75 Reserved*/
-	ETZPC_RESERVED,		/* 76 Reserved*/
-	ETZPC_RESERVED,		/* 77 Reserved*/
-	ETZPC_RESERVED,		/* 78 Reserved*/
-	ETZPC_RESERVED,		/* 79 Reserved*/
-	ETZPC_RESERVED,		/* 80 Reserved*/
-	ETZPC_RESERVED,		/* 81 Reserved*/
-	ETZPC_RESERVED,		/* 82 Reserved*/
-	ETZPC_RESERVED,		/* 83 Reserved*/
-	ETZPC_RESERVED,		/* 84 Reserved*/
-	ETZPC_RESERVED,		/* 85 Reserved*/
-	ETZPC_RESERVED,		/* 86 Reserved*/
-	ETZPC_RESERVED,		/* 87 Reserved*/
-	ETZPC_RESERVED,		/* 88 Reserved*/
-	ETZPC_RESERVED,		/* 89 Reserved*/
-	ETZPC_RESERVED,		/* 90 Reserved*/
-	ETZPC_RESERVED,		/* 91 Reserved*/
-	ETZPC_RESERVED,		/* 92 Reserved*/
-	ETZPC_RESERVED,		/* 93 Reserved*/
-	ETZPC_RESERVED,		/* 94 Reserved*/
-	ETZPC_RESERVED,		/* 95 Reserved*/
-};
-
-static const u32 stm32mp15_ip_addr[] = {
-	0x5c008000,	/* 00 stgenc */
-	0x54000000,	/* 01 bkpsram */
-	0x5c003000,	/* 02 iwdg1 */
-	0x5c000000,	/* 03 usart1 */
-	0x5c001000,	/* 04 spi6 */
-	0x5c002000,	/* 05 i2c4 */
-	ETZPC_RESERVED,	/* 06 reserved */
-	0x54003000,	/* 07 rng1 */
-	0x54002000,	/* 08 hash1 */
-	STM32MP15_CRYP1_BASE,	/* 09 cryp1 */
-	0x5a003000,	/* 0A ddrctrl */
-	0x5a004000,	/* 0B ddrphyc */
-	0x5c009000,	/* 0C i2c6 */
-	ETZPC_RESERVED,	/* 0D reserved */
-	ETZPC_RESERVED,	/* 0E reserved */
-	ETZPC_RESERVED,	/* 0F reserved */
-	0x40000000,	/* 10 tim2 */
-	0x40001000,	/* 11 tim3 */
-	0x40002000,	/* 12 tim4 */
-	0x40003000,	/* 13 tim5 */
-	0x40004000,	/* 14 tim6 */
-	0x40005000,	/* 15 tim7 */
-	0x40006000,	/* 16 tim12 */
-	0x40007000,	/* 17 tim13 */
-	0x40008000,	/* 18 tim14 */
-	0x40009000,	/* 19 lptim1 */
-	0x4000a000,	/* 1A wwdg1 */
-	0x4000b000,	/* 1B spi2 */
-	0x4000c000,	/* 1C spi3 */
-	0x4000d000,	/* 1D spdifrx */
-	0x4000e000,	/* 1E usart2 */
-	0x4000f000,	/* 1F usart3 */
-	0x40010000,	/* 20 uart4 */
-	0x40011000,	/* 21 uart5 */
-	0x40012000,	/* 22 i2c1 */
-	0x40013000,	/* 23 i2c2 */
-	0x40014000,	/* 24 i2c3 */
-	0x40015000,	/* 25 i2c5 */
-	0x40016000,	/* 26 cec */
-	0x40017000,	/* 27 dac */
-	0x40018000,	/* 28 uart7 */
-	0x40019000,	/* 29 uart8 */
-	ETZPC_RESERVED,	/* 2A reserved */
-	ETZPC_RESERVED,	/* 2B reserved */
-	0x4001c000,	/* 2C mdios */
-	ETZPC_RESERVED,	/* 2D reserved */
-	ETZPC_RESERVED,	/* 2E reserved */
-	ETZPC_RESERVED,	/* 2F reserved */
-	0x44000000,	/* 30 tim1 */
-	0x44001000,	/* 31 tim8 */
-	ETZPC_RESERVED,	/* 32 reserved */
-	0x44003000,	/* 33 usart6 */
-	0x44004000,	/* 34 spi1 */
-	0x44005000,	/* 35 spi4 */
-	0x44006000,	/* 36 tim15 */
-	0x44007000,	/* 37 tim16 */
-	0x44008000,	/* 38 tim17 */
-	0x44009000,	/* 39 spi5 */
-	0x4400a000,	/* 3A sai1 */
-	0x4400b000,	/* 3B sai2 */
-	0x4400c000,	/* 3C sai3 */
-	0x4400d000,	/* 3D dfsdm */
-	STM32MP15_FDCAN_BASE,	/* 3E tt_fdcan */
-	ETZPC_RESERVED,	/* 3F reserved */
-	0x50021000,	/* 40 lptim2 */
-	0x50022000,	/* 41 lptim3 */
-	0x50023000,	/* 42 lptim4 */
-	0x50024000,	/* 43 lptim5 */
-	0x50027000,	/* 44 sai4 */
-	0x50025000,	/* 45 vrefbuf */
-	0x4c006000,	/* 46 dcmi */
-	0x4c004000,	/* 47 crc2 */
-	0x48003000,	/* 48 adc */
-	0x4c002000,	/* 49 hash2 */
-	0x4c003000,	/* 4A rng2 */
-	STM32MP15_CRYP2_BASE,	/* 4B cryp2 */
-	ETZPC_RESERVED,	/* 4C reserved */
-	ETZPC_RESERVED,	/* 4D reserved */
-	ETZPC_RESERVED,	/* 4E reserved */
-	ETZPC_RESERVED,	/* 4F reserved */
-	ETZPC_RESERVED,	/* 50 sram1 */
-	ETZPC_RESERVED,	/* 51 sram2 */
-	ETZPC_RESERVED,	/* 52 sram3 */
-	ETZPC_RESERVED,	/* 53 sram4 */
-	ETZPC_RESERVED,	/* 54 retram */
-	0x49000000,	/* 55 otg */
-	0x48004000,	/* 56 sdmmc3 */
-	0x48005000,	/* 57 dlybsd3 */
-	0x48000000,	/* 58 dma1 */
-	0x48001000,	/* 59 dma2 */
-	0x48002000,	/* 5A dmamux */
-	0x58002000,	/* 5B fmc */
-	0x58003000,	/* 5C qspi */
-	0x58004000,	/* 5D dlybq */
-	0x5800a000,	/* 5E eth */
-	ETZPC_RESERVED,	/* 5F reserved */
-};
-
-/* fdt helper */
-static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
-{
-	int node;
-	fdt_addr_t regs;
-
-	for (node = fdt_first_subnode(fdt, offset);
-	     node >= 0;
-	     node = fdt_next_subnode(fdt, node)) {
-		regs = fdtdec_get_addr(fdt, node, "reg");
-		if (addr == regs) {
-			if (fdtdec_get_is_enabled(fdt, node)) {
-				fdt_status_disabled(fdt, node);
-
-				return true;
-			}
-			return false;
-		}
-	}
-
-	return false;
-}
-
-static int stm32_fdt_fixup_etzpc(void *fdt, int soc_node)
-{
-	const u32 *array;
-	int array_size, i;
-	int offset, shift;
-	u32 addr, status, decprot[ETZPC_DECPROT_NB];
-
-	if (IS_ENABLED(CONFIG_STM32MP13x)) {
-		array = stm32mp13_ip_addr;
-		array_size = ARRAY_SIZE(stm32mp13_ip_addr);
-	}
-
-	if (IS_ENABLED(CONFIG_STM32MP15x)) {
-		array = stm32mp15_ip_addr;
-		array_size = ARRAY_SIZE(stm32mp15_ip_addr);
-	}
-
-	for (i = 0; i < ETZPC_DECPROT_NB; i++)
-		decprot[i] = readl(ETZPC_DECPROT(i));
-
-	for (i = 0; i < array_size; i++) {
-		offset = i / NB_PROT_PER_REG;
-		shift = (i % NB_PROT_PER_REG) * DECPROT_NB_BITS;
-		status = (decprot[offset] >> shift) & DECPROT_MASK;
-		addr = array[i];
-
-		log_debug("ETZPC: 0x%08x decprot %d=%d\n", addr, i, status);
-
-		if (addr == ETZPC_RESERVED ||
-		    status == DECPROT_NON_SECURED)
-			continue;
-
-		if (fdt_disable_subnode_by_address(fdt, soc_node, addr))
-			log_notice("ETZPC: 0x%08x node disabled, decprot %d=%d\n",
-				   addr, i, status);
-	}
-
-	return 0;
-}
-
-/* deactivate all the cpu except core 0 */
-static void stm32_fdt_fixup_cpu(void *blob, char *name)
-{
-	int off;
-	u32 reg;
-
-	off = fdt_path_offset(blob, "/cpus");
-	if (off < 0) {
-		log_warning("%s: couldn't find /cpus node\n", __func__);
-		return;
-	}
-
-	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
-	while (off != -FDT_ERR_NOTFOUND) {
-		reg = fdtdec_get_addr(blob, off, "reg");
-		if (reg != 0) {
-			fdt_del_node(blob, off);
-			log_notice("FDT: cpu %d node remove for %s\n",
-				   reg, name);
-			/* after delete we can't trust the offsets anymore */
-			off = -1;
-		}
-		off = fdt_node_offset_by_prop_value(blob, off,
-						    "device_type", "cpu", 4);
-	}
-}
-
-static void stm32_fdt_disable(void *fdt, int offset, u32 addr,
-			      const char *string, const char *name)
-{
-	if (fdt_disable_subnode_by_address(fdt, offset, addr))
-		log_notice("FDT: %s@%08x node disabled for %s\n",
-			   string, addr, name);
-}
-
-static void stm32_fdt_disable_optee(void *blob)
-{
-	int off, node;
-
-	/* Delete "optee" firmware node */
-	off = fdt_node_offset_by_compatible(blob, -1, "linaro,optee-tz");
-	if (off >= 0 && fdtdec_get_is_enabled(blob, off))
-		fdt_del_node(blob, off);
-
-	/* Delete "optee@..." reserved-memory node */
-	off = fdt_path_offset(blob, "/reserved-memory/");
-	if (off < 0)
-		return;
-	for (node = fdt_first_subnode(blob, off);
-	     node >= 0;
-	     node = fdt_next_subnode(blob, node)) {
-		if (strncmp(fdt_get_name(blob, node, NULL), "optee@", 6))
-			continue;
-
-		if (fdt_del_node(blob, node))
-			printf("Failed to remove optee reserved-memory node\n");
-	}
-}
-
-static void stm32mp13_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
-{
-	switch (cpu) {
-	case CPU_STM32MP131Fxx:
-	case CPU_STM32MP131Dxx:
-	case CPU_STM32MP131Cxx:
-	case CPU_STM32MP131Axx:
-		stm32_fdt_disable(blob, soc, STM32MP13_FDCAN_BASE, "can", name);
-		stm32_fdt_disable(blob, soc, STM32MP13_ADC1_BASE, "adc", name);
-		fallthrough;
-	case CPU_STM32MP133Fxx:
-	case CPU_STM32MP133Dxx:
-	case CPU_STM32MP133Cxx:
-	case CPU_STM32MP133Axx:
-		stm32_fdt_disable(blob, soc, STM32MP13_LTDC_BASE, "ltdc", name);
-		stm32_fdt_disable(blob, soc, STM32MP13_DCMIPP_BASE, "dcmipp",
-				  name);
-		stm32_fdt_disable(blob, soc, STM32MP13_TSC_BASE, "tsc", name);
-		break;
-	default:
-		break;
-	}
-
-	switch (cpu) {
-	case CPU_STM32MP135Dxx:
-	case CPU_STM32MP135Axx:
-	case CPU_STM32MP133Dxx:
-	case CPU_STM32MP133Axx:
-	case CPU_STM32MP131Dxx:
-	case CPU_STM32MP131Axx:
-		stm32_fdt_disable(blob, soc, STM32MP13_CRYP_BASE, "cryp", name);
-		break;
-	default:
-		break;
-	}
-}
-
-static void stm32mp15_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
-{
-	u32 pkg;
-
-	switch (cpu) {
-	case CPU_STM32MP151Fxx:
-	case CPU_STM32MP151Dxx:
-	case CPU_STM32MP151Cxx:
-	case CPU_STM32MP151Axx:
-		stm32_fdt_fixup_cpu(blob, name);
-		/* after cpu delete we can't trust the soc offsets anymore */
-		soc = fdt_path_offset(blob, "/soc");
-		stm32_fdt_disable(blob, soc, STM32MP15_FDCAN_BASE, "can", name);
-		fallthrough;
-	case CPU_STM32MP153Fxx:
-	case CPU_STM32MP153Dxx:
-	case CPU_STM32MP153Cxx:
-	case CPU_STM32MP153Axx:
-		stm32_fdt_disable(blob, soc, STM32MP15_GPU_BASE, "gpu", name);
-		stm32_fdt_disable(blob, soc, STM32MP15_DSI_BASE, "dsi", name);
-		break;
-	default:
-		break;
-	}
-	switch (cpu) {
-	case CPU_STM32MP157Dxx:
-	case CPU_STM32MP157Axx:
-	case CPU_STM32MP153Dxx:
-	case CPU_STM32MP153Axx:
-	case CPU_STM32MP151Dxx:
-	case CPU_STM32MP151Axx:
-		stm32_fdt_disable(blob, soc, STM32MP15_CRYP1_BASE, "cryp",
-				  name);
-		stm32_fdt_disable(blob, soc, STM32MP15_CRYP2_BASE, "cryp",
-				  name);
-		break;
-	default:
-		break;
-	}
-	switch (get_cpu_package()) {
-	case STM32MP15_PKG_AA_LBGA448:
-		pkg = STM32MP_PKG_AA;
-		break;
-	case STM32MP15_PKG_AB_LBGA354:
-		pkg = STM32MP_PKG_AB;
-		break;
-	case STM32MP15_PKG_AC_TFBGA361:
-		pkg = STM32MP_PKG_AC;
-		break;
-	case STM32MP15_PKG_AD_TFBGA257:
-		pkg = STM32MP_PKG_AD;
-		break;
-	default:
-		pkg = 0;
-		break;
-	}
-	if (pkg) {
-		do_fixup_by_compat_u32(blob, "st,stm32mp157-pinctrl",
-				       "st,package", pkg, false);
-		do_fixup_by_compat_u32(blob, "st,stm32mp157-z-pinctrl",
-				       "st,package", pkg, false);
-	}
-}
-
-/*
- * This function is called right before the kernel is booted. "blob" is the
- * device tree that will be passed to the kernel.
- */
-int ft_system_setup(void *blob, struct bd_info *bd)
-{
-	int ret = 0;
-	int soc;
-	u32 cpu;
-	char name[SOC_NAME_SIZE];
-
-	soc = fdt_path_offset(blob, "/soc");
-	/* when absent, nothing to do */
-	if (soc == -FDT_ERR_NOTFOUND)
-		return 0;
-	if (soc < 0)
-		return soc;
-
-	if (CONFIG_IS_ENABLED(STM32_ETZPC)) {
-		ret = stm32_fdt_fixup_etzpc(blob, soc);
-		if (ret)
-			return ret;
-	}
-
-	/* MPUs Part Numbers and name*/
-	cpu = get_cpu_type();
-	get_soc_name(name);
-
-	if (IS_ENABLED(CONFIG_STM32MP13x))
-		stm32mp13_fdt_fixup(blob, soc, cpu, name);
-
-	if (IS_ENABLED(CONFIG_STM32MP15x)) {
-		stm32mp15_fdt_fixup(blob, soc, cpu, name);
-
-		/*
-		 * TEMP: remove OP-TEE nodes in kernel device tree
-		 *       copied from U-Boot device tree by optee_copy_fdt_nodes
-		 *       when OP-TEE is not detected (probe failed)
-		 * these OP-TEE nodes are present in <board>-u-boot.dtsi
-		 * under CONFIG_STM32MP15x_STM32IMAGE only for compatibility
-		 * when FIP is not used by TF-A
-		 */
-		if (IS_ENABLED(CONFIG_STM32MP15x_STM32IMAGE) &&
-		    !tee_find_device(NULL, NULL, NULL, NULL))
-			stm32_fdt_disable_optee(blob);
-	}
-
-	return ret;
-}
diff --git a/arch/arm/mach-stm32mp/include/mach/etzpc.h b/arch/arm/mach-stm32mp/include/mach/etzpc.h
new file mode 100644
index 0000000000..fd697c3e2a
--- /dev/null
+++ b/arch/arm/mach-stm32mp/include/mach/etzpc.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef MACH_ETZPC_H
+#define MACH_ETZPC_H
+
+#include <linux/types.h>
+
+/**
+ * stm32_etzpc_check_access - Check ETZPC accesses for given device node
+ *
+ * @device_node		Node of the device for which the accesses are checked
+ *
+ * @returns 0 on success (if access is granted), -EINVAL if access is denied.
+ *          Else, returns an appropriate negative ERRNO value
+ */
+int stm32_etzpc_check_access(ofnode device_node);
+
+/**
+ * stm32_etzpc_check_access_by_id - Check ETZPC accesses for given id
+ *
+ * @device_node		Node of the device to get a reference on ETZPC
+ * @id			ID of the resource to check
+ *
+ * @returns 0 on success (if access is granted), -EINVAL if access is denied.
+ *          Else, returns an appropriate negative ERRNO value
+ */
+int stm32_etzpc_check_access_by_id(ofnode device_node, u32 id);
+
+#endif /* MACH_ETZPC_H*/
diff --git a/arch/arm/mach-stm32mp/include/mach/rif.h b/arch/arm/mach-stm32mp/include/mach/rif.h
new file mode 100644
index 0000000000..10b2210812
--- /dev/null
+++ b/arch/arm/mach-stm32mp/include/mach/rif.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef MACH_RIF_H
+#define MACH_RIF_H
+
+#include <linux/types.h>
+
+/**
+ * stm32_rifsc_check_access - Check RIF accesses for given device node
+ *
+ * @device_node		Node of the device for which the accesses are checked
+ */
+int stm32_rifsc_check_access(ofnode device_node);
+
+/**
+ * stm32_rifsc_check_access - Check RIF accesses for given id
+ *
+ * @device_node		Node of the device to get a reference on RIFSC
+ * @id			ID of the resource to check
+ */
+int stm32_rifsc_check_access_by_id(ofnode device_node, u32 id);
+
+#endif /* MACH_RIF_H*/
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32.h b/arch/arm/mach-stm32mp/include/mach/stm32.h
index 1cdc5e3b18..7c4836a894 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
 /*
- * Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2024, STMicroelectronics - All Rights Reserved
  */
 
 #ifndef _MACH_STM32_H_
@@ -8,16 +8,73 @@
 
 #ifndef __ASSEMBLY__
 #include <linux/bitops.h>
+
+enum boot_device {
+	BOOT_FLASH_SD = 0x10,
+	BOOT_FLASH_SD_1 = 0x11,
+	BOOT_FLASH_SD_2 = 0x12,
+	BOOT_FLASH_SD_3 = 0x13,
+
+	BOOT_FLASH_EMMC = 0x20,
+	BOOT_FLASH_EMMC_1 = 0x21,
+	BOOT_FLASH_EMMC_2 = 0x22,
+	BOOT_FLASH_EMMC_3 = 0x23,
+
+	BOOT_FLASH_NAND = 0x30,
+	BOOT_FLASH_NAND_FMC = 0x31,
+
+	BOOT_FLASH_NOR = 0x40,
+	BOOT_FLASH_NOR_QSPI = 0x41,
+
+	BOOT_SERIAL_UART = 0x50,
+	BOOT_SERIAL_UART_1 = 0x51,
+	BOOT_SERIAL_UART_2 = 0x52,
+	BOOT_SERIAL_UART_3 = 0x53,
+	BOOT_SERIAL_UART_4 = 0x54,
+	BOOT_SERIAL_UART_5 = 0x55,
+	BOOT_SERIAL_UART_6 = 0x56,
+	BOOT_SERIAL_UART_7 = 0x57,
+	BOOT_SERIAL_UART_8 = 0x58,
+
+	BOOT_SERIAL_USB = 0x60,
+	BOOT_SERIAL_USB_OTG = 0x62,
+
+	BOOT_FLASH_SPINAND = 0x70,
+	BOOT_FLASH_SPINAND_1 = 0x71,
+
+	BOOT_FLASH_HYPERFLASH = 0x80,
+	BOOT_FLASH_HYPERFLASH_1 = 0x81
+};
+
+#define TAMP_BOOT_MODE_MASK		GENMASK(15, 8)
+#define TAMP_BOOT_MODE_SHIFT		8
+#define TAMP_BOOT_DEVICE_MASK		GENMASK(7, 4)
+#define TAMP_BOOT_INSTANCE_MASK		GENMASK(3, 0)
+#define TAMP_BOOT_FORCED_MASK		GENMASK(7, 0)
+#define TAMP_BOOT_DEBUG_ON		BIT(16)
+
+enum forced_boot_mode {
+	BOOT_NORMAL = 0x00,
+	BOOT_FASTBOOT = 0x01,
+	BOOT_RECOVERY = 0x02,
+	BOOT_STM32PROG = 0x03,
+	BOOT_UMS_MMC0 = 0x10,
+	BOOT_UMS_MMC1 = 0x11,
+	BOOT_UMS_MMC2 = 0x12,
+};
+
 #endif
 
 /*
  * Peripheral memory map
  * only address used before device tree parsing
  */
+
+#if defined(CONFIG_STM32MP15X) || defined(CONFIG_STM32MP13X)
 #define STM32_RCC_BASE			0x50000000
 #define STM32_PWR_BASE			0x50001000
 #define STM32_SYSCFG_BASE		0x50020000
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_DBGMCU_BASE		0x50081000
 #endif
 #define STM32_FMC2_BASE			0x58002000
@@ -30,11 +87,11 @@
 #define STM32_STGEN_BASE		0x5C008000
 #define STM32_TAMP_BASE			0x5C00A000
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_USART1_BASE		0x5C000000
 #define STM32_USART2_BASE		0x4000E000
 #endif
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define STM32_USART1_BASE		0x4c000000
 #define STM32_USART2_BASE		0x4c001000
 #endif
@@ -49,7 +106,7 @@
 #define STM32_SDMMC2_BASE		0x58007000
 #define STM32_SDMMC3_BASE		0x48004000
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_SYSRAM_BASE		0x2FFC0000
 #define STM32_SYSRAM_SIZE		SZ_256K
 #endif
@@ -58,12 +115,6 @@
 #define STM32_DDR_SIZE			SZ_1G
 
 #ifndef __ASSEMBLY__
-/* enumerated used to identify the SYSCON driver instance */
-enum {
-	STM32MP_SYSCON_UNKNOWN,
-	STM32MP_SYSCON_SYSCFG,
-};
-
 /*
  * enumerated for boot interface from Bootrom, used in TAMP_BOOT_CONTEXT
  * - boot device = bit 8:4
@@ -74,44 +125,10 @@ enum {
 #define BOOT_INSTANCE_MASK	0x0F
 #define BOOT_INSTANCE_SHIFT	0
 
-enum boot_device {
-	BOOT_FLASH_SD = 0x10,
-	BOOT_FLASH_SD_1 = 0x11,
-	BOOT_FLASH_SD_2 = 0x12,
-	BOOT_FLASH_SD_3 = 0x13,
-
-	BOOT_FLASH_EMMC = 0x20,
-	BOOT_FLASH_EMMC_1 = 0x21,
-	BOOT_FLASH_EMMC_2 = 0x22,
-	BOOT_FLASH_EMMC_3 = 0x23,
-
-	BOOT_FLASH_NAND = 0x30,
-	BOOT_FLASH_NAND_FMC = 0x31,
-
-	BOOT_FLASH_NOR = 0x40,
-	BOOT_FLASH_NOR_QSPI = 0x41,
-
-	BOOT_SERIAL_UART = 0x50,
-	BOOT_SERIAL_UART_1 = 0x51,
-	BOOT_SERIAL_UART_2 = 0x52,
-	BOOT_SERIAL_UART_3 = 0x53,
-	BOOT_SERIAL_UART_4 = 0x54,
-	BOOT_SERIAL_UART_5 = 0x55,
-	BOOT_SERIAL_UART_6 = 0x56,
-	BOOT_SERIAL_UART_7 = 0x57,
-	BOOT_SERIAL_UART_8 = 0x58,
-
-	BOOT_SERIAL_USB = 0x60,
-	BOOT_SERIAL_USB_OTG = 0x62,
-
-	BOOT_FLASH_SPINAND = 0x70,
-	BOOT_FLASH_SPINAND_1 = 0x71,
-};
-
 /* TAMP registers */
 #define TAMP_BACKUP_REGISTER(x)		(STM32_TAMP_BASE + 0x100 + 4 * x)
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define TAMP_BACKUP_MAGIC_NUMBER	TAMP_BACKUP_REGISTER(4)
 #define TAMP_BACKUP_BRANCH_ADDRESS	TAMP_BACKUP_REGISTER(5)
 #define TAMP_FWU_BOOT_INFO_REG		TAMP_BACKUP_REGISTER(10)
@@ -123,35 +140,54 @@ enum boot_device {
 #define TAMP_FWU_BOOT_IDX_MASK		GENMASK(3, 0)
 
 #define TAMP_FWU_BOOT_IDX_OFFSET	0
-
-#define TAMP_COPRO_STATE_OFF		0
-#define TAMP_COPRO_STATE_INIT		1
-#define TAMP_COPRO_STATE_CRUN		2
-#define TAMP_COPRO_STATE_CSTOP		3
-#define TAMP_COPRO_STATE_STANDBY	4
-#define TAMP_COPRO_STATE_CRASH		5
 #endif
 
-#ifdef CONFIG_STM32MP13x
-#define TAMP_BOOTCOUNT			TAMP_BACKUP_REGISTER(31)
+#ifdef CONFIG_STM32MP13X
+#define TAMP_FWU_BOOT_INFO_REG		TAMP_BACKUP_REGISTER(10)
 #define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(30)
+#define TAMP_BOOTCOUNT			TAMP_BACKUP_REGISTER(31)
+
+#define TAMP_FWU_BOOT_IDX_MASK		GENMASK(3, 0)
+#define TAMP_FWU_BOOT_IDX_OFFSET	0
 #endif
 
-#define TAMP_BOOT_MODE_MASK		GENMASK(15, 8)
-#define TAMP_BOOT_MODE_SHIFT		8
-#define TAMP_BOOT_DEVICE_MASK		GENMASK(7, 4)
-#define TAMP_BOOT_INSTANCE_MASK		GENMASK(3, 0)
-#define TAMP_BOOT_FORCED_MASK		GENMASK(7, 0)
+#endif /* __ASSEMBLY__ */
+#endif /* CONFIG_STM32MP15X || CONFIG_STM32MP13X */
+#define TAMP_BOOT_AUTH_MASK		GENMASK(23, 16)
+#define TAMP_BOOT_AUTH_SHIFT		16
+#define TAMP_BOOT_AUTH_ST_MASK		GENMASK(7, 4)
+#define TAMP_BOOT_PARTITION_MASK	GENMASK(3, 0)
+
+#if defined(CONFIG_STM32MP21X) || defined(CONFIG_STM32MP23X) || defined(CONFIG_STM32MP25X)
+#define STM32_USART2_BASE		0x400E0000
+#define STM32_USART3_BASE		0x400F0000
+#define STM32_UART4_BASE		0x40100000
+#define STM32_UART5_BASE		0x40110000
+#define STM32_USART6_BASE		0x40220000
+#ifdef CONFIG_STM32MP25X
+#define STM32_UART9_BASE		0x402C0000
+#endif
+#define STM32_USART1_BASE		0x40330000
+#define STM32_UART7_BASE		0x40370000
+#ifdef CONFIG_STM32MP25X
+#define STM32_UART8_BASE		0x40380000
+#endif
+#define STM32_RCC_BASE			0x44200000
+#define STM32_TAMP_BASE			0x46010000
+#define STM32_SDMMC1_BASE		0x48220000
+#define STM32_SDMMC2_BASE		0x48230000
+#define STM32_SDMMC3_BASE		0x48240000
 
-enum forced_boot_mode {
-	BOOT_NORMAL = 0x00,
-	BOOT_FASTBOOT = 0x01,
-	BOOT_RECOVERY = 0x02,
-	BOOT_STM32PROG = 0x03,
-	BOOT_UMS_MMC0 = 0x10,
-	BOOT_UMS_MMC1 = 0x11,
-	BOOT_UMS_MMC2 = 0x12,
-};
+#define STM32_DDR_BASE			0x80000000
+
+#define STM32_DDR_SIZE			SZ_4G
+
+/* TAMP registers x = 0 to 127 : hardcoded description, waiting NVMEM node in DT */
+#define TAMP_BACKUP_REGISTER(x)		(STM32_TAMP_BASE + 0x100 + 4 * (x))
+
+/* TAMP registers zone 3 RIF 1 (RW) at 96*/
+#define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(96)
+#endif /* defined(CONFIG_STM32MP21X) || defined(CONFIG_STM32MP23X) || defined(CONFIG_STM32MP25X) */
 
 /* offset used for BSEC driver: misc_read and misc_write */
 #define STM32_BSEC_SHADOW_OFFSET	0x0
@@ -162,19 +198,38 @@ enum forced_boot_mode {
 #define STM32_BSEC_LOCK(id)		(STM32_BSEC_LOCK_OFFSET + (id) * 4)
 
 /* BSEC OTP index */
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define BSEC_OTP_RPN	1
 #define BSEC_OTP_SERIAL	13
 #define BSEC_OTP_PKG	16
 #define BSEC_OTP_MAC	57
 #define BSEC_OTP_BOARD	59
 #endif
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define BSEC_OTP_RPN	1
 #define BSEC_OTP_SERIAL	13
 #define BSEC_OTP_MAC	57
 #define BSEC_OTP_BOARD	60
 #endif
+#if defined(CONFIG_STM32MP21X) || defined(CONFIG_STM32MP23X) || defined(CONFIG_STM32MP25X)
+#define BSEC_OTP_SERIAL	5
+#define BSEC_OTP_RPN	9
+#define BSEC_OTP_REVID	102
+#define BSEC_OTP_PKG	122
+
+#define BSEC_OTP_BOARD	246
+#define BSEC_OTP_MAC	247
+
+#endif /* defined(CONFIG_STM32MP21X) || defined(CONFIG_STM32MP23X) || defined(CONFIG_STM32MP25X) */
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+/* enumerated used to identify the SYSCON driver instance */
+enum {
+	STM32MP_SYSCON_UNKNOWN,
+	STM32MP_SYSCON_SYSCFG,
+};
+#endif /* __ASSEMBLY__*/
 
-#endif /* __ASSEMBLY__ */
 #endif /* _MACH_STM32_H_ */
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
index 4ad14f963b..b4ea6190a6 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
@@ -15,11 +15,39 @@
  * for SiP (silicon Partner)
  * http://infocenter.arm.com/help/topic/com.arm.doc.den0028a/index.html
  */
-#define STM32_SMC_VERSION		0x82000000
 
 /* Secure Service access from Non-secure */
+
+/*
+ * STM32_SMC_PWR call API
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_PWR			0x82001001
+
+/*
+ * STM32_SMC_BSEC call API
+ *
+ * Argument a0: (input) SMCC ID
+ *		(output) status return code
+ * Argument a1: (input) Service ID (STM32_SMC_BSEC_xxx)
+ * Argument a2: (input) OTP index
+ *		(output) OTP read value, if applicable
+ * Argument a3: (input) OTP value if applicable
+ */
 #define STM32_SMC_BSEC			0x82001003
 
+/* Service ID for STM32_SMC_PWR */
+#define STM32_SMC_REG_READ		0x0
+#define STM32_SMC_REG_WRITE		0x1
+#define STM32_SMC_REG_SET		0x2
+#define STM32_SMC_REG_CLEAR		0x3
+
 /* Service for BSEC */
 #define STM32_SMC_READ_SHADOW		0x01
 #define STM32_SMC_PROG_OTP		0x02
@@ -30,23 +58,25 @@
 #define STM32_SMC_WRLOCK_OTP		0x07
 
 /* SMC error codes */
-#define STM32_SMC_OK			0x0
-#define STM32_SMC_NOT_SUPPORTED		-1
-#define STM32_SMC_FAILED		-2
-#define STM32_SMC_INVALID_PARAMS	-3
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xffffffffU
+#define STM32_SMC_FAILED		0xfffffffeU
+#define STM32_SMC_INVALID_PARAMS	0xfffffffdU
 
 #define stm32_smc_exec(svc, op, data1, data2) \
 	stm32_smc(svc, op, data1, data2, NULL)
 
 #ifdef CONFIG_ARM_SMCCC
-static inline u32 stm32_smc(u32 svc, u8 op, u32 data1, u32 data2, u32 *result)
+static inline u32 stm32_smc(unsigned long svc, unsigned long op,
+			    unsigned long data1, unsigned long data2,
+			    u32 *result)
 {
 	struct arm_smccc_res res;
 
 	arm_smccc_smc(svc, op, data1, data2, 0, 0, 0, 0, &res);
 
 	if (res.a0) {
-		pr_err("%s: Failed to exec svc=%x op=%x in secure mode (err = %ld)\n",
+		pr_err("%s: Failed to exec svc=%lx op=%lx in secure mode (err = %ld)\n",
 		       __func__, svc, op, res.a0);
 		return -EINVAL;
 	}
@@ -56,7 +86,9 @@ static inline u32 stm32_smc(u32 svc, u8 op, u32 data1, u32 data2, u32 *result)
 	return 0;
 }
 #else
-static inline u32 stm32_smc(u32 svc, u8 op, u32 data1, u32 data2, u32 *result)
+static inline u32 stm32_smc(unsigned long svc, unsigned long op,
+			    unsigned long data1, unsigned long data2,
+			    u32 *result)
 {
 	return 0;
 }
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32prog.h b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
index 23d1adfbad..c10bff09c8 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32prog.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
@@ -10,5 +10,3 @@ int stm32prog_write_medium_virt(struct dfu_entity *dfu, u64 offset,
 int stm32prog_read_medium_virt(struct dfu_entity *dfu, u64 offset,
 			       void *buf, long *len);
 int stm32prog_get_medium_size_virt(struct dfu_entity *dfu, u64 *size);
-
-bool stm32prog_get_fsbl_nor(void);
diff --git a/arch/arm/mach-stm32mp/include/mach/sys_proto.h b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
index 83fb32a45f..ce18e54697 100644
--- a/arch/arm/mach-stm32mp/include/mach/sys_proto.h
+++ b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
 /*
- * Copyright (C) 2015-2017, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2015-2024, STMicroelectronics - All Rights Reserved
  */
 
 /* ID = Device Version (bit31:16) + Device Part Number (RPN) (bit15:0) */
@@ -30,15 +30,63 @@
 #define CPU_STM32MP131Fxx	0x05010EC8
 #define CPU_STM32MP131Dxx	0x05010EC9
 
+/* ID for STM32MP2xx = Device Part Number (RPN) (bit31:0) */
+#define CPU_STM32MP257Cxx       0x00002000
+#define CPU_STM32MP255Cxx       0x00082000
+#define CPU_STM32MP253Cxx       0x000B300C
+#define CPU_STM32MP251Cxx       0x000B306D
+#define CPU_STM32MP257Axx       0x40002E00
+#define CPU_STM32MP255Axx       0x40082E00
+#define CPU_STM32MP253Axx       0x400B3E0C
+#define CPU_STM32MP251Axx       0x400B3E6D
+#define CPU_STM32MP257Fxx       0x80002000
+#define CPU_STM32MP255Fxx       0x80082000
+#define CPU_STM32MP253Fxx       0x800B300C
+#define CPU_STM32MP251Fxx       0x800B306D
+#define CPU_STM32MP257Dxx       0xC0002E00
+#define CPU_STM32MP255Dxx       0xC0082E00
+#define CPU_STM32MP253Dxx       0xC00B3E0C
+#define CPU_STM32MP251Dxx       0xC00B3E6D
+
+/* ID for STM32MP23x = Device Part Number (RPN) (bit31:0) */
+#define CPU_STM32MP235Cxx       0x00082182
+#define CPU_STM32MP233Cxx       0x000B318E
+#define CPU_STM32MP231Cxx       0x000B31EF
+#define CPU_STM32MP235Axx       0x40082F82
+#define CPU_STM32MP233Axx       0x400B3F8E
+#define CPU_STM32MP231Axx       0x400B3FEF
+#define CPU_STM32MP235Fxx       0x80082182
+#define CPU_STM32MP233Fxx       0x800B318E
+#define CPU_STM32MP231Fxx       0x800B31EF
+#define CPU_STM32MP235Dxx       0xC0082F82
+#define CPU_STM32MP233Dxx       0xC00B3F8E
+#define CPU_STM32MP231Dxx       0xC00B3FEF
+
+#define CPU_STM32MP211Axx	0x40073E7D
+#define CPU_STM32MP211Cxx	0x0007307D
+#define CPU_STM32MP211Dxx	0xC0073E7D
+#define CPU_STM32MP211Fxx	0x8007307D
+#define CPU_STM32MP213Axx	0x40073E1D
+#define CPU_STM32MP213Cxx	0x0007301D
+#define CPU_STM32MP213Dxx	0xC0073E1D
+#define CPU_STM32MP213Fxx	0x8007301D
+#define CPU_STM32MP215Axx	0x40033E0D
+#define CPU_STM32MP215Cxx	0x0003300D
+#define CPU_STM32MP215Dxx	0xC0033E0D
+#define CPU_STM32MP215Fxx	0x8003300D
+
 /* return CPU_STMP32MP...Xxx constants */
 u32 get_cpu_type(void);
 
 #define CPU_DEV_STM32MP15	0x500
 #define CPU_DEV_STM32MP13	0x501
+#define CPU_DEV_STM32MP21	0x503
+#define CPU_DEV_STM32MP25	0x505
 
 /* return CPU_DEV constants */
 u32 get_cpu_dev(void);
 
+/* Silicon revision = REV_ID[15:0] of Device Version */
 #define CPU_REV1	0x1000
 #define CPU_REV1_1	0x1001
 #define CPU_REV1_2	0x1003
@@ -46,7 +94,15 @@ u32 get_cpu_dev(void);
 #define CPU_REV2_1	0x2001
 #define CPU_REV2_2	0x2003
 
-/* return Silicon revision = REV_ID[15:0] of Device Version */
+/* OTP revision ID = 6 bits : 3 for Major / 3 for Minor */
+#define OTP_REVID_1	0b001000
+#define OTP_REVID_1_1	0b001001
+#define OTP_REVID_1_2	0b001010
+#define OTP_REVID_2	0b010000
+#define OTP_REVID_2_1	0b010001
+#define OTP_REVID_2_2	0b010010
+
+/* return SoC revision = Silicon revision (STM32MP1) or OTP revision ID (STM32MP2)*/
 u32 get_cpu_rev(void);
 
 /* Get Package options from OTP */
@@ -59,6 +115,25 @@ u32 get_cpu_package(void);
 #define STM32MP15_PKG_AD_TFBGA257	1
 #define STM32MP15_PKG_UNKNOWN		0
 
+/* package used for STM32MP25x */
+#define STM32MP25_PKG_CUSTOM		0
+#define STM32MP25_PKG_AL_VFBGA361	1
+#define STM32MP25_PKG_AK_VFBGA424	3
+#define STM32MP25_PKG_AI_TFBGA436	5
+#define STM32MP25_PKG_UNKNOWN		7
+
+#define STM32MP23_PKG_CUSTOM		0
+#define STM32MP23_PKG_AL_VFBGA361	1
+#define STM32MP23_PKG_AK_VFBGA424	3
+#define STM32MP23_PKG_AJ_TFBGA361	7
+
+/* package used for STM32MP21x */
+#define STM32MP21_PKG_CUSTOM		0
+#define STM32MP21_PKG_AL_VFBGA361	1
+#define STM32MP21_PKG_AN_VFBGA273	3
+#define STM32MP21_PKG_AO_VFBGA225	4
+#define STM32MP21_PKG_AM_TFBGA289	5
+
 /* Get SOC name */
 #define SOC_NAME_SIZE 20
 void get_soc_name(char name[SOC_NAME_SIZE]);
@@ -66,6 +141,9 @@ void get_soc_name(char name[SOC_NAME_SIZE]);
 /* return boot mode */
 u32 get_bootmode(void);
 
+/* return auth status and partition */
+u32 get_bootauth(void);
+
 int get_eth_nb(void);
 int setup_mac_address(void);
 
@@ -81,3 +159,10 @@ u32 get_otp(int index, int shift, int mask);
 
 uintptr_t get_stm32mp_rom_api_table(void);
 uintptr_t get_stm32mp_bl2_dtb(void);
+
+/* helper function: check "closed" state in product "Life Cycle" */
+#ifdef CONFIG_CMD_STM32KEY
+bool stm32mp_is_closed(void);
+#else
+static inline bool stm32mp_is_closed(void) { return false; }
+#endif
diff --git a/arch/arm/mach-stm32mp/nvram.c b/arch/arm/mach-stm32mp/nvram.c
new file mode 100644
index 0000000000..f513246d2c
--- /dev/null
+++ b/arch/arm/mach-stm32mp/nvram.c
@@ -0,0 +1,665 @@
+// SPDX-License-Identifier: GPL-2.0-or-lat OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+#define LOG_CATEGORY UCLASS_MISC
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <log.h>
+#include <misc.h>
+#include <regmap.h>
+#include <tee.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/devres.h>
+
+#define RIF_CID1			0x1
+#define CURRENT_CID			RIF_CID1
+#define NB_ZONES_STM32MP1		3
+#define NB_ZONES_STM32MP2		7
+
+#define _TAMP_SECCFGR			0x20U
+#define _TAMP_BKPRIFR(x)		(0x70U + 0x4U * ((x) - 1))
+#define _TAMP_RXCIDCFGR(x)		(0x80U + 0x4U * ((x)))
+
+#define BKPREG_PROTECTION_ZONE_1	0
+#define BKPREG_PROTECTION_ZONE_2	1
+#define BKPREG_PROTECTION_ZONE_3	2
+
+#define BKPREG_PROTECTION_ZONE_1_RIF1	0
+#define BKPREG_PROTECTION_ZONE_1_RIF2	1
+#define BKPREG_PROTECTION_ZONE_2_RIF1	2
+#define BKPREG_PROTECTION_ZONE_2_RIF2	3
+#define BKPREG_PROTECTION_ZONE_3_RIF1	4
+#define BKPREG_PROTECTION_ZONE_3_RIF0	5
+#define BKPREG_PROTECTION_ZONE_3_RIF2	6
+#define NB_COMPARTMENT_STM32MP2		3
+
+enum stm32_tamp_bkpreg_access {
+	BKP_READ_WRITE,
+	BKP_READ,
+	BKP_NO
+};
+
+struct stm32_tamp_nvram_plat {
+	void __iomem *base;
+	void __iomem *parent_base;
+	fdt_size_t size;
+	fdt_size_t parent_size;
+	unsigned int nb_total_regs;
+};
+
+struct stm32_tamp_nvram_priv {
+	int *idx_bkpreg_zones_end;
+	struct regmap *config_regmap;
+	struct regmap *bkpregs_regmap;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+};
+
+struct stm32_tamp_nvram_drvdata {
+	const unsigned int nb_zones;
+	const struct reg_field *reg_fields;
+};
+
+static const struct reg_field stm32mp1_tamp_nvram_zone_cfg_fields[NB_ZONES_STM32MP1 - 1] = {
+	[BKPREG_PROTECTION_ZONE_1] = REG_FIELD(_TAMP_SECCFGR, 0, 7),
+	[BKPREG_PROTECTION_ZONE_2] = REG_FIELD(_TAMP_SECCFGR, 16, 23),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_zone_cfg_fields[NB_ZONES_STM32MP2 - 1] = {
+	[BKPREG_PROTECTION_ZONE_1_RIF1] = REG_FIELD(_TAMP_BKPRIFR(1), 0,  7),
+	[BKPREG_PROTECTION_ZONE_1_RIF2] = REG_FIELD(_TAMP_SECCFGR,    0,  7),
+	[BKPREG_PROTECTION_ZONE_2_RIF1] = REG_FIELD(_TAMP_BKPRIFR(2), 0,  7),
+	[BKPREG_PROTECTION_ZONE_2_RIF2] = REG_FIELD(_TAMP_SECCFGR,   16, 23),
+	[BKPREG_PROTECTION_ZONE_3_RIF1] = REG_FIELD(_TAMP_BKPRIFR(3), 0,  7),
+	[BKPREG_PROTECTION_ZONE_3_RIF0] = REG_FIELD(_TAMP_BKPRIFR(3), 16, 23),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_rxcidcfg_cfen_fields[NB_COMPARTMENT_STM32MP2] = {
+	REG_FIELD(_TAMP_RXCIDCFGR(0), 0, 0),
+	REG_FIELD(_TAMP_RXCIDCFGR(1), 0, 0),
+	REG_FIELD(_TAMP_RXCIDCFGR(2), 0, 0),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_rxcidcfg_fields[NB_COMPARTMENT_STM32MP2] = {
+	REG_FIELD(_TAMP_RXCIDCFGR(0), 4, 6),
+	REG_FIELD(_TAMP_RXCIDCFGR(1), 4, 6),
+	REG_FIELD(_TAMP_RXCIDCFGR(2), 4, 6),
+};
+
+static enum stm32_tamp_bkpreg_access stm32mp1_tamp_bkpreg_access[NB_ZONES_STM32MP1] = {
+	[BKPREG_PROTECTION_ZONE_1] = BKP_NO,
+	[BKPREG_PROTECTION_ZONE_2] = BKP_READ,
+	[BKPREG_PROTECTION_ZONE_3] = BKP_READ_WRITE,
+};
+
+static const struct stm32_tamp_nvram_drvdata stm32mp1_tamp_nvram = {
+	.nb_zones = NB_ZONES_STM32MP1,
+	.reg_fields = stm32mp1_tamp_nvram_zone_cfg_fields,
+};
+
+static const struct stm32_tamp_nvram_drvdata stm32mp25_tamp_nvram = {
+	.nb_zones = NB_ZONES_STM32MP2,
+	.reg_fields = stm32mp25_tamp_nvram_zone_cfg_fields,
+};
+
+static int stm32_tamp_is_compartment_isolation_enabled_mp2X(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int nb_compartment_enabled = 0;
+	u32 cfen;
+	struct regmap_field *cfen_field;
+
+	for (int i = 0; i < NB_COMPARTMENT_STM32MP2; i++) {
+		cfen_field = devm_regmap_field_alloc(dev,
+						     priv->config_regmap,
+						     stm32mp25_tamp_nvram_rxcidcfg_cfen_fields[i]);
+		if (IS_ERR_OR_NULL(cfen_field)) {
+			dev_err(dev, "Can't allocate field for reading configuration\n");
+			return -ENOMEM;
+		}
+		if (regmap_field_read(cfen_field, &cfen) != 0) {
+			dev_err(dev, "Can't read field for registers zones\n");
+			devm_regmap_field_free(dev, cfen_field);
+			return -EINVAL;
+		}
+		nb_compartment_enabled += cfen;
+		devm_regmap_field_free(dev, cfen_field);
+	}
+
+	if (nb_compartment_enabled == 0)
+		return 0;
+	else if (nb_compartment_enabled == NB_COMPARTMENT_STM32MP2)
+		return 1;
+	else
+		return -EINVAL;
+}
+
+static bool *stm32_tamp_get_compartment_owner_mp2X(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	struct regmap_field *cid_field;
+	u32 cid_per_zone;
+	int isolation_enabled;
+	bool *compartment_owner;
+
+	isolation_enabled = stm32_tamp_is_compartment_isolation_enabled_mp2X(dev);
+	if (isolation_enabled < 0)
+		return NULL;
+
+	compartment_owner = devm_kcalloc(dev,
+					 NB_COMPARTMENT_STM32MP2,
+					 sizeof(*compartment_owner),
+					 GFP_KERNEL);
+	if (!compartment_owner)
+		return ERR_PTR(-ENOMEM);
+
+	for (int i = 0; i < NB_COMPARTMENT_STM32MP2; i++) {
+		if (isolation_enabled) {
+			cid_field = devm_regmap_field_alloc(dev,
+							    priv->config_regmap,
+							    stm32mp25_tamp_nvram_rxcidcfg_fields[i]
+							    );
+
+			if (regmap_field_read(cid_field, &cid_per_zone) != 0) {
+				dev_err(dev, "Can't read field for registers zones\n");
+				devm_regmap_field_free(dev, cid_field);
+				devm_kfree(dev, compartment_owner);
+				return ERR_PTR(-EINVAL);
+			}
+			if (cid_per_zone == CURRENT_CID)
+				compartment_owner[i] = true;
+			else
+				compartment_owner[i] = false;
+
+			devm_regmap_field_free(dev, cid_field);
+		} else {
+			compartment_owner[i] = true;
+		}
+	}
+
+	return compartment_owner;
+}
+
+static enum stm32_tamp_bkpreg_access *stm32_tamp_get_access_rights_mp2X(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_drvdata *drvdata =
+		(struct stm32_tamp_nvram_drvdata *)dev_get_driver_data(dev);
+	unsigned int nb_zones = drvdata->nb_zones;
+	bool *compartment_owner;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+
+	compartment_owner = stm32_tamp_get_compartment_owner_mp2X(dev);
+	if (IS_ERR(compartment_owner))
+		return ERR_PTR(-ENODEV);
+
+	bkpreg_access = devm_kcalloc(dev,
+				     NB_ZONES_STM32MP2,
+				     sizeof(*bkpreg_access),
+				     GFP_KERNEL);
+
+	for (int protection_zone_idx = 0; protection_zone_idx < nb_zones;
+	     protection_zone_idx++) {
+		switch (protection_zone_idx) {
+		case BKPREG_PROTECTION_ZONE_1_RIF1:
+			bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_1_RIF2:
+			bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_2_RIF1:
+			if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_2_RIF2:
+			if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF1:
+			if (compartment_owner[1])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[0] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF0:
+			if (compartment_owner[0])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF2:
+			if (compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[0] || compartment_owner[1])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		default:
+			devm_kfree(dev, bkpreg_access);
+			return ERR_PTR(-ENODEV);
+		}
+	}
+
+	return bkpreg_access;
+}
+
+static int stm32_tamp_nvram_bkpreg_get_zone_idx(struct udevice *dev, int reg)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	struct stm32_tamp_nvram_drvdata *drvdata =
+		(struct stm32_tamp_nvram_drvdata *)dev_get_driver_data(dev);
+	int *idx_bkpreg_zones_end = priv->idx_bkpreg_zones_end;
+	int nb_zones = drvdata->nb_zones;
+	int protection_zone_idx;
+
+	if (reg < 0)
+		return -1; // negative reg is the boundary of an empty zone
+
+	for (protection_zone_idx = 0; protection_zone_idx < nb_zones; protection_zone_idx++) {
+		if (reg <= idx_bkpreg_zones_end[protection_zone_idx])
+			break;
+	}
+
+	if (protection_zone_idx >= nb_zones)
+		return -1; // the reg is not a part of any zone
+
+	return protection_zone_idx;
+}
+
+static bool stm32_tamp_nvram_rights(struct udevice *dev, int reg, bool read_only)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int protection_zone_idx = stm32_tamp_nvram_bkpreg_get_zone_idx(dev, reg);
+
+	if (protection_zone_idx < 0)
+		return false;
+
+	switch (priv->bkpreg_access[protection_zone_idx]) {
+	case BKP_READ_WRITE:
+		return true;
+	case BKP_READ:
+		return read_only;
+	case BKP_NO:
+		return false;
+	default:
+		dev_err(dev, "Can't get access rights for the zone\n");
+		return false;
+	}
+
+	return false;
+}
+
+static int stm32_tamp_nvram_write_byte(struct udevice *dev, u32 offset, u8 byte)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int offset_aligned = ALIGN_DOWN(offset, sizeof(u32));
+	int byte_in_word = offset - offset_aligned;
+	u32 read_value, to_be_writen_value;
+	u32 reg_idx = offset_aligned / sizeof(u32);
+
+	if (!stm32_tamp_nvram_rights(dev, reg_idx, false))
+		return -EIO;
+
+	regmap_read(priv->bkpregs_regmap, offset_aligned, &read_value);
+	to_be_writen_value = read_value & ~(0xFFUL << byte_in_word * 8);
+	to_be_writen_value |=  (u32)byte << (byte_in_word * 8);
+
+	return regmap_write(priv->bkpregs_regmap, offset_aligned, to_be_writen_value);
+}
+
+static int stm32_tamp_nvram_read_byte(struct udevice *dev, unsigned int offset, u8 *byte)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int offset_aligned = ALIGN_DOWN(offset, sizeof(u32));
+	int byte_in_word = offset - offset_aligned;
+	u32 read_value;
+	u32 reg_idx = offset_aligned / sizeof(u32);
+
+	if (!stm32_tamp_nvram_rights(dev, reg_idx, true))
+		return -EIO;
+
+	regmap_read(priv->bkpregs_regmap, offset_aligned, &read_value);
+	*byte = (read_value >> (byte_in_word * 8)) & 0xFF;
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_read(struct udevice *dev, int offset, void *buf, int size)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	u8 byte;
+	u8 *buf_u8 = buf;
+	u32 temp_u32;
+	int i, ret;
+	int total = offset + size;
+	u32 reg_idx;
+
+	i = offset;
+	while (i < total)  {
+		reg_idx = i / sizeof(u32);
+		if (i + sizeof(u32) <= total && IS_ALIGNED(i, sizeof(u32))) {
+			if (!stm32_tamp_nvram_rights(dev, reg_idx, true)) {
+				dev_dbg(dev, "Backup register %u is not allowed to be read\n",
+					reg_idx);
+				temp_u32 = 0;
+			} else {
+				regmap_read(priv->bkpregs_regmap, i, &temp_u32);
+			}
+			memcpy(buf_u8, &temp_u32, sizeof(u32));
+			buf_u8 += sizeof(u32);
+			i += sizeof(u32);
+		} else {
+			ret = stm32_tamp_nvram_read_byte(dev, i, &byte);
+			if (ret != 0) {
+				dev_dbg(dev, "Backup register %u is not allowed to be read\n",
+					reg_idx);
+				byte = 0;
+			}
+			*buf_u8 = byte;
+			i++;
+			buf_u8++;
+		}
+	}
+
+	return size;
+}
+
+static int stm32_tamp_nvram_write(struct udevice *dev, int offset, const void *buf, int size)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	u8 *buf_u8 = (u8 *)buf;
+	u32 temp_u32;
+	size_t total = offset + size;
+	int i, ret;
+	u32 reg_idx;
+
+	i = offset;
+	while (i < total)  {
+		reg_idx = i / sizeof(u32);
+		if (i + sizeof(u32) <= total && IS_ALIGNED(i, sizeof(u32))) {
+			if (stm32_tamp_nvram_rights(dev, reg_idx, false)) {
+				memcpy(&temp_u32, buf_u8, sizeof(u32));
+				regmap_write(priv->bkpregs_regmap, i, temp_u32);
+			} else {
+				dev_dbg(dev, "Backup register %u is not allowed to be written",
+					reg_idx);
+			}
+			buf_u8 += sizeof(u32);
+			i += sizeof(u32);
+		} else {
+			ret = stm32_tamp_nvram_write_byte(dev, i, *buf_u8);
+			if (ret != 0)
+				dev_dbg(dev, "Backup register %u is not allowed to be written",
+					reg_idx);
+			i++;
+			buf_u8++;
+		}
+	}
+
+	return size;
+}
+
+static const struct misc_ops stm32_tamp_nvram_ops = {
+	.read = stm32_tamp_nvram_read,
+	.write = stm32_tamp_nvram_write,
+};
+
+static u32 *stm32_tamp_nvram_get_backup_zones(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_plat *plat = dev_get_plat(dev);
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	const struct stm32_tamp_nvram_drvdata *drvdata =
+		(struct stm32_tamp_nvram_drvdata *)dev_get_driver_data(dev);
+	int nb_zones = drvdata->nb_zones;
+	int zone_idx;
+	int *idx_bkpreg_zones_end;
+	struct regmap *tamp_regmap = priv->config_regmap;
+	u32 offset_field;
+
+	idx_bkpreg_zones_end = devm_kcalloc(dev,
+					    sizeof(*idx_bkpreg_zones_end),
+					    nb_zones,
+					    GFP_KERNEL);
+	if (IS_ERR_OR_NULL(idx_bkpreg_zones_end)) {
+		dev_err(dev, "Can't allocate registers zones\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	//Get the n-1 frontiers of zone within the tamp configuration registers
+	for (zone_idx = 0; zone_idx < nb_zones - 1; zone_idx++) {
+		const struct reg_field reg_field = drvdata->reg_fields[zone_idx];
+		struct regmap_field *field = devm_regmap_field_alloc(dev,
+								     tamp_regmap,
+								     reg_field);
+
+		if (IS_ERR_OR_NULL(field)) {
+			dev_err(dev, "Can't allocate registers zones\n");
+			devm_kfree(dev, idx_bkpreg_zones_end);
+			return ERR_PTR(-ENOMEM);
+		}
+		if (regmap_field_read(field, &offset_field) != 0) {
+			dev_err(dev, "Can't read field for registers zones\n");
+			devm_kfree(dev, idx_bkpreg_zones_end);
+			return ERR_PTR(-EIO);
+		}
+
+		idx_bkpreg_zones_end[zone_idx] = offset_field - 1;
+	}
+
+	//The last zone end is defined by the number of registers in TAMP
+	idx_bkpreg_zones_end[zone_idx] = plat->nb_total_regs - 1;
+
+	return idx_bkpreg_zones_end;
+}
+
+static void stm32_tamp_nvram_print_zones(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int *zones_end = priv->idx_bkpreg_zones_end;
+
+	if (device_is_compatible(dev, "st,stm32mp25-tamp-nvram")) {
+		dev_dbg(dev,
+			"\n"
+			"Zone 1-RIF1 %3d - %3d %c%c\n"
+			"Zone 1-RIF2 %3d - %3d %c%c\n"
+			"Zone 2-RIF1 %3d - %3d %c%c\n"
+			"Zone 2-RIF2 %3d - %3d %c%c\n"
+			"Zone 3-RIF1 %3d - %3d %c%c\n"
+			"Zone 3-RIF0 %3d - %3d %c%c\n"
+			"Zone 3-RIF2 %3d - %3d %c%c\n",
+			0, zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF0] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+						false) ?
+				'W' :
+				'-');
+	} else if (device_is_compatible(dev, "st,stm32mp15-tamp-nvram")) {
+		dev_dbg(dev,
+			"\n"
+			"Zone 1 %3d - %3d %c%c\n"
+			"Zone 2 %3d - %3d %c%c\n"
+			"Zone 3 %3d - %3d %c%c\n",
+			0, zones_end[BKPREG_PROTECTION_ZONE_1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1], true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1], false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2], true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2], false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3], true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3], false) ?
+				'W' :
+				'-');
+	}
+}
+
+static int stm32_tamp_nvram_of_to_plat(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_plat *plat = dev_get_plat(dev);
+	fdt_addr_t addr = dev_read_addr_size_index(dev, 0, &plat->size);
+	fdt_addr_t parent_addr = dev_read_addr_size_index(dev->parent, 0, &plat->parent_size);
+
+	if (addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+	plat->base = (void __iomem *)addr;
+
+	if (parent_addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+	plat->parent_base = (void __iomem *)parent_addr;
+
+	if (plat->size == FDT_ADDR_T_NONE)
+		return -EOPNOTSUPP;
+
+	plat->nb_total_regs =  plat->size / sizeof(uint32_t);
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_probe(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_plat *plat = dev_get_plat(dev);
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	struct regmap_config config_regmap;
+	struct regmap_config bckreg_regmap;
+
+	config_regmap.r_start = (ulong)(plat->parent_base);
+	config_regmap.r_size = plat->parent_size;
+	config_regmap.reg_offset_shift = 0;
+	config_regmap.width = REGMAP_SIZE_32;
+	priv->config_regmap = devm_regmap_init(dev, NULL, NULL, &config_regmap);
+
+	bckreg_regmap.r_start = (ulong)(plat->base);
+	bckreg_regmap.r_size = plat->size;
+	bckreg_regmap.reg_offset_shift = 0;
+	bckreg_regmap.width = REGMAP_SIZE_32;
+	priv->bkpregs_regmap = devm_regmap_init(dev, NULL, NULL, &bckreg_regmap);
+
+	priv->idx_bkpreg_zones_end = stm32_tamp_nvram_get_backup_zones(dev);
+	if (IS_ERR_OR_NULL(priv->idx_bkpreg_zones_end)) {
+		dev_err(dev, "Failed to get the backup zone from tamp regs\n\n");
+		return -ENODEV;
+	}
+
+	if (device_is_compatible(dev, "st,stm32mp25-tamp-nvram")) {
+		priv->bkpreg_access = stm32_tamp_get_access_rights_mp2X(dev);
+		if (IS_ERR_OR_NULL(priv->bkpreg_access))
+			return -ENODEV;
+	} else {
+		priv->bkpreg_access = stm32mp1_tamp_bkpreg_access;
+	}
+
+	stm32_tamp_nvram_print_zones(dev);
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_remove(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct udevice_id stm32_tamp_nvram_ids[] = {
+	{ .compatible = "st,stm32mp15-tamp-nvram", .data = (ulong)&stm32mp1_tamp_nvram },
+	{ .compatible = "st,stm32mp25-tamp-nvram", .data = (ulong)&stm32mp25_tamp_nvram },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_tamp_nvram) = {
+	.name = "stm32_tamp_nvram",
+	.id = UCLASS_MISC,
+	.of_match = stm32_tamp_nvram_ids,
+	.priv_auto = sizeof(struct stm32_tamp_nvram_priv),
+	.plat_auto = sizeof(struct stm32_tamp_nvram_plat),
+	.ops = &stm32_tamp_nvram_ops,
+	.of_to_plat = of_match_ptr(stm32_tamp_nvram_of_to_plat),
+	.probe = stm32_tamp_nvram_probe,
+	.remove = stm32_tamp_nvram_remove,
+};
+
diff --git a/arch/arm/mach-stm32mp/soc.c b/arch/arm/mach-stm32mp/soc.c
new file mode 100644
index 0000000000..318c6aa935
--- /dev/null
+++ b/arch/arm/mach-stm32mp/soc.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <misc.h>
+#include <net.h>
+#include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+
+/* max: 8 OTP for 5 mac address on stm32mp2*/
+#define MAX_NB_OTP	8
+
+/*
+ * If there is no MAC address in the environment, then it will be initialized
+ * (silently) from the value in the OTP.
+ */
+__weak int setup_mac_address(void)
+{
+	int ret;
+	int i;
+	u32 otp[MAX_NB_OTP];
+	uchar enetaddr[ARP_HLEN];
+	struct udevice *dev;
+	int nb_eth, nb_otp, index;
+
+	if (!IS_ENABLED(CONFIG_NET))
+		return 0;
+
+	nb_eth = get_eth_nb();
+	if (!nb_eth)
+		return 0;
+
+	/* 6 bytes for each MAC addr and 4 bytes for each OTP */
+	nb_otp = DIV_ROUND_UP(ARP_HLEN * nb_eth, 4);
+	if (nb_otp > MAX_NB_OTP) {
+		log_err("invalid number of OTP = %d, max = %d\n", nb_otp, MAX_NB_OTP);
+		return -EINVAL;
+	}
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_MAC), otp, 4 * nb_otp);
+	if (ret < 0)
+		return ret;
+
+	for (index = 0; index < nb_eth; index++) {
+		/* MAC already in environment */
+		if (eth_env_get_enetaddr_by_index("eth", index, enetaddr))
+			continue;
+
+		for (i = 0; i < ARP_HLEN; i++)
+			enetaddr[i] = ((uint8_t *)&otp)[i + ARP_HLEN * index];
+
+		/* skip FF:FF:FF:FF:FF:FF */
+		if (is_broadcast_ethaddr(enetaddr))
+			continue;
+
+		if (!is_valid_ethaddr(enetaddr)) {
+			log_err("invalid MAC address %d in OTP %pM\n",
+				index, enetaddr);
+			return -EINVAL;
+		}
+		log_debug("OTP MAC address %d = %pM\n", index, enetaddr);
+		ret = eth_env_set_enetaddr_by_index("eth", index, enetaddr);
+		if (ret) {
+			log_err("Failed to set mac address %pM from OTP: %d\n",
+				enetaddr, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-stm32mp/stm32mp1/Makefile b/arch/arm/mach-stm32mp/stm32mp1/Makefile
new file mode 100644
index 0000000000..053162b26d
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp1/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+#
+
+obj-y += cpu.o
+
+obj-$(CONFIG_STM32MP13X) += stm32mp13x.o
+obj-$(CONFIG_STM32MP15X) += stm32mp15x.o
+
+obj-$(CONFIG_STM32_ECDSA_VERIFY) += ecdsa_romapi.o
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+obj-y += tzc400.o
+obj-$(CONFIG_STM32MP1_RESET_HALT_WORKAROUND) += stm32mp1_helper_dbg.o
+else
+obj-$(CONFIG_ARMV7_PSCI) += psci.o
+endif
+
+obj-$(CONFIG_$(SPL_)STM32MP15_PWR) += pwr_regulator.o
+obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
diff --git a/arch/arm/mach-stm32mp/cpu.c b/arch/arm/mach-stm32mp/stm32mp1/cpu.c
similarity index 86%
rename from arch/arm/mach-stm32mp/cpu.c
rename to arch/arm/mach-stm32mp/stm32mp1/cpu.c
index e2f67fc423..518fc799ea 100644
--- a/arch/arm/mach-stm32mp/cpu.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/cpu.c
@@ -39,6 +39,13 @@ u32 get_bootmode(void)
 		    TAMP_BOOT_MODE_SHIFT;
 }
 
+u32 get_bootauth(void)
+{
+	/* read boot auth status and partition from TAMP backup register */
+	return (readl(TAMP_BOOT_CONTEXT) & TAMP_BOOT_AUTH_MASK) >>
+		    TAMP_BOOT_AUTH_SHIFT;
+}
+
 /*
  * weak function overidde: set the DDR/SYSRAM executable before to enable the
  * MMU and configure DACR, for early early_enable_caches (SPL or pre-reloc)
@@ -90,10 +97,10 @@ static void early_enable_caches(void)
 	if (CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
 		return;
 
-	if (!(CONFIG_IS_ENABLED(SYS_ICACHE_OFF) && CONFIG_IS_ENABLED(SYS_DCACHE_OFF))) {
+#if !(CONFIG_IS_ENABLED(SYS_ICACHE_OFF) && CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
 		gd->arch.tlb_size = PGTABLE_SIZE;
 		gd->arch.tlb_addr = (unsigned long)&early_tlb;
-	}
+#endif
 
 	/* enable MMU (default configuration) */
 	dcache_enable();
@@ -128,8 +135,6 @@ int mach_cpu_init(void)
 	if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) &&
 	    (boot_mode & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_UART)
 		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
-	else if (IS_ENABLED(CONFIG_DEBUG_UART) && IS_ENABLED(CONFIG_SPL_BUILD))
-		debug_uart_init();
 
 	return 0;
 }
@@ -283,62 +288,6 @@ static void setup_boot_mode(void)
 	clrsetbits_le32(TAMP_BOOT_CONTEXT, TAMP_BOOT_FORCED_MASK, BOOT_NORMAL);
 }
 
-/*
- * If there is no MAC address in the environment, then it will be initialized
- * (silently) from the value in the OTP.
- */
-__weak int setup_mac_address(void)
-{
-	int ret;
-	int i;
-	u32 otp[3];
-	uchar enetaddr[6];
-	struct udevice *dev;
-	int nb_eth, nb_otp, index;
-
-	if (!IS_ENABLED(CONFIG_NET))
-		return 0;
-
-	nb_eth = get_eth_nb();
-
-	/* 6 bytes for each MAC addr and 4 bytes for each OTP */
-	nb_otp = DIV_ROUND_UP(6 * nb_eth, 4);
-
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_DRIVER_GET(stm32mp_bsec),
-					  &dev);
-	if (ret)
-		return ret;
-
-	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_MAC), otp, 4 * nb_otp);
-	if (ret < 0)
-		return ret;
-
-	for (index = 0; index < nb_eth; index++) {
-		/* MAC already in environment */
-		if (eth_env_get_enetaddr_by_index("eth", index, enetaddr))
-			continue;
-
-		for (i = 0; i < 6; i++)
-			enetaddr[i] = ((uint8_t *)&otp)[i + 6 * index];
-
-		if (!is_valid_ethaddr(enetaddr)) {
-			log_err("invalid MAC address %d in OTP %pM\n",
-				index, enetaddr);
-			return -EINVAL;
-		}
-		log_debug("OTP MAC address %d = %pM\n", index, enetaddr);
-		ret = eth_env_set_enetaddr_by_index("eth", index, enetaddr);
-		if (ret) {
-			log_err("Failed to set mac address %pM from OTP: %d\n",
-				enetaddr, ret);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int setup_serial_number(void)
 {
 	char serial_string[25];
@@ -370,8 +319,24 @@ __weak void stm32mp_misc_init(void)
 {
 }
 
+static int setup_boot_auth_info(void)
+{
+	char buf[10];
+	u32 bootauth = get_bootauth();
+
+	snprintf(buf, sizeof(buf), "%d", bootauth >> 4);
+	env_set("boot_auth", buf);
+
+	snprintf(buf, sizeof(buf), "%d", bootauth &
+		 (u32)TAMP_BOOT_PARTITION_MASK);
+	env_set("boot_part", buf);
+
+	return 0;
+}
+
 int arch_misc_init(void)
 {
+	setup_boot_auth_info();
 	setup_boot_mode();
 	setup_mac_address();
 	setup_serial_number();
diff --git a/arch/arm/mach-stm32mp/stm32mp1/fdt.c b/arch/arm/mach-stm32mp/stm32mp1/fdt.c
new file mode 100644
index 0000000000..9a74493cc8
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp1/fdt.c
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019-2020, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <log.h>
+#include <tee.h>
+#include <asm/arch/sys_proto.h>
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+#include <linux/io.h>
+
+#define STM32MP13_FDCAN_BASE	0x4400F000
+#define STM32MP13_ADC1_BASE	0x48003000
+#define STM32MP13_TSC_BASE	0x5000B000
+#define STM32MP13_CRYP_BASE	0x54002000
+#define STM32MP13_ETH2_BASE	0x5800E000
+#define STM32MP13_DCMIPP_BASE	0x5A000000
+#define STM32MP13_LTDC_BASE	0x5A010000
+
+#define STM32MP15_FDCAN_BASE	0x4400e000
+#define STM32MP15_CRYP2_BASE	0x4c005000
+#define STM32MP15_CRYP1_BASE	0x54001000
+#define STM32MP15_GPU_BASE	0x59000000
+#define STM32MP15_DSI_BASE	0x5a000000
+
+/* fdt helper */
+static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
+{
+	int node;
+	fdt_addr_t regs;
+
+	for (node = fdt_first_subnode(fdt, offset);
+	     node >= 0;
+	     node = fdt_next_subnode(fdt, node)) {
+		regs = fdtdec_get_addr(fdt, node, "reg");
+		if (addr == regs) {
+			if (fdtdec_get_is_enabled(fdt, node)) {
+				fdt_status_disabled(fdt, node);
+
+				return true;
+			}
+			return false;
+		}
+	}
+
+	return false;
+}
+
+/* deactivate all the cpu except core 0 */
+static void stm32_fdt_fixup_cpu(void *blob, char *name)
+{
+	int off;
+	u32 reg;
+
+	off = fdt_path_offset(blob, "/cpus");
+	if (off < 0) {
+		log_warning("%s: couldn't find /cpus node\n", __func__);
+		return;
+	}
+
+	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
+	while (off != -FDT_ERR_NOTFOUND) {
+		reg = fdtdec_get_addr(blob, off, "reg");
+		if (reg != 0) {
+			fdt_del_node(blob, off);
+			log_notice("FDT: cpu %d node remove for %s\n",
+				   reg, name);
+			/* after delete we can't trust the offsets anymore */
+			off = -1;
+		}
+		off = fdt_node_offset_by_prop_value(blob, off,
+						    "device_type", "cpu", 4);
+	}
+}
+
+static void stm32_fdt_disable(void *fdt, int offset, u32 addr,
+			      const char *string, const char *name)
+{
+	if (fdt_disable_subnode_by_address(fdt, offset, addr))
+		log_notice("FDT: %s@%08x node disabled for %s\n",
+			   string, addr, name);
+}
+
+static void stm32_fdt_disable_optee(void *blob)
+{
+	int off, node;
+
+	/* Delete "optee" firmware node */
+	off = fdt_node_offset_by_compatible(blob, -1, "linaro,optee-tz");
+	if (off >= 0 && fdtdec_get_is_enabled(blob, off))
+		fdt_del_node(blob, off);
+
+	/* Delete "optee@..." reserved-memory node */
+	off = fdt_path_offset(blob, "/reserved-memory/");
+	if (off < 0)
+		return;
+	for (node = fdt_first_subnode(blob, off);
+	     node >= 0;
+	     node = fdt_next_subnode(blob, node)) {
+		if (strncmp(fdt_get_name(blob, node, NULL), "optee@", 6))
+			continue;
+
+		if (fdt_del_node(blob, node))
+			printf("Failed to remove optee reserved-memory node\n");
+	}
+}
+
+static void stm32mp13_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
+{
+	switch (cpu) {
+	case CPU_STM32MP131Fxx:
+	case CPU_STM32MP131Dxx:
+	case CPU_STM32MP131Cxx:
+	case CPU_STM32MP131Axx:
+		stm32_fdt_disable(blob, soc, STM32MP13_FDCAN_BASE, "can", name);
+		stm32_fdt_disable(blob, soc, STM32MP13_ADC1_BASE, "adc", name);
+		fallthrough;
+	case CPU_STM32MP133Fxx:
+	case CPU_STM32MP133Dxx:
+	case CPU_STM32MP133Cxx:
+	case CPU_STM32MP133Axx:
+		stm32_fdt_disable(blob, soc, STM32MP13_LTDC_BASE, "ltdc", name);
+		stm32_fdt_disable(blob, soc, STM32MP13_DCMIPP_BASE, "dcmipp",
+				  name);
+		stm32_fdt_disable(blob, soc, STM32MP13_TSC_BASE, "tsc", name);
+		break;
+	default:
+		break;
+	}
+
+	switch (cpu) {
+	case CPU_STM32MP135Dxx:
+	case CPU_STM32MP135Axx:
+	case CPU_STM32MP133Dxx:
+	case CPU_STM32MP133Axx:
+	case CPU_STM32MP131Dxx:
+	case CPU_STM32MP131Axx:
+		stm32_fdt_disable(blob, soc, STM32MP13_CRYP_BASE, "cryp", name);
+		break;
+	default:
+		break;
+	}
+}
+
+static void stm32mp15_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
+{
+	u32 pkg;
+
+	switch (cpu) {
+	case CPU_STM32MP151Fxx:
+	case CPU_STM32MP151Dxx:
+	case CPU_STM32MP151Cxx:
+	case CPU_STM32MP151Axx:
+		stm32_fdt_fixup_cpu(blob, name);
+		/* after cpu delete we can't trust the soc offsets anymore */
+		soc = fdt_path_offset(blob, "/soc");
+		stm32_fdt_disable(blob, soc, STM32MP15_FDCAN_BASE, "can", name);
+		fallthrough;
+	case CPU_STM32MP153Fxx:
+	case CPU_STM32MP153Dxx:
+	case CPU_STM32MP153Cxx:
+	case CPU_STM32MP153Axx:
+		stm32_fdt_disable(blob, soc, STM32MP15_GPU_BASE, "gpu", name);
+		stm32_fdt_disable(blob, soc, STM32MP15_DSI_BASE, "dsi", name);
+		break;
+	default:
+		break;
+	}
+	switch (cpu) {
+	case CPU_STM32MP157Dxx:
+	case CPU_STM32MP157Axx:
+	case CPU_STM32MP153Dxx:
+	case CPU_STM32MP153Axx:
+	case CPU_STM32MP151Dxx:
+	case CPU_STM32MP151Axx:
+		stm32_fdt_disable(blob, soc, STM32MP15_CRYP1_BASE, "cryp",
+				  name);
+		stm32_fdt_disable(blob, soc, STM32MP15_CRYP2_BASE, "cryp",
+				  name);
+		break;
+	default:
+		break;
+	}
+	switch (get_cpu_package()) {
+	case STM32MP15_PKG_AA_LBGA448:
+		pkg = STM32MP_PKG_AA;
+		break;
+	case STM32MP15_PKG_AB_LBGA354:
+		pkg = STM32MP_PKG_AB;
+		break;
+	case STM32MP15_PKG_AC_TFBGA361:
+		pkg = STM32MP_PKG_AC;
+		break;
+	case STM32MP15_PKG_AD_TFBGA257:
+		pkg = STM32MP_PKG_AD;
+		break;
+	default:
+		pkg = 0;
+		break;
+	}
+	if (pkg) {
+		do_fixup_by_compat_u32(blob, "st,stm32mp157-pinctrl",
+				       "st,package", pkg, false);
+		do_fixup_by_compat_u32(blob, "st,stm32mp157-z-pinctrl",
+				       "st,package", pkg, false);
+	}
+}
+
+/*
+ * This function is called right before the kernel is booted. "blob" is the
+ * device tree that will be passed to the kernel.
+ */
+int ft_system_setup(void *blob, struct bd_info *bd)
+{
+	int ret = 0;
+	int soc;
+	u32 cpu;
+	char name[SOC_NAME_SIZE];
+
+	soc = fdt_path_offset(blob, "/soc");
+	/* when absent, nothing to do */
+	if (soc == -FDT_ERR_NOTFOUND)
+		return 0;
+	if (soc < 0)
+		return soc;
+
+	/* MPUs Part Numbers and name*/
+	cpu = get_cpu_type();
+	get_soc_name(name);
+
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		stm32mp13_fdt_fixup(blob, soc, cpu, name);
+
+	if (IS_ENABLED(CONFIG_STM32MP15X)) {
+		stm32mp15_fdt_fixup(blob, soc, cpu, name);
+
+		/*
+		 * TEMP: remove OP-TEE nodes in kernel device tree
+		 *       copied from U-Boot device tree by optee_copy_fdt_nodes
+		 *       when OP-TEE is not detected (probe failed)
+		 * these OP-TEE nodes are present in <board>-u-boot.dtsi
+		 * under CONFIG_STM32MP15X_STM32IMAGE only for compatibility
+		 * when FIP is not used by TF-A
+		 */
+		if (IS_ENABLED(CONFIG_STM32MP15X_STM32IMAGE) &&
+		    !tee_find_device(NULL, NULL, NULL, NULL))
+			stm32_fdt_disable_optee(blob);
+	}
+
+	return ret;
+}
diff --git a/arch/arm/mach-stm32mp/psci.c b/arch/arm/mach-stm32mp/stm32mp1/psci.c
similarity index 100%
rename from arch/arm/mach-stm32mp/psci.c
rename to arch/arm/mach-stm32mp/stm32mp1/psci.c
diff --git a/arch/arm/mach-stm32mp/pwr_regulator.c b/arch/arm/mach-stm32mp/stm32mp1/pwr_regulator.c
similarity index 96%
rename from arch/arm/mach-stm32mp/pwr_regulator.c
rename to arch/arm/mach-stm32mp/stm32mp1/pwr_regulator.c
index 846637ab16..4306cdc99d 100644
--- a/arch/arm/mach-stm32mp/pwr_regulator.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/pwr_regulator.c
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
+#include <asm/arch/stm32mp1_smc.h>
 #include <dm/device_compat.h>
 #include <dm/device-internal.h>
 #include <linux/bitops.h>
@@ -44,6 +45,10 @@ static int stm32mp_pwr_write(struct udevice *dev, uint reg,
 	if (len != 4)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_ARM_SMCCC) && !IS_ENABLED(CONFIG_SPL_BUILD))
+		return stm32_smc_exec(STM32_SMC_PWR, STM32_SMC_REG_WRITE,
+				      STM32MP_PWR_CR3, val);
+
 	writel(val, priv->base + STM32MP_PWR_CR3);
 
 	return 0;
@@ -96,6 +101,7 @@ static struct dm_pmic_ops stm32mp_pwr_ops = {
 };
 
 static const struct udevice_id stm32mp_pwr_ids[] = {
+	{ .compatible = "st,stm32mp1-pwr-reg" },
 	{ .compatible = "st,stm32mp1,pwr-reg" },
 	{ }
 };
diff --git a/arch/arm/mach-stm32mp/spl.c b/arch/arm/mach-stm32mp/stm32mp1/spl.c
similarity index 98%
rename from arch/arm/mach-stm32mp/spl.c
rename to arch/arm/mach-stm32mp/stm32mp1/spl.c
index 6c79259b2c..beda69f335 100644
--- a/arch/arm/mach-stm32mp/spl.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/spl.c
@@ -118,7 +118,7 @@ static int optee_get_reserved_memory(uint32_t *start, uint32_t *size)
 
 	node = ofnode_path("/reserved-memory/optee");
 	if (!ofnode_valid(node))
-		return 0;
+		return -ENOENT;
 
 	fdt_start = ofnode_get_addr_size(node, "reg", &fdt_mem_size);
 	*start = fdt_start;
@@ -134,7 +134,7 @@ void stm32_init_tzc_for_optee(void)
 {
 	const uint32_t dram_size = stm32mp_get_dram_size();
 	const uintptr_t dram_top = STM32_DDR_BASE + (dram_size - 1);
-	uint32_t optee_base, optee_size, tee_shmem_base;
+	u32 optee_base = 0, optee_size = 0, tee_shmem_base;
 	const uintptr_t tzc = STM32_TZC_BASE;
 	int ret;
 
diff --git a/arch/arm/mach-stm32mp/stm32mp13x.c b/arch/arm/mach-stm32mp/stm32mp1/stm32mp13x.c
similarity index 100%
rename from arch/arm/mach-stm32mp/stm32mp13x.c
rename to arch/arm/mach-stm32mp/stm32mp1/stm32mp13x.c
diff --git a/arch/arm/mach-stm32mp/stm32mp15x.c b/arch/arm/mach-stm32mp/stm32mp1/stm32mp15x.c
similarity index 99%
rename from arch/arm/mach-stm32mp/stm32mp15x.c
rename to arch/arm/mach-stm32mp/stm32mp1/stm32mp15x.c
index afc56b02ee..ed4fca4214 100644
--- a/arch/arm/mach-stm32mp/stm32mp15x.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/stm32mp15x.c
@@ -208,7 +208,7 @@ void stm32mp_cpu_init(void)
 	if (!IS_ENABLED(CONFIG_SPL) || IS_ENABLED(CONFIG_SPL_BUILD)) {
 		/* Reset Coprocessor state unless it wakes up from Standby power mode */
 		if (!(readl(PWR_MCUCR) & PWR_MCUCR_SBF)) {
-			writel(TAMP_COPRO_STATE_OFF, TAMP_COPRO_STATE);
+			writel(0, TAMP_COPRO_STATE);
 			writel(0, TAMP_COPRO_RSC_TBL_ADDRESS);
 		}
 	}
diff --git a/arch/arm/mach-stm32mp/tzc400.c b/arch/arm/mach-stm32mp/stm32mp1/tzc400.c
similarity index 100%
rename from arch/arm/mach-stm32mp/tzc400.c
rename to arch/arm/mach-stm32mp/stm32mp1/tzc400.c
diff --git a/arch/arm/mach-stm32mp/stm32mp2/Makefile b/arch/arm/mach-stm32mp/stm32mp2/Makefile
new file mode 100644
index 0000000000..73c366d246
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/Makefile
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+#
+# Copyright (C) 2023-2024, STMicroelectronics - All Rights Reserved
+#
+
+obj-y += cpu.o
+obj-y += arm64-mmu.o
+obj-y += rifsc.o
+obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
+obj-$(CONFIG_STM32MP21X) += stm32mp21x.o
+obj-$(CONFIG_STM32MP25X) += stm32mp25x.o
+obj-$(CONFIG_STM32MP23X) += stm32mp23x.o
diff --git a/arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c b/arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c
new file mode 100644
index 0000000000..9e9a486cda
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023-2024, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <asm/system.h>
+#include <asm/armv8/mmu.h>
+
+#define MP2_MEM_MAP_MAX 10
+
+#if (CONFIG_TEXT_BASE < STM32_DDR_BASE) || \
+	(CONFIG_TEXT_BASE > (STM32_DDR_BASE + STM32_DDR_SIZE))
+#error "invalid CONFIG_TEXT_BASE value"
+#endif
+
+struct mm_region stm32mp2_mem_map[MP2_MEM_MAP_MAX] = {
+	{
+#if defined(CONFIG_STM32MP21X)
+		/* RETRAM, SRAM1, SYSRAM: BOOT alias1 */
+		.virt = 0x0A000000UL,
+		.phys = 0x0A000000UL,
+		.size = 0x00070000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+#endif
+#if defined(CONFIG_STM32MP25X)
+		/* VDERAM, RETRAM, SRAMs, SYSRAM: BOOT alias1 */
+		.virt = 0x0A000000UL,
+		.phys = 0x0A000000UL,
+		.size = 0x00200000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* PCIe */
+		.virt = 0x10000000UL,
+		.phys = 0x10000000UL,
+		.size = 0x10000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+#endif
+		/* Peripherals: alias1 */
+		.virt = 0x40000000UL,
+		.phys = 0x40000000UL,
+		.size = 0x10000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* OSPI and FMC: memory-map area */
+		.virt = 0x60000000UL,
+		.phys = 0x60000000UL,
+		.size = 0x20000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/*
+		 * DDR = STM32_DDR_BASE / STM32_DDR_SIZE
+		 * the beginning of DDR (before CONFIG_TEXT_BASE) is not
+		 * mapped, protected by RIF and reserved for other firmware
+		 * (OP-TEE / TF-M / Cube M33)
+		 */
+		.virt = CONFIG_TEXT_BASE,
+		.phys = CONFIG_TEXT_BASE,
+		.size = STM32_DDR_SIZE - (CONFIG_TEXT_BASE - STM32_DDR_BASE),
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = stm32mp2_mem_map;
diff --git a/arch/arm/mach-stm32mp/stm32mp2/cpu.c b/arch/arm/mach-stm32mp/stm32mp2/cpu.c
new file mode 100644
index 0000000000..dbd6758243
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/cpu.c
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023-2024, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <clk.h>
+#include <cpu_func.h>
+#include <debug_uart.h>
+#include <env_internal.h>
+#include <init.h>
+#include <misc.h>
+#include <wdt.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/system.h>
+#include <dm/device.h>
+#include <dm/lists.h>
+#include <dm/uclass.h>
+
+/*
+ * early TLB into the .data section so that it not get cleared
+ * with 16kB alignment
+ */
+#define EARLY_TLB_SIZE 0x10000
+u8 early_tlb[EARLY_TLB_SIZE] __section(".data") __aligned(0x4000);
+
+/*
+ * initialize the MMU and activate cache in U-Boot pre-reloc stage
+ * MMU/TLB is updated in enable_caches() for U-Boot after relocation
+ */
+static void early_enable_caches(void)
+{
+	if (CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
+		return;
+
+	if (!(CONFIG_IS_ENABLED(SYS_ICACHE_OFF) && CONFIG_IS_ENABLED(SYS_DCACHE_OFF))) {
+		gd->arch.tlb_size = EARLY_TLB_SIZE;
+		gd->arch.tlb_addr = (unsigned long)&early_tlb;
+	}
+	/* enable MMU (default configuration) */
+	dcache_enable();
+}
+
+/*
+ * Early system init
+ */
+int arch_cpu_init(void)
+{
+	icache_enable();
+	early_enable_caches();
+
+	return 0;
+}
+
+int mach_cpu_init(void)
+{
+	u32 boot_mode;
+
+	boot_mode = get_bootmode();
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) &&
+	    (boot_mode & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_UART)
+		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+
+	return 0;
+}
+
+void enable_caches(void)
+{
+	/* deactivate the data cache, early enabled in arch_cpu_init() */
+	dcache_disable();
+	/*
+	 * Force the call of setup_all_pgtables() in mmu_setup() by clearing tlb_fillptr
+	 * to update the TLB location udpated in board_f.c::reserve_mmu
+	 */
+	gd->arch.tlb_fillptr = 0;
+	dcache_enable();
+}
+
+/* used when CONFIG_DISPLAY_CPUINFO is activated */
+int print_cpuinfo(void)
+{
+	char name[SOC_NAME_SIZE];
+
+	get_soc_name(name);
+	printf("CPU: %s\n", name);
+
+	return 0;
+}
+
+/*
+ * Force data-section, as .bss will not be valid
+ * when save_boot_params is invoked.
+ */
+static uintptr_t nt_fw_dtb __section(".data");
+
+uintptr_t get_stm32mp_bl2_dtb(void)
+{
+	return nt_fw_dtb;
+}
+
+/*
+ * Save the FDT address provided by TF-A in r2 at boot time
+ * This function is called from start.S
+ */
+void save_boot_params(unsigned long r0, unsigned long r1, unsigned long r2,
+		      unsigned long r3)
+{
+	nt_fw_dtb = r2;
+
+	save_boot_params_ret();
+}
+
+u32 get_bootmode(void)
+{
+	/* read bootmode from TAMP backup register */
+	return (readl(TAMP_BOOT_CONTEXT) & TAMP_BOOT_MODE_MASK) >>
+		    TAMP_BOOT_MODE_SHIFT;
+
+}
+
+static void setup_boot_mode(void)
+{
+	const u32 serial_addr[] = {
+		STM32_USART1_BASE,
+		STM32_USART2_BASE,
+		STM32_USART3_BASE,
+		STM32_UART4_BASE,
+		STM32_UART5_BASE,
+		STM32_USART6_BASE,
+		STM32_UART7_BASE,
+#ifdef CONFIG_STM32MP25X
+		STM32_UART8_BASE,
+		STM32_UART9_BASE
+#endif
+	};
+	const u32 sdmmc_addr[] = {
+		STM32_SDMMC1_BASE,
+		STM32_SDMMC2_BASE,
+		STM32_SDMMC3_BASE
+	};
+	char cmd[60];
+	u32 boot_ctx = readl(TAMP_BOOT_CONTEXT);
+	u32 boot_mode =
+		(boot_ctx & TAMP_BOOT_MODE_MASK) >> TAMP_BOOT_MODE_SHIFT;
+	unsigned int instance = (boot_mode & TAMP_BOOT_INSTANCE_MASK) - 1;
+	u32 forced_mode = (boot_ctx & TAMP_BOOT_FORCED_MASK);
+	struct udevice *dev;
+
+	log_debug("%s: boot_ctx=0x%x => boot_mode=%x, instance=%d forced=%x\n",
+		  __func__, boot_ctx, boot_mode, instance, forced_mode);
+	switch (boot_mode & TAMP_BOOT_DEVICE_MASK) {
+	case BOOT_SERIAL_UART:
+		if (instance > ARRAY_SIZE(serial_addr))
+			break;
+		/* serial : search associated node in devicetree */
+		sprintf(cmd, "serial@%x", serial_addr[instance]);
+		if (uclass_get_device_by_name(UCLASS_SERIAL, cmd, &dev)) {
+			/* restore console on error */
+			if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL))
+				gd->flags &= ~(GD_FLG_SILENT |
+					       GD_FLG_DISABLE_CONSOLE);
+			log_err("uart%d = %s not found in device tree!\n",
+				instance + 1, cmd);
+			break;
+		}
+		sprintf(cmd, "%d", dev_seq(dev));
+		env_set("boot_device", "serial");
+		env_set("boot_instance", cmd);
+
+		/* restore console on uart when not used */
+		if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) && gd->cur_serial_dev != dev) {
+			gd->flags &= ~(GD_FLG_SILENT |
+				       GD_FLG_DISABLE_CONSOLE);
+			log_info("serial boot with console enabled!\n");
+		}
+		break;
+	case BOOT_SERIAL_USB:
+		env_set("boot_device", "usb");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		if (instance > ARRAY_SIZE(sdmmc_addr))
+			break;
+		/* search associated sdmmc node in devicetree */
+		sprintf(cmd, "mmc@%x", sdmmc_addr[instance]);
+		if (uclass_get_device_by_name(UCLASS_MMC, cmd, &dev)) {
+			printf("mmc%d = %s not found in device tree!\n",
+			       instance, cmd);
+			break;
+		}
+		sprintf(cmd, "%d", dev_seq(dev));
+		env_set("boot_device", "mmc");
+		env_set("boot_instance", cmd);
+		break;
+	case BOOT_FLASH_NAND:
+		env_set("boot_device", "nand");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_FLASH_SPINAND:
+		env_set("boot_device", "spi-nand");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_FLASH_NOR:
+		env_set("boot_device", "nor");
+		if (IS_ENABLED(CONFIG_SYS_MAX_FLASH_BANKS))
+			sprintf(cmd, "%d", CONFIG_SYS_MAX_FLASH_BANKS);
+		else
+			sprintf(cmd, "%d", 0);
+		env_set("boot_instance", cmd);
+		break;
+	case BOOT_FLASH_HYPERFLASH:
+		env_set("boot_device", "nor");
+		env_set("boot_instance", "0");
+		break;
+	default:
+		env_set("boot_device", "invalid");
+		env_set("boot_instance", "");
+		log_err("unexpected boot mode = %x\n", boot_mode);
+		break;
+	}
+
+	switch (forced_mode) {
+	case BOOT_FASTBOOT:
+		log_info("Enter fastboot!\n");
+		env_set("preboot", "env set preboot; fastboot 0");
+		break;
+	case BOOT_STM32PROG:
+		env_set("boot_device", "usb");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_UMS_MMC0:
+	case BOOT_UMS_MMC1:
+	case BOOT_UMS_MMC2:
+		log_info("Enter UMS!\n");
+		instance = forced_mode - BOOT_UMS_MMC0;
+		sprintf(cmd, "env set preboot; ums 0 mmc %d", instance);
+		env_set("preboot", cmd);
+		break;
+	case BOOT_RECOVERY:
+		env_set("preboot", "env set preboot; run altbootcmd");
+		break;
+	case BOOT_NORMAL:
+		break;
+	default:
+		log_debug("unexpected forced boot mode = %x\n", forced_mode);
+		break;
+	}
+
+	/* clear TAMP for next reboot */
+	clrsetbits_le32(TAMP_BOOT_CONTEXT, TAMP_BOOT_FORCED_MASK, BOOT_NORMAL);
+}
+
+static int setup_serial_number(void)
+{
+	char serial_string[25];
+	u32 otp[3] = {0, 0, 0 };
+	struct udevice *dev;
+	int ret;
+
+	if (env_get("serial#"))
+		return 0;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_SERIAL),
+			otp, sizeof(otp));
+	if (ret < 0)
+		return ret;
+
+	sprintf(serial_string, "%08X%08X%08X", otp[0], otp[1], otp[2]);
+	env_set("serial#", serial_string);
+
+	return 0;
+}
+
+int arch_misc_init(void)
+{
+	setup_boot_mode();
+	setup_serial_number();
+	setup_mac_address();
+
+	return 0;
+}
diff --git a/arch/arm/mach-stm32mp/stm32mp2/fdt.c b/arch/arm/mach-stm32mp/stm32mp2/fdt.c
new file mode 100644
index 0000000000..ee570863bb
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/fdt.c
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+
+/*
+ * This function is called right before the kernel is booted. "blob" is the
+ * device tree that will be passed to the kernel.
+ */
+int ft_system_setup(void *blob, struct bd_info *bd)
+{
+	return 0;
+}
+
diff --git a/arch/arm/mach-stm32mp/stm32mp2/rifsc.c b/arch/arm/mach-stm32mp/stm32mp2/rifsc.c
new file mode 100644
index 0000000000..ec893a3212
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/rifsc.c
@@ -0,0 +1,365 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SIMPLE_BUS
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <linux/bitfield.h>
+#include <mach/rif.h>
+
+/* RIFSC offset register */
+#define RIFSC_RISC_SECCFGR0(id)		(0x10 + 0x4 * (id))
+#define RIFSC_RISC_PER0_CIDCFGR(id)	(0x100 + 0x8 * (id))
+#define RIFSC_RISC_PER0_SEMCR(id)	(0x104 + 0x8 * (id))
+
+/*
+ * SEMCR register
+ */
+#define SEMCR_MUTEX			BIT(0)
+
+/* RIFSC miscellaneous */
+#define RIFSC_RISC_SCID_MASK		GENMASK(6, 4)
+#define RIFSC_RISC_SEMWL_MASK		GENMASK(23, 16)
+
+#define IDS_PER_RISC_SEC_PRIV_REGS	32
+
+/*
+ * CIDCFGR register fields
+ */
+#define CIDCFGR_CFEN			BIT(0)
+#define CIDCFGR_SEMEN			BIT(1)
+
+#define SEMWL_SHIFT			16
+
+#define STM32MP25_RIFSC_ENTRIES		178
+
+/* Compartiment IDs */
+#define RIF_CID0			0x0
+#define RIF_CID1			0x1
+
+/*
+ * struct stm32_rifsc_plat: Information about RIFSC device
+ *
+ * @base: Base address of RIFSC
+ */
+struct stm32_rifsc_plat {
+	void *base;
+};
+
+/*
+ * struct stm32_rifsc_child_plat: Information about each child
+ *
+ * @domain_id: Domain id
+ */
+struct stm32_rifsc_child_plat {
+	u32 domain_id;
+};
+
+static bool stm32_rif_is_semaphore_available(void *base, u32 id)
+{
+	void *addr = base + RIFSC_RISC_PER0_SEMCR(id);
+
+	return !(readl(addr) & SEMCR_MUTEX);
+}
+
+static int stm32_rif_acquire_semaphore(void *base, u32 id)
+{
+	void *addr = base + RIFSC_RISC_PER0_SEMCR(id);
+
+	/* Check that the semaphore is available */
+	if (!stm32_rif_is_semaphore_available(base, id))
+		return -EACCES;
+
+	setbits_le32(addr, SEMCR_MUTEX);
+
+	/* Check that CID1 has the semaphore */
+	if (stm32_rif_is_semaphore_available(base, id) ||
+	    FIELD_GET(RIFSC_RISC_SCID_MASK, (readl(addr)) != RIF_CID1))
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32_rif_release_semaphore(void *base, u32 id)
+{
+	void *addr = base + RIFSC_RISC_PER0_SEMCR(id);
+
+	if (stm32_rif_is_semaphore_available(base, id))
+		return 0;
+
+	clrbits_le32(addr, SEMCR_MUTEX);
+
+	/* Ok if another compartment takes the semaphore before the check */
+	if (!stm32_rif_is_semaphore_available(base, id) &&
+	    FIELD_GET(RIFSC_RISC_SCID_MASK, (readl(addr)) == RIF_CID1))
+		return -EACCES;
+
+	return 0;
+}
+
+static int rifsc_parse_access_controller(ofnode node, struct ofnode_phandle_args *args)
+{
+	int ret;
+
+	ret = ofnode_parse_phandle_with_args(node, "access-controllers",
+					     "#access-controller-cells", 0,
+					     0, args);
+	if (ret) {
+		log_debug("failed to parse access-controller (%d)\n", ret);
+		return ret;
+	}
+
+	if (args->args_count != 1) {
+		log_debug("invalid domain args_count: %d\n", args->args_count);
+		return -EINVAL;
+	}
+
+	if (args->args[0] >= STM32MP25_RIFSC_ENTRIES) {
+		log_err("Invalid sys bus ID for %s\n", ofnode_get_name(node));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rifsc_check_access(void *base, u32 id)
+{
+	u32 reg_offset, reg_id, sec_reg_value, cid_reg_value, sem_reg_value;
+
+	/*
+	 * RIFSC_RISC_PRIVCFGRx and RIFSC_RISC_SECCFGRx both handle configuration access for
+	 * 32 peripherals. On the other hand, there is one _RIFSC_RISC_PERx_CIDCFGR register
+	 * per peripheral
+	 */
+	reg_id = id / IDS_PER_RISC_SEC_PRIV_REGS;
+	reg_offset = id % IDS_PER_RISC_SEC_PRIV_REGS;
+	sec_reg_value = readl(base + RIFSC_RISC_SECCFGR0(reg_id));
+	cid_reg_value = readl(base + RIFSC_RISC_PER0_CIDCFGR(id));
+	sem_reg_value = readl(base + RIFSC_RISC_PER0_SEMCR(id));
+
+	/*
+	 * First check conditions for semaphore mode, which doesn't take into
+	 * account static CID.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN)
+		goto skip_cid_check;
+
+	/*
+	 * Skip cid check if CID filtering isn't enabled or filtering is enabled on CID0, which
+	 * corresponds to whatever CID.
+	 */
+	if (!(cid_reg_value & CIDCFGR_CFEN) ||
+	    FIELD_GET(RIFSC_RISC_SCID_MASK, cid_reg_value) == RIF_CID0)
+		goto skip_cid_check;
+
+	/* Coherency check with the CID configuration */
+	if (FIELD_GET(RIFSC_RISC_SCID_MASK, cid_reg_value) != RIF_CID1) {
+		log_debug("Invalid CID configuration for peripheral %d\n", id);
+		return -EACCES;
+	}
+
+skip_cid_check:
+	/* Check security configuration */
+	if (sec_reg_value & BIT(reg_offset)) {
+		log_debug("Invalid security configuration for peripheral %d\n", id);
+		return -EACCES;
+	}
+
+	/* Check semaphore accesses */
+	if (cid_reg_value & CIDCFGR_SEMEN) {
+		if (!(FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_reg_value) & BIT(RIF_CID1))) {
+			log_debug("Not in semaphore whitelist for peripheral %d\n", id);
+			return -EACCES;
+		}
+		if (!stm32_rif_is_semaphore_available(base, id) &&
+		    !(FIELD_GET(RIFSC_RISC_SCID_MASK, sem_reg_value) & BIT(RIF_CID1))) {
+			log_debug("Semaphore unavailable for peripheral %d\n", id);
+			return -EACCES;
+		}
+	}
+
+	return 0;
+}
+
+int stm32_rifsc_check_access_by_id(ofnode device_node, u32 id)
+{
+	struct ofnode_phandle_args args;
+	int err;
+
+	if (id >= STM32MP25_RIFSC_ENTRIES)
+		return -EINVAL;
+
+	err = rifsc_parse_access_controller(device_node, &args);
+	if (err)
+		return err;
+
+	return rifsc_check_access((void *)ofnode_get_addr(args.node), id);
+}
+
+int stm32_rifsc_check_access(ofnode device_node)
+{
+	struct ofnode_phandle_args args;
+	int err;
+
+	err = rifsc_parse_access_controller(device_node, &args);
+	if (err)
+		return err;
+
+	return rifsc_check_access((void *)ofnode_get_addr(args.node), args.args[0]);
+}
+
+static int stm32_rifsc_child_pre_probe(struct udevice *dev)
+{
+	struct stm32_rifsc_plat *plat = dev_get_plat(dev->parent);
+	struct stm32_rifsc_child_plat *child_plat = dev_get_parent_plat(dev);
+	u32 cid_reg_value;
+	int err;
+	u32 id = child_plat->domain_id;
+
+	cid_reg_value = readl(plat->base + RIFSC_RISC_PER0_CIDCFGR(id));
+
+	/*
+	 * If the peripheral is in semaphore mode, take the semaphore so that
+	 * the CID1 has the ownership.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN &&
+	    (FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_reg_value) & BIT(RIF_CID1))) {
+		err = stm32_rif_acquire_semaphore(plat->base, id);
+		if (err) {
+			dev_err(dev, "Couldn't acquire RIF semaphore for peripheral %d (%d)\n",
+				id, err);
+			return err;
+		}
+		dev_dbg(dev, "Acquiring semaphore for peripheral %d\n", id);
+	}
+
+	return 0;
+}
+
+static int stm32_rifsc_child_post_remove(struct udevice *dev)
+{
+	struct stm32_rifsc_plat *plat = dev_get_plat(dev->parent);
+	struct stm32_rifsc_child_plat *child_plat = dev_get_parent_plat(dev);
+	u32 cid_reg_value;
+	int err;
+	u32 id = child_plat->domain_id;
+
+	cid_reg_value = readl(plat->base + RIFSC_RISC_PER0_CIDCFGR(id));
+
+	/*
+	 * If the peripheral is in semaphore mode, release the semaphore so that
+	 * there's no ownership.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN &&
+	    (FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_reg_value) & BIT(RIF_CID1))) {
+		err = stm32_rif_release_semaphore(plat->base, id);
+		if (err)
+			dev_err(dev, "Couldn't release rif semaphore for peripheral %d (%d)\n",
+				id, err);
+	}
+
+	return 0;
+}
+
+static int stm32_rifsc_child_post_bind(struct udevice *dev)
+{
+	struct stm32_rifsc_child_plat *child_plat = dev_get_parent_plat(dev);
+	struct ofnode_phandle_args args;
+	int ret;
+
+	if (!dev_has_ofnode(dev))
+		return -EPERM;
+
+	ret = rifsc_parse_access_controller(dev_ofnode(dev), &args);
+	if (ret)
+		return ret;
+
+	child_plat->domain_id = args.args[0];
+
+	return 0;
+}
+
+static int stm32_rifsc_bind(struct udevice *dev)
+{
+	struct stm32_rifsc_plat *plat = dev_get_plat(dev);
+	struct ofnode_phandle_args args;
+	int ret = 0, err = 0;
+	ofnode node;
+
+	plat->base = dev_read_addr_ptr(dev);
+	if (!plat->base) {
+		dev_err(dev, "can't get registers base address\n");
+		return -ENOENT;
+	}
+
+	for (node = ofnode_first_subnode(dev_ofnode(dev));
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node))
+			continue;
+
+		err = rifsc_parse_access_controller(node, &args);
+		if (err) {
+			dev_dbg(dev, "%s failed to parse child on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = rifsc_check_access(plat->base, args.args[0]);
+		if (err) {
+			dev_info(dev, "%s not allowed on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err && !ret) {
+			ret = err;
+			dev_err(dev, "%s failed to bind on bus (%d)\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_err(dev, "Some child failed to bind (%d)\n", ret);
+
+	return ret;
+}
+
+static int stm32_rifsc_remove(struct udevice *bus)
+{
+	struct udevice *dev;
+
+	/* Deactivate all child devices not yet removed */
+	for (device_find_first_child(bus, &dev); dev; device_find_next_child(&dev))
+		if (device_active(dev))
+			stm32_rifsc_child_post_remove(dev);
+
+	return 0;
+}
+
+static const struct udevice_id stm32_rifsc_ids[] = {
+	{ .compatible = "st,stm32mp25-rifsc" },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_rifsc) = {
+	.name = "stm32_rifsc",
+	.id = UCLASS_NOP,
+	.of_match = stm32_rifsc_ids,
+	.bind = stm32_rifsc_bind,
+	.remove = stm32_rifsc_remove,
+	.child_post_bind = stm32_rifsc_child_post_bind,
+	.child_pre_probe = stm32_rifsc_child_pre_probe,
+	.child_post_remove = stm32_rifsc_child_post_remove,
+	.plat_auto = sizeof(struct stm32_rifsc_plat),
+	.per_child_plat_auto = sizeof(struct stm32_rifsc_child_plat),
+	.flags = DM_FLAG_OS_PREPARE,
+};
diff --git a/arch/arm/mach-stm32mp/stm32mp2/stm32mp21x.c b/arch/arm/mach-stm32mp/stm32mp2/stm32mp21x.c
new file mode 100644
index 0000000000..900e6be313
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/stm32mp21x.c
@@ -0,0 +1,192 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <log.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+
+/* SYSCFG register */
+#define SYSCFG_DEVICEID_OFFSET		0x6400
+#define SYSCFG_DEVICEID_DEV_ID_MASK	GENMASK(11, 0)
+#define SYSCFG_DEVICEID_DEV_ID_SHIFT	0
+#define SYSCFG_DEVICEID_REV_ID_MASK	GENMASK(31, 16)
+#define SYSCFG_DEVICEID_REV_ID_SHIFT	16
+
+/* Revision ID = OTP102[5:0] 6 bits : 3 for Major / 3 for Minor*/
+#define REVID_SHIFT	0
+#define REVID_MASK	GENMASK(5, 0)
+
+/* Device Part Number (RPN) = OTP9 */
+#define RPN_SHIFT	0
+#define RPN_MASK	GENMASK(31, 0)
+
+/* Package = bit 0:2 of OTP122 => STM32MP21_PKG defines
+ * - 000: Custom package
+ * - 001: VFBGA361 => AL = 10x10, 361 balls pith 0.5mm
+ * - 011: VFBGA273 => AN = 11x11, 273 balls pith 0.5mm
+ * - 100: VFBGA225 => AO =   8x8, 225 balls pith 0.5mm
+ * - 101: TFBGA289 => AM = 14x14, 289 balls pith 0.8mm
+ * - others: Reserved
+ */
+#define PKG_SHIFT	0
+#define PKG_MASK	GENMASK(2, 0)
+
+static u32 read_deviceid(void)
+{
+	void *syscfg = syscon_get_first_range(STM32MP_SYSCON_SYSCFG);
+
+	return readl(syscfg + SYSCFG_DEVICEID_OFFSET);
+}
+
+u32 get_cpu_dev(void)
+{
+	return (read_deviceid() & SYSCFG_DEVICEID_DEV_ID_MASK) >> SYSCFG_DEVICEID_DEV_ID_SHIFT;
+}
+
+u32 get_cpu_rev(void)
+{
+	return get_otp(BSEC_OTP_REVID, REVID_SHIFT, REVID_MASK);
+}
+
+/* Get Device Part Number (RPN) from OTP */
+u32 get_cpu_type(void)
+{
+	return get_otp(BSEC_OTP_RPN, RPN_SHIFT, RPN_MASK);
+}
+
+/* Get Package options from OTP */
+u32 get_cpu_package(void)
+{
+	return get_otp(BSEC_OTP_PKG, PKG_SHIFT, PKG_MASK);
+}
+
+int get_eth_nb(void)
+{
+	int nb_eth;
+
+	switch (get_cpu_type()) {
+	case CPU_STM32MP215Axx:
+		fallthrough;
+	case CPU_STM32MP215Cxx:
+		fallthrough;
+	case CPU_STM32MP215Dxx:
+		fallthrough;
+	case CPU_STM32MP215Fxx:
+		fallthrough;
+	case CPU_STM32MP213Axx:
+		fallthrough;
+	case CPU_STM32MP213Cxx:
+		fallthrough;
+	case CPU_STM32MP213Dxx:
+		fallthrough;
+	case CPU_STM32MP213Fxx:
+		nb_eth = 2; /* dual ETH */
+		break;
+	case CPU_STM32MP211Axx:
+		fallthrough;
+	case CPU_STM32MP211Cxx:
+		fallthrough;
+	case CPU_STM32MP211Dxx:
+		fallthrough;
+	case CPU_STM32MP211Fxx:
+		nb_eth = 1; /* single ETH */
+		break;
+	default:
+		nb_eth = 0;
+		break;
+	}
+
+	return nb_eth;
+}
+
+void get_soc_name(char name[SOC_NAME_SIZE])
+{
+	char *cpu_s, *cpu_r, *package;
+
+	cpu_s = "????";
+	cpu_r = "?";
+	package = "??";
+	if (get_cpu_dev() == CPU_DEV_STM32MP21) {
+		switch (get_cpu_type()) {
+		case CPU_STM32MP215Fxx:
+			cpu_s = "215F";
+			break;
+		case CPU_STM32MP215Dxx:
+			cpu_s = "215D";
+			break;
+		case CPU_STM32MP215Cxx:
+			cpu_s = "215C";
+			break;
+		case CPU_STM32MP215Axx:
+			cpu_s = "215A";
+			break;
+		case CPU_STM32MP213Fxx:
+			cpu_s = "213F";
+			break;
+		case CPU_STM32MP213Dxx:
+			cpu_s = "213D";
+			break;
+		case CPU_STM32MP213Cxx:
+			cpu_s = "213C";
+			break;
+		case CPU_STM32MP213Axx:
+			cpu_s = "213A";
+			break;
+		case CPU_STM32MP211Fxx:
+			cpu_s = "211F";
+			break;
+		case CPU_STM32MP211Dxx:
+			cpu_s = "211D";
+			break;
+		case CPU_STM32MP211Cxx:
+			cpu_s = "211C";
+			break;
+		case CPU_STM32MP211Axx:
+			cpu_s = "211A";
+			break;
+		default:
+			cpu_s = "21??";
+			break;
+		}
+		/* REVISION */
+		switch (get_cpu_rev()) {
+		case CPU_REV1:
+			cpu_r = "A";
+			break;
+		case CPU_REV2:
+			cpu_r = "B";
+			break;
+		default:
+			break;
+		}
+		/* PACKAGE */
+		switch (get_cpu_package()) {
+		case STM32MP25_PKG_CUSTOM:
+			package = "XX";
+			break;
+		case STM32MP21_PKG_AL_VFBGA361:
+			package = "AL";
+			break;
+		case STM32MP21_PKG_AN_VFBGA273:
+			package = "AN";
+			break;
+		case STM32MP21_PKG_AO_VFBGA225:
+			package = "AO";
+			break;
+		case STM32MP21_PKG_AM_TFBGA289:
+			package = "AM";
+			break;
+		default:
+			break;
+		}
+	}
+
+	snprintf(name, SOC_NAME_SIZE, "STM32MP%s%s Rev.%s", cpu_s, package, cpu_r);
+}
diff --git a/arch/arm/mach-stm32mp/stm32mp2/stm32mp23x.c b/arch/arm/mach-stm32mp/stm32mp2/stm32mp23x.c
new file mode 100644
index 0000000000..79f1696379
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/stm32mp23x.c
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <log.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+
+/* SYSCFG register */
+#define SYSCFG_DEVICEID_OFFSET		0x6400
+#define SYSCFG_DEVICEID_DEV_ID_MASK	GENMASK(11, 0)
+#define SYSCFG_DEVICEID_DEV_ID_SHIFT	0
+#define SYSCFG_DEVICEID_REV_ID_MASK	GENMASK(31, 16)
+#define SYSCFG_DEVICEID_REV_ID_SHIFT	16
+
+/* Device Part Number (RPN) = OTP9 */
+#define RPN_SHIFT	0
+#define RPN_MASK	GENMASK(31, 0)
+
+/* Package = bit 0:2 of OTP122 => STM32MP25_PKG defines
+ * - 000: Custom package
+ * - 011: TFBGA361 => AL = 10x10, 361 balls pith 0.5mm
+ * - 100: TFBGA424 => AK = 14x14, 424 balls pith 0.5mm
+ * - 101: TFBGA436 => AI = 18x18, 436 balls pith 0.5mm
+ * - others: Reserved
+ */
+#define PKG_SHIFT	0
+#define PKG_MASK	GENMASK(2, 0)
+
+static u32 read_deviceid(void)
+{
+	void *syscfg = syscon_get_first_range(STM32MP_SYSCON_SYSCFG);
+
+	return readl(syscfg + SYSCFG_DEVICEID_OFFSET);
+}
+
+u32 get_cpu_dev(void)
+{
+	return (read_deviceid() & SYSCFG_DEVICEID_DEV_ID_MASK) >> SYSCFG_DEVICEID_DEV_ID_SHIFT;
+}
+
+u32 get_cpu_rev(void)
+{
+	return (read_deviceid() & SYSCFG_DEVICEID_REV_ID_MASK) >> SYSCFG_DEVICEID_REV_ID_SHIFT;
+}
+
+/* Get Device Part Number (RPN) from OTP */
+u32 get_cpu_type(void)
+{
+	return get_otp(BSEC_OTP_RPN, RPN_SHIFT, RPN_MASK);
+}
+
+/* Get Package options from OTP */
+u32 get_cpu_package(void)
+{
+	return get_otp(BSEC_OTP_PKG, PKG_SHIFT, PKG_MASK);
+}
+
+int get_eth_nb(void)
+{
+	int nb_eth;
+
+	switch (get_cpu_type()) {
+	case CPU_STM32MP257Fxx: /* Dirty hack to test STM32MP23 soft on STM32MP25 board */
+		fallthrough;
+	case CPU_STM32MP235Fxx:
+		fallthrough;
+	case CPU_STM32MP235Dxx:
+		fallthrough;
+	case CPU_STM32MP235Cxx:
+		fallthrough;
+	case CPU_STM32MP235Axx:
+		fallthrough;
+	case CPU_STM32MP233Fxx:
+		fallthrough;
+	case CPU_STM32MP233Dxx:
+		fallthrough;
+	case CPU_STM32MP233Cxx:
+		fallthrough;
+	case CPU_STM32MP233Axx:
+		nb_eth = 2; /* dual ETH */
+		break;
+	case CPU_STM32MP231Fxx:
+		fallthrough;
+	case CPU_STM32MP231Dxx:
+		fallthrough;
+	case CPU_STM32MP231Cxx:
+		fallthrough;
+	case CPU_STM32MP231Axx:
+		nb_eth = 1; /* single ETH */
+		break;
+	default:
+		nb_eth = 0;
+		break;
+	}
+
+	return nb_eth;
+}
+
+void get_soc_name(char name[SOC_NAME_SIZE])
+{
+	char *cpu_s, *cpu_r, *package;
+
+	cpu_s = "????";
+	cpu_r = "?";
+	package = "??";
+	if (get_cpu_dev() == CPU_DEV_STM32MP25) {
+		switch (get_cpu_type()) {
+		case CPU_STM32MP235Fxx:
+			cpu_s = "235F";
+			break;
+		case CPU_STM32MP235Dxx:
+			cpu_s = "235D";
+			break;
+		case CPU_STM32MP235Cxx:
+			cpu_s = "235C";
+			break;
+		case CPU_STM32MP235Axx:
+			cpu_s = "235A";
+			break;
+		case CPU_STM32MP233Fxx:
+			cpu_s = "233F";
+			break;
+		case CPU_STM32MP233Dxx:
+			cpu_s = "233D";
+			break;
+		case CPU_STM32MP233Cxx:
+			cpu_s = "233C";
+			break;
+		case CPU_STM32MP233Axx:
+			cpu_s = "233A";
+			break;
+		case CPU_STM32MP231Fxx:
+			cpu_s = "231F";
+			break;
+		case CPU_STM32MP231Dxx:
+			cpu_s = "231D";
+			break;
+		case CPU_STM32MP231Cxx:
+			cpu_s = "231C";
+			break;
+		case CPU_STM32MP231Axx:
+			cpu_s = "231A";
+			break;
+		default:
+			cpu_s = "23??";
+			break;
+		}
+		/* REVISION */
+		switch (get_cpu_rev()) {
+		case CPU_REV1:
+			cpu_r = "A";
+			break;
+		case CPU_REV2:
+			cpu_r = "B";
+			break;
+		default:
+			break;
+		}
+		/* PACKAGE */
+		switch (get_cpu_package()) {
+		case STM32MP23_PKG_CUSTOM:
+			package = "XX";
+			break;
+		case STM32MP23_PKG_AL_VFBGA361:
+			package = "AL";
+			break;
+		case STM32MP23_PKG_AK_VFBGA424:
+			package = "AK";
+			break;
+		case STM32MP23_PKG_AJ_TFBGA361:
+			package = "AI";
+			break;
+		default:
+			break;
+		}
+	}
+
+	snprintf(name, SOC_NAME_SIZE, "STM32MP%s%s Rev.%s", cpu_s, package, cpu_r);
+}
diff --git a/arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c b/arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c
new file mode 100644
index 0000000000..0d199f6f90
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <log.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+
+/* SYSCFG register */
+#define SYSCFG_DEVICEID_OFFSET		0x6400
+#define SYSCFG_DEVICEID_DEV_ID_MASK	GENMASK(11, 0)
+#define SYSCFG_DEVICEID_DEV_ID_SHIFT	0
+
+/* Revision ID = OTP102[5:0] 6 bits : 3 for Major / 3 for Minor*/
+#define REVID_SHIFT	0
+#define REVID_MASK	GENMASK(5, 0)
+
+/* Device Part Number (RPN) = OTP9 */
+#define RPN_SHIFT	0
+#define RPN_MASK	GENMASK(31, 0)
+
+/* Package = bit 0:2 of OTP122 => STM32MP25_PKG defines
+ * - 000: Custom package
+ * - 001: VFBGA361 => AL = 10x10, 361 balls pith 0.5mm
+ * - 011: VFBGA424 => AK = 14x14, 424 balls pith 0.5mm
+ * - 101: TFBGA436 => AI = 18x18, 436 balls pith 0.5mm
+ * - others: Reserved
+ */
+#define PKG_SHIFT	0
+#define PKG_MASK	GENMASK(2, 0)
+
+static u32 read_deviceid(void)
+{
+	void *syscfg = syscon_get_first_range(STM32MP_SYSCON_SYSCFG);
+
+	return readl(syscfg + SYSCFG_DEVICEID_OFFSET);
+}
+
+u32 get_cpu_dev(void)
+{
+	return (read_deviceid() & SYSCFG_DEVICEID_DEV_ID_MASK) >> SYSCFG_DEVICEID_DEV_ID_SHIFT;
+}
+
+u32 get_cpu_rev(void)
+{
+	return get_otp(BSEC_OTP_REVID, REVID_SHIFT, REVID_MASK);
+}
+
+/* Get Device Part Number (RPN) from OTP */
+u32 get_cpu_type(void)
+{
+	return get_otp(BSEC_OTP_RPN, RPN_SHIFT, RPN_MASK);
+}
+
+/* Get Package options from OTP */
+u32 get_cpu_package(void)
+{
+	return get_otp(BSEC_OTP_PKG, PKG_SHIFT, PKG_MASK);
+}
+
+int get_eth_nb(void)
+{
+	int nb_eth;
+
+	switch (get_cpu_type()) {
+	case CPU_STM32MP257Fxx:
+		fallthrough;
+	case CPU_STM32MP257Dxx:
+		fallthrough;
+	case CPU_STM32MP257Cxx:
+		fallthrough;
+	case CPU_STM32MP257Axx:
+		nb_eth = 5; /* dual ETH with TSN support */
+		break;
+	case CPU_STM32MP253Fxx:
+		fallthrough;
+	case CPU_STM32MP253Dxx:
+		fallthrough;
+	case CPU_STM32MP253Cxx:
+		fallthrough;
+	case CPU_STM32MP253Axx:
+		nb_eth = 2; /* dual ETH */
+		break;
+	case CPU_STM32MP251Fxx:
+		fallthrough;
+	case CPU_STM32MP251Dxx:
+		fallthrough;
+	case CPU_STM32MP251Cxx:
+		fallthrough;
+	case CPU_STM32MP251Axx:
+		nb_eth = 1; /* single ETH */
+		break;
+	default:
+		nb_eth = 0;
+		break;
+	}
+
+	return nb_eth;
+}
+
+void get_soc_name(char name[SOC_NAME_SIZE])
+{
+	char *cpu_s, *cpu_r, *package;
+
+	cpu_s = "????";
+	cpu_r = "?";
+	package = "??";
+	if (get_cpu_dev() == CPU_DEV_STM32MP25) {
+		switch (get_cpu_type()) {
+		case CPU_STM32MP257Fxx:
+			cpu_s = "257F";
+			break;
+		case CPU_STM32MP257Dxx:
+			cpu_s = "257D";
+			break;
+		case CPU_STM32MP257Cxx:
+			cpu_s = "257C";
+			break;
+		case CPU_STM32MP257Axx:
+			cpu_s = "257A";
+			break;
+		case CPU_STM32MP255Fxx:
+			cpu_s = "255F";
+			break;
+		case CPU_STM32MP255Dxx:
+			cpu_s = "255D";
+			break;
+		case CPU_STM32MP255Cxx:
+			cpu_s = "255C";
+			break;
+		case CPU_STM32MP255Axx:
+			cpu_s = "255A";
+			break;
+		case CPU_STM32MP253Fxx:
+			cpu_s = "253F";
+			break;
+		case CPU_STM32MP253Dxx:
+			cpu_s = "253D";
+			break;
+		case CPU_STM32MP253Cxx:
+			cpu_s = "253C";
+			break;
+		case CPU_STM32MP253Axx:
+			cpu_s = "253A";
+			break;
+		case CPU_STM32MP251Fxx:
+			cpu_s = "251F";
+			break;
+		case CPU_STM32MP251Dxx:
+			cpu_s = "251D";
+			break;
+		case CPU_STM32MP251Cxx:
+			cpu_s = "251C";
+			break;
+		case CPU_STM32MP251Axx:
+			cpu_s = "251A";
+			break;
+		default:
+			cpu_s = "25??";
+			break;
+		}
+		/* REVISION */
+		switch (get_cpu_rev()) {
+		case OTP_REVID_1:
+			cpu_r = "A";
+			break;
+		case OTP_REVID_1_1:
+			cpu_r = "Z";
+			break;
+		case OTP_REVID_2:
+			cpu_r = "B";
+			break;
+		case OTP_REVID_2_1:
+			cpu_r = "Y";
+			break;
+		case OTP_REVID_2_2:
+			cpu_r = "X";
+			break;
+		default:
+			break;
+		}
+		/* PACKAGE */
+		switch (get_cpu_package()) {
+		case STM32MP25_PKG_CUSTOM:
+			package = "XX";
+			break;
+		case STM32MP25_PKG_AL_VFBGA361:
+			package = "AL";
+			break;
+		case STM32MP25_PKG_AK_VFBGA424:
+			package = "AK";
+			break;
+		case STM32MP25_PKG_AI_TFBGA436:
+			package = "AI";
+			break;
+		default:
+			break;
+		}
+	}
+
+	snprintf(name, SOC_NAME_SIZE, "STM32MP%s%s Rev.%s", cpu_s, package, cpu_r);
+}
diff --git a/arch/arm/mach-stm32mp/syscon.c b/arch/arm/mach-stm32mp/syscon.c
index a0e8e1dfdc..a2e351d74a 100644
--- a/arch/arm/mach-stm32mp/syscon.c
+++ b/arch/arm/mach-stm32mp/syscon.c
@@ -10,8 +10,8 @@
 #include <asm/arch/stm32.h>
 
 static const struct udevice_id stm32mp_syscon_ids[] = {
-	{ .compatible = "st,stm32mp157-syscfg",
-	  .data = STM32MP_SYSCON_SYSCFG },
+	{ .compatible = "st,stm32mp157-syscfg", .data = STM32MP_SYSCON_SYSCFG },
+	{ .compatible = "st,stm32mp25-syscfg", .data = STM32MP_SYSCON_SYSCFG},
 	{ }
 };
 
diff --git a/arch/sandbox/include/asm/gpio.h b/arch/sandbox/include/asm/gpio.h
index 0dd4c7bf60..c5ff9e9cdd 100644
--- a/arch/sandbox/include/asm/gpio.h
+++ b/arch/sandbox/include/asm/gpio.h
@@ -28,9 +28,10 @@
 #define GPIOD_EXT_DRIVEN	BIT(30)	/* external source is driven */
 #define GPIOD_EXT_PULL_UP	BIT(29)	/* GPIO has external pull-up */
 #define GPIOD_EXT_PULL_DOWN	BIT(28)	/* GPIO has external pull-down */
+#define GPIOD_EXT_PROTECTED	BIT(27)	/* GPIO is access protected */
 
 #define GPIOD_EXT_PULL		(BIT(28) | BIT(29))
-#define GPIOD_SANDBOX_MASK	GENMASK(31, 28)
+#define GPIOD_SANDBOX_MASK	GENMASK(31, 27)
 
 /**
  * Return the simulated value of a GPIO (used only in sandbox test code)
diff --git a/board/dhelectronics/dh_stm32mp1/board.c b/board/dhelectronics/dh_stm32mp1/board.c
index f9cfabe242..3bd9a208bd 100644
--- a/board/dhelectronics/dh_stm32mp1/board.c
+++ b/board/dhelectronics/dh_stm32mp1/board.c
@@ -229,8 +229,9 @@ static void board_get_coding_straps(void)
 
 	gpio_free_list_nodev(gpio, ret);
 
-	printf("Code:  SoM:rev=%d,ddr3=%d Board:rev=%d\n",
-		somcode, ddr3code, brdcode);
+	if (CONFIG_IS_ENABLED(DISPLAY_PRINT))
+		printf("Code:  SoM:rev=%d,ddr3=%d Board:rev=%d\n",
+		       somcode, ddr3code, brdcode);
 }
 
 int board_stm32mp1_ddr_config_name_match(struct udevice *dev,
@@ -679,7 +680,7 @@ void board_quiesce_devices(void)
 
 /* eth init function : weak called in eqos driver */
 int board_interface_eth_init(struct udevice *dev,
-			     phy_interface_t interface_type)
+			     phy_interface_t interface_type, ulong rate)
 {
 	u8 *syscfg;
 	u32 value;
diff --git a/board/st/common/Kconfig b/board/st/common/Kconfig
index c1c254d073..da0137f789 100644
--- a/board/st/common/Kconfig
+++ b/board/st/common/Kconfig
@@ -1,7 +1,7 @@
 config CMD_STBOARD
 	bool "stboard - command for OTP board information"
 	depends on ARCH_STM32MP
-	default y if TARGET_ST_STM32MP15x || TARGET_ST_STM32MP13x
+	default y if TARGET_ST_STM32MP21X || TARGET_ST_STM32MP23X || TARGET_ST_STM32MP25X || TARGET_ST_STM32MP15X || TARGET_ST_STM32MP13X
 	help
 	  This compile the stboard command to
 	  read and write the board in the OTP.
@@ -13,9 +13,3 @@ config DFU_ALT_RAM0
 	help
 	  This defines the partitions of ram used to build dfu dynamically.
 
-config TYPEC_STUSB160X
-	tristate "STMicroelectronics STUSB160X Type-C controller driver"
-	depends on DM_I2C
-	help
-	  Say Y if your system has STMicroelectronics STUSB160X Type-C port
-	  controller.
diff --git a/board/st/common/Makefile b/board/st/common/Makefile
index c960829726..f048bca93e 100644
--- a/board/st/common/Makefile
+++ b/board/st/common/Makefile
@@ -8,6 +8,6 @@ obj-$(CONFIG_PMIC_STPMIC1) += stpmic1.o
 
 ifeq ($(CONFIG_ARCH_STM32MP),y)
 obj-$(CONFIG_SET_DFU_ALT_INFO) += stm32mp_dfu.o
+obj-$(CONFIG_$(SPL_)DFU_VIRT) += stm32mp_dfu_virt.o
 endif
 
-obj-$(CONFIG_TYPEC_STUSB160X) += stusb160x.o
diff --git a/board/st/common/cmd_stboard.c b/board/st/common/cmd_stboard.c
index 853ab78bbf..43d8d74c12 100644
--- a/board/st/common/cmd_stboard.c
+++ b/board/st/common/cmd_stboard.c
@@ -49,7 +49,10 @@ static bool check_stboard(u16 board)
 		0x1298,
 		0x1341,
 		0x1497,
+		0x1605, /* stm32mp25xx-dk */
 		0x1635,
+		0x1936, /* stm32mp25xx-ev */
+		0x2059, /* stm32mp21xx-dk */
 	};
 
 	for (i = 0; i < ARRAY_SIZE(st_board_id); i++)
diff --git a/board/st/common/stm32mp_dfu.c b/board/st/common/stm32mp_dfu.c
index 1cf4a3d5fa..a7b1314839 100644
--- a/board/st/common/stm32mp_dfu.c
+++ b/board/st/common/stm32mp_dfu.c
@@ -13,7 +13,6 @@
 #include <misc.h>
 #include <mtd.h>
 #include <mtd_node.h>
-#include <asm/arch/stm32prog.h>
 
 #define DFU_ALT_BUF_LEN SZ_1K
 
@@ -72,7 +71,6 @@ static void board_get_alt_info_mmc(struct udevice *dev, char *buf)
 static void board_get_alt_info_mtd(struct mtd_info *mtd, char *buf)
 {
 	struct mtd_info *part;
-	bool first = true;
 	const char *name;
 	int len, partnum = 0;
 
@@ -85,17 +83,13 @@ static void board_get_alt_info_mtd(struct mtd_info *mtd, char *buf)
 			"mtd %s=", name);
 
 	len += snprintf(buf + len, DFU_ALT_BUF_LEN - len,
-			"%s raw 0x0 0x%llx ",
+			"%s raw 0x0 0x%llx",
 			name, mtd->size);
 
 	list_for_each_entry(part, &mtd->partitions, node) {
 		partnum++;
-		if (!first)
-			len += snprintf(buf + len, DFU_ALT_BUF_LEN - len, ";");
-		first = false;
-
 		len += snprintf(buf + len, DFU_ALT_BUF_LEN - len,
-				"%s_%s part %d",
+				";%s_%s part %d",
 				name, part->name, partnum);
 	}
 }
@@ -126,129 +120,19 @@ void set_dfu_alt_info(char *interface, char *devstr)
 	if (IS_ENABLED(CONFIG_MTD)) {
 		/* probe all MTD devices */
 		mtd_probe_devices();
-
-		/* probe SPI flash device on a bus */
-		if (!uclass_get_device(UCLASS_SPI_FLASH, 0, &dev)) {
-			mtd = get_mtd_device_nm("nor0");
-			if (!IS_ERR_OR_NULL(mtd))
+		mtd_for_each_device(mtd)
+			if (!mtd_is_partition(mtd))
 				board_get_alt_info_mtd(mtd, buf);
-
-			mtd = get_mtd_device_nm("nor1");
-			if (!IS_ERR_OR_NULL(mtd))
-				board_get_alt_info_mtd(mtd, buf);
-		}
-
-		mtd = get_mtd_device_nm("nand0");
-		if (!IS_ERR_OR_NULL(mtd))
-			board_get_alt_info_mtd(mtd, buf);
-
-		mtd = get_mtd_device_nm("spi-nand0");
-		if (!IS_ERR_OR_NULL(mtd))
-			board_get_alt_info_mtd(mtd, buf);
 	}
 
-	if (IS_ENABLED(CONFIG_DFU_VIRT) &&
-	    IS_ENABLED(CMD_STM32PROG_USB)) {
-		strncat(buf, "&virt 0=OTP", DFU_ALT_BUF_LEN);
+	if (IS_ENABLED(CONFIG_DFU_VIRT)) {
+		/* virtual device id 0 is aligned with stm32mp_dfu_virt.c */
+		strlcat(buf, "&virt 0=OTP", DFU_ALT_BUF_LEN);
 
 		if (IS_ENABLED(CONFIG_PMIC_STPMIC1))
-			strncat(buf, "&virt 1=PMIC", DFU_ALT_BUF_LEN);
+			strlcat(buf, "&virt 1=PMIC", DFU_ALT_BUF_LEN);
 	}
 
 	env_set("dfu_alt_info", buf);
 	puts("DFU alt info setting: done\n");
 }
-
-#if CONFIG_IS_ENABLED(DFU_VIRT)
-#include <dfu.h>
-#include <power/stpmic1.h>
-
-static int dfu_otp_read(u64 offset, u8 *buffer, long *size)
-{
-	struct udevice *dev;
-	int ret;
-
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_DRIVER_GET(stm32mp_bsec),
-					  &dev);
-	if (ret)
-		return ret;
-
-	ret = misc_read(dev, offset + STM32_BSEC_OTP_OFFSET, buffer, *size);
-	if (ret >= 0) {
-		*size = ret;
-		ret = 0;
-	}
-
-	return 0;
-}
-
-static int dfu_pmic_read(u64 offset, u8 *buffer, long *size)
-{
-	int ret;
-#ifdef CONFIG_PMIC_STPMIC1
-	struct udevice *dev;
-
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_DRIVER_GET(stpmic1_nvm),
-					  &dev);
-	if (ret)
-		return ret;
-
-	ret = misc_read(dev, 0xF8 + offset, buffer, *size);
-	if (ret >= 0) {
-		*size = ret;
-		ret = 0;
-	}
-	if (ret == -EACCES) {
-		*size = 0;
-		ret = 0;
-	}
-#else
-	log_err("PMIC update not supported");
-	ret = -EOPNOTSUPP;
-#endif
-
-	return ret;
-}
-
-int dfu_read_medium_virt(struct dfu_entity *dfu, u64 offset,
-			 void *buf, long *len)
-{
-	switch (dfu->data.virt.dev_num) {
-	case 0x0:
-		return dfu_otp_read(offset, buf, len);
-	case 0x1:
-		return dfu_pmic_read(offset, buf, len);
-	}
-
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
-	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
-		return stm32prog_read_medium_virt(dfu, offset, buf, len);
-
-	*len = 0;
-	return 0;
-}
-
-int dfu_write_medium_virt(struct dfu_entity *dfu, u64 offset,
-			  void *buf, long *len)
-{
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
-	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
-		return stm32prog_write_medium_virt(dfu, offset, buf, len);
-
-	return -EOPNOTSUPP;
-}
-
-int __weak dfu_get_medium_size_virt(struct dfu_entity *dfu, u64 *size)
-{
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
-	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
-		return stm32prog_get_medium_size_virt(dfu, size);
-
-	*size = SZ_1K;
-
-	return 0;
-}
-
-#endif
diff --git a/board/st/common/stm32mp_dfu_virt.c b/board/st/common/stm32mp_dfu_virt.c
new file mode 100644
index 0000000000..f0f9960579
--- /dev/null
+++ b/board/st/common/stm32mp_dfu_virt.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <dfu.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/arch/stm32prog.h>
+#include <power/stpmic1.h>
+
+static int dfu_otp_read(u64 offset, u8 *buffer, long *size)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, offset + STM32_BSEC_OTP_OFFSET, buffer, *size);
+	if (ret >= 0) {
+		*size = ret;
+		ret = 0;
+	}
+
+	return 0;
+}
+
+static int dfu_pmic_read(u64 offset, u8 *buffer, long *size)
+{
+	int ret;
+	struct udevice *dev;
+
+	if (!IS_ENABLED(CONFIG_PMIC_STPMIC1)) {
+		log_err("PMIC update not supported");
+		return -EOPNOTSUPP;
+	}
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stpmic1_nvm),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, 0xF8 + offset, buffer, *size);
+	if (ret >= 0) {
+		*size = ret;
+		ret = 0;
+	}
+	if (ret == -EACCES) {
+		*size = 0;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+int dfu_read_medium_virt(struct dfu_entity *dfu, u64 offset,
+			 void *buf, long *len)
+{
+	switch (dfu->data.virt.dev_num) {
+	case 0x0:
+		return dfu_otp_read(offset, buf, len);
+	case 0x1:
+		return dfu_pmic_read(offset, buf, len);
+	}
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
+	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
+		return stm32prog_read_medium_virt(dfu, offset, buf, len);
+
+	*len = 0;
+	return 0;
+}
+
+int dfu_write_medium_virt(struct dfu_entity *dfu, u64 offset,
+			  void *buf, long *len)
+{
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
+	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
+		return stm32prog_write_medium_virt(dfu, offset, buf, len);
+
+	return -EOPNOTSUPP;
+}
+
+int dfu_get_medium_size_virt(struct dfu_entity *dfu, u64 *size)
+{
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
+	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
+		return stm32prog_get_medium_size_virt(dfu, size);
+
+	*size = SZ_1K;
+
+	return 0;
+}
diff --git a/board/st/common/stusb160x.c b/board/st/common/stusb160x.c
deleted file mode 100644
index f0385e5e38..0000000000
--- a/board/st/common/stusb160x.c
+++ /dev/null
@@ -1,48 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
-/*
- * STMicroelectronics STUSB Type-C controller driver
- * based on Linux drivers/usb/typec/stusb160x.c
- *
- * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
- */
-
-#define LOG_CATEGORY UCLASS_I2C_GENERIC
-
-#include <common.h>
-#include <dm.h>
-#include <i2c.h>
-
-/* REGISTER */
-#define STUSB160X_CC_CONNECTION_STATUS		0x0E
-
-/* STUSB160X_CC_CONNECTION_STATUS bitfields */
-#define STUSB160X_CC_ATTACH			BIT(0)
-
-int stusb160x_cable_connected(void)
-{
-	struct udevice *dev;
-	int ret;
-
-	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC,
-					  DM_DRIVER_GET(stusb160x),
-					  &dev);
-	if (ret < 0)
-		return ret;
-
-	ret = dm_i2c_reg_read(dev, STUSB160X_CC_CONNECTION_STATUS);
-	if (ret < 0)
-		return 0;
-
-	return ret & STUSB160X_CC_ATTACH;
-}
-
-static const struct udevice_id stusb160x_ids[] = {
-	{ .compatible = "st,stusb1600" },
-	{}
-};
-
-U_BOOT_DRIVER(stusb160x) = {
-	.name = "stusb160x",
-	.id = UCLASS_I2C_GENERIC,
-	.of_match = stusb160x_ids,
-};
diff --git a/board/st/common/stusb160x.h b/board/st/common/stusb160x.h
deleted file mode 100644
index fe39840b41..0000000000
--- a/board/st/common/stusb160x.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2020, STMicroelectronics
- */
-
-#ifdef CONFIG_TYPEC_STUSB160X
-int stusb160x_cable_connected(void);
-#else
-int stusb160x_cable_connected(void) { return -ENODEV; }
-#endif
diff --git a/board/st/stm32f746-disco/stm32f746-disco.c b/board/st/stm32f746-disco/stm32f746-disco.c
index 4cfb29ef42..0f96660084 100644
--- a/board/st/stm32f746-disco/stm32f746-disco.c
+++ b/board/st/stm32f746-disco/stm32f746-disco.c
@@ -14,7 +14,6 @@
 #include <serial.h>
 #include <spl.h>
 #include <splash.h>
-#include <st_logo_data.h>
 #include <video.h>
 #include <asm/global_data.h>
 #include <asm/io.h>
@@ -134,10 +133,5 @@ int board_init(void)
 	}
 #endif
 
-#if defined(CONFIG_CMD_BMP)
-	bmp_display((ulong)stmicroelectronics_uboot_logo_8bit_rle,
-		    BMP_ALIGN_CENTER, BMP_ALIGN_CENTER);
-#endif /* CONFIG_CMD_BMP */
-
 	return 0;
 }
diff --git a/board/st/stm32mp1/Kconfig b/board/st/stm32mp1/Kconfig
index 6ab8f80fa4..96de41546f 100644
--- a/board/st/stm32mp1/Kconfig
+++ b/board/st/stm32mp1/Kconfig
@@ -1,4 +1,4 @@
-if TARGET_ST_STM32MP15x
+if TARGET_ST_STM32MP15X
 
 config SYS_BOARD
 	default "stm32mp1"
@@ -12,7 +12,7 @@ config SYS_CONFIG_NAME
 source "board/st/common/Kconfig"
 endif
 
-if TARGET_ST_STM32MP13x
+if TARGET_ST_STM32MP13X
 
 config SYS_BOARD
 	default "stm32mp1"
diff --git a/board/st/stm32mp1/stm32mp1.c b/board/st/stm32mp1/stm32mp1.c
index 3205a31c6d..9b912a8024 100644
--- a/board/st/stm32mp1/stm32mp1.c
+++ b/board/st/stm32mp1/stm32mp1.c
@@ -20,6 +20,7 @@
 #include <generic-phy.h>
 #include <hang.h>
 #include <i2c.h>
+#include <regmap.h>
 #include <init.h>
 #include <led.h>
 #include <log.h>
@@ -31,6 +32,7 @@
 #include <remoteproc.h>
 #include <reset.h>
 #include <syscon.h>
+#include <typec.h>
 #include <usb.h>
 #include <watchdog.h>
 #include <asm/global_data.h>
@@ -38,6 +40,8 @@
 #include <asm/gpio.h>
 #include <asm/arch/stm32.h>
 #include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
 #include <dm/ofnode.h>
 #include <jffs2/load_kernel.h>
 #include <linux/bitops.h>
@@ -47,8 +51,6 @@
 #include <power/regulator.h>
 #include <usb/dwc2_udc.h>
 
-#include "../../st/common/stusb160x.h"
-
 /* SYSCFG registers */
 #define SYSCFG_BOOTR		0x00
 #define SYSCFG_PMCSETR		0x04
@@ -56,7 +58,8 @@
 #define SYSCFG_ICNR		0x1C
 #define SYSCFG_CMPCR		0x20
 #define SYSCFG_CMPENSETR	0x24
-#define SYSCFG_PMCCLRR		0x44
+#define SYSCFG_PMCCLRR		0x08
+#define SYSCFG_MP13_PMCCLRR	0x44
 
 #define SYSCFG_BOOTR_BOOT_MASK		GENMASK(2, 0)
 #define SYSCFG_BOOTR_BOOTPD_SHIFT	4
@@ -72,15 +75,8 @@
 
 #define SYSCFG_CMPENSETR_MPU_EN		BIT(0)
 
-#define SYSCFG_PMCSETR_ETH_CLK_SEL	BIT(16)
-#define SYSCFG_PMCSETR_ETH_REF_CLK_SEL	BIT(17)
-
-#define SYSCFG_PMCSETR_ETH_SELMII	BIT(20)
-
-#define SYSCFG_PMCSETR_ETH_SEL_MASK	GENMASK(23, 21)
-#define SYSCFG_PMCSETR_ETH_SEL_GMII_MII	0
-#define SYSCFG_PMCSETR_ETH_SEL_RGMII	BIT(21)
-#define SYSCFG_PMCSETR_ETH_SEL_RMII	BIT(23)
+#define GOODIX_REG_ID		0x8140
+#define GOODIX_ID_LEN		4
 
 #define USB_LOW_THRESHOLD_UV		200000
 #define USB_WARNING_LOW_THRESHOLD_UV	660000
@@ -113,7 +109,7 @@ int checkboard(void)
 	int fdt_compat_len;
 
 	if (IS_ENABLED(CONFIG_TFABOOT)) {
-		if (IS_ENABLED(CONFIG_STM32MP15x_STM32IMAGE))
+		if (IS_ENABLED(CONFIG_STM32MP15X_STM32IMAGE))
 			mode = "trusted - stm32image";
 		else
 			mode = "trusted";
@@ -196,6 +192,20 @@ static void board_key_check(void)
 	}
 }
 
+static int typec_usb_cable_connected(void)
+{
+	struct udevice *dev;
+	int ret;
+	u8 connector = 0;
+
+	ret = uclass_get_device(UCLASS_USB_TYPEC, 0, &dev);
+	if (ret < 0)
+		return ret;
+
+	return (typec_is_attached(dev, connector) == TYPEC_ATTACHED) &&
+	       (typec_get_data_role(dev, connector) == TYPEC_DEVICE);
+}
+
 int g_dnl_board_usb_cable_connected(void)
 {
 	struct udevice *dwc2_udc_otg;
@@ -211,8 +221,8 @@ int g_dnl_board_usb_cable_connected(void)
 	if ((get_bootmode() & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_USB)
 		return true;
 
-	/* if typec stusb160x is present, means DK1 or DK2 board */
-	ret = stusb160x_cable_connected();
+	/* if Type-C is present, it means DK1 or DK2 board */
+	ret = typec_usb_cable_connected();
 	if (ret >= 0)
 		return ret;
 
@@ -367,9 +377,6 @@ static int board_check_usb_power(void)
 	u32 nb_blink;
 	u8 i;
 
-	if (!IS_ENABLED(CONFIG_ADC))
-		return -ENODEV;
-
 	node = ofnode_path("/config");
 	if (!ofnode_valid(node)) {
 		log_debug("no /config node?\n");
@@ -615,8 +622,9 @@ error:
 
 static bool board_is_stm32mp15x_dk2(void)
 {
-	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15x) &&
-	    of_machine_is_compatible("st,stm32mp157c-dk2"))
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15X) &&
+	    (of_machine_is_compatible("st,stm32mp157c-dk2") ||
+	     of_machine_is_compatible("st,stm32mp157f-dk2")))
 		return true;
 
 	return false;
@@ -624,7 +632,7 @@ static bool board_is_stm32mp15x_dk2(void)
 
 static bool board_is_stm32mp15x_ev1(void)
 {
-	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15x) &&
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15X) &&
 	    (of_machine_is_compatible("st,stm32mp157a-ev1") ||
 	     of_machine_is_compatible("st,stm32mp157c-ev1") ||
 	     of_machine_is_compatible("st,stm32mp157d-ev1") ||
@@ -634,24 +642,197 @@ static bool board_is_stm32mp15x_ev1(void)
 	return false;
 }
 
+/* touchscreen driver: used for focaltech touchscreen detection */
+static const struct udevice_id edt_ft6236_ids[] = {
+	{ .compatible = "focaltech,ft6236", },
+	{ }
+};
+
+U_BOOT_DRIVER(edt_ft6236) = {
+	.name		= "edt_ft6236",
+	.id		= UCLASS_I2C_GENERIC,
+	.of_match	= edt_ft6236_ids,
+};
+
 /* touchscreen driver: only used for pincontrol configuration */
 static const struct udevice_id goodix_ids[] = {
+	{ .compatible = "goodix,gt911", },
 	{ .compatible = "goodix,gt9147", },
 	{ }
 };
 
 U_BOOT_DRIVER(goodix) = {
 	.name		= "goodix",
-	.id		= UCLASS_NOP,
+	.id		= UCLASS_I2C_GENERIC,
 	.of_match	= goodix_ids,
 };
 
+static int goodix_i2c_read(struct udevice *dev, u16 reg, u8 *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	__be16 wbuf = cpu_to_be16(reg);
+	int ret;
+
+	msgs[0].flags = 0;
+	msgs[0].addr  = 0x5d;
+	msgs[0].len   = 2;
+	msgs[0].buf   = (u8 *)&wbuf;
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr  = 0x5d;
+	msgs[1].len   = len;
+	msgs[1].buf   = buf;
+
+	ret = dm_i2c_xfer(dev, msgs, 2);
+
+	return ret;
+}
+
+/* HELPER: search detected driver */
+struct detect_info_t {
+	bool (*detect)(void);
+	struct driver *drv;
+};
+
+static struct driver *detect_device(struct detect_info_t *info, u8 size)
+{
+	struct driver *drv = NULL;
+	u8 i;
+
+	for (i = 0; i < size && !drv; i++)
+		if (info[i].detect())
+			drv = info[i].drv;
+
+	return drv;
+}
+
+/* HELPER: force new driver binding, replace the existing one */
+static void bind_driver(struct driver *drv, const char *path)
+{
+	ofnode node;
+	struct udevice *dev;
+	struct udevice *parent;
+	int ret;
+
+	node = ofnode_path(path);
+	if (!ofnode_valid(node))
+		return;
+	if (!ofnode_is_enabled(node))
+		return;
+
+	ret = device_find_global_by_ofnode(ofnode_get_parent(node), &parent);
+	if (!parent || ret) {
+		log_debug("Unable to found parent. err:%d\n", ret);
+		return;
+	}
+
+	ret = device_find_global_by_ofnode(node, &dev);
+	/* remove the driver previously binded */
+	if (dev && !ret) {
+		if (dev->driver == drv) {
+			log_debug("nothing to do, %s already binded.\n", drv->name);
+			return;
+		}
+		log_debug("%s unbind\n", dev->driver->name);
+		device_remove(dev, DM_REMOVE_NORMAL);
+		device_unbind(dev);
+	}
+	/* bind the new driver */
+	ret = device_bind_with_driver_data(parent, drv, ofnode_get_name(node),
+					   0, node, &dev);
+	if (ret)
+		log_debug("Unable to bind %s, err:%d\n", drv->name, ret);
+}
+
+bool stm32mp15x_ev1_rm68200(void)
+{
+	struct udevice *dev;
+	struct udevice *bus;
+	struct dm_i2c_chip *chip;
+	char id[GOODIX_ID_LEN];
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC, DM_DRIVER_GET(goodix), &dev);
+	if (ret)
+		return false;
+
+	bus = dev_get_parent(dev);
+	chip = dev_get_parent_plat(dev);
+	ret = dm_i2c_probe(bus, chip->chip_addr, 0, &dev);
+	if (ret)
+		return false;
+
+	ret = goodix_i2c_read(dev, GOODIX_REG_ID, id, sizeof(id));
+	if (ret)
+		return false;
+
+	if (!strncmp(id, "9147", sizeof(id)))
+		return true;
+
+	return false;
+}
+
+bool stm32mp15x_ev1_hx8394(void)
+{
+	return true;
+}
+
+extern U_BOOT_DRIVER(rm68200_panel);
+extern U_BOOT_DRIVER(hx8394_panel);
+
+struct detect_info_t stm32mp15x_ev1_panels[] = {
+	CONFIG_IS_ENABLED(VIDEO_LCD_RAYDIUM_RM68200,
+			  ({ .detect = stm32mp15x_ev1_rm68200,
+			   .drv = DM_DRIVER_REF(rm68200_panel)
+			   },
+			   ))
+	CONFIG_IS_ENABLED(VIDEO_LCD_ROCKTECH_HX8394,
+			  ({ .detect = stm32mp15x_ev1_hx8394,
+			   .drv = DM_DRIVER_REF(hx8394_panel)
+			   },
+			   ))
+};
+
 static void board_stm32mp15x_ev1_init(void)
 {
 	struct udevice *dev;
+	struct driver *drv;
+	struct gpio_desc reset_gpio;
+	char path[40];
+	int ret;
 
 	/* configure IRQ line on EV1 for touchscreen before LCD reset */
-	uclass_get_device_by_driver(UCLASS_NOP, DM_DRIVER_GET(goodix), &dev);
+	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC, DM_DRIVER_GET(goodix), &dev);
+	if (ret)
+		return;
+
+	/* get & set reset gpio for panel */
+	ret = uclass_get_device_by_driver(UCLASS_PANEL, DM_DRIVER_GET(rm68200_panel), &dev);
+	if (ret)
+		return;
+
+	gpio_request_by_name(dev, "reset-gpios", 0, &reset_gpio, GPIOD_IS_OUT);
+
+	if (!dm_gpio_is_valid(&reset_gpio))
+		return;
+
+	dm_gpio_set_value(&reset_gpio, true);
+	mdelay(1);
+	dm_gpio_set_value(&reset_gpio, false);
+	mdelay(10);
+
+	/* auto detection of connected panel-dsi */
+	drv = detect_device(stm32mp15x_ev1_panels, ARRAY_SIZE(stm32mp15x_ev1_panels));
+	if (!drv)
+		return;
+	/* save the detected compatible in environment */
+	env_set("panel-dsi", drv->of_match->compatible);
+
+	dm_gpio_free(NULL, &reset_gpio);
+
+	/* select the driver for the detected PANEL */
+	ofnode_get_path(dev_ofnode(dev), path, sizeof(path));
+	bind_driver(drv, path);
 }
 
 /* board dependent setup after realloc */
@@ -659,12 +840,6 @@ int board_init(void)
 {
 	board_key_check();
 
-	if (board_is_stm32mp15x_ev1())
-		board_stm32mp15x_ev1_init();
-
-	if (board_is_stm32mp15x_dk2())
-		board_stm32mp15x_dk2_init();
-
 	regulators_enable_boot_on(_DEBUG);
 
 	/*
@@ -697,6 +872,12 @@ int board_late_init(void)
 	char dtb_name[256];
 	int buf_len;
 
+	if (IS_ENABLED(CONFIG_VIDEO_LCD_RAYDIUM_RM68200) && board_is_stm32mp15x_ev1())
+		board_stm32mp15x_ev1_init();
+
+	if (board_is_stm32mp15x_dk2())
+		board_stm32mp15x_dk2_init();
+
 	if (IS_ENABLED(CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG)) {
 		fdt_compat = ofnode_get_property(ofnode_root(), "compatible",
 						 &fdt_compat_len);
@@ -730,8 +911,14 @@ int board_late_init(void)
 		}
 	}
 
-	/* for DK1/DK2 boards */
-	board_check_usb_power();
+	if (IS_ENABLED(CONFIG_ADC)) {
+		/* probe all ADC for calibration */
+		uclass_foreach_dev_probe(UCLASS_ADC, dev) {
+			log_debug("ACD probe for calibration: %s\n", dev->name);
+		}
+		/* for DK1/DK2 boards */
+		board_check_usb_power();
+	}
 
 	return 0;
 }
@@ -741,58 +928,114 @@ void board_quiesce_devices(void)
 	setup_led(LEDST_OFF);
 }
 
+/* CLOCK feed to PHY*/
+#define ETH_CK_F_25M	25000000
+#define ETH_CK_F_50M	50000000
+#define ETH_CK_F_125M	125000000
+
+struct stm32_syscfg_pmcsetr {
+	u32 syscfg_clr_off;
+	u32 eth1_clk_sel;
+	u32 eth1_ref_clk_sel;
+	u32 eth1_sel_mii;
+	u32 eth1_sel_rgmii;
+	u32 eth1_sel_rmii;
+	u32 eth2_clk_sel;
+	u32 eth2_ref_clk_sel;
+	u32 eth2_sel_rgmii;
+	u32 eth2_sel_rmii;
+};
+
+const struct stm32_syscfg_pmcsetr stm32mp15_syscfg_pmcsetr = {
+	.syscfg_clr_off		= 0x44,
+	.eth1_clk_sel		= BIT(16),
+	.eth1_ref_clk_sel	= BIT(17),
+	.eth1_sel_mii		= BIT(20),
+	.eth1_sel_rgmii		= BIT(21),
+	.eth1_sel_rmii		= BIT(23),
+	.eth2_clk_sel		= 0,
+	.eth2_ref_clk_sel	= 0,
+	.eth2_sel_rgmii		= 0,
+	.eth2_sel_rmii		= 0
+};
+
+const struct stm32_syscfg_pmcsetr stm32mp13_syscfg_pmcsetr = {
+	.syscfg_clr_off		= 0x08,
+	.eth1_clk_sel		= BIT(16),
+	.eth1_ref_clk_sel	= BIT(17),
+	.eth1_sel_mii		= 0,
+	.eth1_sel_rgmii		= BIT(21),
+	.eth1_sel_rmii		= BIT(23),
+	.eth2_clk_sel		= BIT(24),
+	.eth2_ref_clk_sel	= BIT(25),
+	.eth2_sel_rgmii		= BIT(29),
+	.eth2_sel_rmii		= BIT(31)
+};
+
+#define SYSCFG_PMCSETR_ETH_MASK		GENMASK(23, 16)
+#define SYSCFG_PMCR_ETH_SEL_GMII	0
+
 /* eth init function : weak called in eqos driver */
 int board_interface_eth_init(struct udevice *dev,
-			     phy_interface_t interface_type)
+			     phy_interface_t interface_type, ulong rate)
 {
-	u8 *syscfg;
+	struct regmap *regmap;
+	uint regmap_mask;
+	int ret;
 	u32 value;
-	bool eth_clk_sel_reg = false;
-	bool eth_ref_clk_sel_reg = false;
+	bool ext_phyclk, eth_clk_sel_reg, eth_ref_clk_sel_reg;
+	const struct stm32_syscfg_pmcsetr *pmcsetr;
+
+	/* Ethernet PHY have no crystal */
+	ext_phyclk = dev_read_bool(dev, "st,ext-phyclk");
 
 	/* Gigabit Ethernet 125MHz clock selection. */
 	eth_clk_sel_reg = dev_read_bool(dev, "st,eth-clk-sel");
 
 	/* Ethernet 50Mhz RMII clock selection */
-	eth_ref_clk_sel_reg =
-		dev_read_bool(dev, "st,eth-ref-clk-sel");
+	eth_ref_clk_sel_reg = dev_read_bool(dev, "st,eth-ref-clk-sel");
 
-	syscfg = (u8 *)syscon_get_first_range(STM32MP_SYSCON_SYSCFG);
+	if (device_is_compatible(dev, "st,stm32mp13-dwmac"))
+		pmcsetr = &stm32mp13_syscfg_pmcsetr;
+	else
+		pmcsetr = &stm32mp15_syscfg_pmcsetr;
 
-	if (!syscfg)
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscon");
+	if (!IS_ERR(regmap)) {
+		u32 fmp[3];
+
+		ret = dev_read_u32_array(dev, "st,syscon", fmp, 3);
+		if (ret)
+			/*  If no mask in DT, it is MP15 (backward compatibility) */
+			regmap_mask = SYSCFG_PMCSETR_ETH_MASK;
+		else
+			regmap_mask = fmp[2];
+	} else {
 		return -ENODEV;
+	}
 
 	switch (interface_type) {
 	case PHY_INTERFACE_MODE_MII:
-		value = SYSCFG_PMCSETR_ETH_SEL_GMII_MII |
-			SYSCFG_PMCSETR_ETH_REF_CLK_SEL;
+		value = pmcsetr->eth1_sel_mii;
 		log_debug("PHY_INTERFACE_MODE_MII\n");
 		break;
 	case PHY_INTERFACE_MODE_GMII:
-		if (eth_clk_sel_reg)
-			value = SYSCFG_PMCSETR_ETH_SEL_GMII_MII |
-				SYSCFG_PMCSETR_ETH_CLK_SEL;
-		else
-			value = SYSCFG_PMCSETR_ETH_SEL_GMII_MII;
+		value = SYSCFG_PMCR_ETH_SEL_GMII;
 		log_debug("PHY_INTERFACE_MODE_GMII\n");
 		break;
 	case PHY_INTERFACE_MODE_RMII:
-		if (eth_ref_clk_sel_reg)
-			value = SYSCFG_PMCSETR_ETH_SEL_RMII |
-				SYSCFG_PMCSETR_ETH_REF_CLK_SEL;
-		else
-			value = SYSCFG_PMCSETR_ETH_SEL_RMII;
+		value = pmcsetr->eth1_sel_rmii | pmcsetr->eth2_sel_rmii;
+		if (rate == ETH_CK_F_50M && (eth_clk_sel_reg || ext_phyclk))
+			value |= pmcsetr->eth1_ref_clk_sel | pmcsetr->eth2_ref_clk_sel;
 		log_debug("PHY_INTERFACE_MODE_RMII\n");
 		break;
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_RGMII_RXID:
 	case PHY_INTERFACE_MODE_RGMII_TXID:
-		if (eth_clk_sel_reg)
-			value = SYSCFG_PMCSETR_ETH_SEL_RGMII |
-				SYSCFG_PMCSETR_ETH_CLK_SEL;
-		else
-			value = SYSCFG_PMCSETR_ETH_SEL_RGMII;
+		value = pmcsetr->eth1_sel_rgmii | pmcsetr->eth2_sel_rgmii;
+		if (rate == ETH_CK_F_125M && (eth_clk_sel_reg || ext_phyclk))
+			value |= pmcsetr->eth1_clk_sel | pmcsetr->eth2_clk_sel;
 		log_debug("PHY_INTERFACE_MODE_RGMII\n");
 		break;
 	default:
@@ -802,13 +1045,12 @@ int board_interface_eth_init(struct udevice *dev,
 		return -EINVAL;
 	}
 
-	/* clear and set ETH configuration bits */
-	writel(SYSCFG_PMCSETR_ETH_SEL_MASK | SYSCFG_PMCSETR_ETH_SELMII |
-	       SYSCFG_PMCSETR_ETH_REF_CLK_SEL | SYSCFG_PMCSETR_ETH_CLK_SEL,
-	       syscfg + SYSCFG_PMCCLRR);
-	writel(value, syscfg + SYSCFG_PMCSETR);
+	/* Need to update PMCCLRR (clear register) */
+	regmap_write(regmap, pmcsetr->syscfg_clr_off, regmap_mask);
 
-	return 0;
+	ret = regmap_update_bits(regmap, SYSCFG_PMCSETR, regmap_mask, value);
+
+	return ret;
 }
 
 enum env_location env_get_location(enum env_operation op, int prio)
@@ -912,6 +1154,57 @@ int mmc_get_env_dev(void)
 }
 
 #if defined(CONFIG_OF_BOARD_SETUP)
+void stm32mp15x_dk2_fdt_update(void *new_blob)
+{
+	struct udevice *dev;
+	struct udevice *bus;
+	int nodeoff = 0;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC, DM_DRIVER_GET(edt_ft6236), &dev);
+	if (ret)
+		return;
+
+	bus = dev_get_parent(dev);
+
+	ret = dm_i2c_probe(bus, 0x38, 0, &dev);
+	if (ret < 0) {
+		nodeoff = fdt_node_offset_by_compatible(new_blob, -1, "focaltech,ft6236");
+		if (nodeoff < 0) {
+			log_warning("touchscreen@38 node not found\n");
+		} else {
+			fdt_set_name(new_blob, nodeoff, "touchscreen@2a");
+			fdt_setprop_u32(new_blob, nodeoff, "reg", 0x2a);
+			log_debug("touchscreen@38 node updated to @2a\n");
+		}
+	}
+}
+
+void fdt_update_panel_dsi(void *new_blob)
+{
+	char const *panel = env_get("panel-dsi");
+	int nodeoff = 0;
+
+	if (!panel)
+		return;
+
+	if (!strcmp(panel, "rocktech,hx8394")) {
+		nodeoff = fdt_node_offset_by_compatible(new_blob, -1, "raydium,rm68200");
+		if (nodeoff < 0) {
+			log_warning("panel-dsi node not found");
+			return;
+		}
+		fdt_setprop_string(new_blob, nodeoff, "compatible", panel);
+
+		nodeoff = fdt_node_offset_by_compatible(new_blob, -1, "goodix,gt9147");
+		if (nodeoff < 0) {
+			log_warning("touchscreen node not found");
+			return;
+		}
+		fdt_setprop_string(new_blob, nodeoff, "compatible", "goodix,gt911");
+	}
+}
+
 int ft_board_setup(void *blob, struct bd_info *bd)
 {
 	fdt_copy_fixed_partitions(blob);
@@ -919,10 +1212,106 @@ int ft_board_setup(void *blob, struct bd_info *bd)
 	if (IS_ENABLED(CONFIG_FDT_SIMPLEFB))
 		fdt_simplefb_enable_and_mem_rsv(blob);
 
+	if (board_is_stm32mp15x_dk2())
+		stm32mp15x_dk2_fdt_update(blob);
+
+	if (board_is_stm32mp15x_ev1())
+		fdt_update_panel_dsi(blob);
+
 	return 0;
 }
 #endif
 
+#if defined(CONFIG_OF_BOARD_FIXUP)
+
+int fdt_update_fwu_properties(void *blob, int nodeoff,
+			      const char *compat_str,
+			      const char *storage_path)
+{
+	int ret;
+	int storage_off;
+
+	ret = fdt_increase_size(blob, 100);
+	if (ret) {
+		printf("fdt_increase_size: err=%s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "compatible", compat_str);
+	if (ret) {
+		log_err("Can't set compatible property\n");
+		return ret;
+	}
+
+	storage_off = fdt_path_offset(blob, storage_path);
+	if (storage_off < 0) {
+		log_err("Can't find %s path\n", storage_path);
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "fwu-mdata-store", storage_path);
+
+	if (ret < 0)
+		log_err("Can't set fwu-mdata-store property\n");
+
+	return ret;
+}
+
+int fdt_update_fwu_mdata(void *blob)
+{
+	int nodeoff, ret = 0;
+	u32 bootmode;
+
+	nodeoff = fdt_path_offset(blob, "/fwu-mdata");
+	if (nodeoff < 0) {
+		log_info("no /fwu-mdata node ?\n");
+
+		return 0;
+	}
+
+	bootmode = get_bootmode() & TAMP_BOOT_DEVICE_MASK;
+
+	switch (bootmode) {
+	case BOOT_FLASH_SD:
+		/* sdmmc1 : nothing to do, already the default device tree configuration */
+		break;
+	case BOOT_FLASH_EMMC:
+		/* sdmmc2 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-gpt",
+						"/soc/mmc@58007000");
+		break;
+
+	case BOOT_FLASH_NAND:
+		/* nand@0 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-mtd",
+						"/soc/bus@5c007000/memory-controller@58002000/nand-controller@4,0/nand@0");
+		break;
+
+	case BOOT_FLASH_SPINAND:
+	case BOOT_FLASH_NOR:
+		/* flash0 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-mtd",
+						"/soc/bus@5c007000/spi@58003000/flash@0");
+		break;
+	default:
+		/* TF-A firmware update not supported for other boot device */
+		ret = fdt_del_node(blob, nodeoff);
+	}
+
+	return ret;
+}
+
+int board_fix_fdt(void *blob)
+{
+	int ret = 0;
+
+	if (CONFIG_IS_ENABLED(FWU_MDATA))
+		ret = fdt_update_fwu_mdata(blob);
+
+	return ret;
+}
+#endif /* CONFIG_OF_BOARD_FIXUP */
+
 static void board_copro_image_process(ulong fw_image, size_t fw_size)
 {
 	int ret, id = 0; /* Copro id fixed to 0 as only one coproc on mp1 */
diff --git a/board/st/stm32mp2/Kconfig b/board/st/stm32mp2/Kconfig
new file mode 100644
index 0000000000..49dc7d4b1c
--- /dev/null
+++ b/board/st/stm32mp2/Kconfig
@@ -0,0 +1,41 @@
+if TARGET_ST_STM32MP25X
+
+config SYS_BOARD
+	default "stm32mp2"
+
+config SYS_VENDOR
+	default "st"
+
+config SYS_CONFIG_NAME
+	default "stm32mp25_st_common"
+
+source "board/st/common/Kconfig"
+endif
+
+if TARGET_ST_STM32MP23X
+
+config SYS_BOARD
+	default "stm32mp2"
+
+config SYS_VENDOR
+	default "st"
+
+config SYS_CONFIG_NAME
+	default "stm32mp23_st_common"
+
+source "board/st/common/Kconfig"
+endif
+
+if TARGET_ST_STM32MP21X
+
+config SYS_BOARD
+	default "stm32mp2"
+
+config SYS_VENDOR
+	default "st"
+
+config SYS_CONFIG_NAME
+	default "stm32mp21_st_common"
+
+source "board/st/common/Kconfig"
+endif
diff --git a/board/st/stm32mp2/MAINTAINERS b/board/st/stm32mp2/MAINTAINERS
new file mode 100644
index 0000000000..8f624811f9
--- /dev/null
+++ b/board/st/stm32mp2/MAINTAINERS
@@ -0,0 +1,10 @@
+STM32MP2 BOARD
+M:	Patrice Chotard <patrice.chotard@st.com>
+M:	Patrick Delaunay <patrick.delaunay@st.com>
+L:	uboot-stm32@st-md-mailman.stormreply.com (moderated for non-subscribers)
+S:	Maintained
+F:	arch/arm/dts/stm32mp25*
+F:	board/st/stm32mp2/
+F:	configs/stm32mp25_defconfig
+F:	include/configs/stm32mp25_common.h
+F:	include/configs/stm32mp25_st_common.h
diff --git a/board/st/stm32mp2/Makefile b/board/st/stm32mp2/Makefile
new file mode 100644
index 0000000000..50352fb71b
--- /dev/null
+++ b/board/st/stm32mp2/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+#
+# Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+#
+
+obj-y += stm32mp2.o
diff --git a/board/st/stm32mp2/README b/board/st/stm32mp2/README
new file mode 100644
index 0000000000..b9ec3c965d
--- /dev/null
+++ b/board/st/stm32mp2/README
@@ -0,0 +1 @@
+see doc/board/st/stm32mp2.rst
diff --git a/board/st/stm32mp2/stm32mp2.c b/board/st/stm32mp2/stm32mp2.c
new file mode 100644
index 0000000000..a8b1cdfbaa
--- /dev/null
+++ b/board/st/stm32mp2/stm32mp2.c
@@ -0,0 +1,893 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_BOARD
+
+#include <common.h>
+#include <button.h>
+#include <config.h>
+#include <dm.h>
+#include <efi_loader.h>
+#include <env.h>
+#include <env_internal.h>
+#include <fdt_simplefb.h>
+#include <fdt_support.h>
+#include <g_dnl.h>
+#include <i2c.h>
+#include <led.h>
+#include <log.h>
+#include <misc.h>
+#include <mmc.h>
+#include <init.h>
+#include <net.h>
+#include <netdev.h>
+#include <phy.h>
+#include <regmap.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/global_data.h>
+#include <asm/gpio.h>
+#include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
+#include <dm/ofnode.h>
+#include <dm/uclass.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/iopoll.h>
+
+#define SYSCFG_ETHCR_ETH_SEL_MII	0
+#define SYSCFG_ETHCR_ETH_SEL_RGMII	BIT(4)
+#define SYSCFG_ETHCR_ETH_SEL_RMII	BIT(6)
+#define SYSCFG_ETHCR_ETH_CLK_SEL	BIT(1)
+#define SYSCFG_ETHCR_ETH_REF_CLK_SEL	BIT(0)
+/* CLOCK feed to PHY*/
+#define ETH_CK_F_25M	25000000
+#define ETH_CK_F_50M	50000000
+#define ETH_CK_F_125M	125000000
+
+#define ILITEK_REG_ID		0x40
+#define ILITEK_ID_LEN		7
+#define ADV7511_REG_CHIP_REVISION	0x00
+#define ADV7511_CHIP_REVISION_LEN	256
+
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+struct efi_fw_image fw_images[1];
+
+struct efi_capsule_update_info update_info = {
+	.num_images = ARRAY_SIZE(fw_images),
+	.images = fw_images,
+};
+
+u8 num_image_type_guids = ARRAY_SIZE(fw_images);
+#endif /* EFI_HAVE_CAPSULE_SUPPORT */
+
+/*
+ * Get a global data pointer
+ */
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	int ret;
+	u32 otp;
+	struct udevice *dev;
+	const char *fdt_compat;
+	int fdt_compat_len;
+
+	fdt_compat = ofnode_get_property(ofnode_root(), "compatible", &fdt_compat_len);
+
+	log_info("Board: stm32mp2 (%s)\n", fdt_compat && fdt_compat_len ? fdt_compat : "");
+
+	/* display the STMicroelectronics board identification */
+	if (CONFIG_IS_ENABLED(CMD_STBOARD)) {
+		ret = uclass_get_device_by_driver(UCLASS_MISC,
+						  DM_DRIVER_GET(stm32mp_bsec),
+						  &dev);
+		if (!ret)
+			ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_BOARD),
+					&otp, sizeof(otp));
+		if (ret > 0 && otp)
+			log_info("Board: MB%04x Var%d.%d Rev.%c-%02d\n",
+				 otp >> 16,
+				 (otp >> 12) & 0xF,
+				 (otp >> 4) & 0xF,
+				 ((otp >> 8) & 0xF) - 1 + 'A',
+				 otp & 0xF);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_GADGET_DOWNLOAD
+#define STM32MP1_G_DNL_DFU_PRODUCT_NUM 0xdf11
+#define STM32MP1_G_DNL_FASTBOOT_PRODUCT_NUM 0x0afb
+
+int g_dnl_bind_fixup(struct usb_device_descriptor *dev, const char *name)
+{
+	if (IS_ENABLED(CONFIG_DFU_OVER_USB) &&
+	    !strcmp(name, "usb_dnl_dfu"))
+		put_unaligned(STM32MP1_G_DNL_DFU_PRODUCT_NUM, &dev->idProduct);
+	else if (IS_ENABLED(CONFIG_FASTBOOT) &&
+		 !strcmp(name, "usb_dnl_fastboot"))
+		put_unaligned(STM32MP1_G_DNL_FASTBOOT_PRODUCT_NUM,
+			      &dev->idProduct);
+	else
+		put_unaligned(CONFIG_USB_GADGET_PRODUCT_NUM, &dev->idProduct);
+
+	return 0;
+}
+#endif /* CONFIG_USB_GADGET_DOWNLOAD */
+
+/* touchscreen driver: only used for pincontrol configuration */
+static const struct udevice_id touchscreen_ids[] = {
+	{ .compatible = "ilitek,ili251x", },
+	{ }
+};
+
+U_BOOT_DRIVER(touchscreen) = {
+	.name		= "touchscreen",
+	.id		= UCLASS_I2C_GENERIC,
+	.of_match	= touchscreen_ids,
+};
+
+static int i2c_read(ofnode node, u16 reg, u8 *buf, int len, uint wlen)
+{
+	ofnode bus_node;
+	struct udevice *dev;
+	struct udevice *bus;
+	struct i2c_msg msgs[2];
+	u32 chip_addr;
+	__be16 wbuf;
+	int ret;
+
+	/* parent should be an I2C bus */
+	bus_node = ofnode_get_parent(node);
+	ret = uclass_get_device_by_ofnode(UCLASS_I2C, bus_node, &bus);
+	if (ret) {
+		log_debug("can't find I2C bus for node %s\n", ofnode_get_name(bus_node));
+		return ret;
+	}
+
+	ret = ofnode_read_u32(node, "reg", &chip_addr);
+	if (ret) {
+		log_debug("can't read I2C address in %s\n", ofnode_get_name(node));
+		return ret;
+	}
+
+	ret = dm_i2c_probe(bus, chip_addr, 0, &dev);
+	if (ret)
+		return false;
+
+	if (wlen == 2)
+		wbuf = cpu_to_be16(reg);
+	else
+		wbuf = reg;
+
+	msgs[0].flags = 0;
+	msgs[0].addr  = chip_addr;
+	msgs[0].len   = wlen;
+	msgs[0].buf   = (u8 *)&wbuf;
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr  = chip_addr;
+	msgs[1].len   = len;
+	msgs[1].buf   = buf;
+
+	ret = dm_i2c_xfer(dev, msgs, 2);
+
+	return ret;
+}
+
+static bool reset_gpio(ofnode node)
+{
+	struct gpio_desc reset_gpio;
+
+	gpio_request_by_name_nodev(node, "reset-gpios", 0, &reset_gpio, GPIOD_IS_OUT);
+
+	if (!dm_gpio_is_valid(&reset_gpio))
+		return false;
+
+	dm_gpio_set_value(&reset_gpio, true);
+	mdelay(1);
+	dm_gpio_set_value(&reset_gpio, false);
+	mdelay(10);
+
+	dm_gpio_free(NULL, &reset_gpio);
+
+	return true;
+}
+
+/* HELPER: search detected driver */
+struct detect_info_t {
+	bool (*detect)(void);
+	char *compatible;
+};
+
+static const char *detect_device(const struct detect_info_t *info, u8 size)
+{
+	u8 i;
+
+	for (i = 0; i < size; i++) {
+		if (info[i].detect())
+			return info[i].compatible;
+	}
+
+	return NULL;
+}
+
+bool detect_stm32mp25x_etml0700zxxdha(void)
+{
+	ofnode node;
+	char id[ILITEK_ID_LEN];
+	int ret;
+
+	node = ofnode_by_compatible(ofnode_null(), "ilitek,ili251x");
+	if (!ofnode_valid(node))
+		return false;
+
+	if (!reset_gpio(node))
+		return false;
+
+	mdelay(200);
+
+	ret = i2c_read(node, ILITEK_REG_ID, id, sizeof(id), 1);
+	if (ret)
+		return false;
+
+	/* FW panel ID is starting at the 4th byte */
+	if (!strncmp(&id[4], "WSV", sizeof(id) - 4))
+		return true;
+
+	return false;
+}
+
+bool detect_stm32mp25x_adv753x(void)
+{
+	ofnode node;
+	char id[ADV7511_CHIP_REVISION_LEN];
+
+	node = ofnode_by_compatible(ofnode_null(),  "adi,adv7533");
+	if (!ofnode_valid(node)) {
+		node = ofnode_by_compatible(ofnode_null(),  "adi,adv7535");
+		if (!ofnode_valid(node))
+			return false;
+	}
+
+	if (!reset_gpio(node))
+		return false;
+
+	mdelay(10);
+
+	i2c_read(node, ADV7511_REG_CHIP_REVISION, id, sizeof(id), 1);
+
+	if (id[0] == 0x14)
+		return true;
+
+	return false;
+}
+
+static const struct detect_info_t stm32mp25x_panels[] = {
+	{
+		.detect = detect_stm32mp25x_etml0700zxxdha,
+		.compatible = "edt,etml0700z9ndha",
+	},
+};
+
+static const struct detect_info_t stm32mp25x_bridges[] = {
+	{
+		.detect = detect_stm32mp25x_adv753x,
+		.compatible = "adi,adv7533",
+	},
+	{
+		.detect = detect_stm32mp25x_adv753x,
+		.compatible = "adi,adv7535",
+	},
+};
+
+static void board_stm32mp25x_eval_init(void)
+{
+	const char *compatible;
+	struct udevice *dev;
+	ofnode node;
+
+	/* auto detection of connected panels */
+	compatible = detect_device(stm32mp25x_panels, ARRAY_SIZE(stm32mp25x_panels));
+
+	if (!compatible) {
+		/* remove the panel in environment */
+		env_set("panel", "");
+
+		/* no panel detected then unbind lvds to avoid a bad clock tree */
+		node = ofnode_by_compatible(ofnode_null(), "st,stm32mp25-lvds");
+		if (!ofnode_valid(node))
+			return;
+
+		device_find_global_by_ofnode(node, &dev);
+		device_remove(dev, DM_REMOVE_NORMAL);
+		device_unbind(dev);
+	} else {
+		/* save the detected compatible in environment */
+		env_set("panel", compatible);
+	}
+
+	/* auto detection of connected hdmi bridge */
+	compatible = detect_device(stm32mp25x_bridges, ARRAY_SIZE(stm32mp25x_bridges));
+
+	if (!compatible)
+		/* remove the hdmi bridge in environment */
+		env_set("hdmi", "");
+	else
+		/* save the detected compatible in environment */
+		env_set("hdmi", compatible);
+}
+
+static void board_stm32mp2xx_disco_init(void)
+{
+	const char *compatible;
+	struct udevice *dev;
+	ofnode node;
+
+	/* auto detection of connected panels */
+	compatible = detect_device(stm32mp25x_panels, ARRAY_SIZE(stm32mp25x_panels));
+
+	if (!compatible) {
+		/* remove the panel in environment */
+		env_set("panel", "");
+
+		/* no panel detected then unbind lvds to avoid a bad clock tree */
+		node = ofnode_by_compatible(ofnode_null(), "st,stm32mp25-lvds");
+		if (!ofnode_valid(node))
+			return;
+
+		device_find_global_by_ofnode(node, &dev);
+		device_remove(dev, DM_REMOVE_NORMAL);
+		device_unbind(dev);
+	} else {
+		/* save the detected compatible in environment */
+		env_set("panel", compatible);
+	}
+}
+
+static int get_led(struct udevice **dev, char *led_string)
+{
+	const char *led_name;
+	int ret;
+
+	led_name = ofnode_conf_read_str(led_string);
+	if (!led_name) {
+		log_debug("could not find %s config string\n", led_string);
+		return -ENOENT;
+	}
+	ret = led_get_by_label(led_name, dev);
+	if (ret) {
+		log_debug("get=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int setup_led(enum led_state_t cmd)
+{
+	struct udevice *dev;
+	int ret;
+
+	if (!CONFIG_IS_ENABLED(LED))
+		return 0;
+
+	ret = get_led(&dev, "u-boot,boot-led");
+	if (ret)
+		return ret;
+
+	ret = led_set_state(dev, cmd);
+	return ret;
+}
+
+static void check_user_button(void)
+{
+	struct udevice *button1 = NULL, *button2 = NULL;
+	enum forced_boot_mode boot_mode = BOOT_NORMAL;
+
+	if (!IS_ENABLED(CONFIG_BUTTON))
+		return;
+
+	if (!IS_ENABLED(CONFIG_FASTBOOT) && !IS_ENABLED(CONFIG_CMD_STM32PROG))
+		return;
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG))
+		button_get_by_label("User-1", &button1);
+
+	if (IS_ENABLED(CONFIG_FASTBOOT))
+		button_get_by_label("User-2", &button2);
+
+	if (!button1 && !button2)
+		return;
+
+	if (button1 && button_get_state(button1) == BUTTON_ON) {
+		log_notice("STM32Programmer key pressed, ");
+		boot_mode = BOOT_STM32PROG;
+	}
+
+	if (button2 && button_get_state(button2) == BUTTON_ON) {
+		log_notice("Fastboot key pressed, ");
+		boot_mode = BOOT_FASTBOOT;
+	}
+
+	if (boot_mode != BOOT_NORMAL) {
+		log_notice("entering download mode...\n");
+		clrsetbits_le32(TAMP_BOOT_CONTEXT, TAMP_BOOT_FORCED_MASK,
+				boot_mode);
+	}
+}
+
+static bool board_is_stm32mp257_eval(void)
+{
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP25X) &&
+	    (of_machine_is_compatible("st,stm32mp257f-ev1")))
+		return true;
+
+	return false;
+}
+
+static bool board_is_stm32mp235_disco(void)
+{
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP23X) &&
+	    (of_machine_is_compatible("st,stm32mp235f-dk")))
+		return true;
+
+	return false;
+}
+
+static bool board_is_stm32mp257_disco(void)
+{
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP25X) &&
+	    (of_machine_is_compatible("st,stm32mp257f-dk")))
+		return true;
+
+	return false;
+}
+
+/* board dependent setup after realloc */
+int board_init(void)
+{
+	setup_led(LEDST_ON);
+
+	check_user_button();
+
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+	efi_guid_t image_type_guid = STM32MP_FIP_IMAGE_GUID;
+
+	guidcpy(&fw_images[0].image_type_id, &image_type_guid);
+	fw_images[0].fw_name = u"STM32MP-FIP";
+	fw_images[0].image_index = 1;
+#endif
+
+	return 0;
+}
+
+/* eth init function : weak called in eqos driver */
+int board_interface_eth_init(struct udevice *dev,
+			     phy_interface_t interface_type, ulong rate)
+{
+	struct regmap *regmap;
+	uint regmap_mask, regmap_offset;
+	int ret;
+	u32 value;
+	bool ext_phyclk;
+
+	/* Ethernet PHY have no cristal or need to be clock by RCC */
+	ext_phyclk = dev_read_bool(dev, "st,ext-phyclk");
+
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscon");
+
+	if (!IS_ERR(regmap)) {
+		u32 fmp[3];
+
+		ret = dev_read_u32_array(dev, "st,syscon", fmp, 3);
+		if (ret) {
+			pr_err("%s: Need to specify Offset and Mask of syscon register\n", __func__);
+			return ret;
+		}
+		else {
+			regmap_mask = fmp[2];
+			regmap_offset = fmp[1];
+		}
+	} else {
+		return -ENODEV;
+	}
+	switch (interface_type) {
+	case PHY_INTERFACE_MODE_MII:
+		value = SYSCFG_ETHCR_ETH_SEL_MII;
+		debug("%s: PHY_INTERFACE_MODE_MII\n", __func__);
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		if (rate == ETH_CK_F_50M && ext_phyclk)
+			value = SYSCFG_ETHCR_ETH_SEL_RMII |
+				SYSCFG_ETHCR_ETH_REF_CLK_SEL;
+		else
+			value = SYSCFG_ETHCR_ETH_SEL_RMII;
+		debug("%s: PHY_INTERFACE_MODE_RMII\n", __func__);
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		if (rate == ETH_CK_F_125M && ext_phyclk)
+			value = SYSCFG_ETHCR_ETH_SEL_RGMII |
+				SYSCFG_ETHCR_ETH_CLK_SEL;
+		else
+			value = SYSCFG_ETHCR_ETH_SEL_RGMII;
+		debug("%s: PHY_INTERFACE_MODE_RGMII\n", __func__);
+		break;
+	default:
+		debug("%s: Do not manage %d interface\n",
+		      __func__, interface_type);
+		/* Do not manage others interfaces */
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(regmap, regmap_offset, regmap_mask, value);
+
+	return ret;
+}
+
+enum env_location env_get_location(enum env_operation op, int prio)
+{
+	u32 bootmode = get_bootmode();
+
+	if (prio)
+		return ENVL_UNKNOWN;
+
+	switch (bootmode & TAMP_BOOT_DEVICE_MASK) {
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_MMC))
+			return ENVL_MMC;
+		else
+			return ENVL_NOWHERE;
+
+	case BOOT_FLASH_NAND:
+	case BOOT_FLASH_SPINAND:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_UBI))
+			return ENVL_UBI;
+		else
+			return ENVL_NOWHERE;
+
+	case BOOT_FLASH_NOR:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_SPI_FLASH))
+			return ENVL_SPI_FLASH;
+		else
+			return ENVL_NOWHERE;
+
+	case BOOT_FLASH_HYPERFLASH:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_FLASH))
+			return ENVL_FLASH;
+		else
+			return ENVL_NOWHERE;
+
+	default:
+		return ENVL_NOWHERE;
+	}
+}
+
+int mmc_get_boot(void)
+{
+	struct udevice *dev;
+	u32 boot_mode = get_bootmode();
+	unsigned int instance = (boot_mode & TAMP_BOOT_INSTANCE_MASK) - 1;
+	char cmd[20];
+	const u32 sdmmc_addr[] = {
+		STM32_SDMMC1_BASE,
+		STM32_SDMMC2_BASE,
+		STM32_SDMMC3_BASE
+	};
+
+	if (instance > ARRAY_SIZE(sdmmc_addr))
+		return 0;
+
+	/* search associated sdmmc node in devicetree */
+	snprintf(cmd, sizeof(cmd), "mmc@%x", sdmmc_addr[instance]);
+	if (uclass_get_device_by_name(UCLASS_MMC, cmd, &dev)) {
+		log_err("mmc%d = %s not found in device tree!\n", instance, cmd);
+		return 0;
+	}
+
+	return dev_seq(dev);
+};
+
+int mmc_get_env_dev(void)
+{
+	const int mmc_env_dev = CONFIG_IS_ENABLED(ENV_IS_IN_MMC, (CONFIG_SYS_MMC_ENV_DEV), (-1));
+
+	if (mmc_env_dev >= 0)
+		return mmc_env_dev;
+
+	/* use boot instance to select the correct mmc device identifier */
+	return mmc_get_boot();
+}
+
+int board_late_init(void)
+{
+	const void *fdt_compat;
+	int fdt_compat_len;
+	char dtb_name[256];
+	int buf_len;
+
+	if (board_is_stm32mp257_eval())
+		board_stm32mp25x_eval_init();
+
+	if (board_is_stm32mp257_disco() | board_is_stm32mp235_disco())
+		board_stm32mp2xx_disco_init();
+
+	if (IS_ENABLED(CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG)) {
+		fdt_compat = fdt_getprop(gd->fdt_blob, 0, "compatible",
+					 &fdt_compat_len);
+		if (fdt_compat && fdt_compat_len) {
+			if (strncmp(fdt_compat, "st,", 3) != 0) {
+				env_set("board_name", fdt_compat);
+			} else {
+				env_set("board_name", fdt_compat + 3);
+
+				buf_len = sizeof(dtb_name);
+				strlcpy(dtb_name, fdt_compat + 3, buf_len);
+				buf_len -= strlen(fdt_compat + 3);
+				strlcat(dtb_name, ".dtb", buf_len);
+				env_set("fdtfile", dtb_name);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int fixup_stm32mp257_eval_panel(void *blob)
+{
+	char const *panel = env_get("panel");
+	char const *hdmi = env_get("hdmi");
+	bool detect_etml0700z9ndha = false;
+	bool detect_adv753x = false;
+	int nodeoff = 0, ret;
+	enum fdt_status status;
+
+	if (panel)
+		detect_etml0700z9ndha = !strcmp(panel, "edt,etml0700z9ndha");
+
+	if (hdmi)
+		/* string compare the hdmi compatible limit to 10 chars (adi,adv753) */
+		detect_adv753x = !strncmp(hdmi, "adi,adv753x", 10);
+
+	/* update LVDS panel "edt,etml0700z9ndha" */
+	status = detect_etml0700z9ndha ? FDT_STATUS_OKAY : FDT_STATUS_DISABLED;
+	nodeoff = fdt_set_status_by_compatible(blob, "edt,etml0700z9ndha", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "ilitek,ili251x", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_pathf(blob, status, "/panel-lvds-backlight");
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "st,stm32mp25-lvds", status);
+	if (nodeoff < 0)
+		return nodeoff;
+
+	/* update HDMI bridge "adi,adv753x" */
+	status = detect_adv753x ? FDT_STATUS_OKAY : FDT_STATUS_DISABLED;
+	nodeoff = fdt_set_status_by_compatible(blob, "adi,adv7533", status);
+	if (nodeoff < 0)
+		nodeoff = fdt_set_status_by_compatible(blob, "adi,adv7535", status);
+	/* Do not force disable status for sound card. Keep default status instead */
+	if (status == FDT_STATUS_OKAY) {
+		if (nodeoff < 0)
+			return nodeoff;
+		nodeoff = fdt_node_offset_by_compat_reg(blob, "st,stm32mp25-i2s", 0x400b0000);
+		if (nodeoff < 0)
+			return nodeoff;
+		ret = fdt_set_node_status(blob, nodeoff, status);
+		if (ret < 0)
+			return ret;
+		nodeoff = fdt_set_status_by_pathf(blob, status, "/sound");
+		if (nodeoff < 0)
+			return nodeoff;
+		nodeoff = fdt_status_okay_by_compatible(blob, "st,stm32mp25-dsi");
+		if (nodeoff < 0)
+			return nodeoff;
+	}
+
+	if (!detect_adv753x && !detect_etml0700z9ndha) {
+		nodeoff = fdt_status_disabled_by_compatible(blob, "st,stm32mp25-ltdc");
+		if (nodeoff < 0)
+			return nodeoff;
+	}
+
+	return 0;
+}
+
+static int fixup_stm32mp2xx_disco_panel(void *blob)
+{
+	char const *panel = env_get("panel");
+	bool detect_etml0700z9ndha = false;
+	int nodeoff = 0;
+	enum fdt_status status;
+
+	if (panel)
+		detect_etml0700z9ndha = !strcmp(panel, "edt,etml0700z9ndha");
+
+	/* update LVDS panel "edt,etml0700z9ndha" */
+	status = detect_etml0700z9ndha ? FDT_STATUS_OKAY : FDT_STATUS_DISABLED;
+	nodeoff = fdt_set_status_by_compatible(blob, "edt,etml0700z9ndha", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "ilitek,ili251x", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_pathf(blob, status, "/panel-lvds-backlight");
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "st,stm32mp25-lvds", status);
+	if (nodeoff < 0)
+		return nodeoff;
+
+	return 0;
+}
+
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	int ret;
+
+	fdt_copy_fixed_partitions(blob);
+
+	if (CONFIG_IS_ENABLED(FDT_SIMPLEFB))
+		fdt_simplefb_enable_and_mem_rsv(blob);
+
+	if (board_is_stm32mp257_eval()) {
+		ret = fixup_stm32mp257_eval_panel(blob);
+		if (ret)
+			log_err("Error during panel fixup ! (%d)\n", ret);
+	}
+
+	if (board_is_stm32mp257_disco() | board_is_stm32mp235_disco()) {
+		ret = fixup_stm32mp2xx_disco_panel(blob);
+		if (ret)
+			log_err("Error during panel fixup ! (%d)\n", ret);
+	}
+
+	return 0;
+}
+
+void board_quiesce_devices(void)
+{
+	setup_led(LEDST_OFF);
+}
+
+#if defined(CONFIG_USB_DWC3) && defined(CONFIG_CMD_STM32PROG_USB)
+#include <dfu.h>
+/*
+ * TEMP: force USB BUS reset forced to false, because it is not supported
+ *       in DWC3 USB driver
+ * avoid USB bus reset support in DFU stack is required to reenumeration in
+ * stm32prog command after flashlayout load or after "dfu-util -e -R"
+ */
+bool dfu_usb_get_reset(void)
+{
+	return false;
+}
+#endif
+
+#if defined(CONFIG_STM32_HYPERBUS)
+/* weak function called from common/board_r.c */
+int is_flash_available(void)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MTD,
+					  DM_DRIVER_GET(stm32_hyperbus),
+					  &dev);
+	if (ret)
+		return 0;
+
+	return 1;
+}
+#endif
+
+/* weak function called from env/sf.c */
+void *env_sf_get_env_addr(void)
+{
+	return NULL;
+}
+
+#if defined(CONFIG_OF_BOARD_FIXUP)
+
+#if defined(CONFIG_STM32MP21X)
+#define SPINAND_NOR_PATH "/soc@0/spi@40430000/flash@0"
+#else
+#define SPINAND_NOR_PATH "/soc@0/ommanager@40500000/spi@40430000/flash@0"
+#endif
+
+int fdt_update_fwu_properties(void *blob, int nodeoff,
+			      const char *compat_str,
+			      const char *storage_path)
+{
+	int ret;
+	int storage_off;
+
+	ret = fdt_increase_size(blob, 100);
+	if (ret) {
+		printf("fdt_increase_size: err=%s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "compatible", compat_str);
+	if (ret) {
+		log_err("Can't set compatible property\n");
+		return ret;
+	}
+
+	storage_off = fdt_path_offset(blob, storage_path);
+	if (storage_off < 0) {
+		log_err("Can't find %s path\n", storage_path);
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "fwu-mdata-store", storage_path);
+
+	if (ret < 0)
+		log_err("Can't set fwu-mdata-store property\n");
+
+	return ret;
+}
+
+int fdt_update_fwu_mdata(void *blob)
+{
+	int nodeoff, ret = 0;
+	u32 bootmode;
+
+	nodeoff = fdt_path_offset(blob, "/fwu-mdata");
+	if (nodeoff < 0) {
+		log_info("no /fwu-mdata node ?\n");
+
+		return 0;
+	}
+
+	bootmode = get_bootmode() & TAMP_BOOT_DEVICE_MASK;
+
+	switch (bootmode) {
+	case BOOT_FLASH_SD:
+		/* sdmmc1 : nothing to do, already the default device tree configuration */
+		break;
+	case BOOT_FLASH_EMMC:
+		/* sdmmc2 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-gpt",
+						"/soc@0/bus@42080000/mmc@48230000");
+		break;
+
+	case BOOT_FLASH_SPINAND:
+	case BOOT_FLASH_NOR:
+		/* flash0 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-mtd",
+						SPINAND_NOR_PATH);
+		break;
+	default:
+		/* TF-A firmware update not supported for other boot device */
+		ret = fdt_del_node(blob, nodeoff);
+	}
+
+	return ret;
+}
+
+int board_fix_fdt(void *blob)
+{
+	int ret = 0;
+
+	if (CONFIG_IS_ENABLED(FWU_MDATA))
+		ret = fdt_update_fwu_mdata(blob);
+
+	return ret;
+}
+#endif /* CONFIG_OF_BOARD_FIXUP */
+
diff --git a/cmd/clk.c b/cmd/clk.c
index ff7c7649a1..a12b8d2ac6 100644
--- a/cmd/clk.c
+++ b/cmd/clk.c
@@ -29,7 +29,7 @@ static void show_clks(struct udevice *dev, int depth, int last_flag)
 		depth++;
 		rate = clk_get_rate(clkp);
 
-		printf(" %-12u  %8d        ", rate, clkp->enable_count);
+		printf(" %-12u  %8lx  %8d        ", rate, clkp->id, clkp->enable_count);
 
 		for (i = depth; i >= 0; i--) {
 			is_last = (last_flag >> i) & 1;
@@ -63,8 +63,8 @@ int __weak soc_clk_dump(void)
 {
 	struct udevice *dev;
 
-	printf(" Rate               Usecnt      Name\n");
-	printf("------------------------------------------\n");
+	printf(" Rate             Id          Usecnt      Name\n");
+	printf("--------------------------------------------------\n");
 
 	uclass_foreach_dev_probe(UCLASS_CLK, dev)
 		show_clks(dev, -1, 0);
diff --git a/cmd/fwu_mdata.c b/cmd/fwu_mdata.c
index 5ecda455df..3c8be576ac 100644
--- a/cmd/fwu_mdata.c
+++ b/cmd/fwu_mdata.c
@@ -13,27 +13,33 @@
 
 #include <linux/types.h>
 
-static void print_mdata(struct fwu_mdata *mdata)
+static void print_mdata(struct fwu_data *data)
 {
 	int i, j;
 	struct fwu_image_entry *img_entry;
 	struct fwu_image_bank_info *img_info;
 
 	printf("\tFWU Metadata\n");
-	printf("crc32: %#x\n", mdata->crc32);
-	printf("version: %#x\n", mdata->version);
-	printf("active_index: %#x\n", mdata->active_index);
-	printf("previous_active_index: %#x\n", mdata->previous_active_index);
+	printf("crc32: %#x\n", data->crc32);
+	printf("version: %#x\n", data->version);
+	printf("active_index: %#x\n", data->active_index);
+	printf("previous_active_index: %#x\n", data->previous_active_index);
+
+	if (data->version == 2) {
+		for (i = 0; i < 4; i++)
+			printf("bank_state[%d]: %#x\n",
+			       i, data->bank_state[i]);
+	}
 
 	printf("\tImage Info\n");
 	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
-		img_entry = &mdata->img_entry[i];
+		img_entry = &data->fwu_images[i];
 		printf("\nImage Type Guid: %pUL\n",
-		       &img_entry->image_type_uuid);
-		printf("Location Guid: %pUL\n", &img_entry->location_uuid);
+		       &img_entry->image_type_guid);
+		printf("Location Guid: %pUL\n", &img_entry->location_guid);
 		for (j = 0; j < CONFIG_FWU_NUM_BANKS; j++) {
 			img_info = &img_entry->img_bank_info[j];
-			printf("Image Guid:  %pUL\n", &img_info->image_uuid);
+			printf("Image Guid:  %pUL\n", &img_info->image_guid);
 			printf("Image Acceptance: %s\n",
 			       img_info->accepted == 0x1 ? "yes" : "no");
 		}
@@ -43,20 +49,11 @@ static void print_mdata(struct fwu_mdata *mdata)
 int do_fwu_mdata_read(struct cmd_tbl *cmdtp, int flag,
 		     int argc, char * const argv[])
 {
-	int ret = CMD_RET_SUCCESS, res;
-	struct fwu_mdata mdata;
-
-	res = fwu_get_mdata(&mdata);
-	if (res < 0) {
-		log_err("Unable to get valid FWU metadata\n");
-		ret = CMD_RET_FAILURE;
-		goto out;
-	}
+	struct fwu_data *data = fwu_get_data();
 
-	print_mdata(&mdata);
+	print_mdata(data);
 
-out:
-	return ret;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/legacy-mtd-utils.c b/cmd/legacy-mtd-utils.c
index 5903a90fe5..cdf73b2945 100644
--- a/cmd/legacy-mtd-utils.c
+++ b/cmd/legacy-mtd-utils.c
@@ -1,44 +1,66 @@
 // SPDX-License-Identifier: GPL-2.0+
 
 #include <common.h>
-#include <jffs2/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/string.h>
 #include <mtd.h>
 
-static int get_part(const char *partname, int *idx, loff_t *off, loff_t *size,
-	     loff_t *maxsize, int devtype)
+/* mapping between legacy parameter and MTD device type */
+bool check_devtype(int devtype, u_char mtdtype)
 {
-#ifdef CONFIG_CMD_MTDPARTS
-	struct mtd_device *dev;
-	struct part_info *part;
-	u8 pnum;
-	int ret;
+	if (devtype == MTD_DEV_TYPE_NOR && mtdtype == MTD_NORFLASH)
+		return true;
 
-	ret = mtdparts_init();
-	if (ret)
-		return ret;
+	if ((devtype == MTD_DEV_TYPE_NAND || devtype == MTD_DEV_TYPE_ONENAND) &&
+	    (mtdtype == MTD_NANDFLASH || mtdtype == MTD_NANDFLASH))
+		return true;
+
+	return false;
+}
 
-	ret = find_dev_and_part(partname, &dev, &pnum, &part);
-	if (ret)
-		return ret;
 
-	if (dev->id->type != devtype) {
-		printf("not same typ %d != %d\n", dev->id->type, devtype);
+static int get_part(const char *partname, int *idx, loff_t *off, loff_t *size,
+		    loff_t *maxsize, int devtype)
+{
+	struct mtd_info *mtd;
+	struct mtd_info *partition;
+	bool part_found = false;
+	int part_num;
+
+	if (!IS_ENABLED(CONFIG_MTD)) {
+		puts("mtd support missing.\n");
 		return -1;
 	}
+	/* register partitions with MTDIDS/MTDPARTS or OF fallback */
+	mtd_probe_devices();
+
+	mtd_for_each_device(mtd) {
+		printf("%s:%d(%d, %s)\n", __func__, __LINE__, mtd->type, mtd->name);
+		if (mtd_is_partition(mtd) &&
+		    check_devtype(devtype, mtd->type) &&
+		    (!strcmp(partname, mtd->name))) {
+			part_found = true;
+			break;
+		}
+	}
+	if (!part_found)
+		return -1;
+
+	*off = mtd->offset;
+	*size = mtd->size;
+	*maxsize = mtd->size;
 
-	*off = part->offset;
-	*size = part->size;
-	*maxsize = part->size;
-	*idx = dev->id->num;
+	/* loop on partition list as index is not accessbile in MTD */
+	part_num = 0;
+	list_for_each_entry(partition, &mtd->parent->partitions, node) {
+		part_num++;
+		if (partition == mtd)
+			break;
+	}
 
+	*idx = part_num;
 	return 0;
-#else
-	puts("mtdparts support missing.\n");
-	return -1;
-#endif
 }
 
 int mtd_arg_off(const char *arg, int *idx, loff_t *off, loff_t *size,
diff --git a/cmd/mtdparts.c b/cmd/mtdparts.c
index 0984158f41..792229d762 100644
--- a/cmd/mtdparts.c
+++ b/cmd/mtdparts.c
@@ -75,11 +75,13 @@
 #include <env.h>
 #include <log.h>
 #include <malloc.h>
+#include <mtd.h>
 #include <asm/global_data.h>
 #include <jffs2/load_kernel.h>
 #include <linux/list.h>
 #include <linux/ctype.h>
 #include <linux/err.h>
+#include <linux/sizes.h>
 #include <linux/mtd/mtd.h>
 
 #if defined(CONFIG_CMD_NAND)
@@ -128,6 +130,10 @@ extern void board_mtdparts_default(const char **mtdids, const char **mtdparts);
 static const char *mtdids_default = MTDIDS_DEFAULT;
 static const char *mtdparts_default = MTDPARTS_DEFAULT;
 
+/* default 'mtdids' and 'mtdparts' build from device tree */
+static char *mtdids_dyn;
+static char *mtdparts_dyn;
+
 /* copies of last seen 'mtdids', 'mtdparts' and 'partition' env variables */
 #define MTDIDS_MAXLEN		128
 #define MTDPARTS_MAXLEN		512
@@ -1322,8 +1328,9 @@ static void list_partitions(void)
 	}
 
 	printf("\ndefaults:\n");
-	printf("mtdids  : %s\n",
-		mtdids_default ? mtdids_default : "none");
+	printf("mtdids  : %s%s\n",
+	       mtdids_default ? mtdids_default : "none",
+	       mtdids_default == mtdids_dyn ? "(build from DT)" : "");
 	/*
 	 * Using printf() here results in printbuffer overflow
 	 * if default mtdparts string is greater than console
@@ -1331,7 +1338,7 @@ static void list_partitions(void)
 	 */
 	puts("mtdparts: ");
 	puts(mtdparts_default ? mtdparts_default : "none");
-	puts("\n");
+	puts(mtdparts_default == mtdparts_dyn ? "(build from DT)\n" : "\n");
 }
 
 /**
@@ -1710,6 +1717,55 @@ static int parse_mtdids(const char *const ids)
 	return 0;
 }
 
+/*
+ * update the variables "mtdids" and "mtdparts" for MTD device
+ */
+static void mtdparts_default_build(struct mtd_info *mtd, char *mtdids, char *mtdparts)
+{
+	struct mtd_info *part;
+	char multiplier = 'b';
+	u32 size;
+	char partition[PARTITION_MAXLEN + 20]; /* name + size + mutiliplier */
+	bool first_part;
+
+	/* mtdids: "<dev>=<dev>, ...." */
+	if (mtdids[0] != '\0')
+		strcat(mtdids, ",");
+	strcat(mtdids, mtd->name);
+	strcat(mtdids, "=");
+	strcat(mtdids, mtd->name);
+
+	/* mtdparts: "<dev>:<part1>,<part2>...,<partN>;..." */
+	if (mtdparts[0] != '\0')
+		strlcat(mtdparts, ";", MTDPARTS_MAXLEN);
+
+	strlcat(mtdparts, mtd->name, MTDPARTS_MAXLEN);
+	strlcat(mtdparts, ":", MTDPARTS_MAXLEN);
+
+	first_part = true;
+	list_for_each_entry(part, &mtd->partitions, node) {
+		if (!(part->size % SZ_1G)) {
+			size = (u32)(part->size / SZ_1G);
+			multiplier = 'g';
+		} else if (!(part->size % SZ_1M)) {
+			size = (u32)(part->size / SZ_1M);
+			multiplier = 'm';
+		} else if (!(part->size % SZ_1K)) {
+			size = (u32)(part->size / SZ_1K);
+			multiplier = 'k';
+		} else {
+			size = (u32)part->size;
+		}
+		snprintf(partition, sizeof(partition), "%d%c(%s)", size, multiplier, part->name);
+
+		if (first_part)
+			first_part = false;
+		else
+			strlcat(mtdparts, ",", MTDPARTS_MAXLEN);
+
+		strlcat(mtdparts, partition, MTDPARTS_MAXLEN);
+	}
+}
 
 /**
  * Parse and initialize global mtdids mapping and create global
@@ -1738,6 +1794,34 @@ int mtdparts_init(void)
 #endif
 		use_defaults = 1;
 		initialized = 1;
+
+		if ((!mtdids_default || !strlen(mtdids_default)) &&
+		    (!mtdparts_default || !strlen(mtdparts_default))) {
+			struct mtd_info *mtd;
+
+			mtdids_dyn = malloc(MTDIDS_MAXLEN);
+			mtdparts_dyn = malloc(MTDPARTS_MAXLEN);
+			if (!mtdids_dyn || !mtdparts_dyn) {
+				free(mtdparts_dyn);
+				printf("out of memory\n");
+				return 1;
+			}
+
+			/* used new default */
+			mtdids_dyn[0] = '\0';
+			mtdparts_dyn[0] = '\0';
+			mtdids_default = mtdids_dyn;
+			mtdparts_default = mtdparts_dyn;
+
+			/* register partitions with OF fallback */
+			mtd_probe_devices();
+
+			/* build default variable value with MTD partitions */
+			mtd_for_each_device(mtd) {
+				if (!mtd_is_partition(mtd) && mtd_has_partitions(mtd))
+					mtdparts_default_build(mtd, mtdids_dyn, mtdparts_dyn);
+			}
+		}
 	}
 
 	/* get variables */
diff --git a/common/console.c b/common/console.c
index 98c3ee6ca6..748900ac41 100644
--- a/common/console.c
+++ b/common/console.c
@@ -1010,9 +1010,16 @@ int console_init_f(void)
 	return 0;
 }
 
+static char *get_stdio(const u8 std)
+{
+	return stdio_devices[std] ? stdio_devices[std]->name : "No devices available!";
+}
+
 static void stdio_print_current_devices(void)
 {
-	char *stdinname, *stdoutname, *stderrname;
+	char *stdinname = NULL;
+	char *stdoutname = NULL;
+	char *stderrname = NULL;
 
 	if (CONFIG_IS_ENABLED(CONSOLE_MUX) &&
 	    CONFIG_IS_ENABLED(SYS_CONSOLE_IS_IN_ENV)) {
@@ -1020,22 +1027,12 @@ static void stdio_print_current_devices(void)
 		stdinname  = env_get("stdin");
 		stdoutname = env_get("stdout");
 		stderrname = env_get("stderr");
-
-		stdinname = stdinname ? : "No input devices available!";
-		stdoutname = stdoutname ? : "No output devices available!";
-		stderrname = stderrname ? : "No error devices available!";
-	} else {
-		stdinname = stdio_devices[stdin] ?
-			stdio_devices[stdin]->name :
-			"No input devices available!";
-		stdoutname = stdio_devices[stdout] ?
-			stdio_devices[stdout]->name :
-			"No output devices available!";
-		stderrname = stdio_devices[stderr] ?
-			stdio_devices[stderr]->name :
-			"No error devices available!";
 	}
 
+	stdinname = stdinname ? : get_stdio(stdin);
+	stdoutname = stdoutname ? : get_stdio(stdout);
+	stderrname = stderrname ? : get_stdio(stderr);
+
 	/* Print information */
 	puts("In:    ");
 	printf("%s\n", stdinname);
diff --git a/common/fdt_support.c b/common/fdt_support.c
index 5e49078f8c..c656b24344 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -1054,9 +1054,10 @@ void fdt_fixup_mtdparts(void *blob, const struct node_info *node_info,
 int fdt_copy_fixed_partitions(void *blob)
 {
 	ofnode node, subnode;
+	const u32 *reg;
 	int off, suboff, res;
 	char path[256];
-	int address_cells, size_cells;
+	int address_cells, size_cells, len;
 	u8 i, j, child_count;
 
 	node = ofnode_by_compatible(ofnode_null(), "fixed-partitions");
@@ -1102,9 +1103,6 @@ int fdt_copy_fixed_partitions(void *blob)
 			if (!ofnode_valid(subnode))
 				break;
 
-			const u32 *reg;
-			int len;
-
 			suboff = fdt_find_or_add_subnode(blob, off, ofnode_get_name(subnode));
 			res = fdt_setprop_string(blob, suboff, "label",
 						 ofnode_read_string(subnode, "label"));
diff --git a/common/usb_onboard_hub.c b/common/usb_onboard_hub.c
index 89e18a2dda..8a83f7877e 100644
--- a/common/usb_onboard_hub.c
+++ b/common/usb_onboard_hub.c
@@ -34,18 +34,6 @@ static int usb_onboard_hub_probe(struct udevice *dev)
 	return ret;
 }
 
-static int usb_onboard_hub_remove(struct udevice *dev)
-{
-	struct onboard_hub *hub = dev_get_priv(dev);
-	int ret;
-
-	ret = regulator_set_enable_if_allowed(hub->vdd, false);
-	if (ret)
-		dev_err(dev, "can't disable vdd-supply: %d\n", ret);
-
-	return ret;
-}
-
 static const struct udevice_id usb_onboard_hub_ids[] = {
 	/* Use generic usbVID,PID dt-bindings (usb-device.yaml) */
 	{ .compatible = "usb424,2514" }, /* USB2514B USB 2.0 */
@@ -56,7 +44,6 @@ U_BOOT_DRIVER(usb_onboard_hub) = {
 	.name	= "usb_onboard_hub",
 	.id	= UCLASS_USB_HUB,
 	.probe = usb_onboard_hub_probe,
-	.remove = usb_onboard_hub_remove,
 	.of_match = usb_onboard_hub_ids,
 	.priv_auto = sizeof(struct onboard_hub),
 };
diff --git a/configs/corstone1000_defconfig b/configs/corstone1000_defconfig
index 074936d575..9fe907fed0 100644
--- a/configs/corstone1000_defconfig
+++ b/configs/corstone1000_defconfig
@@ -60,6 +60,8 @@ CONFIG_OPTEE=y
 CONFIG_USB=y
 CONFIG_USB_ISP1760=y
 CONFIG_ERRNO_STR=y
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V1=y
 CONFIG_EFI_MM_COMM_TEE=y
 CONFIG_FFA_SHARED_MM_BUF_SIZE=4096
 CONFIG_FFA_SHARED_MM_BUF_OFFSET=0
diff --git a/configs/sandbox64_defconfig b/configs/sandbox64_defconfig
index 138a99b37f..b9e10b2c9b 100644
--- a/configs/sandbox64_defconfig
+++ b/configs/sandbox64_defconfig
@@ -267,6 +267,7 @@ CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
 CONFIG_EFI_SECURE_BOOT=y
 CONFIG_TEST_FDTDEC=y
 CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V1=y
 CONFIG_UNIT_TEST=y
 CONFIG_UT_TIME=y
 CONFIG_UT_DM=y
diff --git a/configs/stm32f746-disco_defconfig b/configs/stm32f746-disco_defconfig
index 1fb30d8ad6..3c3a0d25d4 100644
--- a/configs/stm32f746-disco_defconfig
+++ b/configs/stm32f746-disco_defconfig
@@ -56,13 +56,13 @@ CONFIG_SPI=y
 CONFIG_DM_SPI=y
 CONFIG_STM32_QSPI=y
 CONFIG_VIDEO=y
+CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_MAX_XRES=480
-CONFIG_VIDEO_STM32_MAX_YRES=640
+CONFIG_VIDEO_STM32_MAX_YRES=272
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
-CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
diff --git a/configs/stm32f746-disco_spl_defconfig b/configs/stm32f746-disco_spl_defconfig
index 25ea254507..1b8b5a17b7 100644
--- a/configs/stm32f746-disco_spl_defconfig
+++ b/configs/stm32f746-disco_spl_defconfig
@@ -82,13 +82,13 @@ CONFIG_DM_SPI=y
 CONFIG_STM32_QSPI=y
 CONFIG_SPL_TIMER=y
 CONFIG_VIDEO=y
+CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_MAX_XRES=480
-CONFIG_VIDEO_STM32_MAX_YRES=640
+CONFIG_VIDEO_STM32_MAX_YRES=272
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
-CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
diff --git a/configs/stm32f769-disco_defconfig b/configs/stm32f769-disco_defconfig
index a92032dc78..3514a78bb8 100644
--- a/configs/stm32f769-disco_defconfig
+++ b/configs/stm32f769-disco_defconfig
@@ -56,6 +56,7 @@ CONFIG_SPI=y
 CONFIG_DM_SPI=y
 CONFIG_STM32_QSPI=y
 CONFIG_VIDEO=y
+CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_STM32=y
@@ -64,7 +65,6 @@ CONFIG_VIDEO_STM32_MAX_XRES=480
 CONFIG_VIDEO_STM32_MAX_YRES=800
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
-CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
diff --git a/configs/stm32f769-disco_spl_defconfig b/configs/stm32f769-disco_spl_defconfig
index deb7963fcc..9b926b2218 100644
--- a/configs/stm32f769-disco_spl_defconfig
+++ b/configs/stm32f769-disco_spl_defconfig
@@ -82,6 +82,7 @@ CONFIG_DM_SPI=y
 CONFIG_STM32_QSPI=y
 CONFIG_SPL_TIMER=y
 CONFIG_VIDEO=y
+CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_STM32=y
@@ -90,7 +91,6 @@ CONFIG_VIDEO_STM32_MAX_XRES=480
 CONFIG_VIDEO_STM32_MAX_YRES=800
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
-CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
diff --git a/configs/stm32mp13_defconfig b/configs/stm32mp13_defconfig
index 4e837533dc..830dfff653 100644
--- a/configs/stm32mp13_defconfig
+++ b/configs/stm32mp13_defconfig
@@ -1,37 +1,54 @@
 CONFIG_ARM=y
+CONFIG_SYS_HAS_NONCACHED_MEMORY=y
 CONFIG_ARCH_STM32MP=y
 CONFIG_TFABOOT=y
 CONFIG_SYS_MALLOC_F_LEN=0x180000
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0400000
 CONFIG_ENV_OFFSET=0x900000
+CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp135f-dk"
-CONFIG_STM32MP13x=y
+CONFIG_STM32MP13X=y
 CONFIG_DDR_CACHEABLE_SIZE=0x8000000
 CONFIG_CMD_STM32KEY=y
-CONFIG_TARGET_ST_STM32MP13x=y
+CONFIG_TARGET_ST_STM32MP13X=y
 CONFIG_ENV_OFFSET_REDUND=0x940000
+CONFIG_CMD_STM32PROG=y
 # CONFIG_ARMV7_NONSEC is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_FDT_SIMPLEFB=y
 CONFIG_SYS_PROMPT="STM32MP> "
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
 CONFIG_CMD_MEMINFO=y
 CONFIG_CMD_MEMTEST=y
 CONFIG_CMD_UNZIP=y
+CONFIG_CMD_ADC=y
 CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
 CONFIG_CMD_FUSE=y
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_LSBLK=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BMP=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_EFIDEBUG=y
 CONFIG_CMD_TIME=y
@@ -44,35 +61,112 @@ CONFIG_CMD_UBI=y
 CONFIG_OF_LIVE=y
 CONFIG_ENV_IS_NOWHERE=y
 CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_IS_IN_UBI=y
 CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_UBI_PART="UBI"
+CONFIG_ENV_UBI_VOLUME="uboot_config"
+CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SYS_MMC_ENV_DEV=-1
 CONFIG_ENV_MMC_USE_DT=y
+CONFIG_TFTP_TSIZE=y
+CONFIG_USE_SERVERIP=y
+CONFIG_SERVERIP="192.168.1.1"
+CONFIG_STM32_ADC=y
+CONFIG_SYS_64BIT_LBA=y
 CONFIG_CLK_SCMI=y
+CONFIG_DFU_TFTP=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
+CONFIG_FASTBOOT_BUF_SIZE=0x02000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_GPIO_HOG=y
 CONFIG_DM_I2C=y
 CONFIG_SYS_I2C_STM32F7=y
 CONFIG_LED=y
 CONFIG_LED_GPIO=y
+CONFIG_STM32_FMC2_EBI=y
 CONFIG_SUPPORT_EMMC_BOOT=y
 CONFIG_STM32_SDMMC2=y
 CONFIG_MTD=y
 CONFIG_DM_MTD=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_NAND_STM32_FMC2=y
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USBPHYC=y
 CONFIG_PINCONF=y
+CONFIG_PINCTRL_MCP23017=y
 CONFIG_DM_REGULATOR=y
 CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_SCMI=y
 CONFIG_RESET_SCMI=y
 CONFIG_DM_RNG=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_STM32_QSPI=y
+CONFIG_STM32_SPI=y
 CONFIG_SYSRESET_PSCI=y
 CONFIG_TEE=y
 CONFIG_OPTEE=y
 # CONFIG_OPTEE_TA_AVB is not set
+CONFIG_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_UCSI=y
+CONFIG_UCSI_STM32G0=y
+CONFIG_USB_ONBOARD_HUB=y
+CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEO_STM32=y
+CONFIG_VIDEO_STM32_MAX_XRES=480
+CONFIG_VIDEO_STM32_MAX_YRES=272
+CONFIG_VIDEO_BMP_RLE8=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
 CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp15_basic_defconfig b/configs/stm32mp15_basic_defconfig
index dc491cf19a..7a4be381e6 100644
--- a/configs/stm32mp15_basic_defconfig
+++ b/configs/stm32mp15_basic_defconfig
@@ -3,7 +3,7 @@ CONFIG_ARCH_STM32MP=y
 CONFIG_SYS_MALLOC_F_LEN=0x3000
 CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0100000
-CONFIG_ENV_OFFSET=0x280000
+CONFIG_ENV_OFFSET=0x900000
 CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_SPL_DM_SPI=y
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
@@ -12,17 +12,20 @@ CONFIG_SPL_MMC=y
 CONFIG_SPL_STACK=0x30000000
 CONFIG_SPL=y
 CONFIG_CMD_STM32KEY=y
-CONFIG_TYPEC_STUSB160X=y
-CONFIG_TARGET_ST_STM32MP15x=y
-CONFIG_ENV_OFFSET_REDUND=0x2C0000
+CONFIG_TARGET_ST_STM32MP15X=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
 CONFIG_CMD_STM32PROG=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI=y
 # CONFIG_ARMV7_VIRT is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
@@ -47,7 +50,9 @@ CONFIG_SYS_SPI_U_BOOT_OFFS=0x80000
 CONFIG_FDT_SIMPLEFB=y
 CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_SYS_PBSIZE=1050
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -97,7 +102,7 @@ CONFIG_TFTP_TSIZE=y
 CONFIG_USE_SERVERIP=y
 CONFIG_SERVERIP="192.168.1.1"
 CONFIG_STM32_ADC=y
-CONFIG_SET_DFU_ALT_INFO=y
+CONFIG_SYS_64BIT_LBA=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
 CONFIG_FASTBOOT_BUF_SIZE=0x02000000
@@ -108,6 +113,7 @@ CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
 CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
 CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
 CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
 CONFIG_GPIO_HOG=y
@@ -150,7 +156,7 @@ CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
 CONFIG_REMOTEPROC_STM32_COPRO=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_STM32MP1=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
@@ -163,6 +169,10 @@ CONFIG_USB=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_STUSB160X=y
 CONFIG_USB_ONBOARD_HUB=y
 CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
 CONFIG_USB_GADGET=y
@@ -171,16 +181,17 @@ CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_VIDEO=y
-CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_DSI=y
 CONFIG_VIDEO_STM32_MAX_XRES=1280
 CONFIG_VIDEO_STM32_MAX_YRES=800
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
+CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
@@ -188,6 +199,14 @@ CONFIG_WDT=y
 CONFIG_WDT_STM32MP=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp15_defconfig b/configs/stm32mp15_defconfig
index 4f7dca4f2a..5821cb3d23 100644
--- a/configs/stm32mp15_defconfig
+++ b/configs/stm32mp15_defconfig
@@ -8,22 +8,27 @@ CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
 CONFIG_DDR_CACHEABLE_SIZE=0x8000000
 CONFIG_CMD_STM32KEY=y
-CONFIG_TYPEC_STUSB160X=y
-CONFIG_TARGET_ST_STM32MP15x=y
+CONFIG_TARGET_ST_STM32MP15X=y
 CONFIG_ENV_OFFSET_REDUND=0x940000
 CONFIG_CMD_STM32PROG=y
 # CONFIG_ARMV7_NONSEC is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
 CONFIG_FDT_SIMPLEFB=y
 CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_SYS_PBSIZE=1050
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -69,8 +74,9 @@ CONFIG_TFTP_TSIZE=y
 CONFIG_USE_SERVERIP=y
 CONFIG_SERVERIP="192.168.1.1"
 CONFIG_STM32_ADC=y
+CONFIG_SYS_64BIT_LBA=y
 CONFIG_CLK_SCMI=y
-CONFIG_SET_DFU_ALT_INFO=y
+CONFIG_DFU_TFTP=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
 CONFIG_FASTBOOT_BUF_SIZE=0x02000000
@@ -81,6 +87,7 @@ CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
 CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
 CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
 CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
 CONFIG_GPIO_HOG=y
@@ -120,10 +127,11 @@ CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
 CONFIG_DM_REGULATOR_SCMI=y
+CONFIG_REMOTEPROC_OPTEE=y
 CONFIG_REMOTEPROC_STM32_COPRO=y
 CONFIG_RESET_SCMI=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_STM32MP1=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
@@ -139,6 +147,10 @@ CONFIG_USB=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_STUSB160X=y
 CONFIG_USB_ONBOARD_HUB=y
 CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
 CONFIG_USB_GADGET=y
@@ -147,23 +159,33 @@ CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_VIDEO=y
-CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_DSI=y
 CONFIG_VIDEO_STM32_MAX_XRES=1280
 CONFIG_VIDEO_STM32_MAX_YRES=800
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
+CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
 CONFIG_WDT=y
 CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp15_trusted_defconfig b/configs/stm32mp15_trusted_defconfig
index 6f4876f099..3bec2207db 100644
--- a/configs/stm32mp15_trusted_defconfig
+++ b/configs/stm32mp15_trusted_defconfig
@@ -3,28 +3,33 @@ CONFIG_ARCH_STM32MP=y
 CONFIG_TFABOOT=y
 CONFIG_SYS_MALLOC_F_LEN=0x3000
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0100000
-CONFIG_ENV_OFFSET=0x280000
+CONFIG_ENV_OFFSET=0x900000
 CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
 CONFIG_DDR_CACHEABLE_SIZE=0x10000000
 CONFIG_CMD_STM32KEY=y
-CONFIG_TYPEC_STUSB160X=y
-CONFIG_STM32MP15x_STM32IMAGE=y
-CONFIG_TARGET_ST_STM32MP15x=y
-CONFIG_ENV_OFFSET_REDUND=0x2C0000
+CONFIG_STM32MP15X_STM32IMAGE=y
+CONFIG_TARGET_ST_STM32MP15X=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
 CONFIG_CMD_STM32PROG=y
 # CONFIG_ARMV7_NONSEC is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
 CONFIG_FDT_SIMPLEFB=y
 CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_SYS_PBSIZE=1050
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -70,8 +75,9 @@ CONFIG_TFTP_TSIZE=y
 CONFIG_USE_SERVERIP=y
 CONFIG_SERVERIP="192.168.1.1"
 CONFIG_STM32_ADC=y
+CONFIG_SYS_64BIT_LBA=y
 CONFIG_CLK_SCMI=y
-CONFIG_SET_DFU_ALT_INFO=y
+CONFIG_DFU_TFTP=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
 CONFIG_FASTBOOT_BUF_SIZE=0x02000000
@@ -82,6 +88,7 @@ CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
 CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
 CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
 CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
 CONFIG_GPIO_HOG=y
@@ -120,10 +127,11 @@ CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
+CONFIG_REMOTEPROC_OPTEE=y
 CONFIG_REMOTEPROC_STM32_COPRO=y
 CONFIG_RESET_SCMI=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_STM32MP1=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
@@ -139,6 +147,10 @@ CONFIG_USB=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_STUSB160X=y
 CONFIG_USB_ONBOARD_HUB=y
 CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
 CONFIG_USB_GADGET=y
@@ -147,16 +159,17 @@ CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_VIDEO=y
-CONFIG_VIDEO_LOGO=y
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_DSI=y
 CONFIG_VIDEO_STM32_MAX_XRES=1280
 CONFIG_VIDEO_STM32_MAX_YRES=800
 CONFIG_SPLASH_SCREEN=y
 CONFIG_SPLASH_SCREEN_ALIGN=y
+CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
@@ -164,6 +177,14 @@ CONFIG_WDT=y
 CONFIG_WDT_STM32MP=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp21_defconfig b/configs/stm32mp21_defconfig
new file mode 100644
index 0000000000..a95320828a
--- /dev/null
+++ b/configs/stm32mp21_defconfig
@@ -0,0 +1,185 @@
+CONFIG_ARM=y
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_ARCH_STM32MP=y
+CONFIG_SYS_MALLOC_F_LEN=0x500000
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x90000000
+CONFIG_ENV_OFFSET=0x900000
+CONFIG_ENV_SECT_SIZE=0x40000
+CONFIG_DEFAULT_DEVICE_TREE="stm32mp215f-dk"
+CONFIG_STM32MP21X=y
+CONFIG_CMD_STM32KEY=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
+CONFIG_TARGET_ST_STM32MP21X=y
+CONFIG_CMD_STM32PROG=y
+CONFIG_SYS_LOAD_ADDR=0x84000000
+CONFIG_ENV_ADDR=0x60900000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_SYS_MEMTEST_START=0x84000000
+CONFIG_SYS_MEMTEST_END=0x88000000
+CONFIG_API=y
+CONFIG_SYS_MMC_MAX_DEVICE=3
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_BOOTDELAY=1
+CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_FDT_SIMPLEFB=y
+CONFIG_SYS_PROMPT="STM32MP> "
+CONFIG_CMD_BDINFO_EXTRA=y
+CONFIG_CMD_FWU_METADATA=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_ADTIMG=y
+# CONFIG_CMD_ELF is not set
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_EFI=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LSBLK=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_REMOTEPROC=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_RNG=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_LOG=y
+CONFIG_CMD_UBI=y
+CONFIG_OF_LIVE=y
+CONFIG_ENV_IS_NOWHERE=y
+CONFIG_ENV_IS_IN_FLASH=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_IS_IN_UBI=y
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_ADDR_REDUND=0x60940000
+CONFIG_ENV_UBI_PART="UBI"
+CONFIG_ENV_UBI_VOLUME="uboot_config"
+CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
+CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_USE_SERVERIP=y
+CONFIG_SERVERIP="192.168.1.1"
+CONFIG_SYS_64BIT_LBA=y
+CONFIG_BUTTON=y
+CONFIG_BUTTON_GPIO=y
+CONFIG_DFU_TFTP=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x84000000
+CONFIG_FASTBOOT_BUF_SIZE=0x2000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
+CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_GPIO_HOG=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_STM32F7=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_STM32_OMI=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_STM32_SDMMC2=y
+CONFIG_MTD=y
+CONFIG_DM_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_SYS_FLASH_CFI_WIDTH_16BIT=y
+CONFIG_CFI_FLASH=y
+CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS=y
+CONFIG_SYS_FLASH_USE_BUFFER_WRITE=y
+CONFIG_FLASH_CFI_MTD=y
+CONFIG_FLASH_CFI_SFDP=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_STM32_HYPERBUS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_SYS_NAND_USE_FLASH_BBT=y
+CONFIG_NAND_STM32_FMC2=y
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_SOFT_RESET=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USB2PHY=y
+CONFIG_PINCONF=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_RAM=y
+# CONFIG_STM32MP1_DDR is not set
+CONFIG_REMOTEPROC_OPTEE=y
+CONFIG_REMOTEPROC_STM32_COPRO=y
+CONFIG_DM_RNG=y
+CONFIG_RNG_STM32=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_STM32=y
+CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_STM32_OSPI=y
+CONFIG_STM32_SPI=y
+# CONFIG_OPTEE_TA_AVB is not set
+CONFIG_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_STM32_USBH=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_UCSI=y
+CONFIG_UCSI_STM32G0=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEO_STM32=y
+CONFIG_VIDEO_STM32_MAX_XRES=480
+CONFIG_VIDEO_STM32_MAX_YRES=272
+CONFIG_VIDEO_BMP_RLE8=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
+CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
+# CONFIG_LMB_USE_MAX_REGIONS is not set
+CONFIG_LMB_MEMORY_REGIONS=2
+CONFIG_LMB_RESERVED_REGIONS=32
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp23_defconfig b/configs/stm32mp23_defconfig
new file mode 100644
index 0000000000..bf6d130902
--- /dev/null
+++ b/configs/stm32mp23_defconfig
@@ -0,0 +1,191 @@
+CONFIG_ARM=y
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_ARCH_STM32MP=y
+CONFIG_SYS_MALLOC_F_LEN=0x500000
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x90000000
+CONFIG_ENV_OFFSET=0x900000
+CONFIG_ENV_SECT_SIZE=0x40000
+CONFIG_DEFAULT_DEVICE_TREE="stm32mp235f-dk"
+CONFIG_STM32MP23X=y
+CONFIG_CMD_STM32KEY=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
+CONFIG_TARGET_ST_STM32MP23X=y
+CONFIG_CMD_STM32PROG=y
+CONFIG_SYS_LOAD_ADDR=0x84000000
+CONFIG_ENV_ADDR=0x60900000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_SYS_MEMTEST_START=0x84000000
+CONFIG_SYS_MEMTEST_END=0x88000000
+CONFIG_API=y
+CONFIG_SYS_MMC_MAX_DEVICE=3
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_BOOTDELAY=1
+CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_FDT_SIMPLEFB=y
+CONFIG_SYS_PROMPT="STM32MP> "
+CONFIG_CMD_BDINFO_EXTRA=y
+CONFIG_CMD_FWU_METADATA=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_ADTIMG=y
+# CONFIG_CMD_ELF is not set
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_EFI=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LSBLK=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_REMOTEPROC=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_RNG=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_LOG=y
+CONFIG_CMD_UBI=y
+CONFIG_OF_LIVE=y
+CONFIG_ENV_IS_NOWHERE=y
+CONFIG_ENV_IS_IN_FLASH=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_IS_IN_UBI=y
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_ADDR_REDUND=0x60940000
+CONFIG_ENV_UBI_PART="UBI"
+CONFIG_ENV_UBI_VOLUME="uboot_config"
+CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
+CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_USE_SERVERIP=y
+CONFIG_SERVERIP="192.168.1.1"
+CONFIG_SYS_64BIT_LBA=y
+CONFIG_BUTTON=y
+CONFIG_BUTTON_GPIO=y
+CONFIG_DFU_TFTP=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x84000000
+CONFIG_FASTBOOT_BUF_SIZE=0x2000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
+CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_GPIO_HOG=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_STM32F7=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_STM32_OMI=y
+CONFIG_STM32_OMM=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_STM32_SDMMC2=y
+CONFIG_MTD=y
+CONFIG_DM_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_SYS_FLASH_CFI_WIDTH_16BIT=y
+CONFIG_CFI_FLASH=y
+CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS=y
+CONFIG_SYS_FLASH_USE_BUFFER_WRITE=y
+CONFIG_FLASH_CFI_MTD=y
+CONFIG_FLASH_CFI_SFDP=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_STM32_HYPERBUS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_SYS_NAND_USE_FLASH_BBT=y
+CONFIG_NAND_STM32_FMC2=y
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_SOFT_RESET=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USB2PHY=y
+CONFIG_PINCONF=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_RAM=y
+# CONFIG_STM32MP1_DDR is not set
+CONFIG_REMOTEPROC_OPTEE=y
+CONFIG_REMOTEPROC_STM32_COPRO=y
+CONFIG_DM_RNG=y
+CONFIG_RNG_STM32=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_STM32=y
+CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_STM32_OSPI=y
+CONFIG_STM32_SPI=y
+# CONFIG_OPTEE_TA_AVB is not set
+CONFIG_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STM32_USBH=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GENERIC=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
+CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
+CONFIG_VIDEO_STM32=y
+CONFIG_VIDEO_STM32_DSI=y
+CONFIG_VIDEO_STM32_LVDS=y
+CONFIG_VIDEO_STM32_MAX_XRES=1920
+CONFIG_VIDEO_STM32_MAX_YRES=1200
+CONFIG_VIDEO_BMP_RLE8=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
+CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
+# CONFIG_LMB_USE_MAX_REGIONS is not set
+CONFIG_LMB_MEMORY_REGIONS=2
+CONFIG_LMB_RESERVED_REGIONS=32
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp25_defconfig b/configs/stm32mp25_defconfig
new file mode 100644
index 0000000000..5b8aab47b8
--- /dev/null
+++ b/configs/stm32mp25_defconfig
@@ -0,0 +1,193 @@
+CONFIG_ARM=y
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_ARCH_STM32MP=y
+CONFIG_SYS_MALLOC_F_LEN=0x500000
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x90000000
+CONFIG_ENV_OFFSET=0x900000
+CONFIG_ENV_SECT_SIZE=0x40000
+CONFIG_DEFAULT_DEVICE_TREE="stm32mp257f-ev1"
+CONFIG_STM32MP25X=y
+CONFIG_CMD_STM32KEY=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
+CONFIG_TARGET_ST_STM32MP25X=y
+CONFIG_CMD_STM32PROG=y
+CONFIG_SYS_LOAD_ADDR=0x84000000
+CONFIG_ENV_ADDR=0x60900000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_SYS_MEMTEST_START=0x84000000
+CONFIG_SYS_MEMTEST_END=0x88000000
+CONFIG_API=y
+CONFIG_SYS_MMC_MAX_DEVICE=3
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_BOOTDELAY=1
+CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_FDT_SIMPLEFB=y
+CONFIG_SYS_PROMPT="STM32MP> "
+CONFIG_CMD_BDINFO_EXTRA=y
+CONFIG_CMD_FWU_METADATA=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_ADTIMG=y
+# CONFIG_CMD_ELF is not set
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_EFI=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LSBLK=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_REMOTEPROC=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_RNG=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_LOG=y
+CONFIG_CMD_UBI=y
+CONFIG_OF_LIVE=y
+CONFIG_ENV_IS_NOWHERE=y
+CONFIG_ENV_IS_IN_FLASH=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_IS_IN_UBI=y
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_ADDR_REDUND=0x60940000
+CONFIG_ENV_UBI_PART="UBI"
+CONFIG_ENV_UBI_VOLUME="uboot_config"
+CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
+CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_USE_SERVERIP=y
+CONFIG_SERVERIP="192.168.1.1"
+CONFIG_SYS_64BIT_LBA=y
+CONFIG_BUTTON=y
+CONFIG_BUTTON_GPIO=y
+CONFIG_DFU_TFTP=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x84000000
+CONFIG_FASTBOOT_BUF_SIZE=0x2000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
+CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_GPIO_HOG=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_STM32F7=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_DM_MAILBOX=y
+CONFIG_STM32_IPCC=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_STM32_OMI=y
+CONFIG_STM32_OMM=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_STM32_SDMMC2=y
+CONFIG_MTD=y
+CONFIG_DM_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_SYS_FLASH_CFI_WIDTH_16BIT=y
+CONFIG_CFI_FLASH=y
+CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS=y
+CONFIG_SYS_FLASH_USE_BUFFER_WRITE=y
+CONFIG_FLASH_CFI_MTD=y
+CONFIG_FLASH_CFI_SFDP=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_STM32_HYPERBUS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_SYS_NAND_USE_FLASH_BBT=y
+CONFIG_NAND_STM32_FMC2=y
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_SOFT_RESET=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USB2PHY=y
+CONFIG_PINCONF=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_RAM=y
+# CONFIG_STM32MP1_DDR is not set
+CONFIG_REMOTEPROC_OPTEE=y
+CONFIG_REMOTEPROC_STM32_COPRO=y
+CONFIG_DM_RNG=y
+CONFIG_RNG_STM32=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_STM32=y
+CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_STM32_OSPI=y
+CONFIG_STM32_SPI=y
+# CONFIG_OPTEE_TA_AVB is not set
+CONFIG_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STM32_USBH=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GENERIC=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
+CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
+CONFIG_VIDEO_STM32=y
+CONFIG_VIDEO_STM32_DSI=y
+CONFIG_VIDEO_STM32_LVDS=y
+CONFIG_VIDEO_STM32_MAX_XRES=1920
+CONFIG_VIDEO_STM32_MAX_YRES=1200
+CONFIG_VIDEO_BMP_RLE8=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
+CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
+# CONFIG_LMB_USE_MAX_REGIONS is not set
+CONFIG_LMB_MEMORY_REGIONS=2
+CONFIG_LMB_RESERVED_REGIONS=32
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/synquacer_developerbox_defconfig b/configs/synquacer_developerbox_defconfig
index b0b6868b22..db5a601c1e 100644
--- a/configs/synquacer_developerbox_defconfig
+++ b/configs/synquacer_developerbox_defconfig
@@ -19,6 +19,7 @@ CONFIG_HUSH_PARSER=y
 CONFIG_SYS_MAXARGS=128
 CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x800000
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_CMD_IMLS=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -98,3 +99,4 @@ CONFIG_EFI_CAPSULE_ON_DISK=y
 CONFIG_EFI_IGNORE_OSINDICATIONS=y
 CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
 CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
diff --git a/configs/tools-only_defconfig b/configs/tools-only_defconfig
index 3f588ea69b..5242765913 100644
--- a/configs/tools-only_defconfig
+++ b/configs/tools-only_defconfig
@@ -37,3 +37,4 @@ CONFIG_TIMER=y
 # CONFIG_GENERATE_ACPI_TABLE is not set
 # CONFIG_EFI_LOADER is not set
 CONFIG_TOOLS_MKEFICAPSULE=y
+CONFIG_TOOLS_MKFWUMDATA=y
diff --git a/doc/board/st/index.rst b/doc/board/st/index.rst
index 2a8a4ef3b8..4aece52a07 100644
--- a/doc/board/st/index.rst
+++ b/doc/board/st/index.rst
@@ -8,4 +8,5 @@ STMicroelectronics
 
    st-dt
    stm32mp1
+   stm32mp2
    stm32_MCU
diff --git a/doc/board/st/st-dt.rst b/doc/board/st/st-dt.rst
index 67e16ef165..a9e9a42a69 100644
--- a/doc/board/st/st-dt.rst
+++ b/doc/board/st/st-dt.rst
@@ -25,6 +25,7 @@ kernel binding directory = Documentation/devicetree/bindings/
 * display
 	- display/st,stm32-dsi.yaml
 	- display/st,stm32-ltdc.yaml
+        - display/st,stm32-lvds.yaml
 * gpio
 	- pinctrl/st,stm32-pinctrl.yaml
 * hwlock
diff --git a/doc/board/st/stm32mp1.rst b/doc/board/st/stm32mp1.rst
index 63b44776ff..81f1abec9c 100644
--- a/doc/board/st/stm32mp1.rst
+++ b/doc/board/st/stm32mp1.rst
@@ -69,23 +69,29 @@ a Cortex-A frequency option:
  - D : Cortex-A7 @ 800 MHz
  - F : Secure Boot + HW Crypto + Cortex-A7 @ 800 MHz
 
-Currently the following boards are supported:
+Currently the following STMIcroelectronics boards are supported:
 
  + stm32mp157a-dk1.dts
+ + stm32mp157a-ed1.dts
+ + stm32mp157a-ev1.dts
  + stm32mp157c-dk2.dts
  + stm32mp157c-ed1.dts
  + stm32mp157c-ev1.dts
- + stm32mp15xx-dhcor-avenger96.dts
+ + stm32mp157d-dk1.dts
+ + stm32mp157d-ed1.dts
+ + stm32mp157d-ev1.dts
+ + stm32mp157f-dk2.dts
+ + stm32mp157f-ed1.dts
+ + stm32mp157f-ev1.dts
 
-The SCMI variant of each board is supported by a specific "scmi" device tree:
- + stm32mp157a-dk1-scmi.dts
- + stm32mp157c-dk2-scmi.dts
- + stm32mp157c-ed1-scmi.dts
- + stm32mp157c-ev1-scmi.dts
+These board with SCMI support are only managed with stm32mp15_defconfig,
+when the resources are secured with RCC_TZCR.TZEN=1 in OP-TEE. The access to
+these reset and clock resources are provided by OP-TEE and the associated SCMI
+services.
 
-SCMI variant is used only with stm32mp15_defconfig, when the resources are
-secured with RCC_TZCR.TZEN=1 in OP-TEE. The access to these reset and clock
-resources are provided by OP-TEE and the associated SCMI services.
+Currently the following customer boards are supported:
+
+ + stm32mp15xx-dhcor-avenger96.dts
 
 STM32MP13x
 ``````````
@@ -146,7 +152,7 @@ TF-A_ (BL2) initialize the DDR and loads the next stage binaries from a FIP file
      the secure monitor to access to secure resources.
    + HW_CONFIG: The hardware configuration file = the U-Boot device tree
 
-The scmi variant of each device tree is only support with OP-TEE as secure
+The SCMI variant of each device tree is only support with OP-TEE as secure
 monitor, with stm32mp15_defconfig.
 
 The **Basic** boot chain with SPL (for STM32MP15x)
@@ -184,19 +190,27 @@ The supported device trees for STM32MP15x (stm32mp15_trusted_defconfig and stm32
 
 + ev1: eval board with pmic stpmic1 (ev1 = mother board + daughter ed1)
 
+   + stm32mp157a-ev1
    + stm32mp157c-ev1
+   + stm32mp157d-ev1
+   + stm32mp157f-ev1
 
 + ed1: daughter board with pmic stpmic1
 
+   + stm32mp157a-ed1
    + stm32mp157c-ed1
+   + stm32mp157d-ed1
+   + stm32mp157f-ed1
 
 + dk1: Discovery board
 
    + stm32mp157a-dk1
+   + stm32mp157d-dk1
 
 + dk2: Discovery board = dk1 with a BT/WiFI combo and a DSI panel
 
    + stm32mp157c-dk2
+   + stm32mp157f-dk2
 
 + avenger96: Avenger96 board from Arrow Electronics based on DH Elec. DHCOR SoM
 
@@ -261,12 +275,6 @@ Build Procedure
 
   a) trusted boot with FIP on STM32MP15x ev1::
 
-     # export KBUILD_OUTPUT=stm32mp15
-     # make stm32mp15_defconfig
-     # make DEVICE_TREE=stm32mp157c-ev1-scmi all
-
-    or without SCMI support
-
      # export KBUILD_OUTPUT=stm32mp15
      # make stm32mp15_defconfig
      # make DEVICE_TREE=stm32mp157c-ev1 all
diff --git a/doc/board/st/stm32mp2.rst b/doc/board/st/stm32mp2.rst
new file mode 100644
index 0000000000..fbfab043a8
--- /dev/null
+++ b/doc/board/st/stm32mp2.rst
@@ -0,0 +1,544 @@
+.. SPDX-License-Identifier: GPL-2.0-or-later
+.. sectionauthor:: Patrice Chotard <patrice.chotard@foss.st.com>
+
+STM32MP2xx boards
+=================
+
+This is a quick instruction for setup STMicroelectronics STM32MP2xx boards.
+
+Further information can be found in STMicroelectronics STM32 WIKI_.
+
+Supported devices
+-----------------
+
+U-Boot supports all the STMicroelectronics MPU with the associated boards
+
+ - STMP32MP25x SoCs:
+
+  - STM32MP257
+  - STM32MP253
+  - STM32MP251
+
+Everything is supported in Linux but U-Boot is limited to the boot device:
+
+ 1. UART
+ 2. SD card/MMC controller (SDMMC)
+ 3. NAND controller (FMC)
+ 4. NOR controller (OSPI)
+ 5. HyperFlash controller (OSPI)
+ 6. USB controller (USB_STM32_USBH)
+ 7. Ethernet controller
+
+And the necessary drivers
+
+ 1. I2C
+ 2. Clock, Reset, Sysreset
+ 3. Fuse (BSEC)
+ 4. OP-TEE
+ 5. ETH
+ 6. USB host
+ 7. WATCHDOG
+ 8. RNG
+ 9. RTC
+
+STM32MP25x
+``````````
+The STM32MP25x is a Cortex-A35 MPU aimed at various applications.
+
+It features:
+
+ - Dual core Cortex-A35 application core (Single on STM32MP251)
+ - 2D/3D image composition with GPU (only on STM32MP255 and STM32MP257)
+ - Standard memories interface support
+ - Standard connectivity, widely inherited from the STM32 MCU family
+ - Comprehensive security support
+ - Cortex M33 coprocessor
+
+Each line comes with a security option (cryptography & secure boot) and
+a Cortex-A frequency option:
+
+ - A : Cortex-A35 @ 1.2 GHz
+ - C : Secure Boot + HW Crypto + Cortex-A35 @ 1.2 GHz
+ - D : Cortex-A35 @ 1.5 GHz
+ - F : Secure Boot + HW Crypto + Cortex-A35 @ 1.5 GHz
+
+Currently the following STMicroelectronics boards are supported:
+
+ + stm32mp257f-dk.dts
+ + stm32mp257f-ev1.dts
+
+The access to reset and clock resources are provided by OP-TEE and the associated SCMI
+services.
+
+Boot Sequences
+--------------
+
+The boot chain is :
+
+- FSBL = **TF-A BL2**
+- Secure monitor = **TF-A BL31**
+- Secure OS = **OP-TEE**
+- SSBL = **U-Boot**
+
+It is the only supported boot chain for STM32MP25x family.
+
+defconfig_file :
+   + **stm32mp25_defconfig**
+
+TF-A_ and OP-TEE_ are 2 separate projects, with their git repository;
+they are compiled separately.
+
+TF-A_ (BL2) initialize the DDR and loads the next stage binaries from a FIP file:
+   + BL32: a secure monitor BL32 = OP-TEE, performs a full initialization of
+     Secure peripherals and provides service to normal world.
+   + BL33: a non-trusted firmware = U-Boot, running in normal world and uses
+     the secure monitor to access to secure resources.
+   + HW_CONFIG: The hardware configuration file = the U-Boot device tree
+
+Device Tree
+-----------
+
+All the STM32MP25x boards supported by U-Boot use the same generic board stm32mp2
+which supports all the bootable devices.
+
+Each STMicroelectronics board is only configured with the associated device tree.
+
+STM32MP25x device Tree Selection
+````````````````````````````````
+The supported device trees for STM32MP25x are:
+
++ ev1: Evaluation board
+
+   + stm32mp257f-ev1
+
++ dk: Discovery board
+
+   + stm32mp257f-dk
+
+Build Procedure
+---------------
+
+1. Install the required tools for U-Boot
+
+  * install package needed in U-Boot makefile
+    (libssl-dev, swig, libpython-dev...)
+
+  * install ARMv8 toolchain for 64bit Cortex-A (from Linaro,
+    from SDK for STM32MP25x, or any crosstoolchains from your distribution)
+    (you can use any gcc cross compiler compatible with U-Boot)
+
+2. Set the cross compiler::
+
+   # export CROSS_COMPILE=/path/to/toolchain/arm-linux-gnueabi-
+
+3. Select the output directory (optional)::
+
+   # export KBUILD_OUTPUT=/path/to/output
+
+   for example: use one output directory for each board::
+
+   # export KBUILD_OUTPUT=stm32mp257f-ev1
+   # export KBUILD_OUTPUT=stm32mp257f-dk
+
+   you can build outside of code directory::
+
+   # export KBUILD_OUTPUT=../build/stm32mp25
+
+4. Configure U-Boot::
+
+   # make <defconfig_file>
+
+   with <defconfig_file>: stm32mp25_defconfig
+
+5. Configure the device-tree and build the U-Boot image::
+
+   # make DEVICE_TREE=<name> all
+
+ 6. U-Boot Output files
+
+   In the output directory (selected by KBUILD_OUTPUT),
+   you can found the needed U-Boot files:
+
+     - stm32mp25_defconfig = **u-boot-nodtb.bin** and **u-boot.dtb**
+
+7. TF-A_ compilation
+
+   see OP-TEE_ and TF-A_ documentation for build commands.
+
+   - compile OP-TEE to generate the binary included in FIP
+
+   - after TF-A compilation, the used files are:
+
+     - TF-A_ BL2 => FSBL = **tf-a.stm32**
+
+     - FIP => **fip.bin**
+
+       FIP file includes the 2 files given in arguments of TF-A_ compilation:
+
+      - BL33=u-boot-nodtb.bin
+      - BL33_CFG=u-boot.dtb
+
+     You can also update an existing FIP after U-boot compilation with fiptool,
+     a tool provided by TF-A_::
+
+     # fiptool update --nt-fw u-boot-nodtb.bin --hw-config u-boot.dtb fip-stm32mp157c-ev1.bin
+
+8. The bootloaders files
+
++ The **ROM code** expects FSBL binaries with STM32 image header = tf-a.stm32
+
+According the FSBL / the boot mode:
+
++ **TF-A** expect a FIP binary = fip.bin, including the OS monitor (OP-TEE_) and the
+  U-Boot binary + device tree
+
+Switch Setting for Boot Mode
+----------------------------
+
+You can select the boot mode, on the board with one switch, to select
+the boot pin values = BOOT0, BOOT1, BOOT2, BOOT3
+
+  +-------------+---------+---------+---------+---------+
+  |*Boot Mode*  | *BOOT3* | *BOOT2* | *BOOT1* | *BOOT0* |
+  +=============+=========+=========+=========+=========+
+  | Recovery    |    0    |    0    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | SD-Card     |    0    |    0    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | eMMC        |    0    |    0    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    0    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | SPI-NOR     |    0    |    1    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    1    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    1    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    1    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    1    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    1    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    1    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Recovery    |    1    |    1    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+
+- on the STM32MP25x **evaluation board ev1 = MB1936** with the switch SW1
+  (BOOT0, BOOT1, BOOT2, BOOT3)
+- on the STM32MP25x **discovery board dk = MB1605** with the switch SW1
+  (BOOT0, BOOT1 only)
+
+Recovery is a boot from serial link (UART/USB) and it is used with
+STM32CubeProgrammer tool to load executable in RAM and to update the flash
+devices available on the board (HyperFlash/NOR/NAND/eMMC/SD card).
+
+The communication between HOST and board is based on
+
+  - for UARTs : the uart protocol used with all MCU STM32
+  - for USB : based on USB DFU 1.1 (without the ST extensions used on MCU STM32)
+
+Prepare a SD card
+-----------------
+
+The minimal requirements for STMP32MP25x boot up to U-Boot are:
+
+- GPT partitioning (with gdisk or with sgdisk)
+- 2 fsbl partitions, named "fsbla1" and "fsbla2", size at least 256KiB (2 copies for
+  redundancy)
+- 2 metadata partitions for FIP update support, named "metadata1" and "metadata2",
+  size at least 256KiB (2 copies for redundancy)
+- 2 fip partitions named "fip-a" and "fip-b" for FIP binary
+- 1 environment partition named "u-boot-env"
+
+The 2 fsbl partitions have the same content and are present to guarantee a
+fail-safe update of FSBL; fsbl2 can be omitted if this ROM code feature is
+not required.
+
+Then the minimal GPT partition is:
+
+  +-------+------------+---------+------------------------+
+  | *Num* |   *Name*   | *Size*  | *Content*              |
+  +=======+============+=========+========================+
+  | 1     |   fsbla1   | 256 KiB | TF-A_ BL2 (tf-a.stm32) |
+  +-------+------------+---------+------------------------+
+  | 2     |   fsbla2   | 256 KiB | TF-A_ BL2 (tf-a.stm32) |
+  +-------+------------+---------+------------------------+
+  | 3     | metadata1  | 256 KiB |                        |
+  +-------+------------+---------+------------------------+
+  | 4     | metadata1  | 256 KiB |                        |
+  +-------+------------+---------+------------------------+
+  | 5     |   fip-a    |   4 MiB |       fip.bin          |
+  +-------+------------+---------+------------------------+
+  | 6     |   fip-b    |   4 MiB |       fip.bin          |
+  +-------+------------+---------+------------------------+
+  | 7     | u-boot-env |  512 KiB|                        |
+  +-------+------------+---------+------------------------+
+  | 8     |   <any>    |  <any>  | Rootfs                 |
+  +-------+------------+---------+------------------------+
+
+And the 8th partition (Rootfs) is marked bootable with a file extlinux.conf
+following the Generic Distribution feature (see :doc:`../../develop/distro` for
+use).
+
+The size of fip partition must be enough for the associated binary file,
+4MB is the default value.
+
+According the used card reader select the correct block device
+(for example /dev/sdx or /dev/mmcblk0), in the next example, it is /dev/mmcblk0
+
+For example:
+
+a) remove previous formatting::
+
+    # sgdisk -o /dev/<SD card dev>
+
+b) create minimal image for FIP
+
+   For FIP support in TF-A_::
+
+    # sgdisk --resize-table=128 -a 1 \
+    -n 1:34:545	                -c 1:fsbla1 \
+    -n 2:546:1057		-c 2:fsbla2 \
+    -n 3:1058:1569              -c 3:metadata1 \
+    -n 4:1570:2081		-c 4:metadata2 \
+    -n 5:2082:10273		-c 5:fip-a \
+    -n 6:10274:18465		-c 6:fip-b \
+    -n 7:18466:19489		-c 7:u-boot-env \
+    -n 8:19490:			-c 8:rootfs -A 4:set:2 \
+    -p /dev/<SD card dev>
+
+   With gpt table with 128 entries an the partition 4 marked bootable (bit 2).
+
+c) copy the FSBL (2 times) and SSBL file on the correct partition.
+   in this example in partition 1 to 6::
+
+    # dd if=tf-a.stm32 of=/dev/mmcblk0p1
+    # dd if=tf-a.stm32 of=/dev/mmcblk0p2
+    # dd if=fip.bin of=/dev/mmcblk0p5
+    # dd if=fip.bin of=/dev/mmcblk0p6
+
+To boot from SD card, select BootPinMode = 1 0 0 0 and reset.
+
+Prepare eMMC
+------------
+
+You can use U-Boot to copy binary in eMMC.
+
+In the next example, you need to boot from SD card and the images
+(tf-a.stm32, metadata, fip.bin, u-boot.img are presents on SD card
+(mmc 0) in ext4 partition 4 (bootfs)
+
+To boot from SD card, select BootPinMode = 1 0 0 0 and reset.
+
+Then you update the eMMC with the next U-Boot command :
+
+a) prepare GPT on eMMC,
+   example with 3 partitions, fip, bootfs and roots::
+
+    # setenv emmc_part "name==metadata1,size=256KiB;name=metada2,size=256KiB;name=fip-a,size=4MiB;name=fip-b,size=4MiB;name=bootfs,type=linux,bootable,size=64MiB;name=rootfs,type=linux,size=512"
+    # gpt write mmc 1 ${emmc_part}
+
+b) copy FSBL ( TF-A_ ) in first eMMC boot partition::
+
+    # ext4load mmc 0:4 0xC0000000 tf-a.stm32
+
+    # mmc dev 1
+    # mmc partconf 1 1 1 1
+    # mmc write ${fileaddr} 0 200
+    # mmc partconf 1 1 1 0
+
+c) copy SSBL ( FIP ) in fip-a GPT partition of eMMC::
+
+    # ext4load mmc 0:4 0xC0000000 fip.bin
+
+    # mmc dev 1
+    # part start mmc 1 fip-a partstart
+    # mmc write ${fileaddr} ${partstart} ${filesize}
+
+To boot from eMMC, select BootPinMode = 0 0 1 0 and reset.
+
+Coprocessor firmware on STM32MP25x
+----------------------------------
+
+U-Boot can boot the coprocessor before the kernel (coprocessor early boot) by using rproc commands (update the bootcmd)
+
+   Configurations::
+
+	# env set name_copro "rproc-m33-fw_sign.bin"
+	# env set dev_copro 0
+	# env set loadaddr_copro ${kernel_addr_r}
+
+   Load binary from bootfs partition on SD card (mmc 0)::
+
+	# load mmc 0#bootfs ${loadaddr_copro} ${name_copro}
+
+   => ${filesize} variable is updated with the size of the loaded file.
+
+   Start M33 firmware with remote proc command::
+
+	# rproc init
+	# rproc load ${dev_copro} ${loadaddr_copro} ${filesize}
+	# rproc start ${dev_copro}"0
+
+DFU support
+-----------
+
+The DFU is supported on ST board.
+
+The env variable dfu_alt_info is automatically build, and all
+the memory present on the ST boards are exported.
+
+The dfu mode is started by the command::
+
+  STM32MP> dfu 0
+
+On EV1 board, booting from SD card::
+
+  STM32MP> dfu 0 list
+  DFU alt settings list:
+
+dev: RAM alt: 0 name: uImage layout: RAM_ADDR
+dev: RAM alt: 1 name: devicetree.dtb layout: RAM_ADDR
+dev: RAM alt: 2 name: uramdisk.image.gz layout: RAM_ADDR
+dev: eMMC alt: 3 name: mmc0_fsbla1 layout: RAW_ADDR
+dev: eMMC alt: 4 name: mmc0_fsbla2 layout: RAW_ADDR
+dev: eMMC alt: 5 name: mmc0_metadata1 layout: RAW_ADDR
+dev: eMMC alt: 6 name: mmc0_metadata2 layout: RAW_ADDR
+dev: eMMC alt: 7 name: mmc0_fip-a layout: RAW_ADDR
+dev: eMMC alt: 8 name: mmc0_fip-b layout: RAW_ADDR
+dev: eMMC alt: 9 name: mmc0_u-boot-env layout: RAW_ADDR
+dev: eMMC alt: 10 name: mmc0_bootfs layout: RAW_ADDR
+dev: eMMC alt: 11 name: mmc0_vendorfs layout: RAW_ADDR
+dev: eMMC alt: 12 name: mmc0_rootfs layout: RAW_ADDR
+dev: eMMC alt: 13 name: mmc0_userfs layout: RAW_ADDR
+dev: eMMC alt: 14 name: mmc1_boot1 layout: RAW_ADDR
+dev: eMMC alt: 15 name: mmc1_boot2 layout: RAW_ADDR
+dev: eMMC alt: 16 name: mmc1_fip layout: RAW_ADDR
+dev: eMMC alt: 17 name: mmc1_bootfs layout: RAW_ADDR
+dev: eMMC alt: 18 name: mmc1_vendorfs layout: RAW_ADDR
+dev: eMMC alt: 19 name: mmc1_rootfs layout: RAW_ADDR
+dev: eMMC alt: 20 name: mmc1_test_report layout: RAW_ADDR
+dev: eMMC alt: 21 name: mmc1_backup layout: RAW_ADDR
+dev: MTD alt: 22 name: nor1 layout: RAW_ADDR
+dev: MTD alt: 23 name: nor1_fsbla1 layout: RAW_ADDR
+dev: MTD alt: 24 name: nor1_fsbla2 layout: RAW_ADDR
+dev: MTD alt: 25 name: nor1_metadata1 layout: RAW_ADDR
+dev: MTD alt: 26 name: nor1_metadata2 layout: RAW_ADDR
+dev: MTD alt: 27 name: nor1_fip-a layout: RAW_ADDR
+dev: MTD alt: 28 name: nor1_fip-b layout: RAW_ADDR
+dev: MTD alt: 29 name: nor1_u-boot-env layout: RAW_ADDR
+dev: MTD alt: 30 name: nor1_nor-user layout: RAW_ADDR
+dev: VIRT alt: 31 name: OTP layout: RAW_ADDR
+
+All the supported device are exported for dfu-util tool::
+
+  $> dfu-util -l
+
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=31, name="OTP", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=30, name="nor1_nor-user", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=29, name="nor1_u-boot-env", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=28, name="nor1_fip-b", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=27, name="nor1_fip-a", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=26, name="nor1_metadata2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=25, name="nor1_metadata1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=24, name="nor1_fsbla2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=23, name="nor1_fsbla1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=22, name="nor1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=21, name="mmc1_backup", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=20, name="mmc1_test_report", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=19, name="mmc1_rootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=18, name="mmc1_vendorfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=17, name="mmc1_bootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=16, name="mmc1_fip", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=15, name="mmc1_boot2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=14, name="mmc1_boot1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=13, name="mmc0_userfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=12, name="mmc0_rootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=11, name="mmc0_vendorfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=10, name="mmc0_bootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=9, name="mmc0_u-boot-env", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=8, name="mmc0_fip-b", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=7, name="mmc0_fip-a", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=6, name="mmc0_metadata2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=5, name="mmc0_metadata1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=4, name="mmc0_fsbla2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=3, name="mmc0_fsbla1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=2, name="uramdisk.image.gz", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=1, name="devicetree.dtb", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=0, name="uImage", serial="004A00253836500B00343046"
+
+You can update the boot device:
+
+- SD card (mmc0)::
+
+  $> dfu-util -d 0483:df11 -a 3 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 4 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 5 -D fip-stm32mp257f-ev1.bin
+  $> dfu-util -d 0483:df11 -a 10 -D st-image-bootfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 11 -D st-image-vendorfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 12 -D st-image-weston-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 13 -D st-image-userfs-openstlinux-weston-stm32mp2.ext4
+
+- EMMC (mmc1)::
+
+  $> dfu-util -d 0483:df11 -a 14 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 15 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 16 -D fip-stm32mp257f-ev1.bin
+  $> dfu-util -d 0483:df11 -a 17 -D st-image-bootfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 18 -D st-image-vendorfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 19 -D st-image-weston-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 20 -D st-image-userfs-openstlinux-weston-stm32mp2.ext4
+
+- you can also dump the OTP and the PMIC NVM with::
+
+  $> dfu-util -d 0483:df11 -a 31 -U otp.bin
+
+When the board is booting for nor1, only the MTD partition on the boot devices are available, for example:
+
+- NOR (nor1 = alt 15) :
+
+  $> dfu-util -d 0483:df11 -a 16 -D tf-a-stm32mp157c-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 17 -D tf-a-stm32mp157c-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 20 -D fip-stm32mp157c-ev1.bin
+  $> dfu-util -d 0483:df11 -a 23 -D st-image-weston-openstlinux-weston-stm32mp1_nand_4_256_multivolume.ubi
+
+References
+----------
+
+.. _WIKI:
+
+STM32 Arm® Cortex®-based MPUs user guide
+
+  + https://wiki.st.com/
+  + https://wiki.st.com/stm32mpu/wiki/Main_Page
+
+.. _TF-A:
+
+TF-A = The Trusted Firmware-A project provides a reference implementation of
+secure world software for Armv7-A and Armv8-A class processors
+
+  + https://www.trustedfirmware.org/projects/tf-a/
+  + https://trustedfirmware-a.readthedocs.io/en/latest/
+  + https://trustedfirmware-a.readthedocs.io/en/latest/plat/stm32mp2.html
+  + https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/
+
+.. _OP-TEE:
+
+OP-TEE = an open source Trusted Execution Environment (TEE) implementing the
+Arm TrustZone technology
+
+  + https://www.op-tee.org/
+  + https://optee.readthedocs.io/en/latest/
+  + https://optee.readthedocs.io/en/latest/building/devices/stm32mp2.html
+  + https://github.com/OP-TEE/optee_os
diff --git a/doc/develop/uefi/fwu_updates.rst b/doc/develop/uefi/fwu_updates.rst
index e4709d82b4..51e8a28efe 100644
--- a/doc/develop/uefi/fwu_updates.rst
+++ b/doc/develop/uefi/fwu_updates.rst
@@ -46,6 +46,8 @@ The feature can be enabled by specifying the following configs::
     CONFIG_FWU_NUM_BANKS=<val>
     CONFIG_FWU_NUM_IMAGES_PER_BANK=<val>
 
+    CONFIG_FWU_MDATA_V1=y or CONFIG_FWU_MDATA_V2=y
+
 in the .config file
 
 By enabling the CONFIG_CMD_FWU_METADATA config option, the
@@ -58,6 +60,14 @@ enable the FWU Multi Bank Update functionality. Please refer to the
 section :ref:`uefi_capsule_update_ref` for more details on generation
 of the UEFI capsule.
 
+FWU Metadata
+------------
+
+U-Boot supports both versions(1 and 2) of the FWU metadata defined in
+the two revisions of the specification. Support can be enabled for
+either of the two versions through a config flag. The mkfwumdata tool
+can generate metadata for both the supported versions.
+
 Setting up the device for GPT partitioned storage
 -------------------------------------------------
 
@@ -94,12 +104,12 @@ of. Each GPT partition entry in the GPT header has two GUIDs::
 * UniquePartitionGUID
 
 The PartitionTypeGUID value should correspond to the
-``image_type_uuid`` field of the FWU metadata. This field is used to
+``image_type_guid`` field of the FWU metadata. This field is used to
 identify a given type of updatable firmware image, e.g. U-Boot,
 OP-TEE, FIP etc. This GUID should also be used for specifying the
 `--guid` parameter when generating the capsule.
 
-The UniquePartitionGUID value should correspond to the ``image_uuid``
+The UniquePartitionGUID value should correspond to the ``image_guid``
 field in the FWU metadata. This GUID is used to identify images of a
 given image type in different banks.
 
@@ -108,8 +118,8 @@ metadata partitions. This would be the PartitionTypeGUID for the
 metadata partitions. Similarly, the UEFI specification defines the ESP
 GUID to be be used.
 
-When generating the metadata, the ``image_type_uuid`` and the
-``image_uuid`` values should match the *PartitionTypeGUID* and the
+When generating the metadata, the ``image_type_guid`` and the
+``image_guid`` values should match the *PartitionTypeGUID* and the
 *UniquePartitionGUID* values respectively.
 
 Performing the Update
@@ -181,5 +191,5 @@ empty capsule would be::
 Links
 -----
 
-* [1] https://developer.arm.com/documentation/den0118/a/ - FWU Specification
+* [1] https://developer.arm.com/documentation/den0118/ - FWU Specification
 * [2] https://git.codelinaro.org/linaro/dependable-boot/mbfw/uploads/6f7ddfe3be24e18d4319e108a758d02e/mbfw.pdf - Dependable Boot Specification
diff --git a/doc/mkfwumdata.1 b/doc/mkfwumdata.1
index 7dd718b26e..2ed0fb100b 100644
--- a/doc/mkfwumdata.1
+++ b/doc/mkfwumdata.1
@@ -6,9 +6,11 @@ mkfwumdata \- create FWU metadata image
 .
 .SH SYNOPSIS
 .SY mkfwumdata
+.OP \-v version
 .OP \-a activeidx
 .OP \-p previousidx
 .OP \-g
+.OP \-V vendor-file
 .BI \-i\~ imagecount
 .BI \-b\~ bankcount
 .I UUIDs
@@ -28,6 +30,12 @@ creates metadata info to be used with FWU.
 Print usage information and exit.
 .
 .TP
+.B \-v
+Set 
+.IR version
+as the metadata version to generate. Valid values 1 or 2.
+.
+.TP
 .B \-a
 Set 
 .IR activeidx
@@ -50,6 +58,12 @@ Convert the
 as GUIDs before use.
 .
 .TP
+.B \-V
+Pass
+.IR vendor-file
+for appending vendor data to the metadata. Supported only with version 2.
+.
+.TP
 .B \-i
 Specify there are
 .IR imagecount
@@ -81,7 +95,7 @@ Create a metadata image with 2 banks and 1 image/bank, BankAct=0, BankPrev=1:
 .EX
 .in +4
 $ \c
-.B mkfwumdata \-a 0 \-p 1 \-b 2 \-i 1 \\\\\&
+.B mkfwumdata \-v 2 \-a 0 \-p 1 \-b 2 \-i 1 \\\\\&
 .in +6
 .B 17e86d77-41f9-4fd7-87ec-a55df9842de5,\\\\\&
 .B 10c36d7d-ca52-b843-b7b9-f9d6c501d108,\\\\\&
diff --git a/drivers/adc/adc-uclass.c b/drivers/adc/adc-uclass.c
index 9646e4d706..ff84edc31f 100644
--- a/drivers/adc/adc-uclass.c
+++ b/drivers/adc/adc-uclass.c
@@ -280,7 +280,7 @@ static int adc_vdd_plat_update(struct udevice *dev)
 	 * will bind before its supply regulator device, then the below 'get'
 	 * will return an error.
 	 */
-	if (!uc_pdata->vdd_supply)
+	if (!uc_pdata->vdd_supply || uc_pdata->vdd_microvolts != -ENODATA)
 		return 0;
 
 	ret = regulator_get_value(uc_pdata->vdd_supply);
@@ -297,7 +297,7 @@ static int adc_vss_plat_update(struct udevice *dev)
 	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
 	int ret;
 
-	if (!uc_pdata->vss_supply)
+	if (!uc_pdata->vss_supply || uc_pdata->vss_microvolts != -ENODATA)
 		return 0;
 
 	ret = regulator_get_value(uc_pdata->vss_supply);
diff --git a/drivers/adc/stm32-adc-core.c b/drivers/adc/stm32-adc-core.c
index 6c176961f1..7aa792f88f 100644
--- a/drivers/adc/stm32-adc-core.c
+++ b/drivers/adc/stm32-adc-core.c
@@ -25,6 +25,13 @@
 
 /* STM32 H7 maximum analog clock rate (from datasheet) */
 #define STM32H7_ADC_MAX_CLK_RATE	36000000
+#define STM32MP25_ADC_MAX_CLK_RATE	70000000
+
+struct stm32_adc_core_cfg {
+	int (*clk_sel)(struct udevice *dev, struct stm32_adc_common *common);
+	const unsigned int *presc;
+	const unsigned int num_presc;
+};
 
 /**
  * struct stm32h7_adc_ck_spec - specification for stm32h7 adc clock
@@ -58,6 +65,9 @@ static const struct stm32h7_adc_ck_spec stm32h7_adc_ckmodes_spec[] = {
 	{ 3, 0, 4 },
 };
 
+/* STM32MP25 ADC internal common clock prescaler division ratios */
+static const unsigned int stm32mp25_presc_div[] = {1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256};
+
 static int stm32h7_adc_clk_sel(struct udevice *dev,
 			       struct stm32_adc_common *common)
 {
@@ -139,9 +149,50 @@ out:
 	return 0;
 }
 
+static int stm32mp25_adc_clk_sel(struct udevice *dev, struct stm32_adc_common *common)
+{
+	const struct stm32_adc_core_cfg *adc_cfg = (struct stm32_adc_core_cfg *)
+						    dev_get_driver_data(dev);
+	unsigned long rate;
+	u32 val;
+	int i;
+
+	if (!clk_valid(&common->aclk)) {
+		dev_err(dev, "No 'adc' clock found\n");
+		return -ENOENT;
+	}
+
+	rate = clk_get_rate(&common->aclk);
+	if (!rate) {
+		dev_err(dev, "Invalid clock rate: 0\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < adc_cfg->num_presc; i++) {
+		if ((rate / adc_cfg->presc[i]) <= STM32MP25_ADC_MAX_CLK_RATE)
+			break;
+	}
+	if (i >= adc_cfg->num_presc) {
+		dev_err(dev, "adc clk selection failed\n");
+		return -EINVAL;
+	}
+
+	common->rate = rate / adc_cfg->presc[i];
+	val = readl_relaxed(common->base + STM32H7_ADC_CCR);
+	val &= ~STM32H7_PRESC_MASK;
+	val |= i << STM32H7_PRESC_SHIFT;
+	writel_relaxed(val, common->base + STM32H7_ADC_CCR);
+
+	dev_dbg(dev, "Using analog clock source at %ld kHz\n", common->rate / 1000);
+
+	return 0;
+}
+
 static int stm32_adc_core_probe(struct udevice *dev)
 {
 	struct stm32_adc_common *common = dev_get_priv(dev);
+	const struct stm32_adc_core_cfg *adc_cfg = (struct stm32_adc_core_cfg *)
+						   dev_get_driver_data(dev);
 	int ret;
 
 	common->base = dev_read_addr_ptr(dev);
@@ -150,6 +201,12 @@ static int stm32_adc_core_probe(struct udevice *dev)
 		return -ENOENT;
 	}
 
+	ret = device_get_supply_regulator(dev, "vdda-supply", &common->vdda);
+	if (ret) {
+		dev_err(dev, "can't get vdda-supply: %d\n", ret);
+		return ret;
+	}
+
 	ret = device_get_supply_regulator(dev, "vref-supply", &common->vref);
 	if (ret) {
 		dev_err(dev, "can't get vref-supply: %d\n", ret);
@@ -172,7 +229,7 @@ static int stm32_adc_core_probe(struct udevice *dev)
 		}
 	}
 
-	ret = clk_get_by_name(dev, "bus", &common->bclk);
+	ret = clk_get_by_name_optional(dev, "bus", &common->bclk);
 	if (!ret) {
 		ret = clk_enable(&common->bclk);
 		if (ret) {
@@ -181,7 +238,7 @@ static int stm32_adc_core_probe(struct udevice *dev)
 		}
 	}
 
-	ret = stm32h7_adc_clk_sel(dev, common);
+	ret = adc_cfg->clk_sel(dev, common);
 	if (ret)
 		goto err_bclk_disable;
 
@@ -198,9 +255,23 @@ err_aclk_disable:
 	return ret;
 }
 
+static const struct stm32_adc_core_cfg stm32h7_adc_priv_cfg = {
+	.clk_sel = &stm32h7_adc_clk_sel,
+};
+
+static const struct stm32_adc_core_cfg stm32mp25_adc_priv_cfg = {
+	.clk_sel = &stm32mp25_adc_clk_sel,
+	.presc = stm32mp25_presc_div,
+	.num_presc = ARRAY_SIZE(stm32mp25_presc_div),
+};
+
 static const struct udevice_id stm32_adc_core_ids[] = {
-	{ .compatible = "st,stm32h7-adc-core" },
-	{ .compatible = "st,stm32mp1-adc-core" },
+	{ .compatible = "st,stm32h7-adc-core", .data = (ulong)&stm32h7_adc_priv_cfg },
+	{ .compatible = "st,stm32mp1-adc-core", .data = (ulong)&stm32h7_adc_priv_cfg },
+	{ .compatible = "st,stm32mp13-adc-core", .data = (ulong)&stm32h7_adc_priv_cfg},
+	{ .compatible = "st,stm32mp21-adc-core", .data = (ulong)&stm32mp25_adc_priv_cfg },
+	{ .compatible = "st,stm32mp23-adc-core", .data = (ulong)&stm32mp25_adc_priv_cfg },
+	{ .compatible = "st,stm32mp25-adc-core", .data = (ulong)&stm32mp25_adc_priv_cfg },
 	{}
 };
 
diff --git a/drivers/adc/stm32-adc-core.h b/drivers/adc/stm32-adc-core.h
index 05968dbcc8..b91f1cded5 100644
--- a/drivers/adc/stm32-adc-core.h
+++ b/drivers/adc/stm32-adc-core.h
@@ -37,6 +37,7 @@ struct udevice;
  * @aclk:		clock for the analog circuitry
  * @bclk:		bus clock common for all ADCs
  * @vref:		regulator reference
+ * @vdda:		supply voltage
  * @vref_uv:		reference supply voltage (uV)
  */
 struct stm32_adc_common {
@@ -45,6 +46,7 @@ struct stm32_adc_common {
 	struct clk aclk;
 	struct clk bclk;
 	struct udevice *vref;
+	struct udevice *vdda;
 	int vref_uv;
 };
 
diff --git a/drivers/adc/stm32-adc.c b/drivers/adc/stm32-adc.c
index 1fba707c6f..17f8fdc121 100644
--- a/drivers/adc/stm32-adc.c
+++ b/drivers/adc/stm32-adc.c
@@ -9,11 +9,14 @@
 #include <common.h>
 #include <adc.h>
 #include <dm.h>
+#include <env.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/iopoll.h>
+#include <power/regulator.h>
 #include "stm32-adc-core.h"
 
 /* STM32H7 - Registers for each ADC instance */
@@ -26,6 +29,11 @@
 #define STM32H7_ADC_SQR1		0x30
 #define STM32H7_ADC_DR			0x40
 #define STM32H7_ADC_DIFSEL		0xC0
+#define STM32H7_ADC_CALFACT		0xC4
+#define STM32H7_ADC_CALFACT2		0xC8
+
+/* STM32MP25 - Registers for each ADC instance */
+#define STM32MP25_ADC_CALFACT STM32H7_ADC_CALFACT
 
 /* STM32H7_ADC_ISR - bit fields */
 #define STM32MP1_VREGREADY		BIT(12)
@@ -37,12 +45,31 @@
 #define STM32H7_ADCALDIF		BIT(30)
 #define STM32H7_DEEPPWD			BIT(29)
 #define STM32H7_ADVREGEN		BIT(28)
+#define STM32H7_LINCALRDYW6		BIT(27)
+#define STM32H7_LINCALRDYW5		BIT(26)
+#define STM32H7_LINCALRDYW4		BIT(25)
+#define STM32H7_LINCALRDYW3		BIT(24)
+#define STM32H7_LINCALRDYW2		BIT(23)
+#define STM32H7_LINCALRDYW1		BIT(22)
 #define STM32H7_ADCALLIN		BIT(16)
 #define STM32H7_BOOST			BIT(8)
+#define STM32H7_ADSTP			BIT(4)
 #define STM32H7_ADSTART			BIT(2)
 #define STM32H7_ADDIS			BIT(1)
 #define STM32H7_ADEN			BIT(0)
 
+/* STM32MP25_ADC_CFGR - bit fields */
+#define STM32MP25_RES_MASK		GENMASK(3, 2)
+
+/* STM32MP25_ADC_CALFACT - bit fields */
+#define STM32MP25_CALADDOS		BIT(31)
+#define STM32MP25_CALFACT_S		GENMASK(8, 0)
+#define STM32MP25_CALFACT_D		GENMASK(24, 16)
+
+/* STM32H7_ADC_CALFACT2 - bit fields */
+#define STM32H7_LINCALFACT_SHIFT	0
+#define STM32H7_LINCALFACT_MASK		GENMASK(29, 0)
+
 /* STM32H7_ADC_CFGR bit fields */
 #define STM32H7_EXTEN			GENMASK(11, 10)
 #define STM32H7_DMNGT			GENMASK(1, 0)
@@ -50,29 +77,75 @@
 /* STM32H7_ADC_SQR1 - bit fields */
 #define STM32H7_SQ1_SHIFT		6
 
+/* STM32H7_ADC_DIFSEL - bit fields */
+#define STM32H7_DIFSEL_SHIFT	0
+#define STM32H7_DIFSEL_MASK		GENMASK(19, 0)
+
 /* BOOST bit must be set on STM32H7 when ADC clock is above 20MHz */
 #define STM32H7_BOOST_CLKRATE		20000000UL
 
+/* STM32MP13 - Registers for each ADC instance */
+#define STM32MP13_ADC_DIFSEL	0xB0
+
+/* STM32MP13_ADC_CFGR specific bit fields */
+#define STM32MP13_DMAEN			BIT(0)
+#define STM32MP13_DMACFG		BIT(1)
+
+/* STM32MP13_ADC_DIFSEL - bit fields */
+#define STM32MP13_DIFSEL_SHIFT	0
+#define STM32MP13_DIFSEL_MASK	GENMASK(18, 0)
+
 #define STM32_ADC_CH_MAX		20	/* max number of channels */
 #define STM32_ADC_TIMEOUT_US		100000
+/* Number of linear calibration shadow registers / LINCALRDYW control bits */
+#define STM32H7_LINCALFACT_NUM		6
+#define STM32H7_LINCAL_NAME_LEN		32
+
+/* Number of loops in the calibration procedure to average data on STM32MP25 */
+#define STM32MP25_CALIB_LOOP		8
 
 struct stm32_adc_cfg {
+	const struct stm32_adc_regspec	*regs;
 	unsigned int max_channels;
 	unsigned int num_bits;
+	int (*calib)(struct udevice *dev);
 	bool has_vregready;
+	bool has_boostmode;
+	bool has_linearcal;
+	bool has_presel;
 };
 
 struct stm32_adc {
 	void __iomem *regs;
 	int active_channel;
 	const struct stm32_adc_cfg *cfg;
+	u32 lincalfact[STM32H7_LINCALFACT_NUM];
+};
+
+struct stm32_adc_regs {
+	int reg;
+	int mask;
+	int shift;
+};
+
+struct stm32_adc_regspec {
+	const struct stm32_adc_regs difsel;
+};
+
+static const struct stm32_adc_regspec stm32h7_adc_regspec = {
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK },
 };
 
+static const struct stm32_adc_regspec stm32mp13_adc_regspec = {
+	.difsel = { STM32MP13_ADC_DIFSEL, STM32MP13_DIFSEL_MASK },
+};
 static void stm32_adc_enter_pwr_down(struct udevice *dev)
 {
 	struct stm32_adc *adc = dev_get_priv(dev);
 
-	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_BOOST);
+	if (adc->cfg->has_boostmode)
+		clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_BOOST);
+
 	/* Setting DEEPPWD disables ADC vreg and clears ADVREGEN */
 	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_DEEPPWD);
 }
@@ -91,8 +164,7 @@ static int stm32_adc_exit_pwr_down(struct udevice *dev)
 	/* Exit deep power down, then enable ADC voltage regulator */
 	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_DEEPPWD);
 	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADVREGEN);
-
-	if (common->rate > STM32H7_BOOST_CLKRATE)
+	if (adc->cfg->has_boostmode && common->rate > STM32H7_BOOST_CLKRATE)
 		setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_BOOST);
 
 	/* Wait for startup time */
@@ -123,32 +195,43 @@ static int stm32_adc_stop(struct udevice *dev)
 	return 0;
 }
 
+static int stm32_adc_enable(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	int ret;
+	u32 val;
+
+	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADEN);
+	ret = readl_poll_timeout(adc->regs + STM32H7_ADC_ISR, val,
+				 val & STM32H7_ADRDY, STM32_ADC_TIMEOUT_US);
+	if (ret < 0) {
+		stm32_adc_stop(dev);
+		dev_err(dev, "Failed to enable ADC: %d\n", ret);
+	}
+
+	return ret;
+}
+
 static int stm32_adc_start_channel(struct udevice *dev, int channel)
 {
 	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
 	struct stm32_adc *adc = dev_get_priv(dev);
 	int ret;
-	u32 val;
 
 	ret = stm32_adc_exit_pwr_down(dev);
 	if (ret < 0)
 		return ret;
 
 	/* Only use single ended channels */
-	writel(0, adc->regs + STM32H7_ADC_DIFSEL);
+	clrbits_le32(adc->regs + adc->cfg->regs->difsel.reg, adc->cfg->regs->difsel.mask);
 
-	/* Enable ADC, Poll for ADRDY to be set (after adc startup time) */
-	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADEN);
-	ret = readl_poll_timeout(adc->regs + STM32H7_ADC_ISR, val,
-				 val & STM32H7_ADRDY, STM32_ADC_TIMEOUT_US);
-	if (ret < 0) {
-		stm32_adc_stop(dev);
-		dev_err(dev, "Failed to enable ADC: %d\n", ret);
+	ret = stm32_adc_enable(dev);
+	if (ret)
 		return ret;
-	}
 
 	/* Preselect channels */
-	writel(uc_pdata->channel_mask, adc->regs + STM32H7_ADC_PCSEL);
+	if (adc->cfg->has_presel)
+		writel(uc_pdata->channel_mask, adc->regs + STM32H7_ADC_PCSEL);
 
 	/* Set sampling time to max value by default */
 	writel(0xffffffff, adc->regs + STM32H7_ADC_SMPR1);
@@ -157,9 +240,11 @@ static int stm32_adc_start_channel(struct udevice *dev, int channel)
 	/* Program regular sequence: chan in SQ1 & len = 0 for one channel */
 	writel(channel << STM32H7_SQ1_SHIFT, adc->regs + STM32H7_ADC_SQR1);
 
-	/* Trigger detection disabled (conversion can be launched in SW) */
-	clrbits_le32(adc->regs + STM32H7_ADC_CFGR, STM32H7_EXTEN |
-		     STM32H7_DMNGT);
+	/*
+	 * Trigger detection disabled (conversion can be launched in SW)
+	 * STM32H7_DMNGT is equivalent to STM32MP13_DMAEN & STM32MP13_DMACFG
+	 */
+	clrbits_le32(adc->regs + STM32H7_ADC_CFGR, STM32H7_EXTEN | STM32H7_DMNGT);
 	adc->active_channel = channel;
 
 	return 0;
@@ -187,7 +272,15 @@ static int stm32_adc_channel_data(struct udevice *dev, int channel,
 
 	*data = readl(adc->regs + STM32H7_ADC_DR);
 
-	return 0;
+	ret = readl_poll_timeout(adc->regs + STM32H7_ADC_CR, val,
+				 !(val & (STM32H7_ADSTART)), STM32_ADC_TIMEOUT_US);
+	if (ret)
+		dev_warn(dev, "conversion stop timed out\n");
+
+	if (adc->cfg->has_presel)
+		setbits_le32(adc->regs + STM32H7_ADC_PCSEL, 0);
+
+	return ret;
 }
 
 /**
@@ -203,16 +296,16 @@ static int stm32_adc_channel_data(struct udevice *dev, int channel,
  */
 #define STM32H7_ADC_CALIB_TIMEOUT_US		100000
 
-static int stm32_adc_selfcalib(struct udevice *dev)
+static int stm32_adc_run_selfcalib(struct udevice *dev, int do_lincal)
 {
 	struct stm32_adc *adc = dev_get_priv(dev);
 	int ret;
-	u32 val;
+	u32 val, mask;
 
 	/*
 	 * Select calibration mode:
 	 * - Offset calibration for single ended inputs
-	 * - No linearity calibration. Done in next step.
+	 * - No linearity calibration.
 	 */
 	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF | STM32H7_ADCALLIN);
 
@@ -222,17 +315,20 @@ static int stm32_adc_selfcalib(struct udevice *dev)
 				       !(val & STM32H7_ADCAL), 100,
 				       STM32H7_ADC_CALIB_TIMEOUT_US);
 	if (ret) {
-		dev_err(dev, "calibration failed\n");
+		dev_err(dev, "calibration (offset single-ended) failed\n");
 		goto out;
 	}
 
 	/*
 	 * Select calibration mode, then start calibration:
 	 * - Offset calibration for differential input
-	 * - Linearity calibration (needs to be done only once for single/diff)
+	 * - Linearity calibration if not already done.
 	 *   will run simultaneously with offset calibration.
 	 */
-	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+	mask = STM32H7_ADCALDIF;
+	if (adc->cfg->has_linearcal && do_lincal)
+		mask |= STM32H7_ADCALLIN;
+	setbits_le32(adc->regs + STM32H7_ADC_CR, mask);
 
 	/* Start calibration, then wait for completion */
 	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCAL);
@@ -240,7 +336,8 @@ static int stm32_adc_selfcalib(struct udevice *dev)
 				       !(val & STM32H7_ADCAL), 100,
 				       STM32H7_ADC_CALIB_TIMEOUT_US);
 	if (ret)
-		dev_err(dev, "calibration failed\n");
+		dev_err(dev, "calibration (offset diff%s) failed\n",
+			(mask & STM32H7_ADCALLIN) ? "+linear" : "");
 
 out:
 	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF | STM32H7_ADCALLIN);
@@ -248,6 +345,319 @@ out:
 	return ret;
 }
 
+static int stm32mp25_adc_calfact_data(struct udevice *dev, u32 *average)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 val, avg = 0;
+	int i, ret;
+
+	for (i = 0; i < STM32MP25_CALIB_LOOP; i++) {
+		setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADSTART);
+
+		/*
+		 * Wait for end of conversion by polling ADSTART bit until it is cleared
+		 * Also work if waiting for EOC to be set in STM32H7_ADC_ISR
+		 */
+		ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+					       !(val & STM32H7_ADSTART), 100, STM32_ADC_TIMEOUT_US);
+		if (ret < 0) {
+			dev_err(dev, "Conversion failed: %d\n", ret);
+			return ret;
+		}
+
+		val = readl(adc->regs + STM32H7_ADC_DR);
+		avg += val;
+	}
+
+	*average = DIV_ROUND_CLOSEST(avg, STM32MP25_CALIB_LOOP);
+
+	return 0;
+}
+
+static int stm32mp25_adc_run_calib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 average_data = 0, calfact = 0;
+	int ret;
+
+	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCAL);
+	/* Clears CALADDOS (and old calibration data if any) */
+	writel_relaxed(0, adc->regs + STM32MP25_ADC_CALFACT);
+	/* Select single ended input calibration */
+	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF);
+	/* Use default resolution (e.g. 12 bits) */
+	clrbits_le32(adc->regs + STM32H7_ADC_CFGR, STM32MP25_RES_MASK);
+
+retry:
+	ret = stm32mp25_adc_calfact_data(dev, &average_data);
+	if (ret)
+		goto out;
+
+	/* If the averaged data is zero, retry with additional offset (set CALADDOS) */
+	if (!average_data) {
+		if (!calfact) {
+			/* Averaged data is zero, retry with additional offset */
+			calfact = STM32MP25_CALADDOS;
+			writel_relaxed(STM32MP25_CALADDOS,
+				       adc->regs + STM32MP25_ADC_CALFACT);
+			goto retry;
+		}
+		/* Averaged data is still zero with additional offset, just warn about it */
+		dev_warn(dev, "Single-ended calibration average: 0\n");
+	}
+
+	calfact |= FIELD_PREP(STM32MP25_CALFACT_S, average_data);
+
+	/* Select differential input calibration (keep previous CALADDOS value) */
+	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF);
+
+	ret = stm32mp25_adc_calfact_data(dev, &average_data);
+	if (ret)
+		goto out;
+	/*
+	 * If the averaged data is below 0x800 (half value in 12-bits mode),
+	 * retry with additional offset
+	 */
+	if (average_data < 0x800) {
+		if (!(calfact & STM32MP25_CALADDOS)) {
+			/* Retry the whole calibration with additional offset */
+			clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF);
+			calfact = STM32MP25_CALADDOS;
+			writel(calfact, adc->regs + STM32MP25_ADC_CALFACT);
+			goto retry;
+		}
+		/*
+		 * Averaged data is still below center value. It needs to be clamped to zero,
+		 * so don't use the result here, warn about it.
+		 */
+		dev_warn(dev, "Differential calibration clamped(0): 0x%x\n", average_data);
+	} else {
+		calfact |= FIELD_PREP(STM32MP25_CALFACT_D, average_data);
+	}
+
+	writel_relaxed(calfact, adc->regs + STM32MP25_ADC_CALFACT);
+
+	dev_dbg(dev, "Set calfact_s=0x%03lx, calfact_d=0x%03lx, calados=%ld\n",
+		FIELD_GET(STM32MP25_CALFACT_S, calfact),
+		FIELD_GET(STM32MP25_CALFACT_D, calfact),
+		FIELD_GET(STM32MP25_CALADDOS, calfact));
+
+out:
+	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCAL);
+
+	return ret;
+}
+
+/* Retrieve calibration data from env variables */
+static bool stm32_adc_getenv_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	char env_name[STM32H7_LINCAL_NAME_LEN];
+	char *env;
+	int i;
+
+	memset(&adc->lincalfact, 0, STM32H7_LINCALFACT_NUM * sizeof(u32));
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		/*
+		 * Save ADC linear calibration factors in U-boot environment variables
+		 * Variables are instantiated according to the adc address through
+		 * adcx_ prefix.
+		 */
+		snprintf(env_name, sizeof(env_name), "adc%x_lincalfact%d", (u32)adc->regs, i + 1);
+		env = env_get(env_name);
+		if (!env)
+			return false;
+		adc->lincalfact[i] = env_get_hex(env_name, 0);
+	}
+	return true;
+}
+
+/* Save calibration data to env variables */
+static void stm32_adc_save_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	char env_name[STM32H7_LINCAL_NAME_LEN];
+	int i;
+
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		snprintf(env_name, sizeof(env_name), "adc%x_lincalfact%d", (u32)adc->regs, i + 1);
+		if (env_set_hex(env_name, adc->lincalfact[i]))
+			dev_warn(dev, "Failed to save %s\n", env_name);
+	}
+}
+
+/* Read calibration data from ADC */
+static int stm32_adc_read_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 lincalrdyw_mask, val;
+	int i, ret;
+
+	/* Read linearity calibration */
+	lincalrdyw_mask = STM32H7_LINCALRDYW6;
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		/* Clear STM32H7_LINCALRDYW[6..1]: transfer calib to CALFACT2 */
+		clrbits_le32(adc->regs + STM32H7_ADC_CR, lincalrdyw_mask);
+
+		/* Poll: wait calib data to be ready in CALFACT2 register */
+		ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+					       !(val & lincalrdyw_mask), 100,
+					       STM32_ADC_TIMEOUT_US);
+		if (ret) {
+			dev_err(dev, "Failed to read calfact\n");
+			return ret;
+		}
+
+		val = readl(adc->regs + STM32H7_ADC_CALFACT2);
+		adc->lincalfact[i] = (val & STM32H7_LINCALFACT_MASK);
+		adc->lincalfact[i] >>= STM32H7_LINCALFACT_SHIFT;
+
+		lincalrdyw_mask >>= 1;
+	}
+
+	return 0;
+}
+
+/* Write calibration data to ADC */
+static int stm32_adc_write_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 lincalrdyw_mask, val;
+	int i, ret;
+
+	lincalrdyw_mask = STM32H7_LINCALRDYW6;
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		/*
+		 * Write saved calibration data to shadow registers:
+		 * Write CALFACT2, and set LINCALRDYW[6..1] bit to trigger
+		 * data write. Then poll to wait for complete transfer.
+		 */
+		val = adc->lincalfact[i] << STM32H7_LINCALFACT_SHIFT;
+		writel(val, adc->regs + STM32H7_ADC_CALFACT2);
+		setbits_le32(adc->regs + STM32H7_ADC_CR, lincalrdyw_mask);
+		ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+					       val & lincalrdyw_mask,
+					       100, STM32_ADC_TIMEOUT_US);
+		if (ret) {
+			dev_err(dev, "Failed to write calfact\n");
+			return ret;
+		}
+
+		lincalrdyw_mask >>= 1;
+	}
+
+	return 0;
+}
+
+static int stm32_adc_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	struct stm32_adc_common *common = dev_get_priv(dev_get_parent(dev));
+	int ret;
+	bool lincal_done = false;
+
+	ret = regulator_set_enable_if_allowed(common->vdda, true);
+	if (ret) {
+		dev_err(dev, "Failed to enable vdd_supply: %s",
+			common->vdda->name);
+		return ret;
+	}
+
+	ret = regulator_set_enable_if_allowed(common->vref, true);
+	if (ret) {
+		dev_err(dev, "Failed to enable Vref: %s", common->vref->name);
+		return ret;
+	}
+
+	/* Try to restore linear calibration */
+	if (adc->cfg->has_linearcal)
+		lincal_done = stm32_adc_getenv_selfcalib(dev);
+
+	/*
+	 * Run offset calibration unconditionally.
+	 * Run linear calibration if not already available.
+	 */
+	ret = stm32_adc_run_selfcalib(dev, !lincal_done);
+	if (ret)
+		return ret;
+
+	ret = stm32_adc_enable(dev);
+	if (ret)
+		return ret;
+
+	if (adc->cfg->has_linearcal) {
+		if (!lincal_done) {
+			ret = stm32_adc_read_selfcalib(dev);
+			if (ret)
+				goto disable;
+
+			stm32_adc_save_selfcalib(dev);
+		}
+
+		/*
+		 * Always write linear calibration data to ADC.
+		 * This allows to ensure that LINCALRDYWx bits are set when entering kernel
+		 *
+		 * - First boot:
+		 *   U-boot performs ADC linear calibration (& offset calibration)
+		 *   U-boot reads & saves linear calibration result in environment variable
+		 *   (Here LINCALRDYWx have been cleared due to the read procedure)
+		 *   U-boot writes back ADC linear calibration to set LINCALRDYWx bits,
+		 *   making the linear calibration available for the kernel.
+		 *
+		 * - Subsequent boot (environment set earlier):
+		 *   U-boot performs ADC offset calibration only
+		 *   U-boot reads ADC linear calibration from environment variable
+		 *   and writes back ADC linear calibration.
+		 *
+		 * - All boot: kernel steps
+		 *   * Case1: ADC calibrated by U-boot (LINCALRDYWx bits set)
+		 *     Read back the linear calibration from ADC registers and save it.
+		 *   * Case2: ADC not calibrated by U-boot
+		 *     Run a linear calibration and save it.
+		 */
+		ret = stm32_adc_write_selfcalib(dev);
+		if (ret)
+			goto disable;
+	}
+
+	return ret;
+
+disable:
+	stm32_adc_stop(dev);
+	return ret;
+}
+
+static int stm32mp25_adc_calib(struct udevice *dev)
+{
+	struct stm32_adc_common *common = dev_get_priv(dev_get_parent(dev));
+	int ret;
+
+	ret = regulator_set_enable_if_allowed(common->vdda, true);
+	if (ret) {
+		dev_err(dev, "Failed to enable vdd_supply: %s",
+			common->vdda->name);
+		return ret;
+	}
+
+	ret = regulator_set_enable_if_allowed(common->vref, true);
+	if (ret) {
+		dev_err(dev, "Failed to enable Vref: %s", common->vref->name);
+		return ret;
+	}
+
+	ret = stm32_adc_enable(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Run offset calibration unconditionally. */
+	ret = stm32mp25_adc_run_calib(dev);
+	if (ret)
+		stm32_adc_stop(dev);
+
+	return ret;
+}
+
 static int stm32_adc_get_legacy_chan_count(struct udevice *dev)
 {
 	int ret;
@@ -368,8 +778,13 @@ static int stm32_adc_probe(struct udevice *dev)
 	adc->regs = common->base + offset;
 	adc->cfg = (const struct stm32_adc_cfg *)dev_get_driver_data(dev);
 
-	/* VDD supplied by common vref pin */
-	uc_pdata->vdd_supply = common->vref;
+	/*
+	 * VDDA and Vref can be two separate ADC supplies.
+	 * Provide the VDDA as VDD to the framework, that supplies the ADC.
+	 * Provide Vref value used by SAR ADC for conversion (can be different),
+	 * the u-class use it for raw to microvolt conversion.
+	 */
+	uc_pdata->vdd_supply = common->vdda;
 	uc_pdata->vdd_microvolts = common->vref_uv;
 	uc_pdata->vss_microvolts = 0;
 
@@ -381,7 +796,7 @@ static int stm32_adc_probe(struct udevice *dev)
 	if (ret < 0)
 		return ret;
 
-	ret = stm32_adc_selfcalib(dev);
+	ret = adc->cfg->calib(dev);
 	if (ret)
 		stm32_adc_enter_pwr_down(dev);
 
@@ -395,14 +810,39 @@ static const struct adc_ops stm32_adc_ops = {
 };
 
 static const struct stm32_adc_cfg stm32h7_adc_cfg = {
+	.regs = &stm32h7_adc_regspec,
 	.num_bits = 16,
 	.max_channels = STM32_ADC_CH_MAX,
+	.calib = &stm32_adc_selfcalib,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
 };
 
 static const struct stm32_adc_cfg stm32mp1_adc_cfg = {
+	.regs = &stm32h7_adc_regspec,
 	.num_bits = 16,
 	.max_channels = STM32_ADC_CH_MAX,
+	.calib = &stm32_adc_selfcalib,
 	.has_vregready = true,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
+};
+
+static const struct stm32_adc_cfg stm32mp13_adc_cfg = {
+	.regs = &stm32mp13_adc_regspec,
+	.num_bits = 12,
+	.max_channels = STM32_ADC_CH_MAX - 1,
+	.calib = &stm32_adc_selfcalib,
+};
+
+static const struct stm32_adc_cfg stm32mp25_adc_cfg = {
+	.regs = &stm32h7_adc_regspec,
+	.num_bits = 12,
+	.max_channels = STM32_ADC_CH_MAX,
+	.calib = &stm32mp25_adc_calib,
+	.has_presel = true,
 };
 
 static const struct udevice_id stm32_adc_ids[] = {
@@ -410,6 +850,14 @@ static const struct udevice_id stm32_adc_ids[] = {
 	  .data = (ulong)&stm32h7_adc_cfg },
 	{ .compatible = "st,stm32mp1-adc",
 	  .data = (ulong)&stm32mp1_adc_cfg },
+	{ .compatible = "st,stm32mp13-adc",
+	  .data = (ulong)&stm32mp13_adc_cfg },
+	{ .compatible = "st,stm32mp21-adc",
+	  .data = (ulong)&stm32mp25_adc_cfg },
+	{ .compatible = "st,stm32mp23-adc",
+	  .data = (ulong)&stm32mp25_adc_cfg },
+	{ .compatible = "st,stm32mp25-adc",
+	  .data = (ulong)&stm32mp25_adc_cfg },
 	{}
 };
 
diff --git a/drivers/button/button-gpio.c b/drivers/button/button-gpio.c
index 7b5b3affe2..1e77324428 100644
--- a/drivers/button/button-gpio.c
+++ b/drivers/button/button-gpio.c
@@ -86,6 +86,9 @@ static int button_gpio_bind(struct udevice *parent)
 		struct button_uc_plat *uc_plat;
 		const char *label;
 
+		if (!ofnode_is_enabled(node))
+			continue;
+
 		label = ofnode_read_string(node, "label");
 		if (!label) {
 			debug("%s: node %s has no label\n", __func__,
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 29859cdfa1..94bf8b113d 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -10,6 +10,16 @@ config CLK
 	  feed into other clocks in a tree structure, with multiplexers to
 	  choose the source for each clock.
 
+config CLK_AUTO_ID
+	bool "Enable support of an unique clock id with several provider"
+	depends on CLK
+	help
+	  Add the uclass sequence number of clock provider in the 8 higher bits
+	  of the clk id to guaranty an unique clock identifier in clk uclass
+	  when several clock providers are present on the device and when
+	  default xlate are used.
+	  This feature limit each identifier for each clock providers (24 bits).
+
 config SPL_CLK
 	bool "Enable clock support in SPL"
 	depends on CLK && SPL && SPL_DM
@@ -162,6 +172,7 @@ config CLK_SCMI
 	bool "Enable SCMI clock driver"
 	depends on CLK
 	depends on SCMI_FIRMWARE
+	select CLK_AUTO_ID if CLK_CCF
 	help
 	  Enable this option if you want to support clock devices exposed
 	  by a SCMI agent based on SCMI clock protocol communication
diff --git a/drivers/clk/clk-uclass.c b/drivers/clk/clk-uclass.c
index dc3e9d6a26..827aa132a1 100644
--- a/drivers/clk/clk-uclass.c
+++ b/drivers/clk/clk-uclass.c
@@ -35,6 +35,12 @@ struct clk *dev_get_clk_ptr(struct udevice *dev)
 	return (struct clk *)dev_get_uclass_priv(dev);
 }
 
+ulong clk_get_id(const struct clk *clk)
+{
+	return (ulong)(clk->id & CLK_ID_MSK);
+}
+
+
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 int clk_get_by_phandle(struct udevice *dev, const struct phandle_1_arg *cells,
 		       struct clk *clk)
@@ -44,7 +50,7 @@ int clk_get_by_phandle(struct udevice *dev, const struct phandle_1_arg *cells,
 	ret = device_get_by_ofplat_idx(cells->idx, &clk->dev);
 	if (ret)
 		return ret;
-	clk->id = cells->arg[0];
+	clk->id = CLK_ID(dev, cells->arg[0]);
 
 	return 0;
 }
@@ -62,7 +68,7 @@ static int clk_of_xlate_default(struct clk *clk,
 	}
 
 	if (args->args_count)
-		clk->id = args->args[0];
+		clk->id = CLK_ID(clk->dev, args->args[0]);
 	else
 		clk->id = 0;
 
@@ -583,17 +589,34 @@ ulong clk_set_rate(struct clk *clk, ulong rate)
 	debug("%s(clk=%p, rate=%lu)\n", __func__, clk, rate);
 	if (!clk_valid(clk))
 		return 0;
-	ops = clk_dev_ops(clk->dev);
 
-	if (!ops->set_rate)
-		return -ENOSYS;
-
-	/* get private clock struct used for cache */
+	/* get private clock struct*/
 	clk_get_priv(clk, &clkp);
+
+	ops = clk_dev_ops(clkp->dev);
+
+	if (!ops->set_rate) {
+		struct clk *pclk = NULL;
+
+		if ((clkp->flags & CLK_SET_RATE_PARENT) == 0)
+			return -ENOSYS;
+
+		pclk = clk_get_parent(clkp);
+		if (IS_ERR(pclk))
+			return -ENODEV;
+
+		ops = clk_dev_ops(pclk->dev);
+
+		/* Clean up cached rates for us and all child clocks */
+		clk_clean_rate_cache(pclk);
+
+		return ops->set_rate(pclk, rate);
+	}
+
 	/* Clean up cached rates for us and all child clocks */
 	clk_clean_rate_cache(clkp);
 
-	return ops->set_rate(clk, rate);
+	return ops->set_rate(clkp, rate);
 }
 
 int clk_set_parent(struct clk *clk, struct clk *parent)
diff --git a/drivers/clk/clk_fixed_rate.c b/drivers/clk/clk_fixed_rate.c
index b5e78c7055..d79d158ef2 100644
--- a/drivers/clk/clk_fixed_rate.c
+++ b/drivers/clk/clk_fixed_rate.c
@@ -45,6 +45,7 @@ void clk_fixed_rate_ofdata_to_plat_(struct udevice *dev,
 	dev_set_uclass_priv(dev, clk);
 
 	clk->dev = dev;
+	clk->id = CLK_ID(dev, 0);
 	clk->enable_count = 0;
 }
 
diff --git a/drivers/clk/clk_sandbox.c b/drivers/clk/clk_sandbox.c
index 636914db8c..cfec0779de 100644
--- a/drivers/clk/clk_sandbox.c
+++ b/drivers/clk/clk_sandbox.c
@@ -14,24 +14,26 @@
 static ulong sandbox_clk_get_rate(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	return priv->rate[clk->id];
+	return priv->rate[id];
 }
 
 static ulong sandbox_clk_round_rate(struct clk *clk, ulong rate)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
 	if (!rate)
@@ -44,18 +46,19 @@ static ulong sandbox_clk_set_rate(struct clk *clk, ulong rate)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
 	ulong old_rate;
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
 	if (!rate)
 		return -EINVAL;
 
-	old_rate = priv->rate[clk->id];
-	priv->rate[clk->id] = rate;
+	old_rate = priv->rate[id];
+	priv->rate[id] = rate;
 
 	return old_rate;
 }
@@ -63,14 +66,15 @@ static ulong sandbox_clk_set_rate(struct clk *clk, ulong rate)
 static int sandbox_clk_enable(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	priv->enabled[clk->id] = true;
+	priv->enabled[id] = true;
 
 	return 0;
 }
@@ -78,14 +82,15 @@ static int sandbox_clk_enable(struct clk *clk)
 static int sandbox_clk_disable(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	priv->enabled[clk->id] = false;
+	priv->enabled[id] = false;
 
 	return 0;
 }
@@ -93,22 +98,24 @@ static int sandbox_clk_disable(struct clk *clk)
 static int sandbox_clk_request(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	priv->requested[clk->id] = true;
+	priv->requested[id] = true;
 	return 0;
 }
 
 static void sandbox_clk_free(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return;
 
-	priv->requested[clk->id] = false;
+	priv->requested[id] = false;
 	return;
 }
 
diff --git a/drivers/clk/clk_sandbox_ccf.c b/drivers/clk/clk_sandbox_ccf.c
index fedcdd4044..9ca19b4945 100644
--- a/drivers/clk/clk_sandbox_ccf.c
+++ b/drivers/clk/clk_sandbox_ccf.c
@@ -236,47 +236,47 @@ static int sandbox_clk_ccf_probe(struct udevice *dev)
 	void *base = NULL;
 	u32 reg;
 
-	clk_dm(SANDBOX_CLK_PLL3,
-	       sandbox_clk_pllv3(SANDBOX_PLLV3_USB, "pll3_usb_otg", "osc",
-				 base + 0x10, 0x3));
+	dev_clk_dm(dev, SANDBOX_CLK_PLL3,
+		   sandbox_clk_pllv3(SANDBOX_PLLV3_USB, "pll3_usb_otg", "osc",
+				     base + 0x10, 0x3));
 
-	clk_dm(SANDBOX_CLK_PLL3_60M,
-	       sandbox_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8));
+	dev_clk_dm(dev, SANDBOX_CLK_PLL3_60M,
+		   sandbox_clk_fixed_factor("pll3_60m", "pll3_usb_otg",   1, 8));
 
-	clk_dm(SANDBOX_CLK_PLL3_80M,
-	       sandbox_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6));
+	dev_clk_dm(dev, SANDBOX_CLK_PLL3_80M,
+		   sandbox_clk_fixed_factor("pll3_80m", "pll3_usb_otg",   1, 6));
 
 	/* The HW adds +1 to the divider value (2+1) is the divider */
 	reg = (2 << 19);
-	clk_dm(SANDBOX_CLK_ECSPI_ROOT,
-	       sandbox_clk_divider("ecspi_root", "pll3_60m", &reg, 19, 6));
+	dev_clk_dm(dev, SANDBOX_CLK_ECSPI_ROOT,
+		   sandbox_clk_divider("ecspi_root", "pll3_60m", &reg, 19, 6));
 
 	reg = 0;
-	clk_dm(SANDBOX_CLK_ECSPI0,
-	       sandbox_clk_gate("ecspi0", "ecspi_root", &reg, 0, 0));
+	dev_clk_dm(dev, SANDBOX_CLK_ECSPI0,
+		   sandbox_clk_gate("ecspi0", "ecspi_root", &reg, 0, 0));
 
-	clk_dm(SANDBOX_CLK_ECSPI1,
-	       sandbox_clk_gate2("ecspi1", "ecspi_root", base + 0x6c, 0));
+	dev_clk_dm(dev, SANDBOX_CLK_ECSPI1,
+		   sandbox_clk_gate2("ecspi1", "ecspi_root", base + 0x6c, 0));
 
 	/* Select 'pll3_60m' */
 	reg = 0;
-	clk_dm(SANDBOX_CLK_USDHC1_SEL,
-	       sandbox_clk_mux("usdhc1_sel", &reg, 16, 1, usdhc_sels,
-			       ARRAY_SIZE(usdhc_sels)));
+	dev_clk_dm(dev, SANDBOX_CLK_USDHC1_SEL,
+		   sandbox_clk_mux("usdhc1_sel", &reg, 16, 1, usdhc_sels,
+				   ARRAY_SIZE(usdhc_sels)));
 
 	/* Select 'pll3_80m' */
 	reg = BIT(17);
-	clk_dm(SANDBOX_CLK_USDHC2_SEL,
-	       sandbox_clk_mux("usdhc2_sel", &reg, 17, 1, usdhc_sels,
-			       ARRAY_SIZE(usdhc_sels)));
+	dev_clk_dm(dev, SANDBOX_CLK_USDHC2_SEL,
+		   sandbox_clk_mux("usdhc2_sel", &reg, 17, 1, usdhc_sels,
+				   ARRAY_SIZE(usdhc_sels)));
 
 	reg = BIT(28) | BIT(24) | BIT(16);
-	clk_dm(SANDBOX_CLK_I2C,
-	       sandbox_clk_composite("i2c", i2c_sels, ARRAY_SIZE(i2c_sels),
-				     &reg, CLK_SET_RATE_UNGATE));
+	dev_clk_dm(dev, SANDBOX_CLK_I2C,
+		   sandbox_clk_composite("i2c", i2c_sels, ARRAY_SIZE(i2c_sels),
+					 &reg, CLK_SET_RATE_UNGATE));
 
-	clk_dm(SANDBOX_CLK_I2C_ROOT,
-	       sandbox_clk_gate2("i2c_root", "i2c", base + 0x7c, 0));
+	dev_clk_dm(dev, SANDBOX_CLK_I2C_ROOT,
+		   sandbox_clk_gate2("i2c_root", "i2c", base + 0x7c, 0));
 
 	return 0;
 }
diff --git a/drivers/clk/clk_scmi.c b/drivers/clk/clk_scmi.c
index d172fed24c..5c23c5777e 100644
--- a/drivers/clk/clk_scmi.c
+++ b/drivers/clk/clk_scmi.c
@@ -42,7 +42,7 @@ static int scmi_clk_get_num_clock(struct udevice *dev, size_t *num_clocks)
 	return 0;
 }
 
-static int scmi_clk_get_attibute(struct udevice *dev, int clkid, char **name)
+static int scmi_clk_get_attribute(struct udevice *dev, int clkid, char **name)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(dev);
 	struct scmi_clk_attribute_in in = {
@@ -63,6 +63,10 @@ static int scmi_clk_get_attibute(struct udevice *dev, int clkid, char **name)
 	if (ret)
 		return ret;
 
+	/* Do not register clk with empty name */
+	if (!out.clock_name[0])
+		return -ECANCELED;
+
 	*name = strdup(out.clock_name);
 
 	return 0;
@@ -72,7 +76,7 @@ static int scmi_clk_gate(struct clk *clk, int enable)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(clk->dev);
 	struct scmi_clk_state_in in = {
-		.clock_id = clk->id,
+		.clock_id = clk_get_id(clk),
 		.attributes = enable,
 	};
 	struct scmi_clk_state_out out;
@@ -102,7 +106,7 @@ static ulong scmi_clk_get_rate(struct clk *clk)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(clk->dev);
 	struct scmi_clk_rate_get_in in = {
-		.clock_id = clk->id,
+		.clock_id = clk_get_id(clk),
 	};
 	struct scmi_clk_rate_get_out out;
 	struct scmi_msg msg = SCMI_MSG_IN(SCMI_PROTOCOL_ID_CLOCK,
@@ -125,7 +129,7 @@ static ulong scmi_clk_set_rate(struct clk *clk, ulong rate)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(clk->dev);
 	struct scmi_clk_rate_set_in in = {
-		.clock_id = clk->id,
+		.clock_id = clk_get_id(clk),
 		.flags = SCMI_CLK_RATE_ROUND_CLOSEST,
 		.rate_lsb = (u32)rate,
 		.rate_msb = (u32)((u64)rate >> 32),
@@ -172,7 +176,7 @@ static int scmi_clk_probe(struct udevice *dev)
 	for (i = 0; i < num_clocks; i++) {
 		char *clock_name;
 
-		if (!scmi_clk_get_attibute(dev, i, &clock_name)) {
+		if (!scmi_clk_get_attribute(dev, i, &clock_name)) {
 			clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 			if (!clk || !clock_name)
 				ret = -ENOMEM;
@@ -186,7 +190,7 @@ static int scmi_clk_probe(struct udevice *dev)
 				return ret;
 			}
 
-			clk_dm(i, clk);
+			dev_clk_dm(dev, i, clk);
 		}
 	}
 
@@ -205,5 +209,5 @@ U_BOOT_DRIVER(scmi_clock) = {
 	.id = UCLASS_CLK,
 	.ops = &scmi_clk_ops,
 	.probe = scmi_clk_probe,
-	.priv_auto = sizeof(struct scmi_clk_priv *),
+	.priv_auto = sizeof(struct scmi_clk_priv),
 };
diff --git a/drivers/clk/stm32/Kconfig b/drivers/clk/stm32/Kconfig
index 7a34ea23c3..e63385d305 100644
--- a/drivers/clk/stm32/Kconfig
+++ b/drivers/clk/stm32/Kconfig
@@ -23,7 +23,7 @@ config CLK_STM32_CORE
 config CLK_STM32MP1
 	bool "Enable RCC clock driver for STM32MP15"
 	depends on ARCH_STM32MP && CLK
-	default y if STM32MP15x
+	default y if STM32MP15X
 	help
 	  Enable the STM32 clock (RCC) driver. Enable support for
 	  manipulating STM32MP15's on-SoC clocks.
@@ -31,8 +31,26 @@ config CLK_STM32MP1
 config CLK_STM32MP13
 	bool "Enable RCC clock driver for STM32MP13"
 	depends on ARCH_STM32MP && CLK
-	default y if STM32MP13x
+	default y if STM32MP13X
 	select CLK_STM32_CORE
 	help
 	  Enable the STM32 clock (RCC) driver. Enable support for
 	  manipulating STM32MP13's on-SoC clocks.
+
+config CLK_STM32MP21
+	bool "Enable RCC clock driver for STM32MP21"
+	depends on ARCH_STM32MP && CLK
+	default y if STM32MP21X
+	select CLK_STM32_CORE
+	help
+	  Enable the STM32 clock (RCC) driver. Enable support for
+	  manipulating STM32MP21's on-SoC clocks.
+
+config CLK_STM32MP25
+	bool "Enable RCC clock driver for STM32MP25"
+	depends on ARCH_STM32MP && CLK
+	default y if STM32MP23X || STM32MP25X
+	select CLK_STM32_CORE
+	help
+	  Enable the STM32 clock (RCC) driver. Enable support for
+	  manipulating STM32MP25's on-SoC clocks.
diff --git a/drivers/clk/stm32/Makefile b/drivers/clk/stm32/Makefile
index 20afbc3cfc..20abd1a447 100644
--- a/drivers/clk/stm32/Makefile
+++ b/drivers/clk/stm32/Makefile
@@ -1,9 +1,11 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 #
-# Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+# Copyright (C) 2022-2024, STMicroelectronics - All Rights Reserved
 
 obj-$(CONFIG_CLK_STM32_CORE) += clk-stm32-core.o
 obj-$(CONFIG_CLK_STM32F) += clk-stm32f.o
 obj-$(CONFIG_CLK_STM32H7) += clk-stm32h7.o
 obj-$(CONFIG_CLK_STM32MP1) += clk-stm32mp1.o
 obj-$(CONFIG_CLK_STM32MP13) += clk-stm32mp13.o
+obj-$(CONFIG_CLK_STM32MP21) += clk-stm32mp21.o
+obj-$(CONFIG_CLK_STM32MP25) += clk-stm32mp25.o
diff --git a/drivers/clk/stm32/clk-stm32-core.c b/drivers/clk/stm32/clk-stm32-core.c
index 37e996e78f..5bb9843065 100644
--- a/drivers/clk/stm32/clk-stm32-core.c
+++ b/drivers/clk/stm32/clk-stm32-core.c
@@ -42,12 +42,13 @@ int stm32_rcc_init(struct udevice *dev,
 		const struct clock_config *cfg = &data->tab_clocks[i];
 		struct clk *clk = ERR_PTR(-ENOENT);
 
-		if (data->check_security && data->check_security(priv->base, cfg))
+		if (data->check_security && data->check_security(dev, priv->base, cfg))
 			continue;
 
 		if (cfg->setup) {
 			clk = cfg->setup(dev, cfg);
-			clk->id = cfg->id;
+			/* set identifier of clock provider*/
+			dev_clk_dm(dev, cfg->id, clk);
 		} else {
 			dev_err(dev, "failed to register clock %s\n", cfg->name);
 			return -ENOENT;
@@ -70,11 +71,71 @@ ulong clk_stm32_get_rate_by_name(const char *name)
 	return 0;
 }
 
+static const struct clk_ops *clk_dev_ops(struct udevice *dev)
+{
+	return (const struct clk_ops *)dev->driver->ops;
+}
+
+static int stm32_clk_endisable(struct clk *clk, bool enable)
+{
+	const struct clk_ops *ops;
+	struct clk *c = NULL;
+
+	if (!clk->id || clk_get_by_id(clk->id, &c))
+		return -ENOENT;
+
+	ops = clk_dev_ops(c->dev);
+	if (!ops->enable || !ops->disable)
+		return 0;
+
+	return enable ? ops->enable(c) : ops->disable(c);
+}
+
+static int stm32_clk_enable(struct clk *clk)
+{
+	return stm32_clk_endisable(clk, true);
+}
+
+static int stm32_clk_disable(struct clk *clk)
+{
+	return stm32_clk_endisable(clk, false);
+}
+
+static ulong stm32_clk_get_rate(struct clk *clk)
+{
+	const struct clk_ops *ops;
+	struct clk *c = NULL;
+
+	if (!clk->id || clk_get_by_id(clk->id, &c))
+		return -ENOENT;
+
+	ops = clk_dev_ops(c->dev);
+	if (!ops->get_rate)
+		return -ENOSYS;
+
+	return ops->get_rate(c);
+}
+
+static ulong stm32_clk_set_rate(struct clk *clk, unsigned long clk_rate)
+{
+	const struct clk_ops *ops;
+	struct clk *c = NULL;
+
+	if (!clk->id || clk_get_by_id(clk->id, &c))
+		return -ENOENT;
+
+	ops = clk_dev_ops(c->dev);
+	if (!ops->set_rate)
+		return -ENOSYS;
+
+	return ops->set_rate(c, clk_rate);
+}
+
 const struct clk_ops stm32_clk_ops = {
-	.enable = ccf_clk_enable,
-	.disable = ccf_clk_disable,
-	.get_rate = ccf_clk_get_rate,
-	.set_rate = ccf_clk_set_rate,
+	.enable = stm32_clk_enable,
+	.disable = stm32_clk_disable,
+	.get_rate = stm32_clk_get_rate,
+	.set_rate = stm32_clk_set_rate,
 };
 
 #define RCC_MP_ENCLRR_OFFSET	4
diff --git a/drivers/clk/stm32/clk-stm32-core.h b/drivers/clk/stm32/clk-stm32-core.h
index 53c2b467ab..296ac297c5 100644
--- a/drivers/clk/stm32/clk-stm32-core.h
+++ b/drivers/clk/stm32/clk-stm32-core.h
@@ -127,7 +127,7 @@ struct stm32_clock_match_data {
 	unsigned int num_clocks;
 	const struct clock_config *tab_clocks;
 	const struct clk_stm32_clock_data *clock_data;
-	int (*check_security)(void __iomem *base,
+	int (*check_security)(struct udevice *dev, void __iomem *base,
 			      const struct clock_config *cfg);
 };
 
diff --git a/drivers/clk/stm32/clk-stm32mp1.c b/drivers/clk/stm32/clk-stm32mp1.c
index 6150287694..84a34c8c94 100644
--- a/drivers/clk/stm32/clk-stm32mp1.c
+++ b/drivers/clk/stm32/clk-stm32mp1.c
@@ -72,6 +72,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define RCC_PLL2CSGR		0xA4
 #define RCC_I2C46CKSELR		0xC0
 #define RCC_SPI6CKSELR		0xC4
+#define RCC_UART1CKSELR		0xC8
 #define RCC_CPERCKSELR		0xD0
 #define RCC_STGENCKSELR		0xD4
 #define RCC_DDRITFCR		0xD8
@@ -317,6 +318,7 @@ enum stm32mp1_parent_sel {
 	_SPI45_SEL,
 	_SPI6_SEL,
 	_RTC_SEL,
+	_UART1_SEL,
 	_PARENT_SEL_NB,
 	_UNKNOWN_SEL = 0xff,
 };
@@ -550,6 +552,7 @@ static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
 	STM32MP1_CLK_SET_CLR_F(RCC_MP_APB4ENSETR, 0, LTDC_PX, _PLL4_Q),
 	STM32MP1_CLK_SET_CLR_F(RCC_MP_APB4ENSETR, 4, DSI_PX, _PLL4_Q),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 4, DSI_K, _DSI_SEL),
+	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 4, DSI, _PLL4_P),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 8, DDRPERFM, _UNKNOWN_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 15, IWDG2, _UNKNOWN_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 16, USBPHY_K, _USBPHY_SEL),
@@ -557,6 +560,7 @@ static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 0, SPI6_K, _SPI6_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 2, I2C4_K, _I2C46_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 3, I2C6_K, _I2C46_SEL),
+	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 4, USART1_K, _UART1_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 8, RTCAPB, _PCLK5),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 16, BSEC, _UNKNOWN_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 20, STGEN_K, _STGEN_SEL),
@@ -602,6 +606,8 @@ static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
 static const u8 i2c12_parents[] = {_PCLK1, _PLL4_R, _HSI_KER, _CSI_KER};
 static const u8 i2c35_parents[] = {_PCLK1, _PLL4_R, _HSI_KER, _CSI_KER};
 static const u8 i2c46_parents[] = {_PCLK5, _PLL3_Q, _HSI_KER, _CSI_KER};
+static const u8 uart1_parents[] = {_PCLK5, _PLL3_Q, _HSI_KER, _CSI_KER,
+					_PLL4_Q, _HSE_KER};
 static const u8 uart6_parents[] = {_PCLK2, _PLL4_Q, _HSI_KER, _CSI_KER,
 					_HSE_KER};
 static const u8 uart24_parents[] = {_PCLK1, _PLL4_Q, _HSI_KER, _CSI_KER,
@@ -659,6 +665,7 @@ static const struct stm32mp1_clk_sel stm32mp1_clk_sel[_PARENT_SEL_NB] = {
 	STM32MP1_CLK_PARENT(_RTC_SEL, RCC_BDCR, RCC_BDCR_RTCSRC_SHIFT,
 			    (RCC_BDCR_RTCSRC_MASK >> RCC_BDCR_RTCSRC_SHIFT),
 			    rtc_parents),
+	STM32MP1_CLK_PARENT(_UART1_SEL, RCC_UART1CKSELR, 0, 0x7, uart1_parents),
 };
 
 #ifdef STM32MP1_CLOCK_TREE_INIT
@@ -786,6 +793,7 @@ char * const stm32mp1_clk_parent_sel_name[_PARENT_SEL_NB] = {
 	[_SPI1_SEL] = "SPI1",
 	[_SPI45_SEL] = "SPI45",
 	[_RTC_SEL] = "RTC",
+	[_UART1_SEL] = "UART1",
 };
 
 static const struct stm32mp1_clk_data stm32mp1_data = {
diff --git a/drivers/clk/stm32/clk-stm32mp13.c b/drivers/clk/stm32/clk-stm32mp13.c
index 5174ae53a1..a946213cd3 100644
--- a/drivers/clk/stm32/clk-stm32mp13.c
+++ b/drivers/clk/stm32/clk-stm32mp13.c
@@ -693,6 +693,11 @@ static const struct clock_config stm32mp13_clock_cfg[] = {
 	PCLK(DDRPERFM, "ddrperfm", "pclk4", 0, GATE_DDRPERFM, SECF_NONE),
 	PCLK(ETH1STP, "eth1stp", "ck_axi", 0, GATE_ETH1STP, SECF_ETH1STP),
 	PCLK(ETH2STP, "eth2stp", "ck_axi", 0, GATE_ETH2STP, SECF_ETH2STP),
+	PCLK(SPI1, "spi1", "pclk2", 0, GATE_SPI1, SECF_NONE),
+	PCLK(SPI2, "spi2", "pclk1", 0, GATE_SPI2, SECF_NONE),
+	PCLK(SPI3, "spi3", "pclk1", 0, GATE_SPI3, SECF_NONE),
+	PCLK(SPI4, "spi4", "pclk6", 0, GATE_SPI4, SECF_SPI4),
+	PCLK(SPI5, "spi5", "pclk6", 0, GATE_SPI5, SECF_SPI5),
 
 	/* Kernel clocks */
 	KCLK(SDMMC1_K, "sdmmc1_k", 0, GATE_SDMMC1, MUX_SDMMC1, SECF_SDMMC1),
@@ -770,7 +775,7 @@ static const struct clock_config stm32mp13_clock_cfg[] = {
 			      GATE_TRACECK, DIV_TRACE),
 };
 
-static int stm32mp13_check_security(void __iomem *base,
+static int stm32mp13_check_security(struct udevice *dev, void __iomem *base,
 				    const struct clock_config *cfg)
 {
 	int sec_id = cfg->sec_id;
diff --git a/drivers/clk/stm32/clk-stm32mp21.c b/drivers/clk/stm32/clk-stm32mp21.c
new file mode 100644
index 0000000000..dd2959a747
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp21.c
@@ -0,0 +1,627 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ */
+
+#include <clk-uclass.h>
+#include <common.h>
+#include <dm.h>
+#include <dt-bindings/clock/st,stm32mp21-rcc.h>
+#include <linux/bitfield.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <mach/rif.h>
+
+#include "clk-stm32-core.h"
+#include "stm32mp21_rcc.h"
+
+/* Clock security definition */
+#define SECF_NONE		-1
+
+#define RCC_REG_SIZE	32
+#define RCC_SECCFGR(x)	(((x) / RCC_REG_SIZE) * 0x4 + RCC_SECCFGR0)
+#define RCC_CIDCFGR(x)	((x) * 0x8 + RCC_R0CIDCFGR)
+#define RCC_SEMCR(x)	((x) * 0x8 + RCC_R0SEMCR)
+#define RCC_CID1	1
+
+/* Register: RIFSC_CIDCFGR */
+#define RCC_CIDCFGR_CFEN	BIT(0)
+#define RCC_CIDCFGR_SEM_EN	BIT(1)
+#define RCC_CIDCFGR_SEMWLC1_EN	BIT(17)
+#define RCC_CIDCFGR_SCID_MASK	GENMASK(6, 4)
+
+/* Register: RIFSC_SEMCR */
+#define RCC_SEMCR_SEMCID_MASK	GENMASK(6, 4)
+
+#define STM32MP21_RIFRCC_DBG_ID		73
+#define STM32MP21_RIFRCC_MCO1_ID	108
+#define STM32MP21_RIFRCC_MCO2_ID	109
+#define STM32MP21_RIFRCC_OSPI1_ID	110
+
+#define SEC_RIFSC_FLAG		BIT(31)
+#define SEC_RIFRCC(_id)		(STM32MP21_RIFRCC_##_id##_ID)
+#define SEC_RIFSC(_id)		((_id) | SEC_RIFSC_FLAG)
+
+static const char * const adc1_src[] = {
+	"ck_flexgen_46", "ck_icn_ls_mcu"
+};
+
+static const char * const adc2_src[] = {
+	"ck_flexgen_47", "ck_icn_ls_mcu", "ck_flexgen_46"
+};
+
+static const char * const usb2phy1_src[] = {
+	"ck_flexgen_57", "hse_div2_ck"
+};
+
+static const char * const usb2phy2_src[] = {
+	"ck_flexgen_58", "hse_div2_ck"
+};
+
+static const char * const dts_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const mco1_src[] = {
+	"ck_flexgen_61", "ck_obs0"
+};
+
+static const char * const mco2_src[] = {
+	"ck_flexgen_62", "ck_obs1"
+};
+
+enum enum_mux_cfg {
+	MUX_MCO1,
+	MUX_MCO2,
+	MUX_ADC1,
+	MUX_ADC2,
+	MUX_USB2PHY1,
+	MUX_USB2PHY2,
+	MUX_DTS,
+	MUX_NB
+};
+
+#define MUX_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+		.num_parents	= ARRAY_SIZE(src),\
+		.parent_names	= src,\
+		.reg_off	= (_offset),\
+		.shift		= (_shift),\
+		.width		= (_witdh),\
+}
+
+static const struct stm32_mux_cfg stm32mp21_muxes[MUX_NB] = {
+	MUX_CFG(MUX_ADC1,		adc1_src,	RCC_ADC1CFGR,		12,	1),
+	MUX_CFG(MUX_ADC2,		adc2_src,	RCC_ADC2CFGR,		12,	2),
+	MUX_CFG(MUX_DTS,		dts_src,	RCC_DTSCFGR,		12,	2),
+	MUX_CFG(MUX_MCO1,		mco1_src,	RCC_MCO1CFGR,		0,	1),
+	MUX_CFG(MUX_MCO2,		mco2_src,	RCC_MCO2CFGR,		0,	1),
+	MUX_CFG(MUX_USB2PHY1,		usb2phy1_src,	RCC_USB2PHY1CFGR,	15,	1),
+	MUX_CFG(MUX_USB2PHY2,		usb2phy2_src,	RCC_USB2PHY2CFGR,	15,	1),
+};
+
+enum enum_gate_cfg {
+	GATE_ADC1,
+	GATE_ADC2,
+	GATE_CRC,
+	GATE_CRYP1,
+	GATE_CRYP2,
+	GATE_CSI,
+	GATE_DBG,
+	GATE_DCMIPP,
+	GATE_DTS,
+	GATE_ETH1,
+	GATE_ETH1MAC,
+	GATE_ETH1RX,
+	GATE_ETH1STP,
+	GATE_ETH1TX,
+	GATE_ETH2,
+	GATE_ETH2MAC,
+	GATE_ETH2RX,
+	GATE_ETH2STP,
+	GATE_ETH2TX,
+	GATE_ETR,
+	GATE_FDCAN,
+	GATE_HASH1,
+	GATE_HASH2,
+	GATE_HDP,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I3C1,
+	GATE_I3C2,
+	GATE_I3C3,
+	GATE_IWDG1,
+	GATE_IWDG2,
+	GATE_IWDG3,
+	GATE_IWDG4,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_LPUART1,
+	GATE_LTDC,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_MDF1,
+	GATE_OSPI1,
+	GATE_PKA,
+	GATE_RNG1,
+	GATE_RNG2,
+	GATE_SAES,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_SERC,
+	GATE_SPDIFRX,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_STGEN,
+	GATE_STM,
+	GATE_TIM1,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM8,
+	GATE_TIM10,
+	GATE_TIM11,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_TRACE,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_UART7,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_USART3,
+	GATE_USART6,
+	GATE_USBH,
+	GATE_USBOTG,
+	GATE_USB2PHY1,
+	GATE_USB2PHY2,
+	GATE_VREF,
+	GATE_WWDG1,
+	GATE_NB
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)[id] = {\
+	.reg_off	= (_offset),\
+	.bit_idx	= (_bit_idx),\
+	.set_clr	= (_offset_clr),\
+}
+
+static const struct stm32_gate_cfg stm32mp21_gates[GATE_NB] = {
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,		8,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,		8,	0),
+	GATE_CFG(GATE_OSPI1,		RCC_OSPI1CFGR,		1,	0),
+	GATE_CFG(GATE_DBG,		RCC_DBGCFGR,		8,	0),
+	GATE_CFG(GATE_TRACE,		RCC_DBGCFGR,		9,	0),
+	GATE_CFG(GATE_STM,		RCC_STMCFGR,		1,	0),
+	GATE_CFG(GATE_ETR,		RCC_ETRCFGR,		1,	0),
+	GATE_CFG(GATE_TIM1,		RCC_TIM1CFGR,		1,	0),
+	GATE_CFG(GATE_TIM2,		RCC_TIM2CFGR,		1,	0),
+	GATE_CFG(GATE_TIM3,		RCC_TIM3CFGR,		1,	0),
+	GATE_CFG(GATE_TIM4,		RCC_TIM4CFGR,		1,	0),
+	GATE_CFG(GATE_TIM5,		RCC_TIM5CFGR,		1,	0),
+	GATE_CFG(GATE_TIM6,		RCC_TIM6CFGR,		1,	0),
+	GATE_CFG(GATE_TIM7,		RCC_TIM7CFGR,		1,	0),
+	GATE_CFG(GATE_TIM8,		RCC_TIM8CFGR,		1,	0),
+	GATE_CFG(GATE_TIM10,		RCC_TIM10CFGR,		1,	0),
+	GATE_CFG(GATE_TIM11,		RCC_TIM11CFGR,		1,	0),
+	GATE_CFG(GATE_TIM12,		RCC_TIM12CFGR,		1,	0),
+	GATE_CFG(GATE_TIM13,		RCC_TIM13CFGR,		1,	0),
+	GATE_CFG(GATE_TIM14,		RCC_TIM14CFGR,		1,	0),
+	GATE_CFG(GATE_TIM15,		RCC_TIM15CFGR,		1,	0),
+	GATE_CFG(GATE_TIM16,		RCC_TIM16CFGR,		1,	0),
+	GATE_CFG(GATE_TIM17,		RCC_TIM17CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM1,		RCC_LPTIM1CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM2,		RCC_LPTIM2CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3,		RCC_LPTIM3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM4,		RCC_LPTIM4CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM5,		RCC_LPTIM5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI1,		RCC_SPI1CFGR,		1,	0),
+	GATE_CFG(GATE_SPI2,		RCC_SPI2CFGR,		1,	0),
+	GATE_CFG(GATE_SPI3,		RCC_SPI3CFGR,		1,	0),
+	GATE_CFG(GATE_SPI4,		RCC_SPI4CFGR,		1,	0),
+	GATE_CFG(GATE_SPI5,		RCC_SPI5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI6,		RCC_SPI6CFGR,		1,	0),
+	GATE_CFG(GATE_SPDIFRX,		RCC_SPDIFRXCFGR,	1,	0),
+	GATE_CFG(GATE_USART1,		RCC_USART1CFGR,		1,	0),
+	GATE_CFG(GATE_USART2,		RCC_USART2CFGR,		1,	0),
+	GATE_CFG(GATE_USART3,		RCC_USART3CFGR,		1,	0),
+	GATE_CFG(GATE_UART4,		RCC_UART4CFGR,		1,	0),
+	GATE_CFG(GATE_UART5,		RCC_UART5CFGR,		1,	0),
+	GATE_CFG(GATE_USART6,		RCC_USART6CFGR,		1,	0),
+	GATE_CFG(GATE_UART7,		RCC_UART7CFGR,		1,	0),
+	GATE_CFG(GATE_LPUART1,		RCC_LPUART1CFGR,	1,	0),
+	GATE_CFG(GATE_I2C1,		RCC_I2C1CFGR,		1,	0),
+	GATE_CFG(GATE_I2C2,		RCC_I2C2CFGR,		1,	0),
+	GATE_CFG(GATE_I2C3,		RCC_I2C3CFGR,		1,	0),
+	GATE_CFG(GATE_SAI1,		RCC_SAI1CFGR,		1,	0),
+	GATE_CFG(GATE_SAI2,		RCC_SAI2CFGR,		1,	0),
+	GATE_CFG(GATE_SAI3,		RCC_SAI3CFGR,		1,	0),
+	GATE_CFG(GATE_SAI4,		RCC_SAI4CFGR,		1,	0),
+	GATE_CFG(GATE_MDF1,		RCC_MDF1CFGR,		1,	0),
+	GATE_CFG(GATE_FDCAN,		RCC_FDCANCFGR,		1,	0),
+	GATE_CFG(GATE_HDP,		RCC_HDPCFGR,		1,	0),
+	GATE_CFG(GATE_ADC1,		RCC_ADC1CFGR,		1,	0),
+	GATE_CFG(GATE_ADC2,		RCC_ADC2CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1MAC,		RCC_ETH1CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1STP,		RCC_ETH1CFGR,		4,	0),
+	GATE_CFG(GATE_ETH1,		RCC_ETH1CFGR,		5,	0),
+	GATE_CFG(GATE_ETH1TX,		RCC_ETH1CFGR,		8,	0),
+	GATE_CFG(GATE_ETH1RX,		RCC_ETH1CFGR,		10,	0),
+	GATE_CFG(GATE_ETH2MAC,		RCC_ETH2CFGR,		1,	0),
+	GATE_CFG(GATE_ETH2STP,		RCC_ETH2CFGR,		4,	0),
+	GATE_CFG(GATE_ETH2,		RCC_ETH2CFGR,		5,	0),
+	GATE_CFG(GATE_ETH2TX,		RCC_ETH2CFGR,		8,	0),
+	GATE_CFG(GATE_ETH2RX,		RCC_ETH2CFGR,		10,	0),
+	GATE_CFG(GATE_USBH,		RCC_USBHCFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY1,		RCC_USB2PHY1CFGR,	1,	0),
+	GATE_CFG(GATE_USBOTG,		RCC_OTGCFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY2,		RCC_USB2PHY2CFGR,	1,	0),
+	GATE_CFG(GATE_STGEN,		RCC_STGENCFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC1,		RCC_SDMMC1CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC2,		RCC_SDMMC2CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC3,		RCC_SDMMC3CFGR,		1,	0),
+	GATE_CFG(GATE_LTDC,		RCC_LTDCCFGR,		1,	0),
+	GATE_CFG(GATE_CSI,		RCC_CSICFGR,		1,	0),
+	GATE_CFG(GATE_DCMIPP,		RCC_DCMIPPCFGR,		1,	0),
+	GATE_CFG(GATE_RNG1,		RCC_RNG1CFGR,		1,	0),
+	GATE_CFG(GATE_RNG2,		RCC_RNG2CFGR,		1,	0),
+	GATE_CFG(GATE_PKA,		RCC_PKACFGR,		1,	0),
+	GATE_CFG(GATE_SAES,		RCC_SAESCFGR,		1,	0),
+	GATE_CFG(GATE_HASH1,		RCC_HASH1CFGR,		1,	0),
+	GATE_CFG(GATE_HASH2,		RCC_HASH2CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP1,		RCC_CRYP1CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP2,		RCC_CRYP2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG1,		RCC_IWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG2,		RCC_IWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG3,		RCC_IWDG3CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG4,		RCC_IWDG4CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG1,		RCC_WWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_VREF,		RCC_VREFCFGR,		1,	0),
+	GATE_CFG(GATE_DTS,		RCC_DTSCFGR,		1,	0),
+	GATE_CFG(GATE_CRC,		RCC_CRCCFGR,		1,	0),
+	GATE_CFG(GATE_SERC,		RCC_SERCCFGR,		1,	0),
+	GATE_CFG(GATE_I3C1,		RCC_I3C1CFGR,		1,	0),
+	GATE_CFG(GATE_I3C2,		RCC_I3C2CFGR,		1,	0),
+	GATE_CFG(GATE_I3C3,		RCC_I3C3CFGR,		1,	0),
+};
+
+static int stm32_rcc_get_access(struct udevice *dev, u32 index)
+{
+	fdt_addr_t rcc_base = dev_read_addr(dev->parent);
+	u32 seccfgr, cidcfgr, semcr;
+	int bit, cid;
+
+	bit = index % RCC_REG_SIZE;
+
+	seccfgr = readl(rcc_base + RCC_SECCFGR(index));
+	if (seccfgr & BIT(bit))
+		return -EACCES;
+
+	cidcfgr = readl(rcc_base + RCC_CIDCFGR(index));
+	if (!(cidcfgr & RCC_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & RCC_CIDCFGR_SEM_EN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(RCC_CIDCFGR_SCID_MASK, cidcfgr);
+		if (cid != RCC_CID1)
+			return -EACCES;
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & RCC_CIDCFGR_SEMWLC1_EN))
+		return -EACCES;
+
+	semcr = readl(rcc_base + RCC_SEMCR(index));
+
+	cid = FIELD_GET(RCC_SEMCR_SEMCID_MASK, semcr);
+	if (cid != RCC_CID1)
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32mp21_check_security(struct udevice *dev, void __iomem *base,
+				    const struct clock_config *cfg)
+{
+	int ret = 0;
+
+	if (cfg->sec_id != SECF_NONE) {
+		u32 index = (u32)cfg->sec_id;
+
+		if (index & SEC_RIFSC_FLAG)
+			ret = stm32_rifsc_check_access_by_id(dev_ofnode(dev),
+							     index & ~SEC_RIFSC_FLAG);
+		else
+			ret = stm32_rcc_get_access(dev, index);
+	}
+
+	return ret;
+}
+
+#define STM32_COMPOSITE_NODIV(_id, _name, _flags, _sec_id, _gate_id, _mux_id)\
+	STM32_COMPOSITE(_id, _name, _flags, _sec_id, _gate_id, _mux_id, NO_STM32_DIV)
+
+static const struct clock_config stm32mp21_clock_cfg[] = {
+	/* ADC */
+	STM32_GATE(CK_BUS_ADC1, "ck_icn_p_adc1", "ck_icn_ls_mcu", 0, GATE_ADC1,
+		   SEC_RIFSC(58)),
+	STM32_COMPOSITE_NODIV(CK_KER_ADC1, "ck_ker_adc12", 0, SEC_RIFSC(58),
+			      GATE_ADC1, MUX_ADC1),
+	STM32_GATE(CK_BUS_ADC2, "ck_icn_p_adc2", "ck_icn_ls_mcu", 0, GATE_ADC2, SEC_RIFSC(59)),
+	STM32_COMPOSITE_NODIV(CK_KER_ADC2, "ck_ker_adc2", 0, SEC_RIFSC(59), GATE_ADC2, MUX_ADC2),
+
+	/*TODO: check csi gate for all clocks ? */
+	/* CSI-HOST */
+	STM32_GATE(CK_BUS_CSI, "ck_icn_p_csi", "ck_icn_apb4", 0, GATE_CSI, SEC_RIFSC(86)),
+	STM32_GATE(CK_KER_CSI, "ck_ker_csi", "ck_flexgen_29", 0, GATE_CSI, SEC_RIFSC(86)),
+	STM32_GATE(CK_KER_CSITXESC, "ck_ker_csitxesc", "ck_flexgen_30", 0, GATE_CSI,
+		   SEC_RIFSC(86)),
+
+	/* CSI-PHY */
+	STM32_GATE(CK_KER_CSIPHY, "ck_ker_csiphy", "ck_flexgen_31", 0, GATE_CSI,
+		   SEC_RIFSC(86)),
+
+	/* DCMIPP */
+	STM32_GATE(CK_BUS_DCMIPP, "ck_icn_p_dcmipp", "ck_icn_apb4", 0, GATE_DCMIPP,
+		   SEC_RIFSC(87)),
+
+	/* CRC */
+	STM32_GATE(CK_BUS_CRC, "ck_icn_p_crc", "ck_icn_ls_mcu", 0, GATE_CRC, SEC_RIFSC(109)),
+
+	/* CRYP */
+	STM32_GATE(CK_BUS_CRYP1, "ck_icn_p_cryp1", "ck_icn_ls_mcu", 0, GATE_CRYP1,
+		   SEC_RIFSC(96)),
+	STM32_GATE(CK_BUS_CRYP2, "ck_icn_p_cryp2", "ck_icn_ls_mcu", 0, GATE_CRYP2,
+		   SEC_RIFSC(97)),
+
+	/* DBG & TRACE*/
+	/* Trace and debug clocks are managed by SCMI */
+
+	/* Display subsystem */
+	/* LTDC */
+	STM32_GATE(CK_BUS_LTDC, "ck_icn_p_ltdc", "ck_icn_apb4", 0, GATE_LTDC, SEC_RIFSC(80)),
+	STM32_GATE(CK_KER_LTDC, "ck_ker_ltdc", "ck_flexgen_27", CLK_SET_RATE_PARENT, GATE_LTDC,
+		   SEC_RIFSC(80)),
+
+	/* DTS */
+	STM32_COMPOSITE_NODIV(CK_KER_DTS, "ck_ker_dts", 0, SEC_RIFSC(107), GATE_DTS, MUX_DTS),
+
+	/* ETHERNET */
+	STM32_GATE(CK_BUS_ETH1, "ck_icn_p_eth1", "ck_icn_ls_mcu", 0, GATE_ETH1, SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_STP, "ck_ker_eth1stp", "ck_icn_ls_mcu", 0, GATE_ETH1STP,
+		   SEC_RIFSC(60)),
+	STM32_GATE(CK_KER_ETH1, "ck_ker_eth1", "ck_flexgen_54", 0, GATE_ETH1, SEC_RIFSC(60)),
+	STM32_GATE(CK_KER_ETH1, "ck_ker_eth1ptp", "ck_flexgen_56", 0, GATE_ETH1, SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_MAC, "ck_ker_eth1mac", "ck_icn_ls_mcu", 0, GATE_ETH1MAC,
+		   SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_TX, "ck_ker_eth1tx", "ck_icn_ls_mcu", 0, GATE_ETH1TX, SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_RX, "ck_ker_eth1rx", "ck_icn_ls_mcu", 0, GATE_ETH1RX, SEC_RIFSC(60)),
+
+	STM32_GATE(CK_BUS_ETH2, "ck_icn_p_eth2", "ck_icn_ls_mcu", 0, GATE_ETH2, SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_STP, "ck_ker_eth2stp", "ck_icn_ls_mcu", 0, GATE_ETH2STP,
+		   SEC_RIFSC(61)),
+	STM32_GATE(CK_KER_ETH2, "ck_ker_eth2", "ck_flexgen_54", 0, GATE_ETH2, SEC_RIFSC(61)),
+	STM32_GATE(CK_KER_ETH2, "ck_ker_eth2ptp", "ck_flexgen_56", 0, GATE_ETH2, SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_MAC, "ck_ker_eth2mac", "ck_icn_ls_mcu", 0, GATE_ETH2MAC,
+		   SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_TX, "ck_ker_eth2tx", "ck_icn_ls_mcu", 0, GATE_ETH2TX, SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_RX, "ck_ker_eth2rx", "ck_icn_ls_mcu", 0, GATE_ETH2RX, SEC_RIFSC(61)),
+
+	/* FDCAN */
+	STM32_GATE(CK_BUS_FDCAN, "ck_icn_p_fdcan", "ck_icn_apb2", 0, GATE_FDCAN, SEC_RIFSC(56)),
+	STM32_GATE(CK_KER_FDCAN, "ck_ker_fdcan", "ck_flexgen_26", 0, GATE_FDCAN, SEC_RIFSC(56)),
+
+	/* HASH */
+	STM32_GATE(CK_BUS_HASH1, "ck_icn_p_hash1", "ck_icn_ls_mcu", 0, GATE_HASH1, SEC_RIFSC(90)),
+	STM32_GATE(CK_BUS_HASH2, "ck_icn_p_hash2", "ck_icn_ls_mcu", 0, GATE_HASH2, SEC_RIFSC(95)),
+
+	/* HDP */
+	STM32_GATE(CK_BUS_HDP, "ck_icn_p_hdp", "ck_icn_apb3", 0, GATE_HDP, SEC_RIFSC(57)),
+
+	/* I2C */
+	STM32_GATE(CK_KER_I2C1, "ck_ker_i2c1", "ck_flexgen_13", 0, GATE_I2C1, SEC_RIFSC(41)),
+	STM32_GATE(CK_KER_I2C2, "ck_ker_i2c2", "ck_flexgen_13", 0, GATE_I2C2, SEC_RIFSC(42)),
+	STM32_GATE(CK_KER_I2C3, "ck_ker_i2c3", "ck_flexgen_38", 0, GATE_I2C3, SEC_RIFSC(43)),
+
+	/* I3C */
+	STM32_GATE(CK_KER_I3C1, "ck_ker_i3c1", "ck_flexgen_14", 0, GATE_I3C1, SEC_RIFSC(114)),
+	STM32_GATE(CK_KER_I3C2, "ck_ker_i3c2", "ck_flexgen_14", 0, GATE_I3C2, SEC_RIFSC(115)),
+	STM32_GATE(CK_KER_I3C3, "ck_ker_i3c3", "ck_flexgen_36", 0, GATE_I3C3, SEC_RIFSC(116)),
+
+	/* IWDG */
+	STM32_GATE(CK_BUS_IWDG1, "ck_icn_p_iwdg1", "ck_icn_apb3", 0, GATE_IWDG1, SEC_RIFSC(98)),
+	STM32_GATE(CK_BUS_IWDG2, "ck_icn_p_iwdg2", "ck_icn_apb3", 0, GATE_IWDG2, SEC_RIFSC(99)),
+	STM32_GATE(CK_BUS_IWDG3, "ck_icn_p_iwdg3", "ck_icn_apb3", 0, GATE_IWDG3, SEC_RIFSC(100)),
+	STM32_GATE(CK_BUS_IWDG4, "ck_icn_p_iwdg4", "ck_icn_apb3", 0, GATE_IWDG4, SEC_RIFSC(101)),
+
+	/* LPTIM */
+	STM32_GATE(CK_KER_LPTIM1, "ck_ker_lptim1", "ck_flexgen_07", 0, GATE_LPTIM1,
+		   SEC_RIFSC(17)),
+	STM32_GATE(CK_KER_LPTIM2, "ck_ker_lptim2", "ck_flexgen_07", 0, GATE_LPTIM2,
+		   SEC_RIFSC(18)),
+	STM32_GATE(CK_KER_LPTIM3, "ck_ker_lptim3", "ck_flexgen_40", 0, GATE_LPTIM3,
+		   SEC_RIFSC(19)),
+	STM32_GATE(CK_KER_LPTIM4, "ck_ker_lptim4", "ck_flexgen_41", 0, GATE_LPTIM4,
+		   SEC_RIFSC(20)),
+	STM32_GATE(CK_KER_LPTIM5, "ck_ker_lptim5", "ck_flexgen_42", 0, GATE_LPTIM5,
+		   SEC_RIFSC(21)),
+
+	/* LPUART */
+	STM32_GATE(CK_KER_LPUART1, "ck_ker_lpuart1", "ck_flexgen_39", 0, GATE_LPUART1,
+		   SEC_RIFSC(40)),
+
+	/* MCO1 & MCO2 */
+	STM32_COMPOSITE_NODIV(CK_MCO1, "ck_mco1", 0, SEC_RIFRCC(MCO1), GATE_MCO1, MUX_MCO1),
+	STM32_COMPOSITE_NODIV(CK_MCO2, "ck_mco2", 0, SEC_RIFRCC(MCO2), GATE_MCO2, MUX_MCO2),
+
+	/* MDF */
+	STM32_GATE(CK_KER_MDF1, "ck_ker_mdf1", "ck_flexgen_21", 0, GATE_MDF1, SEC_RIFSC(54)),
+
+	/* PKA */
+	STM32_GATE(CK_BUS_PKA, "ck_icn_p_pka", "ck_icn_ls_mcu", 0, GATE_PKA, SEC_RIFSC(93)),
+
+	/* RNG */
+	STM32_GATE(CK_BUS_RNG1, "ck_icn_p_rng1", "ck_icn_ls_mcu", CLK_IGNORE_UNUSED, GATE_RNG1,
+		   SEC_RIFSC(89)),
+	STM32_GATE(CK_BUS_RNG2, "ck_icn_p_rng2", "ck_icn_ls_mcu", CLK_IGNORE_UNUSED, GATE_RNG2,
+		   SEC_RIFSC(92)),
+
+	/* SAES */
+	STM32_GATE(CK_BUS_SAES, "ck_icn_p_saes", "ck_icn_ls_mcu", 0, GATE_SAES, SEC_RIFSC(94)),
+
+	/* SAI [1..4] */
+	STM32_GATE(CK_BUS_SAI1, "ck_icn_p_sai1", "ck_icn_apb2", 0, GATE_SAI1, SEC_RIFSC(49)),
+	STM32_GATE(CK_BUS_SAI2, "ck_icn_p_sai2", "ck_icn_apb2", 0, GATE_SAI2, SEC_RIFSC(50)),
+	STM32_GATE(CK_BUS_SAI3, "ck_icn_p_sai3", "ck_icn_apb2", 0, GATE_SAI3, SEC_RIFSC(51)),
+	STM32_GATE(CK_BUS_SAI4, "ck_icn_p_sai4", "ck_icn_apb2", 0, GATE_SAI4, SEC_RIFSC(52)),
+	STM32_GATE(CK_KER_SAI1, "ck_ker_sai1", "ck_flexgen_22", 0, GATE_SAI1, SEC_RIFSC(49)),
+	STM32_GATE(CK_KER_SAI2, "ck_ker_sai2", "ck_flexgen_23", 0, GATE_SAI2, SEC_RIFSC(50)),
+	STM32_GATE(CK_KER_SAI3, "ck_ker_sai3", "ck_flexgen_24", 0, GATE_SAI3, SEC_RIFSC(51)),
+	STM32_GATE(CK_KER_SAI4, "ck_ker_sai4", "ck_flexgen_25", 0, GATE_SAI4, SEC_RIFSC(52)),
+
+	/* SDMMC */
+	STM32_GATE(CK_KER_SDMMC1, "ck_ker_sdmmc1", "ck_flexgen_51", 0, GATE_SDMMC1,
+		   SEC_RIFSC(76)),
+	STM32_GATE(CK_KER_SDMMC2, "ck_ker_sdmmc2", "ck_flexgen_52", 0, GATE_SDMMC2,
+		   SEC_RIFSC(77)),
+	STM32_GATE(CK_KER_SDMMC3, "ck_ker_sdmmc3", "ck_flexgen_53", 0, GATE_SDMMC3,
+		   SEC_RIFSC(78)),
+
+	/* SERC */
+	STM32_GATE(CK_BUS_SERC, "ck_icn_p_serc", "ck_icn_apb3", 0, GATE_SERC, SEC_RIFSC(110)),
+
+	/* SPDIF */
+	STM32_GATE(CK_KER_SPDIFRX, "ck_ker_spdifrx", "ck_flexgen_12", 0, GATE_SPDIFRX,
+		   SEC_RIFSC(30)),
+
+	/* SPI */
+	STM32_GATE(CK_KER_SPI1, "ck_ker_spi1", "ck_flexgen_16", 0, GATE_SPI1, SEC_RIFSC(22)),
+	STM32_GATE(CK_KER_SPI2, "ck_ker_spi2", "ck_flexgen_10", 0, GATE_SPI2, SEC_RIFSC(23)),
+	STM32_GATE(CK_KER_SPI3, "ck_ker_spi3", "ck_flexgen_11", 0, GATE_SPI3, SEC_RIFSC(24)),
+	STM32_GATE(CK_KER_SPI4, "ck_ker_spi4", "ck_flexgen_17", 0, GATE_SPI4, SEC_RIFSC(25)),
+	STM32_GATE(CK_KER_SPI5, "ck_ker_spi5", "ck_flexgen_17", 0, GATE_SPI5, SEC_RIFSC(26)),
+	STM32_GATE(CK_KER_SPI6, "ck_ker_spi6", "ck_flexgen_37", 0, GATE_SPI6, SEC_RIFSC(27)),
+
+	/* STGEN */
+	STM32_GATE(CK_KER_STGEN, "ck_ker_stgen", "ck_flexgen_33", CLK_IGNORE_UNUSED, GATE_STGEN,
+		   SEC_RIFSC(73)),
+
+	/* Timers */
+	STM32_GATE(CK_KER_TIM2, "ck_ker_tim2", "timg1_ck", 0, GATE_TIM2, SEC_RIFSC(1)),
+	STM32_GATE(CK_KER_TIM3, "ck_ker_tim3", "timg1_ck", 0, GATE_TIM3, SEC_RIFSC(2)),
+	STM32_GATE(CK_KER_TIM4, "ck_ker_tim4", "timg1_ck", 0, GATE_TIM4, SEC_RIFSC(3)),
+	STM32_GATE(CK_KER_TIM5, "ck_ker_tim5", "timg1_ck", 0, GATE_TIM5, SEC_RIFSC(4)),
+	STM32_GATE(CK_KER_TIM6, "ck_ker_tim6", "timg1_ck", 0, GATE_TIM6, SEC_RIFSC(5)),
+	STM32_GATE(CK_KER_TIM7, "ck_ker_tim7", "timg1_ck", 0, GATE_TIM7, SEC_RIFSC(6)),
+	STM32_GATE(CK_KER_TIM10, "ck_ker_tim10", "timg1_ck", 0, GATE_TIM10, SEC_RIFSC(8)),
+	STM32_GATE(CK_KER_TIM11, "ck_ker_tim11", "timg1_ck", 0, GATE_TIM11, SEC_RIFSC(9)),
+	STM32_GATE(CK_KER_TIM12, "ck_ker_tim12", "timg1_ck", 0, GATE_TIM12, SEC_RIFSC(10)),
+	STM32_GATE(CK_KER_TIM13, "ck_ker_tim13", "timg1_ck", 0, GATE_TIM13, SEC_RIFSC(11)),
+	STM32_GATE(CK_KER_TIM14, "ck_ker_tim14", "timg1_ck", 0, GATE_TIM14, SEC_RIFSC(12)),
+
+	STM32_GATE(CK_KER_TIM1, "ck_ker_tim1", "timg2_ck", 0, GATE_TIM1, SEC_RIFSC(0)),
+	STM32_GATE(CK_KER_TIM8, "ck_ker_tim8", "timg2_ck", 0, GATE_TIM8, SEC_RIFSC(7)),
+	STM32_GATE(CK_KER_TIM15, "ck_ker_tim15", "timg2_ck", 0, GATE_TIM15, SEC_RIFSC(13)),
+	STM32_GATE(CK_KER_TIM16, "ck_ker_tim16", "timg2_ck", 0, GATE_TIM16, SEC_RIFSC(14)),
+	STM32_GATE(CK_KER_TIM17, "ck_ker_tim17", "timg2_ck", 0, GATE_TIM17, SEC_RIFSC(15)),
+
+	/* UART/USART */
+	STM32_GATE(CK_KER_USART2, "ck_ker_usart2", "ck_flexgen_08", 0, GATE_USART2,
+		   SEC_RIFSC(32)),
+	STM32_GATE(CK_KER_UART4, "ck_ker_uart4", "ck_flexgen_08", 0, GATE_UART4,
+		   SEC_RIFSC(34)),
+	STM32_GATE(CK_KER_USART3, "ck_ker_usart3", "ck_flexgen_09", 0, GATE_USART3,
+		   SEC_RIFSC(33)),
+	STM32_GATE(CK_KER_UART5, "ck_ker_uart5", "ck_flexgen_09", 0, GATE_UART5,
+		   SEC_RIFSC(35)),
+	STM32_GATE(CK_KER_USART1, "ck_ker_usart1", "ck_flexgen_18", 0, GATE_USART1,
+		   SEC_RIFSC(31)),
+	STM32_GATE(CK_KER_USART6, "ck_ker_usart6", "ck_flexgen_19", 0, GATE_USART6,
+		   SEC_RIFSC(36)),
+	STM32_GATE(CK_KER_UART7, "ck_ker_uart7", "ck_flexgen_20", 0, GATE_UART7,
+		   SEC_RIFSC(37)),
+
+	/* USB2PHY1 */
+	STM32_COMPOSITE_NODIV(CK_KER_USB2PHY1, "ck_ker_usb2phy1", 0, SEC_RIFSC(63),
+			      GATE_USB2PHY1, MUX_USB2PHY1),
+
+	/* USB2H */
+	STM32_GATE(CK_BUS_USBHOHCI, "ck_icn_m_usbhohci", "ck_icn_hsl", 0, GATE_USBH,
+		   SEC_RIFSC(63)),
+	STM32_GATE(CK_BUS_USBHEHCI, "ck_icn_m_usbhehci", "ck_icn_hsl", 0, GATE_USBH,
+		   SEC_RIFSC(63)),
+
+	/* USBOTG */
+	STM32_GATE(CK_BUS_OTG, "ck_icn_m_otg", "ck_icn_hsl", 0, GATE_USBOTG,
+		   SEC_RIFSC(66)),
+
+	/* USB2PHY2 */
+	STM32_COMPOSITE_NODIV(CK_KER_USB2PHY2EN, "ck_ker_usb2phy2_en", 0, SEC_RIFSC(66),
+			      GATE_USB2PHY2, MUX_USB2PHY2),
+
+	/* VREF */
+	STM32_GATE(CK_BUS_VREF, "ck_icn_p_vref", "ck_icn_apb3", 0, RCC_VREFCFGR,
+		   SEC_RIFSC(106)),
+
+	/* WWDG */
+	STM32_GATE(CK_BUS_WWDG1, "ck_icn_p_wwdg1", "ck_icn_apb3", 0, GATE_WWDG1,
+		   SEC_RIFSC(103)),
+};
+
+static const struct stm32_clock_match_data stm32mp21_data = {
+	.tab_clocks	= stm32mp21_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp21_clock_cfg),
+	.clock_data = &(const struct clk_stm32_clock_data) {
+		.num_gates	= ARRAY_SIZE(stm32mp21_gates),
+		.gates		= stm32mp21_gates,
+		.muxes		= stm32mp21_muxes,
+	},
+	.check_security = stm32mp21_check_security,
+
+};
+
+static int stm32mp21_clk_probe(struct udevice *dev)
+{
+	fdt_addr_t base = dev_read_addr(dev->parent);
+	struct udevice *scmi;
+
+	if (base == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	/* force SCMI probe to register all SCMI clocks */
+	uclass_get_device_by_driver(UCLASS_CLK, DM_DRIVER_GET(scmi_clock), &scmi);
+
+	stm32_rcc_init(dev, &stm32mp21_data);
+
+	return 0;
+}
+
+U_BOOT_DRIVER(stm32mp21_clock) = {
+	.name = "stm32mp21_clk",
+	.id = UCLASS_CLK,
+	.ops = &stm32_clk_ops,
+	.priv_auto = sizeof(struct stm32mp_rcc_priv),
+	.probe = stm32mp21_clk_probe,
+};
diff --git a/drivers/clk/stm32/clk-stm32mp25.c b/drivers/clk/stm32/clk-stm32mp25.c
new file mode 100644
index 0000000000..754929c890
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp25.c
@@ -0,0 +1,785 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <clk-uclass.h>
+#include <common.h>
+#include <dm.h>
+#include <dt-bindings/clock/st,stm32mp25-rcc.h>
+#include <linux/bitfield.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <mach/rif.h>
+
+#include "clk-stm32-core.h"
+#include "stm32mp25_rcc.h"
+
+/* Clock security definition */
+#define SECF_NONE		-1
+
+#define RCC_REG_SIZE	32
+#define RCC_SECCFGR(x)	(((x) / RCC_REG_SIZE) * 0x4 + RCC_SECCFGR0)
+#define RCC_CIDCFGR(x)	((x) * 0x8 + RCC_R0CIDCFGR)
+#define RCC_SEMCR(x)	((x) * 0x8 + RCC_R0SEMCR)
+#define RCC_CID1	1
+
+/* Register: RIFSC_CIDCFGR */
+#define RCC_CIDCFGR_CFEN	BIT(0)
+#define RCC_CIDCFGR_SEM_EN	BIT(1)
+#define RCC_CIDCFGR_SEMWLC1_EN	BIT(17)
+#define RCC_CIDCFGR_SCID_MASK	GENMASK(6, 4)
+
+/* Register: RIFSC_SEMCR */
+#define RCC_SEMCR_SEMCID_MASK	GENMASK(6, 4)
+
+#define STM32MP25_RIFRCC_DBG_ID		73
+#define STM32MP25_RIFRCC_IS2M_ID	107
+#define STM32MP25_RIFRCC_MCO1_ID	108
+#define STM32MP25_RIFRCC_MCO2_ID	109
+#define STM32MP25_RIFRCC_OSPI1_ID	110
+#define STM32MP25_RIFRCC_OSPI2_ID	111
+
+#define SEC_RIFSC_FLAG		BIT(31)
+#define SEC_RIFRCC(_id)		(STM32MP25_RIFRCC_##_id##_ID)
+#define SEC_RIFSC(_id)		((_id) | SEC_RIFSC_FLAG)
+
+static const char * const adc12_src[] = {
+	"ck_flexgen_46", "ck_icn_ls_mcu"
+};
+
+static const char * const adc3_src[] = {
+	"ck_flexgen_47", "ck_icn_ls_mcu", "ck_flexgen_46"
+};
+
+static const char * const usb2phy1_src[] = {
+	"ck_flexgen_57", "hse_div2_ck"
+};
+
+static const char * const usb2phy2_src[] = {
+	"ck_flexgen_58", "hse_div2_ck"
+};
+
+static const char * const usb3pciphy_src[] = {
+	"ck_flexgen_34", "hse_div2_ck"
+};
+
+static const char * const dsiblane_src[] = {
+	"txbyteclk", "ck_ker_ltdc"
+};
+
+static const char * const dsiphy_src[] = {
+	"ck_flexgen_28", "hse_ck"
+};
+
+static const char * const lvdsphy_src[] = {
+	"ck_flexgen_32", "hse_ck"
+};
+
+static const char * const dts_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const mco1_src[] = {
+	"ck_flexgen_61", "ck_obs0"
+};
+
+static const char * const mco2_src[] = {
+	"ck_flexgen_62", "ck_obs1"
+};
+
+enum enum_mux_cfg {
+	MUX_MCO1,
+	MUX_MCO2,
+	MUX_ADC12,
+	MUX_ADC3,
+	MUX_USB2PHY1,
+	MUX_USB2PHY2,
+	MUX_USB3PCIEPHY,
+	MUX_DSIBLANE,
+	MUX_DSIPHY,
+	MUX_LVDSPHY,
+	MUX_DTS,
+	MUX_NB
+};
+
+#define MUX_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+		.num_parents	= ARRAY_SIZE(src),\
+		.parent_names	= src,\
+		.reg_off	= (_offset),\
+		.shift		= (_shift),\
+		.width		= (_witdh),\
+}
+
+static const struct stm32_mux_cfg stm32mp25_muxes[MUX_NB] = {
+	MUX_CFG(MUX_ADC12,		adc12_src,	RCC_ADC12CFGR,		12,	1),
+	MUX_CFG(MUX_ADC3,		adc3_src,	RCC_ADC3CFGR,		12,	2),
+	MUX_CFG(MUX_DSIBLANE,		dsiblane_src,	RCC_DSICFGR,		12,	1),
+	MUX_CFG(MUX_DSIPHY,		dsiphy_src,	RCC_DSICFGR,		15,	1),
+	MUX_CFG(MUX_DTS,		dts_src,	RCC_DTSCFGR,		12,	2),
+	MUX_CFG(MUX_MCO1,		mco1_src,	RCC_MCO1CFGR,		0,	1),
+	MUX_CFG(MUX_MCO2,		mco2_src,	RCC_MCO2CFGR,		0,	1),
+	MUX_CFG(MUX_LVDSPHY,		lvdsphy_src,	RCC_LVDSCFGR,		15,	1),
+	MUX_CFG(MUX_USB2PHY1,		usb2phy1_src,	RCC_USB2PHY1CFGR,	15,	1),
+	MUX_CFG(MUX_USB2PHY2,		usb2phy2_src,	RCC_USB2PHY2CFGR,	15,	1),
+	MUX_CFG(MUX_USB3PCIEPHY,	usb3pciphy_src,	RCC_USB3PCIEPHYCFGR,	15,	1),
+};
+
+enum enum_gate_cfg {
+	GATE_ADC12,
+	GATE_ADC3,
+	GATE_ADF1,
+	GATE_CCI,
+	GATE_CRC,
+	GATE_CRYP1,
+	GATE_CRYP2,
+	GATE_CSI,
+	GATE_DBG,
+	GATE_DCMIPP,
+	GATE_DSI,
+	GATE_DTS,
+	GATE_ETH1,
+	GATE_ETH1MAC,
+	GATE_ETH1RX,
+	GATE_ETH1STP,
+	GATE_ETH1TX,
+	GATE_ETH2,
+	GATE_ETH2MAC,
+	GATE_ETH2RX,
+	GATE_ETH2STP,
+	GATE_ETH2TX,
+	GATE_ETHSW,
+	GATE_ETHSWMAC,
+	GATE_ETHSWREF,
+	GATE_ETR,
+	GATE_FDCAN,
+	GATE_GPU,
+	GATE_HASH,
+	GATE_HDP,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_I2C7,
+	GATE_I2C8,
+	GATE_I3C1,
+	GATE_I3C2,
+	GATE_I3C3,
+	GATE_I3C4,
+	GATE_IS2M,
+	GATE_IWDG1,
+	GATE_IWDG2,
+	GATE_IWDG3,
+	GATE_IWDG4,
+	GATE_IWDG5,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_LPUART1,
+	GATE_LTDC,
+	GATE_LVDS,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_MDF1,
+	GATE_OSPI1,
+	GATE_OSPI2,
+	GATE_OSPIIOM,
+	GATE_PCIE,
+	GATE_PKA,
+	GATE_RNG,
+	GATE_SAES,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_SERC,
+	GATE_SPDIFRX,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPI7,
+	GATE_SPI8,
+	GATE_STGEN,
+	GATE_STM500,
+	GATE_TIM1,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM8,
+	GATE_TIM10,
+	GATE_TIM11,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_TIM20,
+	GATE_TRACE,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_UART9,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_USART3,
+	GATE_USART6,
+	GATE_USB2,
+	GATE_USB2PHY1,
+	GATE_USB2PHY2,
+	GATE_USB3DR,
+	GATE_USB3PCIEPHY,
+	GATE_USBTC,
+	GATE_VDEC,
+	GATE_VENC,
+	GATE_VREF,
+	GATE_WWDG1,
+	GATE_WWDG2,
+	GATE_NB
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)[id] = {\
+	.reg_off	= (_offset),\
+	.bit_idx	= (_bit_idx),\
+	.set_clr	= (_offset_clr),\
+}
+
+static const struct stm32_gate_cfg stm32mp25_gates[GATE_NB] = {
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,		8,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,		8,	0),
+	GATE_CFG(GATE_OSPI1,		RCC_OSPI1CFGR,		1,	0),
+	GATE_CFG(GATE_OSPI2,		RCC_OSPI2CFGR,		1,	0),
+	GATE_CFG(GATE_DBG,		RCC_DBGCFGR,		8,	0),
+	GATE_CFG(GATE_TRACE,		RCC_DBGCFGR,		9,	0),
+	GATE_CFG(GATE_STM500,		RCC_STM500CFGR,		1,	0),
+	GATE_CFG(GATE_ETR,		RCC_ETRCFGR,		1,	0),
+	GATE_CFG(GATE_IS2M,		RCC_IS2MCFGR,		1,	0),
+	GATE_CFG(GATE_TIM1,		RCC_TIM1CFGR,		1,	0),
+	GATE_CFG(GATE_TIM2,		RCC_TIM2CFGR,		1,	0),
+	GATE_CFG(GATE_TIM3,		RCC_TIM3CFGR,		1,	0),
+	GATE_CFG(GATE_TIM4,		RCC_TIM4CFGR,		1,	0),
+	GATE_CFG(GATE_TIM5,		RCC_TIM5CFGR,		1,	0),
+	GATE_CFG(GATE_TIM6,		RCC_TIM6CFGR,		1,	0),
+	GATE_CFG(GATE_TIM7,		RCC_TIM7CFGR,		1,	0),
+	GATE_CFG(GATE_TIM8,		RCC_TIM8CFGR,		1,	0),
+	GATE_CFG(GATE_TIM10,		RCC_TIM10CFGR,		1,	0),
+	GATE_CFG(GATE_TIM11,		RCC_TIM11CFGR,		1,	0),
+	GATE_CFG(GATE_TIM12,		RCC_TIM12CFGR,		1,	0),
+	GATE_CFG(GATE_TIM13,		RCC_TIM13CFGR,		1,	0),
+	GATE_CFG(GATE_TIM14,		RCC_TIM14CFGR,		1,	0),
+	GATE_CFG(GATE_TIM15,		RCC_TIM15CFGR,		1,	0),
+	GATE_CFG(GATE_TIM16,		RCC_TIM16CFGR,		1,	0),
+	GATE_CFG(GATE_TIM17,		RCC_TIM17CFGR,		1,	0),
+	GATE_CFG(GATE_TIM20,		RCC_TIM20CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM1,		RCC_LPTIM1CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM2,		RCC_LPTIM2CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3,		RCC_LPTIM3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM4,		RCC_LPTIM4CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM5,		RCC_LPTIM5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI1,		RCC_SPI1CFGR,		1,	0),
+	GATE_CFG(GATE_SPI2,		RCC_SPI2CFGR,		1,	0),
+	GATE_CFG(GATE_SPI3,		RCC_SPI3CFGR,		1,	0),
+	GATE_CFG(GATE_SPI4,		RCC_SPI4CFGR,		1,	0),
+	GATE_CFG(GATE_SPI5,		RCC_SPI5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI6,		RCC_SPI6CFGR,		1,	0),
+	GATE_CFG(GATE_SPI7,		RCC_SPI7CFGR,		1,	0),
+	GATE_CFG(GATE_SPI8,		RCC_SPI8CFGR,		1,	0),
+	GATE_CFG(GATE_SPDIFRX,		RCC_SPDIFRXCFGR,	1,	0),
+	GATE_CFG(GATE_USART1,		RCC_USART1CFGR,		1,	0),
+	GATE_CFG(GATE_USART2,		RCC_USART2CFGR,		1,	0),
+	GATE_CFG(GATE_USART3,		RCC_USART3CFGR,		1,	0),
+	GATE_CFG(GATE_UART4,		RCC_UART4CFGR,		1,	0),
+	GATE_CFG(GATE_UART5,		RCC_UART5CFGR,		1,	0),
+	GATE_CFG(GATE_USART6,		RCC_USART6CFGR,		1,	0),
+	GATE_CFG(GATE_UART7,		RCC_UART7CFGR,		1,	0),
+	GATE_CFG(GATE_UART8,		RCC_UART8CFGR,		1,	0),
+	GATE_CFG(GATE_UART9,		RCC_UART9CFGR,		1,	0),
+	GATE_CFG(GATE_LPUART1,		RCC_LPUART1CFGR,	1,	0),
+	GATE_CFG(GATE_I2C1,		RCC_I2C1CFGR,		1,	0),
+	GATE_CFG(GATE_I2C2,		RCC_I2C2CFGR,		1,	0),
+	GATE_CFG(GATE_I2C3,		RCC_I2C3CFGR,		1,	0),
+	GATE_CFG(GATE_I2C4,		RCC_I2C4CFGR,		1,	0),
+	GATE_CFG(GATE_I2C5,		RCC_I2C5CFGR,		1,	0),
+	GATE_CFG(GATE_I2C6,		RCC_I2C6CFGR,		1,	0),
+	GATE_CFG(GATE_I2C7,		RCC_I2C7CFGR,		1,	0),
+	GATE_CFG(GATE_I2C8,		RCC_I2C8CFGR,		1,	0),
+	GATE_CFG(GATE_SAI1,		RCC_SAI1CFGR,		1,	0),
+	GATE_CFG(GATE_SAI2,		RCC_SAI2CFGR,		1,	0),
+	GATE_CFG(GATE_SAI3,		RCC_SAI3CFGR,		1,	0),
+	GATE_CFG(GATE_SAI4,		RCC_SAI4CFGR,		1,	0),
+	GATE_CFG(GATE_MDF1,		RCC_MDF1CFGR,		1,	0),
+	GATE_CFG(GATE_ADF1,		RCC_ADF1CFGR,		1,	0),
+	GATE_CFG(GATE_FDCAN,		RCC_FDCANCFGR,		1,	0),
+	GATE_CFG(GATE_HDP,		RCC_HDPCFGR,		1,	0),
+	GATE_CFG(GATE_ADC12,		RCC_ADC12CFGR,		1,	0),
+	GATE_CFG(GATE_ADC3,		RCC_ADC3CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1MAC,		RCC_ETH1CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1STP,		RCC_ETH1CFGR,		4,	0),
+	GATE_CFG(GATE_ETH1,		RCC_ETH1CFGR,		5,	0),
+	GATE_CFG(GATE_ETH1TX,		RCC_ETH1CFGR,		8,	0),
+	GATE_CFG(GATE_ETH1RX,		RCC_ETH1CFGR,		10,	0),
+	GATE_CFG(GATE_ETH2MAC,		RCC_ETH2CFGR,		1,	0),
+	GATE_CFG(GATE_ETH2STP,		RCC_ETH2CFGR,		4,	0),
+	GATE_CFG(GATE_ETH2,		RCC_ETH2CFGR,		5,	0),
+	GATE_CFG(GATE_ETH2TX,		RCC_ETH2CFGR,		8,	0),
+	GATE_CFG(GATE_ETH2RX,		RCC_ETH2CFGR,		10,	0),
+	GATE_CFG(GATE_USB2,		RCC_USB2CFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY1,		RCC_USB2PHY1CFGR,	1,	0),
+	GATE_CFG(GATE_USB2PHY2,		RCC_USB2PHY2CFGR,	1,	0),
+	GATE_CFG(GATE_USB3DR,		RCC_USB3DRCFGR,		1,	0),
+	GATE_CFG(GATE_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	1,	0),
+	GATE_CFG(GATE_PCIE,		RCC_PCIECFGR,		1,	0),
+	GATE_CFG(GATE_USBTC,		RCC_USBTCCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSWMAC,		RCC_ETHSWCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSW,		RCC_ETHSWCFGR,		5,	0),
+	GATE_CFG(GATE_ETHSWREF,		RCC_ETHSWCFGR,		21,	0),
+	GATE_CFG(GATE_STGEN,		RCC_STGENCFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC1,		RCC_SDMMC1CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC2,		RCC_SDMMC2CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC3,		RCC_SDMMC3CFGR,		1,	0),
+	GATE_CFG(GATE_GPU,		RCC_GPUCFGR,		1,	0),
+	GATE_CFG(GATE_LTDC,		RCC_LTDCCFGR,		1,	0),
+	GATE_CFG(GATE_DSI,		RCC_DSICFGR,		1,	0),
+	GATE_CFG(GATE_LVDS,		RCC_LVDSCFGR,		1,	0),
+	GATE_CFG(GATE_CSI,		RCC_CSICFGR,		1,	0),
+	GATE_CFG(GATE_DCMIPP,		RCC_DCMIPPCFGR,		1,	0),
+	GATE_CFG(GATE_CCI,		RCC_CCICFGR,		1,	0),
+	GATE_CFG(GATE_VDEC,		RCC_VDECCFGR,		1,	0),
+	GATE_CFG(GATE_VENC,		RCC_VENCCFGR,		1,	0),
+	GATE_CFG(GATE_RNG,		RCC_RNGCFGR,		1,	0),
+	GATE_CFG(GATE_PKA,		RCC_PKACFGR,		1,	0),
+	GATE_CFG(GATE_SAES,		RCC_SAESCFGR,		1,	0),
+	GATE_CFG(GATE_HASH,		RCC_HASHCFGR,		1,	0),
+	GATE_CFG(GATE_CRYP1,		RCC_CRYP1CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP2,		RCC_CRYP2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG1,		RCC_IWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG2,		RCC_IWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG3,		RCC_IWDG3CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG4,		RCC_IWDG4CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG5,		RCC_IWDG5CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG1,		RCC_WWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG2,		RCC_WWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_VREF,		RCC_VREFCFGR,		1,	0),
+	GATE_CFG(GATE_DTS,		RCC_DTSCFGR,		1,	0),
+	GATE_CFG(GATE_CRC,		RCC_CRCCFGR,		1,	0),
+	GATE_CFG(GATE_SERC,		RCC_SERCCFGR,		1,	0),
+	GATE_CFG(GATE_OSPIIOM,		RCC_OSPIIOMCFGR,	1,	0),
+	GATE_CFG(GATE_I3C1,		RCC_I3C1CFGR,		1,	0),
+	GATE_CFG(GATE_I3C2,		RCC_I3C2CFGR,		1,	0),
+	GATE_CFG(GATE_I3C3,		RCC_I3C3CFGR,		1,	0),
+	GATE_CFG(GATE_I3C4,		RCC_I3C4CFGR,		1,	0),
+};
+
+static int stm32_rcc_get_access(struct udevice *dev, u32 index)
+{
+	fdt_addr_t rcc_base = dev_read_addr(dev->parent);
+	u32 seccfgr, cidcfgr, semcr;
+	int bit, cid;
+
+	bit = index % RCC_REG_SIZE;
+
+	seccfgr = readl(rcc_base + RCC_SECCFGR(index));
+	if (seccfgr & BIT(bit))
+		return -EACCES;
+
+	cidcfgr = readl(rcc_base + RCC_CIDCFGR(index));
+	if (!(cidcfgr & RCC_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & RCC_CIDCFGR_SEM_EN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(RCC_CIDCFGR_SCID_MASK, cidcfgr);
+		if (cid != RCC_CID1)
+			return -EACCES;
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & RCC_CIDCFGR_SEMWLC1_EN))
+		return -EACCES;
+
+	semcr = readl(rcc_base + RCC_SEMCR(index));
+
+	cid = FIELD_GET(RCC_SEMCR_SEMCID_MASK, semcr);
+	if (cid != RCC_CID1)
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32mp25_check_security(struct udevice *dev, void __iomem *base,
+				    const struct clock_config *cfg)
+{
+	int ret = 0;
+
+	if (cfg->sec_id != SECF_NONE) {
+		u32 index = (u32)cfg->sec_id;
+
+		if (index & SEC_RIFSC_FLAG)
+			ret = stm32_rifsc_check_access_by_id(dev_ofnode(dev),
+							     index & ~SEC_RIFSC_FLAG);
+		else
+			ret = stm32_rcc_get_access(dev, index);
+	}
+
+	return ret;
+}
+
+#define STM32_COMPOSITE_NODIV(_id, _name, _flags, _sec_id, _gate_id, _mux_id)\
+	STM32_COMPOSITE(_id, _name, _flags, _sec_id, _gate_id, _mux_id, NO_STM32_DIV)
+
+static const struct clock_config stm32mp25_clock_cfg[] = {
+	/* ADC */
+	STM32_GATE(CK_BUS_ADC12, "ck_icn_p_adc12", "ck_icn_ls_mcu", 0, GATE_ADC12,
+		   SEC_RIFSC(58)),
+	STM32_COMPOSITE_NODIV(CK_KER_ADC12, "ck_ker_adc12", 0, SEC_RIFSC(58),
+			      GATE_ADC12, MUX_ADC12),
+	STM32_GATE(CK_BUS_ADC3, "ck_icn_p_adc3", "ck_icn_ls_mcu", 0, GATE_ADC3, SEC_RIFSC(59)),
+	STM32_COMPOSITE_NODIV(CK_KER_ADC3, "ck_ker_adc3", 0, SEC_RIFSC(59), GATE_ADC3, MUX_ADC3),
+
+	/* ADF */
+	STM32_GATE(CK_BUS_ADF1, "ck_icn_p_adf1", "ck_icn_ls_mcu", 0, GATE_ADF1, SEC_RIFSC(55)),
+	STM32_GATE(CK_KER_ADF1, "ck_ker_adf1", "ck_flexgen_42", 0, GATE_ADF1, SEC_RIFSC(55)),
+
+	/* Camera */
+	/* DCMI */
+	STM32_GATE(CK_BUS_CCI, "ck_icn_p_cci", "ck_icn_ls_mcu", 0, GATE_CCI, SEC_RIFSC(88)),
+
+	/*TODO: check csi gate for all clocks ? */
+	/* CSI-HOST */
+	STM32_GATE(CK_BUS_CSI, "ck_icn_p_csi", "ck_icn_apb4", 0, GATE_CSI, SEC_RIFSC(86)),
+	STM32_GATE(CK_KER_CSI, "ck_ker_csi", "ck_flexgen_29", 0, GATE_CSI, SEC_RIFSC(86)),
+	STM32_GATE(CK_KER_CSITXESC, "ck_ker_csitxesc", "ck_flexgen_30", 0, GATE_CSI,
+		   SEC_RIFSC(86)),
+
+	/* CSI-PHY */
+	STM32_GATE(CK_KER_CSIPHY, "ck_ker_csiphy", "ck_flexgen_31", 0, GATE_CSI,
+		   SEC_RIFSC(86)),
+
+	/* DCMIPP */
+	STM32_GATE(CK_BUS_DCMIPP, "ck_icn_p_dcmipp", "ck_icn_apb4", 0, GATE_DCMIPP,
+		   SEC_RIFSC(87)),
+
+	/* CRC */
+	STM32_GATE(CK_BUS_CRC, "ck_icn_p_crc", "ck_icn_ls_mcu", 0, GATE_CRC, SEC_RIFSC(109)),
+
+	/* CRYP */
+	STM32_GATE(CK_BUS_CRYP1, "ck_icn_p_cryp1", "ck_icn_ls_mcu", 0, GATE_CRYP1,
+		   SEC_RIFSC(96)),
+	STM32_GATE(CK_BUS_CRYP2, "ck_icn_p_cryp2", "ck_icn_ls_mcu", 0, GATE_CRYP2,
+		   SEC_RIFSC(97)),
+
+	/* DBG & TRACE*/
+	/* Trace and debug clocks are managed by SCMI */
+
+	/* Display subsystem */
+	/* LTDC */
+	STM32_GATE(CK_BUS_LTDC, "ck_icn_p_ltdc", "ck_icn_apb4", 0, GATE_LTDC, SEC_RIFSC(80)),
+	STM32_GATE(CK_KER_LTDC, "ck_ker_ltdc", "ck_flexgen_27", CLK_SET_RATE_PARENT, GATE_LTDC,
+		   SEC_RIFSC(80)),
+
+	/* DSI */
+	STM32_GATE(CK_BUS_DSI, "ck_icn_p_dsi", "ck_icn_apb4", 0, GATE_DSI, SEC_RIFSC(81)),
+	STM32_COMPOSITE_NODIV(CK_KER_DSIBLANE, "clk_lanebyte", 0, SEC_RIFSC(81),
+			      GATE_DSI, MUX_DSIBLANE),
+
+	/* LVDS */
+	STM32_GATE(CK_BUS_LVDS, "ck_icn_p_lvds", "ck_icn_apb4", 0, GATE_LVDS, SEC_RIFSC(84)),
+
+	/* DSI PHY */
+	STM32_COMPOSITE_NODIV(CK_KER_DSIPHY, "ck_ker_dsiphy", 0, SEC_RIFSC(81),
+			      GATE_DSI, MUX_DSIPHY),
+
+	/* LVDS PHY */
+	STM32_COMPOSITE_NODIV(CK_KER_LVDSPHY, "ck_ker_lvdsphy", 0, SEC_RIFSC(84),
+			      GATE_LVDS, MUX_LVDSPHY),
+
+	/* DTS */
+	STM32_COMPOSITE_NODIV(CK_KER_DTS, "ck_ker_dts", 0, SEC_RIFSC(107), GATE_DTS, MUX_DTS),
+
+	/* ETHERNET */
+	STM32_GATE(CK_BUS_ETH1, "ck_icn_p_eth1", "ck_icn_ls_mcu", 0, GATE_ETH1, SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_STP, "ck_ker_eth1stp", "ck_icn_ls_mcu", 0, GATE_ETH1STP,
+		   SEC_RIFSC(60)),
+	STM32_GATE(CK_KER_ETH1, "ck_ker_eth1", "ck_flexgen_54", 0, GATE_ETH1, SEC_RIFSC(60)),
+	STM32_GATE(CK_KER_ETH1, "ck_ker_eth1ptp", "ck_flexgen_56", 0, GATE_ETH1, SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_MAC, "ck_ker_eth1mac", "ck_icn_ls_mcu", 0, GATE_ETH1MAC,
+		   SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_TX, "ck_ker_eth1tx", "ck_icn_ls_mcu", 0, GATE_ETH1TX, SEC_RIFSC(60)),
+	STM32_GATE(CK_ETH1_RX, "ck_ker_eth1rx", "ck_icn_ls_mcu", 0, GATE_ETH1RX, SEC_RIFSC(60)),
+
+	STM32_GATE(CK_BUS_ETH2, "ck_icn_p_eth2", "ck_icn_ls_mcu", 0, GATE_ETH2, SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_STP, "ck_ker_eth2stp", "ck_icn_ls_mcu", 0, GATE_ETH2STP,
+		   SEC_RIFSC(61)),
+	STM32_GATE(CK_KER_ETH2, "ck_ker_eth2", "ck_flexgen_54", 0, GATE_ETH2, SEC_RIFSC(61)),
+	STM32_GATE(CK_KER_ETH2, "ck_ker_eth2ptp", "ck_flexgen_56", 0, GATE_ETH2, SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_MAC, "ck_ker_eth2mac", "ck_icn_ls_mcu", 0, GATE_ETH2MAC,
+		   SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_TX, "ck_ker_eth2tx", "ck_icn_ls_mcu", 0, GATE_ETH2TX, SEC_RIFSC(61)),
+	STM32_GATE(CK_ETH2_RX, "ck_ker_eth2rx", "ck_icn_ls_mcu", 0, GATE_ETH2RX, SEC_RIFSC(61)),
+
+	STM32_GATE(CK_BUS_ETHSW, "ck_icn_p_ethsw", "ck_icn_ls_mcu", 0, GATE_ETHSWMAC,
+		   SEC_RIFSC(70)),
+	STM32_GATE(CK_KER_ETHSW, "ck_ker_ethsw", "ck_flexgen_54", 0, GATE_ETHSW,
+		   SEC_RIFSC(70)),
+	STM32_GATE(CK_KER_ETHSWREF, "ck_ker_ethswref", "ck_flexgen_60", 0, GATE_ETHSWREF,
+		   SEC_RIFSC(70)),
+
+	/* FDCAN */
+	STM32_GATE(CK_BUS_FDCAN, "ck_icn_p_fdcan", "ck_icn_apb2", 0, GATE_FDCAN, SEC_RIFSC(56)),
+	STM32_GATE(CK_KER_FDCAN, "ck_ker_fdcan", "ck_flexgen_26", 0, GATE_FDCAN, SEC_RIFSC(56)),
+
+	/* GPU */
+	STM32_GATE(CK_BUS_GPU, "ck_icn_m_gpu", "ck_flexgen_59", 0, GATE_GPU, SEC_RIFSC(79)),
+	STM32_GATE(CK_KER_GPU, "ck_ker_gpu", "ck_pll3", 0, GATE_GPU, SEC_RIFSC(79)),
+
+	/* HASH */
+	STM32_GATE(CK_BUS_HASH, "ck_icn_p_hash", "ck_icn_ls_mcu", 0, GATE_HASH, SEC_RIFSC(95)),
+
+	/* HDP */
+	STM32_GATE(CK_BUS_HDP, "ck_icn_p_hdp", "ck_icn_apb3", 0, GATE_HDP, SEC_RIFSC(57)),
+
+	/* I2C */
+	STM32_GATE(CK_KER_I2C1, "ck_ker_i2c1", "ck_flexgen_12", 0, GATE_I2C1, SEC_RIFSC(41)),
+	STM32_GATE(CK_KER_I2C2, "ck_ker_i2c2", "ck_flexgen_12", 0, GATE_I2C2, SEC_RIFSC(42)),
+	STM32_GATE(CK_KER_I2C3, "ck_ker_i2c3", "ck_flexgen_13", 0, GATE_I2C3, SEC_RIFSC(43)),
+	STM32_GATE(CK_KER_I2C5, "ck_ker_i2c5", "ck_flexgen_13", 0, GATE_I2C5, SEC_RIFSC(45)),
+	STM32_GATE(CK_KER_I2C4, "ck_ker_i2c4", "ck_flexgen_14", 0, GATE_I2C4, SEC_RIFSC(44)),
+	STM32_GATE(CK_KER_I2C6, "ck_ker_i2c6", "ck_flexgen_14", 0, GATE_I2C6, SEC_RIFSC(46)),
+	STM32_GATE(CK_KER_I2C7, "ck_ker_i2c7", "ck_flexgen_15", 0, GATE_I2C7, SEC_RIFSC(47)),
+	STM32_GATE(CK_KER_I2C8, "ck_ker_i2c8", "ck_flexgen_38", 0, GATE_I2C8, SEC_RIFSC(48)),
+
+	/* I3C */
+	STM32_GATE(CK_KER_I3C1, "ck_ker_i3c1", "ck_flexgen_12", 0, GATE_I3C1, SEC_RIFSC(114)),
+	STM32_GATE(CK_KER_I3C2, "ck_ker_i3c2", "ck_flexgen_12", 0, GATE_I3C2, SEC_RIFSC(115)),
+	STM32_GATE(CK_KER_I3C3, "ck_ker_i3c3", "ck_flexgen_13", 0, GATE_I3C3, SEC_RIFSC(116)),
+	STM32_GATE(CK_KER_I3C4, "ck_ker_i3c4", "ck_flexgen_36", 0, GATE_I3C4, SEC_RIFSC(117)),
+
+	/* I2S */
+	STM32_GATE(CK_BUS_IS2M, "ck_icn_p_is2m", "ck_icn_apb3", 0, GATE_IS2M, SEC_RIFRCC(IS2M)),
+
+	/* IWDG */
+	STM32_GATE(CK_BUS_IWDG1, "ck_icn_p_iwdg1", "ck_icn_apb3", 0, GATE_IWDG1, SEC_RIFSC(98)),
+	STM32_GATE(CK_BUS_IWDG2, "ck_icn_p_iwdg2", "ck_icn_apb3", 0, GATE_IWDG2, SEC_RIFSC(99)),
+	STM32_GATE(CK_BUS_IWDG3, "ck_icn_p_iwdg3", "ck_icn_apb3", 0, GATE_IWDG3, SEC_RIFSC(100)),
+	STM32_GATE(CK_BUS_IWDG4, "ck_icn_p_iwdg4", "ck_icn_apb3", 0, GATE_IWDG4, SEC_RIFSC(101)),
+	STM32_GATE(CK_BUS_IWDG5, "ck_icn_p_iwdg5", "ck_icn_ls_mcu", 0, GATE_IWDG5,
+		   SEC_RIFSC(102)),
+
+	/* LPTIM */
+	STM32_GATE(CK_KER_LPTIM1, "ck_ker_lptim1", "ck_flexgen_07", 0, GATE_LPTIM1,
+		   SEC_RIFSC(17)),
+	STM32_GATE(CK_KER_LPTIM2, "ck_ker_lptim2", "ck_flexgen_07", 0, GATE_LPTIM2,
+		   SEC_RIFSC(18)),
+	STM32_GATE(CK_KER_LPTIM3, "ck_ker_lptim3", "ck_flexgen_40", 0, GATE_LPTIM3,
+		   SEC_RIFSC(19)),
+	STM32_GATE(CK_KER_LPTIM4, "ck_ker_lptim4", "ck_flexgen_41", 0, GATE_LPTIM4,
+		   SEC_RIFSC(20)),
+	STM32_GATE(CK_KER_LPTIM5, "ck_ker_lptim5", "ck_flexgen_41", 0, GATE_LPTIM5,
+		   SEC_RIFSC(21)),
+
+	/* LPUART */
+	STM32_GATE(CK_KER_LPUART1, "ck_ker_lpuart1", "ck_flexgen_39", 0, GATE_LPUART1,
+		   SEC_RIFSC(40)),
+
+	/* MCO1 & MCO2 */
+	STM32_COMPOSITE_NODIV(CK_MCO1, "ck_mco1", 0, SEC_RIFRCC(MCO1), GATE_MCO1, MUX_MCO1),
+	STM32_COMPOSITE_NODIV(CK_MCO2, "ck_mco2", 0, SEC_RIFRCC(MCO2), GATE_MCO2, MUX_MCO2),
+
+	/* MDF */
+	STM32_GATE(CK_KER_MDF1, "ck_ker_mdf1", "ck_flexgen_23", 0, GATE_MDF1, SEC_RIFSC(54)),
+
+	/* OCTOSPI */
+	STM32_GATE(CK_BUS_OSPIIOM, "ck_icn_p_ospiiom", "ck_icn_ls_mcu", 0, GATE_OSPIIOM,
+		   SEC_RIFSC(111)),
+
+	/* PCIE */
+	STM32_GATE(CK_BUS_PCIE, "ck_icn_p_pcie", "ck_icn_ls_mcu", 0, GATE_PCIE, SEC_RIFSC(68)),
+
+	/* PKA */
+	STM32_GATE(CK_BUS_PKA, "ck_icn_p_pka", "ck_icn_ls_mcu", 0, GATE_PKA, SEC_RIFSC(93)),
+
+	/* RNG */
+	STM32_GATE(CK_BUS_RNG, "ck_icn_p_rng", "ck_icn_ls_mcu", CLK_IGNORE_UNUSED, GATE_RNG,
+		   SEC_RIFSC(92)),
+
+	/* SAES */
+	STM32_GATE(CK_BUS_SAES, "ck_icn_p_saes", "ck_icn_ls_mcu", 0, GATE_SAES, SEC_RIFSC(94)),
+
+	/* SAI [1..4] */
+	STM32_GATE(CK_BUS_SAI1, "ck_icn_p_sai1", "ck_icn_apb2", 0, GATE_SAI1, SEC_RIFSC(49)),
+	STM32_GATE(CK_BUS_SAI2, "ck_icn_p_sai2", "ck_icn_apb2", 0, GATE_SAI2, SEC_RIFSC(50)),
+	STM32_GATE(CK_BUS_SAI3, "ck_icn_p_sai3", "ck_icn_apb2", 0, GATE_SAI3, SEC_RIFSC(51)),
+	STM32_GATE(CK_BUS_SAI4, "ck_icn_p_sai4", "ck_icn_apb2", 0, GATE_SAI4, SEC_RIFSC(52)),
+	STM32_GATE(CK_KER_SAI1, "ck_ker_sai1", "ck_flexgen_23", 0, GATE_SAI1, SEC_RIFSC(49)),
+	STM32_GATE(CK_KER_SAI2, "ck_ker_sai2", "ck_flexgen_24", 0, GATE_SAI2, SEC_RIFSC(50)),
+	STM32_GATE(CK_KER_SAI3, "ck_ker_sai3", "ck_flexgen_25", 0, GATE_SAI3, SEC_RIFSC(51)),
+	STM32_GATE(CK_KER_SAI4, "ck_ker_sai4", "ck_flexgen_25", 0, GATE_SAI4, SEC_RIFSC(52)),
+
+	/* SDMMC */
+	STM32_GATE(CK_KER_SDMMC1, "ck_ker_sdmmc1", "ck_flexgen_51", 0, GATE_SDMMC1,
+		   SEC_RIFSC(76)),
+	STM32_GATE(CK_KER_SDMMC2, "ck_ker_sdmmc2", "ck_flexgen_52", 0, GATE_SDMMC2,
+		   SEC_RIFSC(77)),
+	STM32_GATE(CK_KER_SDMMC3, "ck_ker_sdmmc3", "ck_flexgen_53", 0, GATE_SDMMC3,
+		   SEC_RIFSC(78)),
+
+	/* SERC */
+	STM32_GATE(CK_BUS_SERC, "ck_icn_p_serc", "ck_icn_apb3", 0, GATE_SERC, SEC_RIFSC(110)),
+
+	/* SPDIF */
+	STM32_GATE(CK_KER_SPDIFRX, "ck_ker_spdifrx", "ck_flexgen_11", 0, GATE_SPDIFRX,
+		   SEC_RIFSC(30)),
+
+	/* SPI */
+	STM32_GATE(CK_KER_SPI1, "ck_ker_spi1", "ck_flexgen_16", 0, GATE_SPI1, SEC_RIFSC(22)),
+	STM32_GATE(CK_KER_SPI2, "ck_ker_spi2", "ck_flexgen_10", 0, GATE_SPI2, SEC_RIFSC(23)),
+	STM32_GATE(CK_KER_SPI3, "ck_ker_spi3", "ck_flexgen_10", 0, GATE_SPI3, SEC_RIFSC(24)),
+	STM32_GATE(CK_KER_SPI4, "ck_ker_spi4", "ck_flexgen_17", 0, GATE_SPI4, SEC_RIFSC(25)),
+	STM32_GATE(CK_KER_SPI5, "ck_ker_spi5", "ck_flexgen_17", 0, GATE_SPI5, SEC_RIFSC(26)),
+	STM32_GATE(CK_KER_SPI6, "ck_ker_spi6", "ck_flexgen_18", 0, GATE_SPI6, SEC_RIFSC(27)),
+	STM32_GATE(CK_KER_SPI7, "ck_ker_spi7", "ck_flexgen_18", 0, GATE_SPI7, SEC_RIFSC(28)),
+	STM32_GATE(CK_KER_SPI8, "ck_ker_spi8", "ck_flexgen_37", 0, GATE_SPI8, SEC_RIFSC(29)),
+
+	/* STGEN */
+	STM32_GATE(CK_KER_STGEN, "ck_ker_stgen", "ck_flexgen_33", CLK_IGNORE_UNUSED, GATE_STGEN,
+		   SEC_RIFSC(73)),
+
+	/* Timers */
+	STM32_GATE(CK_KER_TIM2, "ck_ker_tim2", "timg1_ck", 0, GATE_TIM2, SEC_RIFSC(1)),
+	STM32_GATE(CK_KER_TIM3, "ck_ker_tim3", "timg1_ck", 0, GATE_TIM3, SEC_RIFSC(2)),
+	STM32_GATE(CK_KER_TIM4, "ck_ker_tim4", "timg1_ck", 0, GATE_TIM4, SEC_RIFSC(3)),
+	STM32_GATE(CK_KER_TIM5, "ck_ker_tim5", "timg1_ck", 0, GATE_TIM5, SEC_RIFSC(4)),
+	STM32_GATE(CK_KER_TIM6, "ck_ker_tim6", "timg1_ck", 0, GATE_TIM6, SEC_RIFSC(5)),
+	STM32_GATE(CK_KER_TIM7, "ck_ker_tim7", "timg1_ck", 0, GATE_TIM7, SEC_RIFSC(6)),
+	STM32_GATE(CK_KER_TIM10, "ck_ker_tim10", "timg1_ck", 0, GATE_TIM10, SEC_RIFSC(8)),
+	STM32_GATE(CK_KER_TIM11, "ck_ker_tim11", "timg1_ck", 0, GATE_TIM11, SEC_RIFSC(9)),
+	STM32_GATE(CK_KER_TIM12, "ck_ker_tim12", "timg1_ck", 0, GATE_TIM12, SEC_RIFSC(10)),
+	STM32_GATE(CK_KER_TIM13, "ck_ker_tim13", "timg1_ck", 0, GATE_TIM13, SEC_RIFSC(11)),
+	STM32_GATE(CK_KER_TIM14, "ck_ker_tim14", "timg1_ck", 0, GATE_TIM14, SEC_RIFSC(12)),
+
+	STM32_GATE(CK_KER_TIM1, "ck_ker_tim1", "timg2_ck", 0, GATE_TIM1, SEC_RIFSC(0)),
+	STM32_GATE(CK_KER_TIM8, "ck_ker_tim8", "timg2_ck", 0, GATE_TIM8, SEC_RIFSC(7)),
+	STM32_GATE(CK_KER_TIM15, "ck_ker_tim15", "timg2_ck", 0, GATE_TIM15, SEC_RIFSC(13)),
+	STM32_GATE(CK_KER_TIM16, "ck_ker_tim16", "timg2_ck", 0, GATE_TIM16, SEC_RIFSC(14)),
+	STM32_GATE(CK_KER_TIM17, "ck_ker_tim17", "timg2_ck", 0, GATE_TIM17, SEC_RIFSC(15)),
+	STM32_GATE(CK_KER_TIM20, "ck_ker_tim20", "timg2_ck", 0, GATE_TIM20, SEC_RIFSC(20)),
+
+	/* UART/USART */
+	STM32_GATE(CK_KER_USART2, "ck_ker_usart2", "ck_flexgen_08", 0, GATE_USART2,
+		   SEC_RIFSC(32)),
+	STM32_GATE(CK_KER_UART4, "ck_ker_uart4", "ck_flexgen_08", 0, GATE_UART4,
+		   SEC_RIFSC(34)),
+	STM32_GATE(CK_KER_USART3, "ck_ker_usart3", "ck_flexgen_09", 0, GATE_USART3,
+		   SEC_RIFSC(33)),
+	STM32_GATE(CK_KER_UART5, "ck_ker_uart5", "ck_flexgen_09", 0, GATE_UART5,
+		   SEC_RIFSC(35)),
+	STM32_GATE(CK_KER_USART1, "ck_ker_usart1", "ck_flexgen_19", 0, GATE_USART1,
+		   SEC_RIFSC(31)),
+	STM32_GATE(CK_KER_USART6, "ck_ker_usart6", "ck_flexgen_20", 0, GATE_USART6,
+		   SEC_RIFSC(36)),
+	STM32_GATE(CK_KER_UART7, "ck_ker_uart7", "ck_flexgen_21", 0, GATE_UART7,
+		   SEC_RIFSC(37)),
+	STM32_GATE(CK_KER_UART8, "ck_ker_uart8", "ck_flexgen_21", 0, GATE_UART8,
+		   SEC_RIFSC(38)),
+	STM32_GATE(CK_KER_UART9, "ck_ker_uart9", "ck_flexgen_22", 0, GATE_UART9,
+		   SEC_RIFSC(39)),
+
+	/* USB2PHY1 */
+	STM32_COMPOSITE_NODIV(CK_KER_USB2PHY1, "ck_ker_usb2phy1", 0, SEC_RIFSC(63),
+			      GATE_USB2PHY1, MUX_USB2PHY1),
+
+	/* USBH */
+	STM32_GATE(CK_BUS_USB2OHCI, "ck_icn_m_usb2ohci", "ck_icn_hsl", 0, GATE_USB2,
+		   SEC_RIFSC(63)),
+	STM32_GATE(CK_BUS_USB2EHCI, "ck_icn_m_usb2ehci", "ck_icn_hsl", 0, GATE_USB2,
+		   SEC_RIFSC(63)),
+
+	/* USB2PHY2 */
+	STM32_COMPOSITE_NODIV(CK_KER_USB2PHY2EN, "ck_ker_usb2phy2_en", 0, SEC_RIFSC(66),
+			      GATE_USB2PHY2, MUX_USB2PHY2),
+
+	/* USB3 PCIe COMBOPHY */
+	STM32_GATE(CK_BUS_USB3PCIEPHY, "ck_icn_p_usb3pciephy", "ck_icn_apb4", 0, GATE_USB3PCIEPHY,
+		   SEC_RIFSC(67)),
+
+	STM32_COMPOSITE_NODIV(CK_KER_USB3PCIEPHY, "ck_ker_usb3pciephy", 0, SEC_RIFSC(67),
+			      GATE_USB3PCIEPHY, MUX_USB3PCIEPHY),
+
+	/* USB3 DRD */
+	STM32_GATE(CK_BUS_USB3DR, "ck_icn_m_usb3dr", "ck_icn_hsl", 0, GATE_USB3DR,
+		   SEC_RIFSC(66)),
+	STM32_GATE(CK_KER_USB2PHY2, "ck_ker_usb2phy2", "ck_flexgen_58", 0, GATE_USB3DR,
+		   SEC_RIFSC(66)),
+
+	/* USBTC */
+	STM32_GATE(CK_BUS_USBTC, "ck_icn_p_usbtc", "ck_flexgen_35", 0, GATE_USBTC,
+		   SEC_RIFSC(69)),
+	STM32_GATE(CK_KER_USBTC, "ck_ker_usbtc", "ck_flexgen_35", 0, GATE_USBTC,
+		   SEC_RIFSC(69)),
+
+	/* VDEC / VENC */
+	STM32_GATE(CK_BUS_VDEC, "ck_icn_p_vdec", "ck_icn_apb4", 0, GATE_VDEC, SEC_RIFSC(89)),
+	STM32_GATE(CK_BUS_VENC, "ck_icn_p_venc", "ck_icn_apb4", 0, GATE_VENC, SEC_RIFSC(90)),
+
+	/* VREF */
+	STM32_GATE(CK_BUS_VREF, "ck_icn_p_vref", "ck_icn_apb3", 0, RCC_VREFCFGR,
+		   SEC_RIFSC(106)),
+
+	/* WWDG */
+	STM32_GATE(CK_BUS_WWDG1, "ck_icn_p_wwdg1", "ck_icn_apb3", 0, GATE_WWDG1,
+		   SEC_RIFSC(103)),
+	STM32_GATE(CK_BUS_WWDG2, "ck_icn_p_wwdg2", "ck_icn_ls_mcu", 0, GATE_WWDG2,
+		   SEC_RIFSC(104)),
+};
+
+static const struct stm32_clock_match_data stm32mp25_data = {
+	.tab_clocks	= stm32mp25_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp25_clock_cfg),
+	.clock_data = &(const struct clk_stm32_clock_data) {
+		.num_gates	= ARRAY_SIZE(stm32mp25_gates),
+		.gates		= stm32mp25_gates,
+		.muxes		= stm32mp25_muxes,
+	},
+	.check_security = stm32mp25_check_security,
+
+};
+
+static int stm32mp25_clk_probe(struct udevice *dev)
+{
+	fdt_addr_t base = dev_read_addr(dev->parent);
+	struct udevice *scmi;
+
+	if (base == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	/* force SCMI probe to register all SCMI clocks */
+	uclass_get_device_by_driver(UCLASS_CLK, DM_DRIVER_GET(scmi_clock), &scmi);
+
+	stm32_rcc_init(dev, &stm32mp25_data);
+
+	return 0;
+}
+
+U_BOOT_DRIVER(stm32mp25_clock) = {
+	.name = "stm32mp25_clk",
+	.id = UCLASS_CLK,
+	.ops = &stm32_clk_ops,
+	.priv_auto = sizeof(struct stm32mp_rcc_priv),
+	.probe = stm32mp25_clk_probe,
+};
diff --git a/drivers/core/ofnode.c b/drivers/core/ofnode.c
index 8df16e56af..9e49e36f2e 100644
--- a/drivers/core/ofnode.c
+++ b/drivers/core/ofnode.c
@@ -960,13 +960,16 @@ int ofnode_decode_display_timing(ofnode parent, int index,
 	int ret = 0;
 
 	timings = ofnode_find_subnode(parent, "display-timings");
-	if (!ofnode_valid(timings))
-		return -EINVAL;
-
-	i = 0;
-	ofnode_for_each_subnode(node, timings) {
-		if (i++ == index)
-			break;
+	if (ofnode_valid(timings)) {
+		i = 0;
+		ofnode_for_each_subnode(node, timings) {
+			if (i++ == index)
+				break;
+		}
+	} else {
+		if (index != 0)
+			return -EINVAL;
+		node = ofnode_find_subnode(parent, "panel-timing");
 	}
 
 	if (!ofnode_valid(node))
diff --git a/drivers/dfu/dfu_mtd.c b/drivers/dfu/dfu_mtd.c
index 75e2f6a421..cb20a10618 100644
--- a/drivers/dfu/dfu_mtd.c
+++ b/drivers/dfu/dfu_mtd.c
@@ -85,27 +85,39 @@ static int mtd_block_op(enum dfu_op op, struct dfu_entity *dfu,
 
 		while (remaining) {
 			if (erase_op.addr + remaining > lim) {
-				printf("Limit reached 0x%llx while erasing at offset 0x%llx\n",
-				       lim, off);
+				printf("Limit reached 0x%llx while erasing at offset 0x%llx, remaining 0x%llx\n",
+				       lim, erase_op.addr, remaining);
 				return -EIO;
 			}
 
+			/* Skip the block if it is bad, don't erase it again */
+			if (mtd_block_isbad(mtd, erase_op.addr)) {
+				printf("Skipping bad block at 0x%08llx\n",
+				       erase_op.addr);
+				erase_op.addr += mtd->erasesize;
+				continue;
+			}
+
 			ret = mtd_erase(mtd, &erase_op);
 
 			if (ret) {
-				/* Abort if its not a bad block error */
-				if (ret != -EIO) {
-					printf("Failure while erasing at offset 0x%llx\n",
-					       erase_op.fail_addr);
-					return 0;
+				/* If this is not -EIO, we have no idea what to do. */
+				if (ret == -EIO) {
+					printf("Marking bad block at 0x%08llx (%d)\n",
+					       erase_op.fail_addr, ret);
+					ret = mtd_block_markbad(mtd, erase_op.addr);
+				}
+				/* Abort if it is not -EIO or can't mark bad */
+				if (ret) {
+					printf("Failure while erasing at offset 0x%llx (%d)\n",
+					       erase_op.fail_addr, ret);
+					return ret;
 				}
-				printf("Skipping bad block at 0x%08llx\n",
-				       erase_op.addr);
 			} else {
 				remaining -= mtd->erasesize;
 			}
 
-			/* Continue erase behind bad block */
+			/* Continue erase behind the current block */
 			erase_op.addr += mtd->erasesize;
 		}
 	}
diff --git a/drivers/fastboot/fb_command.c b/drivers/fastboot/fb_command.c
index 71cfaec6e9..947277ea61 100644
--- a/drivers/fastboot/fb_command.c
+++ b/drivers/fastboot/fb_command.c
@@ -426,13 +426,16 @@ static void __maybe_unused oem_format(char *cmd_parameter, char *response)
 	char cmdbuf[32];
 	const int mmc_dev = config_opt_enabled(CONFIG_FASTBOOT_FLASH_MMC,
 					       CONFIG_FASTBOOT_FLASH_MMC_DEV, -1);
+	const char *part = env_get("partitions");
 
-	if (!env_get("partitions")) {
+	if (!part) {
 		fastboot_fail("partitions not set", response);
 	} else {
 		sprintf(cmdbuf, "gpt write mmc %x $partitions", mmc_dev);
+		printf("Execute: %s\n", cmdbuf);
+		printf("with partitions: %s\n", part);
 		if (run_command(cmdbuf, 0))
-			fastboot_fail("", response);
+			fastboot_fail("Cannot write GPT", response);
 		else
 			fastboot_okay(NULL, response);
 	}
diff --git a/drivers/fastboot/fb_mmc.c b/drivers/fastboot/fb_mmc.c
index 060918e491..79a0aad91a 100644
--- a/drivers/fastboot/fb_mmc.c
+++ b/drivers/fastboot/fb_mmc.c
@@ -212,8 +212,8 @@ static int fb_mmc_erase_mmc_hwpart(struct blk_desc *dev_desc)
 		return 1;
 	}
 
-	printf("........ erased %lu bytes from mmc hwpart[%u]\n",
-	       dev_desc->lba * dev_desc->blksz, dev_desc->hwpart);
+	printf("........ erased %llu bytes from mmc hwpart[%u]\n",
+	       (u64)(dev_desc->lba * dev_desc->blksz), dev_desc->hwpart);
 
 	return 0;
 }
@@ -258,8 +258,8 @@ static void fb_mmc_boot_ops(struct blk_desc *dev_desc, void *buffer,
 			return;
 		}
 
-		printf("........ wrote %lu bytes to EMMC_BOOT%d\n",
-		       blkcnt * blksz, hwpart);
+		printf("........ wrote %llu bytes to EMMC_BOOT%d\n",
+		       (u64)(blkcnt * blksz), hwpart);
 	} else { /* erase */
 		if (fb_mmc_erase_mmc_hwpart(dev_desc)) {
 			pr_err("Failed to erase EMMC_BOOT%d\n", hwpart);
diff --git a/drivers/fwu-mdata/fwu-mdata-uclass.c b/drivers/fwu-mdata/fwu-mdata-uclass.c
index 0a8edaaa41..145479bab0 100644
--- a/drivers/fwu-mdata/fwu-mdata-uclass.c
+++ b/drivers/fwu-mdata/fwu-mdata-uclass.c
@@ -20,7 +20,8 @@
  *
  * Return: 0 if OK, -ve on error
  */
-int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
+int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary,
+		   uint32_t size)
 {
 	const struct fwu_mdata_ops *ops = device_get_ops(dev);
 
@@ -29,7 +30,7 @@ int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
 		return -ENOSYS;
 	}
 
-	return ops->read_mdata(dev, mdata, primary);
+	return ops->read_mdata(dev, mdata, primary, size);
 }
 
 /**
@@ -37,7 +38,8 @@ int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
  *
  * Return: 0 if OK, -ve on error
  */
-int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
+int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary,
+		    uint32_t size)
 {
 	const struct fwu_mdata_ops *ops = device_get_ops(dev);
 
@@ -46,7 +48,7 @@ int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
 		return -ENOSYS;
 	}
 
-	return ops->write_mdata(dev, mdata, primary);
+	return ops->write_mdata(dev, mdata, primary, size);
 }
 
 UCLASS_DRIVER(fwu_mdata) = {
diff --git a/drivers/fwu-mdata/gpt_blk.c b/drivers/fwu-mdata/gpt_blk.c
index c7284916c4..97eac3611f 100644
--- a/drivers/fwu-mdata/gpt_blk.c
+++ b/drivers/fwu-mdata/gpt_blk.c
@@ -81,15 +81,14 @@ static int gpt_get_mdata_disk_part(struct blk_desc *desc,
 	return -ENOENT;
 }
 
-static int gpt_read_write_mdata(struct blk_desc *desc,
-				struct fwu_mdata *mdata,
-				u8 access, u32 part_num)
+static int gpt_read_write_mdata(struct blk_desc *desc, struct fwu_mdata *mdata,
+				u8 access, u32 part_num, u32 size)
 {
 	int ret;
 	u32 len, blk_start, blkcnt;
 	struct disk_partition info;
 
-	ALLOC_CACHE_ALIGN_BUFFER_PAD(struct fwu_mdata, mdata_aligned, 1,
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(u8, mdata_aligned, size,
 				     desc->blksz);
 
 	if (!mdata)
@@ -101,7 +100,7 @@ static int gpt_read_write_mdata(struct blk_desc *desc,
 		return -ENOENT;
 	}
 
-	len = sizeof(*mdata);
+	len = size;
 	blkcnt = BLOCK_CNT(len, desc);
 	if (blkcnt > info.size) {
 		log_debug("Block count exceeds FWU metadata partition size\n");
@@ -114,7 +113,7 @@ static int gpt_read_write_mdata(struct blk_desc *desc,
 			log_debug("Error reading FWU metadata from the device\n");
 			return -EIO;
 		}
-		memcpy(mdata, mdata_aligned, sizeof(struct fwu_mdata));
+		memcpy(mdata, mdata_aligned, size);
 	} else {
 		if (blk_dwrite(desc, blk_start, blkcnt, mdata) != blkcnt) {
 			log_debug("Error writing FWU metadata to the device\n");
@@ -164,7 +163,7 @@ static int fwu_mdata_gpt_blk_probe(struct udevice *dev)
 }
 
 static int fwu_gpt_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
-			      bool primary)
+			      bool primary, u32 size)
 {
 	struct fwu_mdata_gpt_blk_priv *priv = dev_get_priv(dev);
 	struct blk_desc *desc = dev_get_uclass_plat(priv->blk_dev);
@@ -177,11 +176,13 @@ static int fwu_gpt_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
 	}
 
 	return gpt_read_write_mdata(desc, mdata, MDATA_READ,
-				    primary ? g_mdata_part[0] : g_mdata_part[1]);
+				    primary ?
+				    g_mdata_part[0] : g_mdata_part[1],
+				    size);
 }
 
 static int fwu_gpt_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
-			       bool primary)
+			       bool primary, u32 size)
 {
 	struct fwu_mdata_gpt_blk_priv *priv = dev_get_priv(dev);
 	struct blk_desc *desc = dev_get_uclass_plat(priv->blk_dev);
@@ -194,7 +195,9 @@ static int fwu_gpt_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
 	}
 
 	return gpt_read_write_mdata(desc, mdata, MDATA_WRITE,
-				    primary ? g_mdata_part[0] : g_mdata_part[1]);
+				    primary ?
+				    g_mdata_part[0] : g_mdata_part[1],
+				    size);
 }
 
 static const struct fwu_mdata_ops fwu_gpt_blk_ops = {
diff --git a/drivers/fwu-mdata/raw_mtd.c b/drivers/fwu-mdata/raw_mtd.c
index 17e4517973..78a709f766 100644
--- a/drivers/fwu-mdata/raw_mtd.c
+++ b/drivers/fwu-mdata/raw_mtd.c
@@ -12,22 +12,11 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 
-/* Internal helper structure to move data around */
-struct fwu_mdata_mtd_priv {
-	struct mtd_info *mtd;
-	char pri_label[50];
-	char sec_label[50];
-	u32 pri_offset;
-	u32 sec_offset;
-};
-
 enum fwu_mtd_op {
 	FWU_MTD_READ,
 	FWU_MTD_WRITE,
 };
 
-extern struct fwu_mtd_image_info fwu_mtd_images[];
-
 static bool mtd_is_aligned_with_block_size(struct mtd_info *mtd, u64 size)
 {
 	return !do_div(size, mtd->erasesize);
@@ -97,22 +86,24 @@ lock:
 	return ret;
 }
 
-static int fwu_mtd_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
+static int fwu_mtd_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+			      bool primary, u32 size)
 {
 	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
 	struct mtd_info *mtd = mtd_priv->mtd;
 	u32 offs = primary ? mtd_priv->pri_offset : mtd_priv->sec_offset;
 
-	return mtd_io_data(mtd, offs, sizeof(struct fwu_mdata), mdata, FWU_MTD_READ);
+	return mtd_io_data(mtd, offs, size, mdata, FWU_MTD_READ);
 }
 
-static int fwu_mtd_write_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary)
+static int fwu_mtd_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+			       bool primary, u32 size)
 {
 	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
 	struct mtd_info *mtd = mtd_priv->mtd;
 	u32 offs = primary ? mtd_priv->pri_offset : mtd_priv->sec_offset;
 
-	return mtd_io_data(mtd, offs, sizeof(struct fwu_mdata), mdata, FWU_MTD_WRITE);
+	return mtd_io_data(mtd, offs, size, mdata, FWU_MTD_WRITE);
 }
 
 static int flash_partition_offset(struct udevice *dev, const char *part_name, fdt_addr_t *offset)
@@ -132,7 +123,7 @@ static int flash_partition_offset(struct udevice *dev, const char *part_name, fd
 	return (int)size;
 }
 
-static int fwu_mdata_mtd_of_to_plat(struct udevice *dev)
+static int get_fwu_mdata_dev(struct udevice *dev)
 {
 	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
 	const fdt32_t *phandle_p = NULL;
@@ -142,8 +133,6 @@ static int fwu_mdata_mtd_of_to_plat(struct udevice *dev)
 	fdt_addr_t offset;
 	int ret, size;
 	u32 phandle;
-	ofnode bank;
-	int off_img;
 
 	/* Find the FWU mdata storage device */
 	phandle_p = ofnode_get_property(dev_ofnode(dev),
@@ -197,8 +186,28 @@ static int fwu_mdata_mtd_of_to_plat(struct udevice *dev)
 		return ret;
 	mtd_priv->sec_offset = offset;
 
-	off_img = 0;
+	return 0;
+}
+
+static int fwu_mtd_image_info_populate(struct udevice *dev, u8 nbanks,
+				       u16 nimages)
+{
+	struct fwu_mtd_image_info *mtd_images;
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
+	struct udevice *mtd_dev = mtd_priv->mtd->dev;
+	fdt_addr_t offset;
+	ofnode bank;
+	int off_img;
+	u32 total_images;
 
+	total_images = nbanks * nimages;
+	mtd_priv->fwu_mtd_images = malloc(sizeof(struct fwu_mtd_image_info) *
+					  total_images);
+	if (!mtd_priv->fwu_mtd_images)
+		return -ENOMEM;
+
+	off_img = 0;
+	mtd_images = mtd_priv->fwu_mtd_images;
 	ofnode_for_each_subnode(bank, dev_ofnode(dev)) {
 		int bank_num, bank_offset, bank_size;
 		const char *bank_name;
@@ -217,8 +226,7 @@ static int fwu_mdata_mtd_of_to_plat(struct udevice *dev)
 			int image_num, image_offset, image_size;
 			const char *uuid;
 
-			if (off_img == CONFIG_FWU_NUM_BANKS *
-						CONFIG_FWU_NUM_IMAGES_PER_BANK) {
+			if (off_img == total_images) {
 				log_err("DT provides more images than configured!\n");
 				break;
 			}
@@ -228,11 +236,11 @@ static int fwu_mdata_mtd_of_to_plat(struct udevice *dev)
 			ofnode_read_u32(image, "offset", &image_offset);
 			ofnode_read_u32(image, "size", &image_size);
 
-			fwu_mtd_images[off_img].start = bank_offset + image_offset;
-			fwu_mtd_images[off_img].size = image_size;
-			fwu_mtd_images[off_img].bank_num = bank_num;
-			fwu_mtd_images[off_img].image_num = image_num;
-			strcpy(fwu_mtd_images[off_img].uuidbuf, uuid);
+			mtd_images[off_img].start = bank_offset + image_offset;
+			mtd_images[off_img].size = image_size;
+			mtd_images[off_img].bank_num = bank_num;
+			mtd_images[off_img].image_num = image_num;
+			strcpy(mtd_images[off_img].uuidbuf, uuid);
 			log_debug("\tImage%d: %s @0x%x\n\n",
 				  image_num, uuid, bank_offset + image_offset);
 			off_img++;
@@ -244,8 +252,21 @@ static int fwu_mdata_mtd_of_to_plat(struct udevice *dev)
 
 static int fwu_mdata_mtd_probe(struct udevice *dev)
 {
-	/* Ensure the metadata can be read. */
-	return fwu_get_mdata(NULL);
+	u8 nbanks;
+	u16 nimages;
+	int ret;
+
+	ret = get_fwu_mdata_dev(dev);
+	if (ret)
+		return ret;
+
+	nbanks = CONFIG_FWU_NUM_BANKS;
+	nimages = CONFIG_FWU_NUM_IMAGES_PER_BANK;
+	ret = fwu_mtd_image_info_populate(dev, nbanks, nimages);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 static struct fwu_mdata_ops fwu_mtd_ops = {
@@ -264,6 +285,5 @@ U_BOOT_DRIVER(fwu_mdata_mtd) = {
 	.of_match	= fwu_mdata_ids,
 	.ops		= &fwu_mtd_ops,
 	.probe		= fwu_mdata_mtd_probe,
-	.of_to_plat	= fwu_mdata_mtd_of_to_plat,
 	.priv_auto	= sizeof(struct fwu_mdata_mtd_priv),
 };
diff --git a/drivers/gpio/gpio-uclass.c b/drivers/gpio/gpio-uclass.c
index 31027f3d99..6f47f90b14 100644
--- a/drivers/gpio/gpio-uclass.c
+++ b/drivers/gpio/gpio-uclass.c
@@ -811,6 +811,7 @@ static const char * const gpio_function[GPIOF_COUNT] = {
 	"unused",
 	"unknown",
 	"func",
+	"protected",
 };
 
 static int get_function(struct udevice *dev, int offset, bool skip_unused,
diff --git a/drivers/gpio/sandbox.c b/drivers/gpio/sandbox.c
index 305f9a6ff6..41a0095bd8 100644
--- a/drivers/gpio/sandbox.c
+++ b/drivers/gpio/sandbox.c
@@ -192,6 +192,8 @@ static int sb_gpio_set_value(struct udevice *dev, unsigned offset, int value)
 
 static int sb_gpio_get_function(struct udevice *dev, unsigned offset)
 {
+	if (get_gpio_flag(dev, offset, GPIOD_EXT_PROTECTED))
+		return GPIOF_PROTECTED;
 	if (get_gpio_flag(dev, offset, GPIOD_IS_OUT))
 		return GPIOF_OUTPUT;
 	if (get_gpio_flag(dev, offset, GPIOD_IS_IN))
@@ -199,7 +201,7 @@ static int sb_gpio_get_function(struct udevice *dev, unsigned offset)
 	if (get_gpio_flag(dev, offset, GPIOD_IS_AF))
 		return GPIOF_FUNC;
 
-	return GPIOF_INPUT; /*GPIO is not configurated */
+	return GPIOF_INPUT; /* GPIO is not configured */
 }
 
 static int sb_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
@@ -528,6 +530,14 @@ static int sb_pinctrl_get_pin_muxing(struct udevice *dev,
 	unsigned int gpio_idx;
 	ulong flags;
 	int function;
+	static const char * const gpio_function[GPIOF_COUNT] = {
+		"input",
+		"output",
+		"unused",
+		"unknown",
+		"func",
+		"protected",
+	};
 
 	/* look up for the bank which owns the requested pin */
 	gpio_dev = sb_pinctrl_get_gpio_dev(dev, selector, &gpio_idx);
@@ -536,9 +546,7 @@ static int sb_pinctrl_get_pin_muxing(struct udevice *dev,
 	} else {
 		function = sb_gpio_get_function(gpio_dev, gpio_idx);
 		flags = *get_gpio_flags(gpio_dev, gpio_idx);
-
-		snprintf(buf, size, "gpio %s %s",
-			 function == GPIOF_OUTPUT ? "output" : "input",
+		snprintf(buf, size, "gpio %s %s", gpio_function[function],
 			 get_flags_string(flags));
 	}
 
diff --git a/drivers/gpio/stm32_gpio.c b/drivers/gpio/stm32_gpio.c
index 7a2ca91c76..98fc021c15 100644
--- a/drivers/gpio/stm32_gpio.c
+++ b/drivers/gpio/stm32_gpio.c
@@ -15,6 +15,7 @@
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/errno.h>
 #include <linux/io.h>
@@ -33,6 +34,19 @@
 #define OTYPE_BITS(gpio_pin)		(gpio_pin)
 #define OTYPE_MSK			1
 
+#define SECCFG_BITS(gpio_pin)		(gpio_pin)
+#define SECCFG_MSK			1
+
+#define STM32_GPIO_CID1			1
+
+#define STM32_GPIO_CIDCFGR_CFEN		BIT(0)
+#define STM32_GPIO_CIDCFGR_SEMEN	BIT(1)
+#define STM32_GPIO_CIDCFGR_SCID_MASK	GENMASK(5, 4)
+#define STM32_GPIO_CIDCFGR_SEMWL_CID1	BIT(16 + STM32_GPIO_CID1)
+
+#define STM32_GPIO_SEMCR_SEM_MUTEX	BIT(0)
+#define STM32_GPIO_SEMCR_SEMCID_MASK	GENMASK(5, 4)
+
 static void stm32_gpio_set_moder(struct stm32_gpio_regs *regs,
 				 int idx,
 				 int mode)
@@ -90,6 +104,97 @@ static bool stm32_gpio_is_mapped(struct udevice *dev, int offset)
 	return !!(priv->gpio_range & BIT(offset));
 }
 
+bool stm32_gpio_rif_valid(struct stm32_gpio_regs *regs, unsigned int offset)
+{
+	u32 cid, sem;
+
+	cid = readl(&regs->rif[offset].cidcfgr);
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return true;
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMEN)) {
+		if (FIELD_GET(STM32_GPIO_CIDCFGR_SCID_MASK, cid) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMWL_CID1))
+		return false;
+
+	sem = readl(&regs->rif[offset].semcr);
+
+	if (sem & STM32_GPIO_SEMCR_SEM_MUTEX) {
+		if (FIELD_GET(STM32_GPIO_SEMCR_SEMCID_MASK, sem) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	writel(STM32_GPIO_SEMCR_SEM_MUTEX, &regs->rif[offset].semcr);
+	sem = readl(&regs->rif[offset].semcr);
+	if (sem & STM32_GPIO_SEMCR_SEM_MUTEX &&
+	    FIELD_GET(STM32_GPIO_SEMCR_SEMCID_MASK, sem) == STM32_GPIO_CID1)
+		return true;
+
+	return false;
+}
+
+static void stm32_gpio_rif_release(struct stm32_gpio_regs *regs, unsigned int offset)
+{
+	u32 cid;
+
+	cid = readl(&regs->rif[offset].cidcfgr);
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return;
+
+	if (cid & STM32_GPIO_CIDCFGR_SEMEN && cid & STM32_GPIO_CIDCFGR_SEMWL_CID1)
+		writel(0, &regs->rif[offset].semcr);
+}
+
+static int stm32_gpio_request(struct udevice *dev, unsigned offset, const char *label)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(dev);
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
+
+	if (!stm32_gpio_is_mapped(dev, offset))
+		return -ENXIO;
+
+	/* Deny request access if IO is secured */
+	if ((drv_data & STM32_GPIO_FLAG_SEC_CTRL) &&
+	    ((readl(&regs->seccfgr) >> SECCFG_BITS(offset)) & SECCFG_MSK)) {
+		dev_err(dev, "Failed to get secure IO %s %d @ %p\n",
+			uc_priv->bank_name, offset, regs);
+		return -EACCES;
+	}
+
+	/* Deny request access if IO RIF semaphore is not available */
+	if ((drv_data & STM32_GPIO_FLAG_RIF_CTRL) &&
+	    !stm32_gpio_rif_valid(regs, offset)) {
+		dev_err(dev, "Failed to take RIF semaphore on IO %s %d @ %p\n",
+			uc_priv->bank_name, offset, regs);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+static int stm32_gpio_rfree(struct udevice *dev, unsigned int offset)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
+
+	if (drv_data & STM32_GPIO_FLAG_RIF_CTRL)
+		stm32_gpio_rif_release(regs, offset);
+
+	return 0;
+}
+
 static int stm32_gpio_direction_input(struct udevice *dev, unsigned offset)
 {
 	struct stm32_gpio_priv *priv = dev_get_priv(dev);
@@ -147,6 +252,7 @@ static int stm32_gpio_get_function(struct udevice *dev, unsigned int offset)
 {
 	struct stm32_gpio_priv *priv = dev_get_priv(dev);
 	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
 	int bits_index;
 	int mask;
 	u32 mode;
@@ -154,6 +260,16 @@ static int stm32_gpio_get_function(struct udevice *dev, unsigned int offset)
 	if (!stm32_gpio_is_mapped(dev, offset))
 		return GPIOF_UNKNOWN;
 
+	/* Return 'protected' if the IO is secured */
+	if ((drv_data & STM32_GPIO_FLAG_SEC_CTRL) &&
+	    ((readl(&regs->seccfgr) >> SECCFG_BITS(offset)) & SECCFG_MSK))
+		return GPIOF_PROTECTED;
+
+	/* Return 'protected' if the IO RIF semaphore is not available */
+	if ((drv_data & STM32_GPIO_FLAG_RIF_CTRL) &&
+	    !stm32_gpio_rif_valid(regs, offset))
+		return GPIOF_PROTECTED;
+
 	bits_index = MODE_BITS(offset);
 	mask = MODE_BITS_MASK << bits_index;
 
@@ -239,6 +355,8 @@ static int stm32_gpio_get_flags(struct udevice *dev, unsigned int offset,
 }
 
 static const struct dm_gpio_ops gpio_stm32_ops = {
+	.request		= stm32_gpio_request,
+	.rfree			= stm32_gpio_rfree,
 	.direction_input	= stm32_gpio_direction_input,
 	.direction_output	= stm32_gpio_direction_output,
 	.get_value		= stm32_gpio_get_value,
@@ -309,11 +427,39 @@ static int gpio_stm32_probe(struct udevice *dev)
 	return 0;
 }
 
+static int gpio_stm32_remove(struct udevice *dev)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
+	unsigned int offset;
+	u32 seccfgr = 0;
+
+	if (!(drv_data & STM32_GPIO_FLAG_RIF_CTRL))
+		return 0;
+
+	if (drv_data & STM32_GPIO_FLAG_SEC_CTRL)
+		seccfgr = readl(&regs->seccfgr);
+
+	for (offset = 0; offset < STM32_GPIOS_PER_BANK; offset++) {
+		if (!stm32_gpio_is_mapped(dev, offset))
+			continue;
+
+		if ((seccfgr >> SECCFG_BITS(offset)) & SECCFG_MSK)
+			continue;
+
+		stm32_gpio_rif_release(regs, offset);
+	}
+
+	return 0;
+}
+
 U_BOOT_DRIVER(gpio_stm32) = {
 	.name	= "gpio_stm32",
 	.id	= UCLASS_GPIO,
 	.probe	= gpio_stm32_probe,
+	.remove	= gpio_stm32_remove,
 	.ops	= &gpio_stm32_ops,
-	.flags	= DM_UC_FLAG_SEQ_ALIAS,
+	.flags	= DM_UC_FLAG_SEQ_ALIAS | DM_FLAG_OS_PREPARE,
 	.priv_auto	= sizeof(struct stm32_gpio_priv),
 };
diff --git a/drivers/gpio/stm32_gpio_priv.h b/drivers/gpio/stm32_gpio_priv.h
index 662a000fe7..1da066dec3 100644
--- a/drivers/gpio/stm32_gpio_priv.h
+++ b/drivers/gpio/stm32_gpio_priv.h
@@ -51,17 +51,63 @@ enum stm32_gpio_af {
 	STM32_GPIO_AF15
 };
 
+enum stm32_gpio_delay_path {
+	STM32_GPIO_DELAY_PATH_OUT = 0,
+	STM32_GPIO_DELAY_PATH_IN
+};
+
+enum stm32_gpio_clk_edge {
+	STM32_GPIO_CLK_EDGE_SINGLE = 0,
+	STM32_GPIO_CLK_EDGE_DOUBLE
+};
+
+enum stm32_gpio_clk_type {
+	STM32_GPIO_CLK_TYPE_NOT_INVERT = 0,
+	STM32_GPIO_CLK_TYPE_INVERT
+};
+
+enum stm32_gpio_retime {
+	STM32_GPIO_RETIME_DISABLED = 0,
+	STM32_GPIO_RETIME_ENABLED
+};
+
+enum stm32_gpio_delay {
+	STM32_GPIO_DELAY_NONE = 0,
+	STM32_GPIO_DELAY_0_3,
+	STM32_GPIO_DELAY_0_5,
+	STM32_GPIO_DELAY_0_75,
+	STM32_GPIO_DELAY_1_0,
+	STM32_GPIO_DELAY_1_25,
+	STM32_GPIO_DELAY_1_5,
+	STM32_GPIO_DELAY_1_75,
+	STM32_GPIO_DELAY_2_0,
+	STM32_GPIO_DELAY_2_25,
+	STM32_GPIO_DELAY_2_5,
+	STM32_GPIO_DELAY_2_75,
+	STM32_GPIO_DELAY_3_0,
+	STM32_GPIO_DELAY_3_25
+};
+
+#define STM32_GPIO_FLAG_SEC_CTRL	BIT(0)
+#define STM32_GPIO_FLAG_IO_SYNC_CTRL	BIT(1)
+#define STM32_GPIO_FLAG_RIF_CTRL	BIT(2)
+
 struct stm32_gpio_dsc {
 	u8	port;
 	u8	pin;
 };
 
 struct stm32_gpio_ctl {
-	enum stm32_gpio_mode	mode;
-	enum stm32_gpio_otype	otype;
-	enum stm32_gpio_speed	speed;
-	enum stm32_gpio_pupd	pupd;
-	enum stm32_gpio_af	af;
+	enum stm32_gpio_mode		mode;
+	enum stm32_gpio_otype		otype;
+	enum stm32_gpio_speed		speed;
+	enum stm32_gpio_pupd		pupd;
+	enum stm32_gpio_af		af;
+	enum stm32_gpio_delay_path	delay_path;
+	enum stm32_gpio_clk_edge	clk_edge;
+	enum stm32_gpio_clk_type	clk_type;
+	enum stm32_gpio_retime		retime;
+	enum stm32_gpio_delay		delay;
 };
 
 struct stm32_gpio_regs {
@@ -74,6 +120,18 @@ struct stm32_gpio_regs {
 	u32 bsrr;	/* GPIO port bit set/reset */
 	u32 lckr;	/* GPIO port configuration lock */
 	u32 afr[2];	/* GPIO alternate function */
+	u32 brr;	/* GPIO port bit reset */
+	u32 rfu;	/* Reserved */
+	u32 seccfgr;	/* GPIO secure configuration */
+	u32 rfu2;	/* Reserved (privcfgr) */
+	u32 rfu3;	/* Reserved (rcfglock) */
+	u32 rfu4;	/* Reserved */
+	u32 delayr[2];	/* GPIO port delay */
+	u32 advcfgr[2];	/* GPIO port PIO control */
+	struct {
+		u32 cidcfgr;	/* GPIO RIF CID configuration */
+		u32 semcr;	/* GPIO RIF semaphore */
+	} rif[16];
 };
 
 struct stm32_gpio_priv {
@@ -81,4 +139,6 @@ struct stm32_gpio_priv {
 	unsigned int gpio_range;
 };
 
+bool stm32_gpio_rif_valid(struct stm32_gpio_regs *regs, unsigned int offset);
+
 #endif /* _STM32_GPIO_PRIV_H_ */
diff --git a/drivers/hwspinlock/hwspinlock-uclass.c b/drivers/hwspinlock/hwspinlock-uclass.c
index e012d5a4c9..a47d615841 100644
--- a/drivers/hwspinlock/hwspinlock-uclass.c
+++ b/drivers/hwspinlock/hwspinlock-uclass.c
@@ -24,7 +24,7 @@ hwspinlock_dev_ops(struct udevice *dev)
 static int hwspinlock_of_xlate_default(struct hwspinlock *hws,
 				       struct ofnode_phandle_args *args)
 {
-	if (args->args_count > 1) {
+	if (args->args_count > 2) {
 		debug("Invalid args_count: %d\n", args->args_count);
 		return -EINVAL;
 	}
diff --git a/drivers/i2c/stm32f7_i2c.c b/drivers/i2c/stm32f7_i2c.c
index 836148e4c1..eec5ac4ef9 100644
--- a/drivers/i2c/stm32f7_i2c.c
+++ b/drivers/i2c/stm32f7_i2c.c
@@ -170,9 +170,11 @@ struct stm32_i2c_setup {
 /**
  * struct stm32_i2c_data - driver data for I2C configuration by compatible
  * @fmp_clr_offset: Fast Mode Plus clear register offset from set register
+ * @fmp_cr1_bit: Fast Mode Plus control is done via a bit in CR1
  */
 struct stm32_i2c_data {
 	u32 fmp_clr_offset;
+	bool fmp_cr1_bit;
 };
 
 /**
@@ -270,6 +272,10 @@ static const struct stm32_i2c_data stm32mp13_data = {
 	.fmp_clr_offset = 0x4,
 };
 
+static const struct stm32_i2c_data stm32mp25_data = {
+	.fmp_cr1_bit = true,
+};
+
 static int stm32_i2c_check_device_busy(struct stm32_i2c_priv *i2c_priv)
 {
 	struct stm32_i2c_regs *regs = i2c_priv->regs;
@@ -483,9 +489,9 @@ static int stm32_i2c_message_xfer(struct stm32_i2c_priv *i2c_priv,
 		}
 	}
 
-	/* End of transfer, send stop condition if appropriate */
-	if (!ret && !(status & (STM32_I2C_ISR_NACKF | STM32_I2C_ISR_ERRORS)))
-		setbits_le32(&regs->cr2, STM32_I2C_CR2_STOP);
+	/* End of transfer, send stop condition */
+	mask = STM32_I2C_CR2_STOP;
+	setbits_le32(&regs->cr2, mask);
 
 	return stm32_i2c_check_end_of_message(i2c_priv);
 }
@@ -797,6 +803,8 @@ static int stm32_i2c_write_fm_plus_bits(struct stm32_i2c_priv *i2c_priv)
 	int ret;
 	bool enable = i2c_priv->speed > I2C_SPEED_FAST_RATE;
 
+	/* TODO STM32MP25: handle FMP bit in CR1  register (fmp_cr1_bit = true) */
+
 	/* Optional */
 	if (IS_ERR_OR_NULL(i2c_priv->regmap))
 		return 0;
@@ -934,19 +942,21 @@ static int stm32_of_to_plat(struct udevice *dev)
 
 	i2c_priv->setup.analog_filter = dev_read_bool(dev, "i2c-analog-filter");
 
-	/* Optional */
-	i2c_priv->regmap = syscon_regmap_lookup_by_phandle(dev,
-							   "st,syscfg-fmp");
-	if (!IS_ERR(i2c_priv->regmap)) {
-		u32 fmp[3];
+	if (!data->fmp_cr1_bit) {
+		/* Optional */
+		i2c_priv->regmap = syscon_regmap_lookup_by_phandle(dev,
+								   "st,syscfg-fmp");
+		if (!IS_ERR(i2c_priv->regmap)) {
+			u32 fmp[3];
 
-		ret = dev_read_u32_array(dev, "st,syscfg-fmp", fmp, 3);
-		if (ret)
-			return ret;
+			ret = dev_read_u32_array(dev, "st,syscfg-fmp", fmp, 3);
+			if (ret)
+				return ret;
 
-		i2c_priv->regmap_sreg = fmp[1];
-		i2c_priv->regmap_creg = fmp[1] + data->fmp_clr_offset;
-		i2c_priv->regmap_mask = fmp[2];
+			i2c_priv->regmap_sreg = fmp[1];
+			i2c_priv->regmap_creg = fmp[1] + data->fmp_clr_offset;
+			i2c_priv->regmap_mask = fmp[2];
+		}
 	}
 
 	return 0;
@@ -961,6 +971,7 @@ static const struct udevice_id stm32_i2c_of_match[] = {
 	{ .compatible = "st,stm32f7-i2c", .data = (ulong)&stm32f7_data },
 	{ .compatible = "st,stm32mp15-i2c", .data = (ulong)&stm32mp15_data },
 	{ .compatible = "st,stm32mp13-i2c", .data = (ulong)&stm32mp13_data },
+	{ .compatible = "st,stm32mp25-i2c", .data = (ulong)&stm32mp25_data },
 	{}
 };
 
diff --git a/drivers/mailbox/stm32-ipcc.c b/drivers/mailbox/stm32-ipcc.c
index 69c86e059f..27e58e3ed8 100644
--- a/drivers/mailbox/stm32-ipcc.c
+++ b/drivers/mailbox/stm32-ipcc.c
@@ -103,7 +103,7 @@ static int stm32_ipcc_probe(struct udevice *dev)
 {
 	struct stm32_ipcc *ipcc = dev_get_priv(dev);
 	fdt_addr_t addr;
-	struct clk clk;
+	struct clk *clk;
 	int ret;
 
 	dev_dbg(dev, "\n");
@@ -115,7 +115,7 @@ static int stm32_ipcc_probe(struct udevice *dev)
 	ipcc->reg_base = (void __iomem *)addr;
 
 	/* proc_id */
-	ret = dev_read_u32_index(dev, "st,proc_id", 1, &ipcc->proc_id);
+	ret = dev_read_u32_index(dev, "st,proc-id", 0, &ipcc->proc_id);
 	if (ret) {
 		dev_dbg(dev, "Missing st,proc_id\n");
 		return -EINVAL;
@@ -127,25 +127,20 @@ static int stm32_ipcc_probe(struct udevice *dev)
 	}
 
 	ipcc->reg_proc = ipcc->reg_base + ipcc->proc_id * IPCC_PROC_OFFST;
-
-	ret = clk_get_by_index(dev, 0, &clk);
+	/*  Check if clocks is present, since clock is not present in m33td flavor */
+	clk = devm_clk_get_optional(dev, NULL);
+	ret = IS_ERR(clk);
 	if (ret)
 		return ret;
 
-	ret = clk_enable(&clk);
+	ret = clk_enable(clk);
 	if (ret)
-		goto clk_free;
-
+		return ret;
 	/* get channel number */
 	ipcc->n_chans = readl(ipcc->reg_base + IPCC_HWCFGR);
 	ipcc->n_chans &= IPCFGR_CHAN_MASK;
 
 	return 0;
-
-clk_free:
-	clk_free(&clk);
-
-	return ret;
 }
 
 static const struct udevice_id stm32_ipcc_ids[] = {
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 22cb9d637c..1c6ffe2851 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -37,6 +37,14 @@ config STM32_FMC2_EBI
 	  devices (like SRAM, ethernet adapters, FPGAs, LCD displays, ...) on
 	  SOCs containing the FMC2 External Bus Interface.
 
+config STM32_OMI
+	bool "Support for Octo Memory Interface on STM32MP SoCs"
+	depends on ARCH_STM32MP
+	help
+	  Select this option to enable the STM32 Octo Memory Interface controller
+	  (OMI) which provides either SPI or HyperBus support. This allows to support
+	  sNOR, sNAND or HyperFlash devices.
+
 config TI_AEMIF
 	tristate "Texas Instruments AEMIF driver"
 	depends on ARCH_KEYSTONE
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index 1cabf8ac9c..6e71365dca 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_MEMORY) += memory-uclass.o
 obj-$(CONFIG_SANDBOX_MEMORY) += memory-sandbox.o
 obj-$(CONFIG_STM32_FMC2_EBI) += stm32-fmc2-ebi.o
+obj-$(CONFIG_STM32_OMI) += stm32-omi.o
 obj-$(CONFIG_ATMEL_EBI) += atmel_ebi.o
 obj-$(CONFIG_TI_AEMIF) += ti-aemif.o
 obj-$(CONFIG_TI_GPMC) += ti-gpmc.o
diff --git a/drivers/memory/stm32-fmc2-ebi.c b/drivers/memory/stm32-fmc2-ebi.c
index 212bb4f5dc..2ef3cf5bba 100644
--- a/drivers/memory/stm32-fmc2-ebi.c
+++ b/drivers/memory/stm32-fmc2-ebi.c
@@ -21,8 +21,15 @@
 #define FMC2_BCR(x)			((x) * 0x8 + FMC2_BCR1)
 #define FMC2_BTR(x)			((x) * 0x8 + FMC2_BTR1)
 #define FMC2_PCSCNTR			0x20
+#define FMC2_CFGR			0x20
+#define FMC2_SR				0x84
 #define FMC2_BWTR1			0x104
 #define FMC2_BWTR(x)			((x) * 0x8 + FMC2_BWTR1)
+#define FMC2_SECCFGR			0x300
+#define FMC2_CIDCFGR0			0x30c
+#define FMC2_CIDCFGR(x)			((x) * 0x8 + FMC2_CIDCFGR0)
+#define FMC2_SEMCR0			0x310
+#define FMC2_SEMCR(x)			((x) * 0x8 + FMC2_SEMCR0)
 
 /* Register: FMC2_BCR1 */
 #define FMC2_BCR1_CCLKEN		BIT(20)
@@ -43,6 +50,7 @@
 #define FMC2_BCR_ASYNCWAIT		BIT(15)
 #define FMC2_BCR_CPSIZE			GENMASK(18, 16)
 #define FMC2_BCR_CBURSTRW		BIT(19)
+#define FMC2_BCR_CSCOUNT		GENMASK(21, 20)
 #define FMC2_BCR_NBLSET			GENMASK(23, 22)
 
 /* Register: FMC2_BTRx/FMC2_BWTRx */
@@ -59,8 +67,28 @@
 #define FMC2_PCSCNTR_CSCOUNT		GENMASK(15, 0)
 #define FMC2_PCSCNTR_CNTBEN(x)		BIT((x) + 16)
 
+/* Register: FMC2_CFGR */
+#define FMC2_CFGR_CLKDIV		GENMASK(19, 16)
+#define FMC2_CFGR_CCLKEN		BIT(20)
+#define FMC2_CFGR_FMC2EN		BIT(31)
+
+/* Register: FMC2_SR */
+#define FMC2_SR_ISOST			GENMASK(1, 0)
+
+/* Register: FMC2_CIDCFGR */
+#define FMC2_CIDCFGR_CFEN		BIT(0)
+#define FMC2_CIDCFGR_SEMEN		BIT(1)
+#define FMC2_CIDCFGR_SCID		GENMASK(6, 4)
+#define FMC2_CIDCFGR_SEMWLC1		BIT(17)
+
+/* Register: FMC2_SEMCR */
+#define FMC2_SEMCR_SEM_MUTEX		BIT(0)
+#define FMC2_SEMCR_SEMCID		GENMASK(6, 4)
+
 #define FMC2_MAX_EBI_CE			4
 #define FMC2_MAX_BANKS			5
+#define FMC2_MAX_RESOURCES		6
+#define FMC2_CID1			1
 
 #define FMC2_BCR_CPSIZE_0		0x0
 #define FMC2_BCR_CPSIZE_128		0x1
@@ -75,6 +103,11 @@
 #define FMC2_BCR_MTYP_PSRAM		0x1
 #define FMC2_BCR_MTYP_NOR		0x2
 
+#define FMC2_BCR_CSCOUNT_0		0x0
+#define FMC2_BCR_CSCOUNT_1		0x1
+#define FMC2_BCR_CSCOUNT_64		0x2
+#define FMC2_BCR_CSCOUNT_256		0x3
+
 #define FMC2_BXTR_EXTMOD_A		0x0
 #define FMC2_BXTR_EXTMOD_B		0x1
 #define FMC2_BXTR_EXTMOD_C		0x2
@@ -89,6 +122,7 @@
 #define FMC2_BTR_CLKDIV_MAX		0xf
 #define FMC2_BTR_DATLAT_MAX		0xf
 #define FMC2_PCSCNTR_CSCOUNT_MAX	0xff
+#define FMC2_CFGR_CLKDIV_MAX		0xf
 
 #define FMC2_NSEC_PER_SEC		1000000000L
 
@@ -104,7 +138,8 @@ enum stm32_fmc2_ebi_register_type {
 	FMC2_REG_BCR = 1,
 	FMC2_REG_BTR,
 	FMC2_REG_BWTR,
-	FMC2_REG_PCSCNTR
+	FMC2_REG_PCSCNTR,
+	FMC2_REG_CFGR
 };
 
 enum stm32_fmc2_ebi_transaction_type {
@@ -135,10 +170,30 @@ enum stm32_fmc2_ebi_cpsize {
 	FMC2_CPSIZE_1024 = 1024
 };
 
+enum stm32_fmc2_ebi_cscount {
+	FMC2_CSCOUNT_0 = 0,
+	FMC2_CSCOUNT_1 = 1,
+	FMC2_CSCOUNT_64 = 64,
+	FMC2_CSCOUNT_256 = 256
+};
+
+struct stm32_fmc2_ebi;
+
+struct stm32_fmc2_ebi_data {
+	const struct stm32_fmc2_prop *child_props;
+	unsigned int nb_child_props;
+	u32 fmc2_enable_reg;
+	u32 fmc2_enable_bit;
+	int (*nwait_used_by_ctrls)(struct stm32_fmc2_ebi *ebi);
+	int (*check_rif)(struct stm32_fmc2_ebi *ebi, u32 resource);
+};
+
 struct stm32_fmc2_ebi {
 	struct clk clk;
 	fdt_addr_t io_base;
+	const struct stm32_fmc2_ebi_data *data;
 	u8 bank_assigned;
+	bool access_granted;
 };
 
 /*
@@ -210,6 +265,28 @@ static int stm32_fmc2_ebi_check_sync_trans(struct stm32_fmc2_ebi *ebi,
 	return -EINVAL;
 }
 
+static int stm32_fmc2_ebi_mp25_check_cclk(struct stm32_fmc2_ebi *ebi,
+					  const struct stm32_fmc2_prop *prop,
+					  int cs)
+{
+	if (!ebi->access_granted)
+		return -EACCES;
+
+	return stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);
+}
+
+static int stm32_fmc2_ebi_mp25_check_clk_period(struct stm32_fmc2_ebi *ebi,
+						const struct stm32_fmc2_prop *prop,
+						int cs)
+{
+	u32 cfgr = readl(ebi->io_base + FMC2_CFGR);
+
+	if (cfgr & FMC2_CFGR_CCLKEN && !ebi->access_granted)
+		return -EACCES;
+
+	return stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);
+}
+
 static int stm32_fmc2_ebi_check_async_trans(struct stm32_fmc2_ebi *ebi,
 					    const struct stm32_fmc2_prop *prop,
 					    int cs)
@@ -297,6 +374,24 @@ static u32 stm32_fmc2_ebi_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
 	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
 }
 
+static u32 stm32_fmc2_ebi_mp25_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
+						int cs, u32 setup)
+{
+	u32 nb_clk_cycles = stm32_fmc2_ebi_ns_to_clock_cycles(ebi, cs, setup);
+	u32 cfgr = readl(ebi->io_base + FMC2_CFGR);
+	u32 clk_period;
+
+	if (cfgr & FMC2_CFGR_CCLKEN) {
+		clk_period = FIELD_GET(FMC2_CFGR_CLKDIV, cfgr) + 1;
+	} else {
+		u32 btr = readl(ebi->io_base + FMC2_BTR(cs));
+
+		clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
+	}
+
+	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
+}
+
 static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 {
 	switch (reg_type) {
@@ -312,6 +407,9 @@ static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 	case FMC2_REG_PCSCNTR:
 		*reg = FMC2_PCSCNTR;
 		break;
+	case FMC2_REG_CFGR:
+		*reg = FMC2_CFGR;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -650,6 +748,26 @@ static int stm32_fmc2_ebi_set_clk_period(struct stm32_fmc2_ebi *ebi,
 	return 0;
 }
 
+static int stm32_fmc2_ebi_mp25_set_clk_period(struct stm32_fmc2_ebi *ebi,
+					      const struct stm32_fmc2_prop *prop,
+					      int cs, u32 setup)
+{
+	u32 cfgr = readl(ebi->io_base + FMC2_CFGR);
+	u32 val;
+
+	if (cfgr & FMC2_CFGR_CCLKEN) {
+		val = setup ? clamp_val(setup - 1, 1, FMC2_CFGR_CLKDIV_MAX) : 1;
+		val = FIELD_PREP(FMC2_CFGR_CLKDIV, val);
+		clrsetbits_le32(ebi->io_base + FMC2_CFGR, FMC2_CFGR_CLKDIV, val);
+	} else {
+		val = setup ? clamp_val(setup - 1, 1, FMC2_BTR_CLKDIV_MAX) : 1;
+		val = FIELD_PREP(FMC2_BTR_CLKDIV, val);
+		clrsetbits_le32(ebi->io_base + FMC2_BTR(cs), FMC2_BTR_CLKDIV, val);
+	}
+
+	return 0;
+}
+
 static int stm32_fmc2_ebi_set_data_latency(struct stm32_fmc2_ebi *ebi,
 					   const struct stm32_fmc2_prop *prop,
 					   int cs, u32 setup)
@@ -690,6 +808,27 @@ static int stm32_fmc2_ebi_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
 	return 0;
 }
 
+static int stm32_fmc2_ebi_mp25_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
+						 const struct stm32_fmc2_prop *prop,
+						 int cs, u32 setup)
+{
+	u32 val;
+
+	if (setup == FMC2_CSCOUNT_0)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_0);
+	else if (setup == FMC2_CSCOUNT_1)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_1);
+	else if (setup <= FMC2_CSCOUNT_64)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_64);
+	else
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_256);
+
+	clrsetbits_le32(ebi->io_base + FMC2_BCR(cs),
+			FMC2_BCR_CSCOUNT, val);
+
+	return 0;
+}
+
 static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	/* st,fmc2-ebi-cs-trans-type must be the first property */
 	{
@@ -855,6 +994,235 @@ static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	},
 };
 
+static const struct stm32_fmc2_prop stm32_fmc2_mp25_child_props[] = {
+	/* st,fmc2-ebi-cs-trans-type must be the first property */
+	{
+		.name = "st,fmc2-ebi-cs-transaction-type",
+		.mprop = true,
+		.set = stm32_fmc2_ebi_set_trans_type,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-cclk-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_CFGR,
+		.reg_mask = FMC2_CFGR_CCLKEN,
+		.check = stm32_fmc2_ebi_mp25_check_cclk,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-mux-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_MUXEN,
+		.check = stm32_fmc2_ebi_check_mux,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-buswidth",
+		.reset_val = FMC2_BUSWIDTH_16,
+		.set = stm32_fmc2_ebi_set_buswidth,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-waitpol-high",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITPOL,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-waitcfg-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITCFG,
+		.check = stm32_fmc2_ebi_check_waitcfg,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-wait-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITEN,
+		.check = stm32_fmc2_ebi_check_sync_trans,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-asyncwait-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_ASYNCWAIT,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-cpsize",
+		.check = stm32_fmc2_ebi_check_cpsize,
+		.set = stm32_fmc2_ebi_set_cpsize,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-byte-lane-setup-ns",
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bl_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-address-setup-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_ADDSET_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-address-hold-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_ADDHLD_MAX,
+		.check = stm32_fmc2_ebi_check_address_hold,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-setup-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_DATAST_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-bus-turnaround-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bus_turnaround,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-hold-ns",
+		.reg_type = FMC2_REG_BTR,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-clk-period-ns",
+		.reset_val = FMC2_CFGR_CLKDIV_MAX + 1,
+		.check = stm32_fmc2_ebi_mp25_check_clk_period,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_mp25_set_clk_period,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-latency-ns",
+		.check = stm32_fmc2_ebi_check_sync_trans,
+		.calculate = stm32_fmc2_ebi_mp25_ns_to_clk_period,
+		.set = stm32_fmc2_ebi_set_data_latency,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-address-setup-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_ADDSET_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-address-hold-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_ADDHLD_MAX,
+		.check = stm32_fmc2_ebi_check_address_hold,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-data-setup-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_DATAST_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-bus-turnaround-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bus_turnaround,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-data-hold-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-max-low-pulse-ns",
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_mp25_set_max_low_pulse,
+	},
+};
+
+static int stm32_fmc2_ebi_mp25_check_rif(struct stm32_fmc2_ebi *ebi, u32 resource)
+{
+	u32 seccfgr, cidcfgr, semcr;
+	int cid;
+
+	if (resource >= FMC2_MAX_RESOURCES)
+		return -EINVAL;
+
+	seccfgr = readl(ebi->io_base + FMC2_SECCFGR);
+	if (seccfgr & BIT(resource)) {
+		if (resource)
+			log_err("resource %d is configured as secure\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	cidcfgr = readl(ebi->io_base + FMC2_CIDCFGR(resource));
+	if (!(cidcfgr & FMC2_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMEN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(FMC2_CIDCFGR_SCID, cidcfgr);
+		if (cid != FMC2_CID1) {
+			if (resource)
+				log_err("static CID%d set for resource %d\n",
+					cid, resource);
+
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMWLC1)) {
+		if (resource)
+			log_err("CID1 is block-listed for resource %d\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	semcr = readl(ebi->io_base + FMC2_SEMCR(resource));
+	if (!(semcr & FMC2_SEMCR_SEM_MUTEX)) {
+		setbits_le32(ebi->io_base + FMC2_SEMCR(resource),
+			     FMC2_SEMCR_SEM_MUTEX);
+		semcr = readl(ebi->io_base + FMC2_SEMCR(resource));
+	}
+
+	cid = FIELD_GET(FMC2_SEMCR_SEMCID, semcr);
+	if (cid != FMC2_CID1) {
+		if (resource)
+			log_err("resource %d is already used by CID%d\n",
+				resource, cid);
+
+		return -EACCES;
+	}
+
+	return 0;
+}
+
 static int stm32_fmc2_ebi_parse_prop(struct stm32_fmc2_ebi *ebi,
 				     ofnode node,
 				     const struct stm32_fmc2_prop *prop,
@@ -916,7 +1284,7 @@ static void stm32_fmc2_ebi_disable_bank(struct stm32_fmc2_ebi *ebi, int cs)
 }
 
 /* NWAIT signal can not be connected to EBI controller and NAND controller */
-static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
+static int stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 {
 	unsigned int cs;
 	u32 bcr;
@@ -927,16 +1295,22 @@ static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 
 		bcr = readl(ebi->io_base + FMC2_BCR(cs));
 		if ((bcr & FMC2_BCR_WAITEN || bcr & FMC2_BCR_ASYNCWAIT) &&
-		    ebi->bank_assigned & BIT(FMC2_NAND))
-			return true;
+		    ebi->bank_assigned & BIT(FMC2_NAND)) {
+			log_err("NWAIT signal connected to EBI and NAND controllers\n");
+			return -EINVAL;
+		}
 	}
 
-	return false;
+	return 0;
 }
 
 static void stm32_fmc2_ebi_enable(struct stm32_fmc2_ebi *ebi)
 {
-	setbits_le32(ebi->io_base + FMC2_BCR1, FMC2_BCR1_FMC2EN);
+	if (!ebi->access_granted)
+		return;
+
+	setbits_le32(ebi->io_base + ebi->data->fmc2_enable_reg,
+		     ebi->data->fmc2_enable_bit);
 }
 
 static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
@@ -947,8 +1321,8 @@ static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
 
 	stm32_fmc2_ebi_disable_bank(ebi, cs);
 
-	for (i = 0; i < ARRAY_SIZE(stm32_fmc2_child_props); i++) {
-		const struct stm32_fmc2_prop *p = &stm32_fmc2_child_props[i];
+	for (i = 0; i < ebi->data->nb_child_props; i++) {
+		const struct stm32_fmc2_prop *p = &ebi->data->child_props[i];
 
 		ret = stm32_fmc2_ebi_parse_prop(ebi, node, p, cs);
 		if (ret) {
@@ -988,6 +1362,14 @@ static int stm32_fmc2_ebi_parse_dt(struct udevice *dev,
 			return -EINVAL;
 		}
 
+		if (ebi->data->check_rif) {
+			ret = ebi->data->check_rif(ebi, bank + 1);
+			if (ret) {
+				dev_err(dev, "bank access failed: %d\n", bank);
+				return ret;
+			}
+		}
+
 		if (bank < FMC2_MAX_EBI_CE) {
 			ret = stm32_fmc2_ebi_setup_cs(ebi, child, bank);
 			if (ret) {
@@ -1005,9 +1387,10 @@ static int stm32_fmc2_ebi_parse_dt(struct udevice *dev,
 		return -ENODEV;
 	}
 
-	if (stm32_fmc2_ebi_nwait_used_by_ctrls(ebi)) {
-		dev_err(dev, "NWAIT signal connected to EBI and NAND controllers\n");
-		return -EINVAL;
+	if (ebi->data->nwait_used_by_ctrls) {
+		ret = ebi->data->nwait_used_by_ctrls(ebi);
+		if (ret)
+			return ret;
 	}
 
 	stm32_fmc2_ebi_enable(ebi);
@@ -1021,6 +1404,10 @@ static int stm32_fmc2_ebi_probe(struct udevice *dev)
 	struct reset_ctl reset;
 	int ret;
 
+	ebi->data = (void *)dev_get_driver_data(dev);
+	if (!ebi->data)
+		return -EINVAL;
+
 	ebi->io_base = dev_read_addr(dev);
 	if (ebi->io_base == FDT_ADDR_T_NONE)
 		return -EINVAL;
@@ -1040,11 +1427,49 @@ static int stm32_fmc2_ebi_probe(struct udevice *dev)
 		reset_deassert(&reset);
 	}
 
+	/* Check if CFGR register can be modified */
+	ebi->access_granted = true;
+	if (ebi->data->check_rif) {
+		ret = ebi->data->check_rif(ebi, 0);
+		if (ret) {
+			ebi->access_granted = false;
+
+			/* In case of CFGR is secure, just check that the FMC2 is enabled */
+			if (readl(ebi->io_base + FMC2_SR) & FMC2_SR_ISOST) {
+				dev_err(dev, "FMC2 is not ready to be used.\n");
+				return -EACCES;
+			}
+		}
+	}
+
 	return stm32_fmc2_ebi_parse_dt(dev, ebi);
 }
 
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp1_data = {
+	.child_props = stm32_fmc2_child_props,
+	.nb_child_props = ARRAY_SIZE(stm32_fmc2_child_props),
+	.fmc2_enable_reg = FMC2_BCR1,
+	.fmc2_enable_bit = FMC2_BCR1_FMC2EN,
+	.nwait_used_by_ctrls = stm32_fmc2_ebi_nwait_used_by_ctrls,
+};
+
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp25_data = {
+	.child_props = stm32_fmc2_mp25_child_props,
+	.nb_child_props = ARRAY_SIZE(stm32_fmc2_mp25_child_props),
+	.fmc2_enable_reg = FMC2_CFGR,
+	.fmc2_enable_bit = FMC2_CFGR_FMC2EN,
+	.check_rif = stm32_fmc2_ebi_mp25_check_rif,
+};
+
 static const struct udevice_id stm32_fmc2_ebi_match[] = {
-	{.compatible = "st,stm32mp1-fmc2-ebi"},
+	{
+		.compatible = "st,stm32mp1-fmc2-ebi",
+		.data = (ulong)&stm32_fmc2_ebi_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-ebi",
+		.data = (ulong)&stm32_fmc2_ebi_mp25_data,
+	},
 	{ /* Sentinel */ }
 };
 
diff --git a/drivers/memory/stm32-omi.c b/drivers/memory/stm32-omi.c
new file mode 100644
index 0000000000..2bc63c319e
--- /dev/null
+++ b/drivers/memory/stm32-omi.c
@@ -0,0 +1,523 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <misc.h>
+#include <regmap.h>
+#include <stm32_omi.h>
+#include <syscon.h>
+#include <watchdog.h>
+#include <dm/of_access.h>
+#include <dm/device-internal.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <dm/read.h>
+#include <linux/bitfield.h>
+#include <linux/ioport.h>
+
+static int stm32_omi_dlyb_set_tap(struct udevice *dev, u8 tap, bool rx_tap)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	u32 sr, mask, ack;
+	int ret;
+	u8 shift;
+
+	if (!omi_plat->regmap || !omi_plat->dlyb_base)
+		return -EINVAL;
+
+	if (rx_tap) {
+		mask = DLYBOS_CR_RXTAPSEL_MASK;
+		shift = DLYBOS_CR_RXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_RXTAPSEL_ACK;
+	} else {
+		mask = DLYBOS_CR_TXTAPSEL_MASK;
+		shift = DLYBOS_CR_TXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_TXTAPSEL_ACK;
+	}
+
+	regmap_update_bits(omi_plat->regmap,
+			   omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+			   mask, mask & (tap << shift));
+
+	ret = regmap_read_poll_timeout(omi_plat->regmap,
+				       omi_plat->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & ack, 1,
+				       STM32_DLYBOS_TIMEOUT_MS);
+	if (ret)
+		dev_err(dev, "%s delay block phase configuration timeout\n",
+			rx_tap ? "RX" : "TX");
+
+	return ret;
+}
+
+int stm32_omi_dlyb_find_tap(struct udevice *dev, bool rx_only, u8 *window_len)
+{
+	struct stm32_omi_priv *omi_priv = dev_get_priv(dev);
+	struct stm32_tap_window rx_tap_w[DLYBOS_TAPSEL_NB];
+	int ret;
+	u8 rx_len, rx_window_len, rx_window_end;
+	u8 tx_len, tx_window_len, tx_window_end;
+	u8 rx_tap, tx_tap, tx_tap_max, tx_tap_min, best_tx_tap = 0;
+	u8 score, score_max;
+
+	tx_len = 0;
+	tx_window_len = 0;
+	tx_window_end = 0;
+	omi_priv->is_calibrating = true;
+
+	for (tx_tap = 0;
+	     tx_tap < (rx_only ? 1 : DLYBOS_TAPSEL_NB);
+	     tx_tap++) {
+		ret = stm32_omi_dlyb_set_tap(dev, tx_tap, false);
+		if (ret)
+			return ret;
+
+		rx_len = 0;
+		rx_window_len = 0;
+		rx_window_end = 0;
+
+		for (rx_tap = 0; rx_tap < DLYBOS_TAPSEL_NB; rx_tap++) {
+			ret = stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+			if (ret)
+				return ret;
+
+			ret = omi_priv->check_transfer(dev);
+			if (ret) {
+				if ((!rx_only && ret == -ETIMEDOUT) ||
+				    ret == -EOPNOTSUPP)
+					break;
+
+				rx_len = 0;
+			} else {
+				rx_len++;
+				if (rx_len > rx_window_len) {
+					rx_window_len = rx_len;
+					rx_window_end = rx_tap;
+				}
+			}
+		}
+
+		if (ret == -EOPNOTSUPP)
+			break;
+
+		rx_tap_w[tx_tap].end = rx_window_end;
+		rx_tap_w[tx_tap].length = rx_window_len;
+
+		if (!rx_window_len) {
+			tx_len = 0;
+		} else {
+			tx_len++;
+			if (tx_len > tx_window_len) {
+				tx_window_len = tx_len;
+				tx_window_end = tx_tap;
+			}
+		}
+
+		dev_dbg(dev, "rx_tap_w[%02d].end = %d rx_tap_w[%02d].length = %d\n",
+			tx_tap, rx_tap_w[tx_tap].end, tx_tap, rx_tap_w[tx_tap].length);
+	}
+
+	omi_priv->is_calibrating = false;
+
+	if (ret == -EOPNOTSUPP) {
+		dev_err(dev, "Calibration can not be done on this device\n");
+		return ret;
+	}
+
+	if (rx_only) {
+		if (!rx_window_len) {
+			dev_err(dev, "Can't find RX phase settings\n");
+			return -EIO;
+		}
+
+		rx_tap = rx_window_end - rx_window_len / 2;
+		*window_len = rx_window_len;
+		dev_dbg(dev, "RX_TAP_SEL set to %d\n", rx_tap);
+
+		return stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+	}
+
+	if (!tx_window_len) {
+		dev_err(dev, "Can't find TX phase settings\n");
+		return -EIO;
+	}
+
+	/* find the best duet TX/RX TAP */
+	tx_tap_min = tx_window_end - tx_window_len + 1;
+	tx_tap_max = tx_window_end;
+	score_max = 0;
+	for (tx_tap = tx_tap_min; tx_tap <= tx_tap_max; tx_tap++) {
+		score = min_t(u8, tx_tap - tx_tap_min, tx_tap_max - tx_tap) +
+			rx_tap_w[tx_tap].length;
+		if (score > score_max) {
+			score_max = score;
+			best_tx_tap = tx_tap;
+		}
+	}
+
+	rx_tap = rx_tap_w[best_tx_tap].end - rx_tap_w[best_tx_tap].length / 2;
+
+	dev_dbg(dev, "RX_TAP_SEL set to %d\n", rx_tap);
+	ret = stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+	if (ret)
+		return ret;
+
+	dev_dbg(dev, "TX_TAP_SEL set to %d\n", best_tx_tap);
+
+	return stm32_omi_dlyb_set_tap(dev, best_tx_tap, false);
+}
+
+int stm32_omi_dlyb_set_cr(struct udevice *dev, u32 dlyb_cr)
+{
+	bool bypass_mode = false;
+	int ret;
+	u16 period_ps;
+	u8 rx_tap, tx_tap;
+
+	period_ps = FIELD_GET(DLYBOS_BYP_CMD_MASK, dlyb_cr);
+	if (dlyb_cr & DLYBOS_BYP_EN)
+		bypass_mode = true;
+
+	ret = stm32_omi_dlyb_configure(dev, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	/* restore Rx and TX tap */
+	rx_tap = FIELD_GET(DLYBOS_CR_RXTAPSEL_MASK, dlyb_cr);
+	ret = stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+	if (ret)
+		return ret;
+
+	tx_tap = FIELD_GET(DLYBOS_CR_TXTAPSEL_MASK, dlyb_cr);
+	return stm32_omi_dlyb_set_tap(dev, tx_tap, false);
+}
+
+void stm32_omi_dlyb_get_cr(struct udevice *dev, u32 *dlyb_cr)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+
+	regmap_read(omi_plat->regmap, omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+		    dlyb_cr);
+}
+
+/* ½ memory clock period in pico second */
+static const u16 dlybos_delay_ps[STM32_DLYBOS_DELAY_NB] = {
+2816, 4672, 6272, 7872, 9472, 11104, 12704, 14304, 15904, 17536, 19136, 20736,
+22336, 23968, 25568, 27168, 28768, 30400, 32000, 33600, 35232, 36832, 38432, 40032
+};
+
+static u32 stm32_omi_find_byp_cmd(u16 period_ps)
+{
+	u16 half_period_ps = period_ps / 2;
+	u8 max = STM32_DLYBOS_DELAY_NB - 1;
+	u8 i, min = 0;
+
+	/* find closest value in dlybos_delay_ps[] with half_period_ps*/
+	if (half_period_ps < dlybos_delay_ps[0])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, 1);
+
+	if (half_period_ps > dlybos_delay_ps[max])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, STM32_DLYBOS_DELAY_NB);
+
+	while (max - min > 1) {
+		i = DIV_ROUND_UP(min + max, 2);
+		if (half_period_ps > dlybos_delay_ps[i])
+			min = i;
+		else
+			max = i;
+	}
+
+	if ((dlybos_delay_ps[max] - half_period_ps) >
+	    (half_period_ps - dlybos_delay_ps[min]))
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, min + 1);
+	else
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, max + 1);
+}
+
+void stm32_omi_dlyb_stop(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+
+	/* disable delay block */
+	regmap_write(omi_plat->regmap,
+		     omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+		     0x0);
+}
+
+int stm32_omi_dlyb_configure(struct udevice *dev,
+			     bool bypass_mode, u16 period_ps)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	u32 sr, mask, val;
+	int ret;
+
+	if (!omi_plat->regmap || !omi_plat->dlyb_base)
+		return -EINVAL;
+
+	if (bypass_mode) {
+		val = DLYBOS_BYP_EN | stm32_omi_find_byp_cmd(period_ps);
+		mask = DLYBOS_BYP_EN | DLYBOS_BYP_CMD_MASK;
+	} else {
+		val = DLYBOS_CR_EN;
+		mask = DLYBOS_CR_EN;
+	}
+
+	regmap_update_bits(omi_plat->regmap,
+			  omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+			  mask, val);
+
+	if (bypass_mode)
+		return 0;
+
+	/* in lock mode, wait for lock status bit */
+	ret = regmap_read_poll_timeout(omi_plat->regmap,
+				       omi_plat->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & DLYBOS_SR_LOCK, 1,
+				       STM32_DLYBOS_TIMEOUT_MS);
+	if (ret) {
+		dev_err(dev, "Delay Block lock timeout\n");
+		stm32_omi_dlyb_stop(dev);
+	}
+
+	return ret;
+}
+
+static void stm32_omi_read_fifo(u8 *val, phys_addr_t addr)
+{
+	*val = readb(addr);
+	schedule();
+}
+
+static void stm32_omi_write_fifo(u8 *val, phys_addr_t addr)
+{
+	writeb(*val, addr);
+}
+
+int stm32_omi_tx_poll(struct udevice *dev, u8 *buf, u32 len, bool read)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	struct stm32_omi_priv *omi_priv = dev_get_priv(dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	void (*fifo)(u8 *val, phys_addr_t addr);
+	u32 sr;
+	int ret;
+
+	if (read)
+		fifo = stm32_omi_read_fifo;
+	else
+		fifo = stm32_omi_write_fifo;
+
+	while (len--) {
+		ret = readl_poll_timeout(regs_base + OSPI_SR, sr,
+					 sr & OSPI_SR_FTF,
+					 OSPI_FIFO_TIMEOUT_US);
+		if (ret) {
+			if (!omi_priv->is_calibrating)
+				dev_err(dev, "fifo timeout (len:%d stat:%#x)\n",
+					len, sr);
+			return ret;
+		}
+
+		fifo(buf++, regs_base + OSPI_DR);
+	}
+
+	return 0;
+}
+
+int stm32_omi_wait_for_not_busy(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 sr;
+	int ret;
+
+	ret = readl_poll_timeout(regs_base + OSPI_SR, sr, !(sr & OSPI_SR_BUSY),
+				 OSPI_BUSY_TIMEOUT_US);
+	if (ret)
+		dev_err(dev, "busy timeout (stat:%#x)\n", sr);
+
+	return ret;
+}
+
+int stm32_omi_wait_cmd(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 sr;
+	int ret = 0;
+
+	ret = readl_poll_timeout(regs_base + OSPI_SR, sr,
+				 sr & OSPI_SR_TCF,
+				 OSPI_CMD_TIMEOUT_US);
+	if (ret) {
+		dev_err(dev, "cmd timeout (stat:%#x)\n", sr);
+	} else if (readl(regs_base + OSPI_SR) & OSPI_SR_TEF) {
+		dev_err(dev, "transfer error (stat:%#x)\n", sr);
+		ret = -EIO;
+	}
+
+	/* clear flags */
+	writel(OSPI_FCR_CTCF | OSPI_FCR_CTEF, regs_base + OSPI_FCR);
+
+	if (!ret)
+		ret = stm32_omi_wait_for_not_busy(dev);
+
+	return ret;
+}
+
+static int stm32_omi_bind(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	struct driver *drv;
+	const char *name;
+	ofnode flash_node;
+	u8 hyperflash_count = 0;
+	u8 spi_flash_count = 0;
+	u8 child_count = 0;
+
+	/*
+	 * Flash subnodes sanity check:
+	 *        2 spi-nand/spi-nor flashes			=> supported
+	 *        1 HyperFlash					=> supported
+	 *	  All other flash node configuration		=> not supported
+	 */
+	omi_plat->jedec_flash = false;
+
+	dev_for_each_subnode(flash_node, dev) {
+		if (ofnode_device_is_compatible(flash_node, "cfi-flash"))
+			hyperflash_count++;
+
+		if (ofnode_device_is_compatible(flash_node, "jedec-flash")) {
+			hyperflash_count++;
+			omi_plat->jedec_flash = true;
+		}
+
+		if (ofnode_device_is_compatible(flash_node, "jedec,spi-nor") ||
+		    ofnode_device_is_compatible(flash_node, "spi-nand"))
+			spi_flash_count++;
+
+		child_count++;
+	}
+
+	if (!child_count) {
+		dev_err(dev, "Missing flash node\n");
+		return -ENODEV;
+	}
+
+	if ((!hyperflash_count && !spi_flash_count) ||
+	    child_count != (hyperflash_count + spi_flash_count)) {
+		dev_warn(dev, "Unknown flash type\n");
+		return -ENODEV;
+	}
+
+	if ((hyperflash_count && spi_flash_count) ||
+	    hyperflash_count > 1) {
+		dev_err(dev, "Flash node configuration not supported\n");
+		return -EINVAL;
+	}
+
+	if (spi_flash_count)
+		name = "stm32_ospi";
+	else
+		name = "stm32_hyperbus";
+
+	drv = lists_driver_lookup_name(name);
+	if (!drv) {
+		dev_err(dev, "Cannot find driver '%s'\n", name);
+		return -ENOENT;
+	}
+
+	return device_bind(dev, drv, dev_read_name(dev), NULL, dev_ofnode(dev), NULL);
+}
+
+static int stm32_omi_of_to_plat(struct udevice *dev)
+{
+	struct stm32_omi_plat *plat = dev_get_plat(dev);
+	struct resource res;
+	struct ofnode_phandle_args args;
+	const fdt32_t *reg;
+	int ret, len;
+
+	reg = dev_read_prop(dev, "reg", &len);
+	if (!reg) {
+		dev_err(dev, "Can't get regs base address\n");
+		return -ENOENT;
+	}
+
+	plat->regs_base = (phys_addr_t)dev_translate_address(dev, reg);
+
+	/* optional */
+	ret = dev_read_phandle_with_args(dev, "memory-region", NULL, 0, 0, &args);
+	if (!ret) {
+		ret = ofnode_read_resource(args.node, 0, &res);
+		if (ret) {
+			dev_err(dev, "Can't get mmap base address(%d)\n", ret);
+			return ret;
+		}
+
+		plat->mm_base = res.start;
+		plat->mm_size = resource_size(&res);
+
+		if (plat->mm_size > OSPI_MAX_MMAP_SZ) {
+			dev_err(dev, "Incorrect memory-map size: %lld Bytes\n", plat->mm_size);
+			return -EINVAL;
+		}
+
+		dev_dbg(dev, "%s: regs_base=<0x%llx> mm_base=<0x%llx> mm_size=<0x%x>\n",
+			__func__, plat->regs_base, plat->mm_base, (u32)plat->mm_size);
+	} else {
+		plat->mm_base = 0;
+		plat->mm_size = 0;
+		dev_info(dev, "memory-region property not found (%d)\n", ret);
+	}
+
+	ret = clk_get_by_index(dev, 0, &plat->clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to get clock\n");
+		return ret;
+	}
+
+	ret = reset_get_bulk(dev, &plat->rst_ctl);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Failed to get reset\n");
+		clk_free(&plat->clk);
+		return ret;
+	}
+
+	plat->clock_rate = clk_get_rate(&plat->clk);
+	if (!plat->clock_rate) {
+		clk_free(&plat->clk);
+		return -EINVAL;
+	}
+
+	plat->regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg-dlyb");
+	if (IS_ERR(plat->regmap)) {
+		dev_err(dev, "Can't find st,syscfg-dlyb property\n");
+		ret = PTR_ERR(plat->regmap);
+	} else {
+		ret = dev_read_u32_index(dev, "st,syscfg-dlyb", 1, &plat->dlyb_base);
+		if (ret)
+			dev_err(dev, "Can't read delay block base address\n");
+	}
+
+	return ret;
+};
+
+static const struct udevice_id stm32_omi_ids[] = {
+	{.compatible = "st,stm32mp25-omi" },
+	{ }
+};
+
+U_BOOT_DRIVER(stm32_omi) = {
+	.name		= "stm32-omi",
+	.id		= UCLASS_NOP,
+	.of_match	= stm32_omi_ids,
+	.of_to_plat	= stm32_omi_of_to_plat,
+	.plat_auto	= sizeof(struct stm32_omi_plat),
+	.priv_auto	= sizeof(struct stm32_omi_priv),
+	.bind		= stm32_omi_bind,
+};
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index b9f5c7a37a..50f0fd7fd6 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -452,6 +452,23 @@ config STM32MP_FUSE
 	  for STM32MP architecture.
 	  This API is needed for CMD_FUSE.
 
+config STM32_OMM
+	bool "Enable Octo Memory Manager (OMM) driver for the STM32MP2 SoC's family"
+	depends on (STM32MP23X || STM32MP25X) && MISC
+	help
+	  This driver manages the muxing between the 2 OSPI busses and
+	  the 2 output ports. There are 4 possible muxing configurations:
+	  - direct mode (no multiplexing): OSPI1 output is on port 1 and OSPI2
+	       output is on port 2
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 1
+	  - swapped mode (no multiplexing), OSPI1 output is on port 2,
+	       OSPI2 output is on port 1
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 2
+	  It also manages :
+	    - the split of the memory area shared between the 2 OSPI instances.
+	    - chip select selection override.
+	    - the time between 2 transactions in multiplexed mode.
+
 config STM32_RCC
 	bool "Enable RCC driver for the STM32 SoC's family"
 	depends on (ARCH_STM32 || ARCH_STM32MP) && MISC
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index fd8805f34b..30732a246d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -74,6 +74,7 @@ obj-$(CONFIG_SIFIVE_OTP) += sifive-otp.o
 obj-$(CONFIG_SMSC_LPC47M) += smsc_lpc47m.o
 obj-$(CONFIG_SMSC_SIO1007) += smsc_sio1007.o
 obj-$(CONFIG_STM32MP_FUSE) += stm32mp_fuse.o
+obj-$(CONFIG_STM32_OMM) += stm32_omm.o
 obj-$(CONFIG_STM32_RCC) += stm32_rcc.o
 obj-$(CONFIG_SYS_DPAA_QBMAN) += fsl_portals.o
 obj-$(CONFIG_TEGRA186_BPMP) += tegra186_bpmp.o
diff --git a/drivers/misc/stm32_omm.c b/drivers/misc/stm32_omm.c
new file mode 100644
index 0000000000..0d4f618ca4
--- /dev/null
+++ b/drivers/misc/stm32_omm.c
@@ -0,0 +1,428 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <regmap.h>
+#include <stm32_omi.h>
+#include <syscon.h>
+#include <dm/device_compat.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <dm/of_addr.h>
+#include <dm/of_access.h>
+#include <linux/bitfield.h>
+#include <linux/ioport.h>
+#include <mach/rif.h>
+
+#define OCTOSPIM_CR		0
+#define CR_MUXEN		BIT(0)
+#define CR_MUXENMODE_MASK	GENMASK(1, 0)
+#define CR_CSSEL_OVR_EN		BIT(4)
+#define CR_CSSEL_OVR_MASK	GENMASK(6, 5)
+#define CR_REQ2ACK_MASK		GENMASK(23, 16)
+
+#define OMM_CHILD_NB		2
+
+#define NSEC_PER_SEC		1000000000L
+
+struct stm32_omm_plat {
+	struct regmap *omm_regmap;
+	struct regmap *syscfg_regmap;
+	struct clk clk;
+	struct reset_ctl reset_ctl;
+	resource_size_t mm_ospi2_size;
+	u32 mux;
+	u32 cssel_ovr;
+	u32 req2ack;
+	u32 amcr_base;
+	u32 amcr_mask;
+	unsigned long clk_rate_max;
+};
+
+static int stm32_omm_set_amcr(struct udevice *dev, bool set)
+{
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	unsigned int amcr, read_amcr;
+
+	amcr = plat->mm_ospi2_size / SZ_64M;
+
+	if (set)
+		regmap_update_bits(plat->syscfg_regmap, plat->amcr_base,
+				   plat->amcr_mask, amcr);
+
+	/* read AMCR and check coherency with memory-map areas defined in DT */
+	regmap_read(plat->syscfg_regmap, plat->amcr_base, &read_amcr);
+	read_amcr = read_amcr >> (ffs(plat->amcr_mask) - 1);
+
+	if (amcr != read_amcr) {
+		dev_err(dev, "AMCR value not coherent with DT memory-map areas\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32_omm_configure(struct udevice *dev)
+{
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	int ret;
+	u32 mux = 0;
+	u32 cssel_ovr = 0;
+	u32 req2ack = 0;
+
+	ret = clk_enable(&plat->clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable OMM clock (%d)\n", ret);
+		return ret;
+	}
+
+	reset_assert(&plat->reset_ctl);
+	udelay(2);
+	reset_deassert(&plat->reset_ctl);
+
+	if (plat->mux & CR_MUXEN) {
+		if (!plat->req2ack) {
+			req2ack = DIV_ROUND_UP(plat->req2ack,
+					       NSEC_PER_SEC / plat->clk_rate_max) - 1;
+			if (req2ack > 256)
+				req2ack = 256;
+		}
+
+		req2ack = FIELD_PREP(CR_REQ2ACK_MASK, req2ack);
+		regmap_update_bits(plat->omm_regmap, OCTOSPIM_CR,
+					 CR_REQ2ACK_MASK, req2ack);
+	}
+
+	if (plat->cssel_ovr != 0xff) {
+		cssel_ovr = FIELD_PREP(CR_CSSEL_OVR_MASK, cssel_ovr);
+		cssel_ovr |= CR_CSSEL_OVR_EN;
+		regmap_update_bits(plat->omm_regmap, OCTOSPIM_CR,
+				   CR_CSSEL_OVR_MASK, cssel_ovr);
+	}
+
+	mux = FIELD_PREP(CR_MUXENMODE_MASK, plat->mux);
+	regmap_update_bits(plat->omm_regmap, OCTOSPIM_CR,
+			   CR_MUXENMODE_MASK, mux);
+
+	clk_disable(&plat->clk);
+
+	return stm32_omm_set_amcr(dev, true);
+}
+
+static int stm32_omm_disable_child(struct udevice *dev, ofnode child)
+{
+	struct regmap *omi_regmap;
+	struct clk omi_clk;
+	int ret;
+
+	ret = regmap_init_mem(child, &omi_regmap);
+	if (ret) {
+		dev_err(dev, "Regmap failed for node %s\n", ofnode_get_name(child));
+		return ret;
+	}
+
+	/* retrieve OMI clk */
+	ret = clk_get_by_index_nodev(child, 0, &omi_clk);
+	if (ret) {
+		dev_err(dev, "Failed to get clock for %s\n", ofnode_get_name(child));
+		return ret;
+	}
+
+	ret = clk_enable(&omi_clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clock for %s\n", ofnode_get_name(child));
+		goto clk_free;
+	}
+
+	regmap_update_bits(omi_regmap, OSPI_CR, OSPI_CR_EN, 0);
+
+	clk_disable(&omi_clk);
+clk_free:
+	clk_free(&omi_clk);
+
+	return ret;
+}
+
+static int stm32_omm_enable_child_clock(struct udevice *dev, ofnode child)
+{
+	struct clk omi_clk;
+	int ret;
+
+	ret = clk_get_by_index_nodev(child, 0, &omi_clk);
+	if (ret) {
+		dev_err(dev, "Failed to get clock for %s\n", ofnode_get_name(child));
+		return ret;
+	}
+
+	ret = clk_enable(&omi_clk);
+	if (ret)
+		dev_err(dev, "Failed to enable clock for %s\n", ofnode_get_name(child));
+
+	clk_free(&omi_clk);
+
+	return ret;
+}
+
+static int stm32_omm_probe(struct udevice *dev) {
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	ofnode child_list[OMM_CHILD_NB];
+	ofnode child;
+	int ret;
+	u8 nb_child = 0;
+	u8 child_access_granted = 0;
+	u8 i;
+	bool child_access[OMM_CHILD_NB];
+
+	/* check child's access */
+	for (child = ofnode_first_subnode(dev_ofnode(dev));
+	     ofnode_valid(child);
+	     child = ofnode_next_subnode(child)) {
+
+		if (nb_child > OMM_CHILD_NB) {
+			dev_err(dev, "Bad DT, found too much children\n");
+			return -E2BIG;
+		}
+
+		if (!ofnode_device_is_compatible(child, "st,stm32mp25-omi"))
+			return -EINVAL;
+
+		ret = stm32_rifsc_check_access(child);
+		if (ret < 0 && ret != -EACCES)
+			return ret;
+
+		child_access[nb_child] = false;
+		if (!ret) {
+			child_access_granted++;
+			child_access[nb_child] = true;
+		}
+
+		child_list[nb_child] = child;
+		nb_child++;
+	}
+
+	if (nb_child != OMM_CHILD_NB)
+		return -EINVAL;
+
+	/* check if OMM's ressource access is granted */
+	ret = stm32_rifsc_check_access(dev_ofnode(dev));
+	if (ret < 0 && ret != -EACCES)
+		return ret;
+
+	/* All child's access are granted ? */
+	if (!ret && child_access_granted == nb_child) {
+		/* Ensure both OSPI instance are disabled before configuring OMM */
+		for (i = 0; i < nb_child; i++) {
+			ret = stm32_omm_disable_child(dev, child_list[i]);
+			if (ret)
+				return ret;
+		}
+
+		ret = stm32_omm_configure(dev);
+		if (ret)
+			return ret;
+
+		if (plat->mux & CR_MUXEN) {
+			/*
+			 * If the mux is enabled, the 2 OSPI clocks have to be
+			 * always enabled
+			 */
+
+			for (i = 0; i < nb_child; i++) {
+				ret = stm32_omm_enable_child_clock(dev, child_list[i]);
+				if (ret)
+					return ret;
+			}
+		}
+	} else {
+		dev_dbg(dev, "Octo Memory Manager resource's access not granted\n");
+		/*
+		 * AMCR can't be set, so check if current value is coherent
+		 * with memory-map areas defined in DT
+		 */
+		ret = stm32_omm_set_amcr(dev, false);
+	}
+
+	return ret;
+}
+
+static int stm32_omm_of_to_plat(struct udevice *dev)
+{
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	static const char *mm_name[] = { "mm_ospi1", "mm_ospi2" };
+	struct resource res, res1, mm_res;
+	struct ofnode_phandle_args args;
+	struct udevice *child;
+	unsigned long clk_rate;
+	struct clk child_clk;
+	u32 mm_size = 0;
+	int ret, idx;
+	u8 i;
+
+	ret = regmap_init_mem(dev_ofnode(dev), &plat->omm_regmap);
+	if (ret) {
+		dev_err(dev, "I/O manager regmap failed\n");
+		return ret;
+	}
+
+	ret = dev_read_resource_byname(dev, "omm_mm", &mm_res);
+	if (ret) {
+		dev_err(dev, "can't get omm_mm mmap resource(ret = %d)!\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_index(dev, 0, &plat->reset_ctl);
+	if (ret)
+		return ret;
+
+	ret = clk_get_by_index(dev, 0, &plat->clk);
+	if (ret < 0) {
+		dev_err(dev, "Can't find I/O manager clock\n");
+		return ret;
+	}
+
+	/* parse children's clock */
+	plat->clk_rate_max = 0;
+	device_foreach_child(child, dev) {
+		ret = clk_get_by_index(child, 0, &child_clk);
+		if (ret) {
+			dev_err(dev, "Failed to get clock for %s\n",
+				dev_read_name(child));
+			return ret;
+		}
+
+		clk_rate = clk_get_rate(&child_clk);
+		clk_free(&child_clk);
+		if (!clk_rate) {
+			dev_err(dev, "Invalid clock rate\n");
+			return -EINVAL;
+		}
+
+		if (clk_rate > plat->clk_rate_max)
+			plat->clk_rate_max = clk_rate;
+	}
+
+	plat->mux = dev_read_u32_default(dev, "st,omm-mux", 0);
+	plat->req2ack = dev_read_u32_default(dev, "st,omm-req2ack-ns", 0);
+	plat->cssel_ovr = dev_read_u32_default(dev, "st,omm-cssel-ovr", 0xff);
+	plat->mm_ospi2_size = 0;
+
+	for (i = 0; i < 2; i++) {
+		idx = dev_read_stringlist_search(dev, "memory-region-names",
+						 mm_name[i]);
+		if (idx < 0)
+			continue;
+
+		/* res1 only used on second loop iteration */
+		res1.start = res.start;
+		res1.end = res.end;
+
+		dev_read_phandle_with_args(dev, "memory-region", NULL, 0, idx,
+					   &args);
+		ret = ofnode_read_resource(args.node, 0, &res);
+		if (ret) {
+			dev_err(dev, "unable to resolve memory region\n");
+			goto clk_free;
+		}
+
+		/* check that memory region fits inside OMM memory map area */
+		if (!resource_contains(&mm_res, &res)) {
+			dev_err(dev, "%s doesn't fit inside OMM memory map area\n",
+				mm_name[i]);
+			dev_err(dev, "[0x%llx-0x%llx] doesn't fit inside [0x%llx-0x%llx]\n",
+				res.start, res.end,
+				mm_res.start, mm_res.end);
+
+			return -EFAULT;
+		}
+
+		if (i == 1) {
+			plat->mm_ospi2_size = resource_size(&res);
+
+			/* check that OMM memory region 1 doesn't overlap memory region 2 */
+			if (resource_overlaps(&res, &res1)) {
+				dev_err(dev, "OMM memory-region %s overlaps memory region %s\n",
+					mm_name[0], mm_name[1]);
+				dev_err(dev, "[0x%llx-0x%llx] overlaps [0x%llx-0x%llx]\n",
+					res1.start, res1.end, res.start, res.end);
+
+				return -EFAULT;
+			}
+		}
+
+		mm_size += resource_size(&res);
+	}
+
+	plat->syscfg_regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg-amcr");
+	if (IS_ERR(plat->syscfg_regmap)) {
+		dev_err(dev, "Failed to get st,syscfg-amcr property\n");
+		ret = PTR_ERR(plat->syscfg_regmap);
+		goto clk_free;
+	}
+
+	ret = dev_read_u32_index(dev, "st,syscfg-amcr", 1, &plat->amcr_base);
+	if (ret) {
+		dev_err(dev, "Failed to get st,syscfg-amcr base\n");
+		goto clk_free;
+	}
+
+	ret = dev_read_u32_index(dev, "st,syscfg-amcr", 2, &plat->amcr_mask);
+	if (ret) {
+		dev_err(dev, "Failed to get st,syscfg-amcr mask\n");
+		goto clk_free;
+	}
+
+	return 0;
+
+clk_free:
+	clk_free(&plat->clk);
+
+	return ret;
+};
+
+static int stm32_omm_bind(struct udevice *dev)
+{
+	int ret = 0, err = 0;
+	ofnode node;
+
+	for (node = ofnode_first_subnode(dev_ofnode(dev));
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node) || stm32_rifsc_check_access(node)) {
+			dev_dbg(dev, "%s failed to bind\n", node_name);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err && !ret) {
+			ret = err;
+			dev_dbg(dev, "%s: ret=%d\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_dbg(dev, "Some drivers failed to bind\n");
+
+	return ret;
+}
+
+static const struct udevice_id stm32_omm_ids[] = {
+	{ .compatible = "st,stm32mp25-omm", },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_omm) = {
+	.name		= "stm32_omm",
+	.id		= UCLASS_NOP,
+	.probe		= stm32_omm_probe,
+	.of_match	= stm32_omm_ids,
+	.of_to_plat	= stm32_omm_of_to_plat,
+	.plat_auto	= sizeof(struct stm32_omm_plat),
+	.bind		= stm32_omm_bind,
+};
diff --git a/drivers/misc/stm32_rcc.c b/drivers/misc/stm32_rcc.c
index c1e5428a6b..af389c04d6 100644
--- a/drivers/misc/stm32_rcc.c
+++ b/drivers/misc/stm32_rcc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2017-2024, STMicroelectronics - All Rights Reserved
  * Author(s): Patrice Chotard, <patrice.chotard@foss.st.com> for STMicroelectronics.
  */
 
@@ -15,47 +15,61 @@
 #include <dm/device_compat.h>
 #include <dm/lists.h>
 
-struct stm32_rcc_clk stm32_rcc_clk_f42x = {
-	.drv_name = "stm32fx_rcc_clock",
+static const struct stm32_rcc stm32_rcc_f42x = {
+	.drv_name_clk = "stm32fx_rcc_clock",
+	.drv_name_rst = "stm32_rcc_reset",
 	.soc = STM32F42X,
 };
 
-struct stm32_rcc_clk stm32_rcc_clk_f469 = {
-	.drv_name = "stm32fx_rcc_clock",
+static const struct stm32_rcc stm32_rcc_f469 = {
+	.drv_name_clk = "stm32fx_rcc_clock",
+	.drv_name_rst = "stm32_rcc_reset",
 	.soc = STM32F469,
 };
 
-struct stm32_rcc_clk stm32_rcc_clk_f7 = {
-	.drv_name = "stm32fx_rcc_clock",
+static const struct stm32_rcc stm32_rcc_f7 = {
+	.drv_name_clk = "stm32fx_rcc_clock",
+	.drv_name_rst = "stm32_rcc_reset",
 	.soc = STM32F7,
 };
 
-struct stm32_rcc_clk stm32_rcc_clk_h7 = {
-	.drv_name = "stm32h7_rcc_clock",
+static const struct stm32_rcc stm32_rcc_h7 = {
+	.drv_name_clk = "stm32h7_rcc_clock",
+	.drv_name_rst = "stm32_rcc_reset",
 };
 
-struct stm32_rcc_clk stm32_rcc_clk_mp1 = {
-	.drv_name = "stm32mp1_clk",
-	.soc = STM32MP1,
+static const struct stm32_rcc stm32_rcc_mp1 = {
+	.drv_name_clk = "stm32mp1_clk",
+	.drv_name_rst = "stm32mp1_reset",
 };
 
-struct stm32_rcc_clk stm32_rcc_clk_mp13 = {
-	.drv_name = "stm32mp13_clk",
-	.soc = STM32MP1,
+static const struct stm32_rcc stm32_rcc_mp13 = {
+	.drv_name_clk = "stm32mp13_clk",
+	.drv_name_rst = "stm32mp1_reset",
+};
+
+static const struct stm32_rcc stm32_rcc_mp21 = {
+	.drv_name_clk = "stm32mp21_clk",
+	.drv_name_rst = "stm32mp21_reset",
+};
+
+static const struct stm32_rcc stm32_rcc_mp25 = {
+	.drv_name_clk = "stm32mp25_clk",
+	.drv_name_rst = "stm32mp25_reset",
 };
 
 static int stm32_rcc_bind(struct udevice *dev)
 {
 	struct udevice *child;
 	struct driver *drv;
-	struct stm32_rcc_clk *rcc_clk =
-		(struct stm32_rcc_clk *)dev_get_driver_data(dev);
+	struct stm32_rcc *rcc_clk =
+		(struct stm32_rcc *)dev_get_driver_data(dev);
 	int ret;
 
 	dev_dbg(dev, "RCC bind\n");
-	drv = lists_driver_lookup_name(rcc_clk->drv_name);
+	drv = lists_driver_lookup_name(rcc_clk->drv_name_clk);
 	if (!drv) {
-		dev_err(dev, "Cannot find driver '%s'\n", rcc_clk->drv_name);
+		dev_err(dev, "Cannot find driver '%s'\n", rcc_clk->drv_name_clk);
 		return -ENOENT;
 	}
 
@@ -66,26 +80,25 @@ static int stm32_rcc_bind(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	drv = lists_driver_lookup_name("stm32_rcc_reset");
+	drv = lists_driver_lookup_name(rcc_clk->drv_name_rst);
 	if (!drv) {
-		dev_err(dev, "Cannot find driver stm32_rcc_reset'\n");
+		dev_err(dev, "Cannot find driver '%s'\n", rcc_clk->drv_name_rst);
 		return -ENOENT;
 	}
 
-	return device_bind_with_driver_data(dev, drv, dev->name,
-					    rcc_clk->soc,
-					    dev_ofnode(dev), &child);
+	return device_bind(dev, drv, dev->name, NULL, dev_ofnode(dev), &child);
 }
 
-
 static const struct udevice_id stm32_rcc_ids[] = {
-	{.compatible = "st,stm32f42xx-rcc", .data = (ulong)&stm32_rcc_clk_f42x },
-	{.compatible = "st,stm32f469-rcc", .data = (ulong)&stm32_rcc_clk_f469 },
-	{.compatible = "st,stm32f746-rcc", .data = (ulong)&stm32_rcc_clk_f7 },
-	{.compatible = "st,stm32h743-rcc", .data = (ulong)&stm32_rcc_clk_h7 },
-	{.compatible = "st,stm32mp1-rcc", .data = (ulong)&stm32_rcc_clk_mp1 },
-	{.compatible = "st,stm32mp1-rcc-secure", .data = (ulong)&stm32_rcc_clk_mp1 },
-	{.compatible = "st,stm32mp13-rcc", .data = (ulong)&stm32_rcc_clk_mp13 },
+	{.compatible = "st,stm32f42xx-rcc", .data = (ulong)&stm32_rcc_f42x },
+	{.compatible = "st,stm32f469-rcc", .data = (ulong)&stm32_rcc_f469 },
+	{.compatible = "st,stm32f746-rcc", .data = (ulong)&stm32_rcc_f7 },
+	{.compatible = "st,stm32h743-rcc", .data = (ulong)&stm32_rcc_h7 },
+	{.compatible = "st,stm32mp1-rcc", .data = (ulong)&stm32_rcc_mp1 },
+	{.compatible = "st,stm32mp1-rcc-secure", .data = (ulong)&stm32_rcc_mp1 },
+	{.compatible = "st,stm32mp13-rcc", .data = (ulong)&stm32_rcc_mp13 },
+	{.compatible = "st,stm32mp21-rcc", .data = (ulong)&stm32_rcc_mp21 },
+	{.compatible = "st,stm32mp25-rcc", .data = (ulong)&stm32_rcc_mp25 },
 	{ }
 };
 
diff --git a/drivers/mmc/stm32_sdmmc2.c b/drivers/mmc/stm32_sdmmc2.c
index b68594de37..5bfedb826f 100644
--- a/drivers/mmc/stm32_sdmmc2.c
+++ b/drivers/mmc/stm32_sdmmc2.c
@@ -219,9 +219,9 @@ static void stm32_sdmmc2_start_data(struct udevice *dev,
 
 	if (data->flags & MMC_DATA_READ) {
 		data_ctrl |= SDMMC_DCTRL_DTDIR;
-		idmabase0 = (u32)data->dest;
+		idmabase0 = (u32)(long)data->dest;
 	} else {
-		idmabase0 = (u32)data->src;
+		idmabase0 = (u32)(long)data->src;
 	}
 
 	/* Set the SDMMC DataLength value */
@@ -462,8 +462,8 @@ retry_cmd:
 
 	stm32_sdmmc2_start_cmd(dev, cmd, cmdat, &ctx);
 
-	dev_dbg(dev, "send cmd %d data: 0x%x @ 0x%x\n",
-		cmd->cmdidx, data ? ctx.data_length : 0, (unsigned int)data);
+	dev_dbg(dev, "send cmd %d data: 0x%x @ 0x%p\n",
+		cmd->cmdidx, data ? ctx.data_length : 0, data);
 
 	ret = stm32_sdmmc2_end_cmd(dev, cmd, &ctx);
 
@@ -790,6 +790,7 @@ static int stm32_sdmmc2_bind(struct udevice *dev)
 
 static const struct udevice_id stm32_sdmmc2_ids[] = {
 	{ .compatible = "st,stm32-sdmmc2" },
+	{ .compatible = "st,stm32mp25-sdmmc2" },
 	{ }
 };
 
diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index c56840c849..2bce1e0ebf 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -134,6 +134,13 @@ config FLASH_CFI_MTD
 	  in the drivers directory. The driver exports CFI flash
 	  to the MTD layer.
 
+ config FLASH_CFI_SFDP
+	bool "Enable SFDP parsing"
+	depends on FLASH_CFI_DRIVER
+	help
+	  This option enables the SFDP parsing which allows
+	  to support SEMPER flashes.
+
 config SYS_FLASH_PROTECTION
 	bool "Use hardware flash protection"
 	depends on FLASH_CFI_DRIVER
@@ -207,6 +214,13 @@ config STM32_FLASH
 	 This is the driver of embedded flash for some STMicroelectronics
 	 STM32 MCU.
 
+config STM32_HYPERBUS
+	bool "STMicroelectronics HyperBus driver"
+	depends on ARCH_STM32MP && DM_MTD && CFI_FLASH
+	help
+	  This enables STMicroelectronics HyperBus controller on STM32MP2
+	  SoCs family.
+
 config SYS_MAX_FLASH_SECT
 	int "Maximumm number of sectors on a flash chip"
 	depends on MTD_NOR_FLASH || FLASH_CFI_DRIVER
@@ -215,6 +229,7 @@ config SYS_MAX_FLASH_SECT
 config SAMSUNG_ONENAND
 	bool "Samsung OneNAND driver support"
 
+
 config USE_SYS_MAX_FLASH_BANKS
 	bool "Enable Max number of Flash memory banks"
 	help
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index c638980ea2..b66f506559 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -11,7 +11,9 @@ mtd-$(CONFIG_ALTERA_QSPI) += altera_qspi.o
 mtd-$(CONFIG_FLASH_CFI_DRIVER) += cfi_flash.o
 mtd-$(CONFIG_FLASH_CFI_MTD) += cfi_mtd.o
 mtd-$(CONFIG_FLASH_CFI_LEGACY) += jedec_flash.o
+mtd-$(CONFIG_FLASH_CFI_SFDP) += sfdp_flash.o
 mtd-$(CONFIG_STM32_FLASH) += stm32_flash.o
+mtd-$(CONFIG_STM32_HYPERBUS) += stm32_hyperbus.o
 mtd-$(CONFIG_RENESAS_RPC_HF) += renesas_rpc_hf.o
 mtd-$(CONFIG_HBMC_AM654) += hbmc-am654.o
 
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 8ade7949a6..d0300eba61 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -31,9 +31,15 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <asm/unaligned.h>
+#include <dm/device_compat.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
 #include <env_internal.h>
 #include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sizes.h>
 #include <mtd/cfi_flash.h>
+#include <mtd/sfdp_flash.h>
 #include <watchdog.h>
 
 /*
@@ -599,6 +605,11 @@ static int flash_status_check(flash_info_t *info, flash_sect_t sector,
 	return ERR_OK;
 }
 
+static inline int manufact_match(flash_info_t *info, u32 manu)
+{
+	return info->manufacturer_id == ((manu & FLASH_VENDMASK) >> 16);
+}
+
 /*-----------------------------------------------------------------------
  * Wait for XSR.7 to be set, if it times out print an error, otherwise
  * do a full status check.
@@ -641,6 +652,30 @@ static int flash_full_status_check(flash_info_t *info, flash_sect_t sector,
 		flash_write_cmd(info, sector, 0, info->cmd_reset);
 		udelay(1);
 		break;
+	case CFI_CMDSET_AMD_STANDARD:
+		if (retcode == ERR_OK && manufact_match(info, CY_MANUFACT)) {
+			ushort st;
+
+			flash_write_cmd(info, sector, info->addr_unlock1,
+					FLASH_CMD_READ_STATUS);
+			st = flash_read_word(info, 0);
+
+			if (st & (FLASH_STATUS_ECLBS | FLASH_STATUS_PSLBS)) {
+				if (st & FLASH_STATUS_ECLBS) {
+					puts("Block Erase Error.\n");
+					retcode = ERR_NOT_ERASED;
+				} else if (st & FLASH_STATUS_VPENS) {
+					puts("Write Buffer Abort.\n");
+					retcode = ERR_ABORTED;
+				} else {
+					puts("Program Error.\n");
+					retcode = ERR_PROG_ERROR;
+				}
+				flash_write_cmd(info, 0, info->addr_unlock1,
+						FLASH_CMD_CLEAR_ERROR_STATUS);
+			}
+		}
+		break;
 	default:
 		break;
 	}
@@ -994,6 +1029,11 @@ static int flash_write_cfibuffer(flash_info_t *info, ulong dest, uchar *cp,
 #ifdef CONFIG_FLASH_SPANSION_S29WS_N
 		offset = ((unsigned long)dst - info->start[sector]) >> shift;
 #endif
+		if (manufact_match(info, CY_MANUFACT) &&
+		    flash_sector_size(info, sector) != SZ_256K)
+			offset = (((unsigned long)dst - info->start[sector]) &
+				  ~(SZ_4K - 1)) >> shift;
+
 		flash_write_cmd(info, sector, offset, AMD_CMD_WRITE_TO_BUFFER);
 		cnt = len >> shift;
 		flash_write_cmd(info, sector, offset, cnt - 1);
@@ -1028,7 +1068,10 @@ static int flash_write_cfibuffer(flash_info_t *info, ulong dest, uchar *cp,
 			goto out_unmap;
 		}
 
-		flash_write_cmd(info, sector, 0, AMD_CMD_WRITE_BUFFER_CONFIRM);
+		if (!manufact_match(info, CY_MANUFACT))
+			offset = 0;
+
+		flash_write_cmd(info, sector, offset, AMD_CMD_WRITE_BUFFER_CONFIRM);
 		if (use_flash_status_poll(info))
 			retcode = flash_status_poll(info, src - (1 << shift),
 						    dst - (1 << shift),
@@ -1051,6 +1094,29 @@ out_unmap:
 }
 #endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
 
+static int flash_blank_check(flash_info_t *info, int sect)
+{
+	int retcode;
+
+	/* Issue Blank Check command */
+	flash_write_cmd(info, sect, info->addr_unlock1, 0x33);
+
+	/* Wait till ready */
+	retcode = flash_status_check(info, sect, info->erase_blk_tout,
+				     "blkchk");
+	if (retcode)
+		return 0; /* Not erased in any error cases */
+
+	/* Read status again to check erase status */
+	flash_write_cmd(info, sect, info->addr_unlock1, FLASH_CMD_READ_STATUS);
+	if (flash_isset(info, sect, 0, FLASH_STATUS_ECLBS)) {
+		flash_write_cmd(info, 0, info->addr_unlock1, 0x71);
+		return 0;
+	}
+
+	return 1; /* erased */
+}
+
 /*-----------------------------------------------------------------------
  */
 int flash_erase(flash_info_t *info, int s_first, int s_last)
@@ -1087,32 +1153,41 @@ int flash_erase(flash_info_t *info, int s_first, int s_last)
 		}
 
 		if (info->protect[sect] == 0) { /* not protected */
-#ifdef CONFIG_SYS_FLASH_CHECK_BLANK_BEFORE_ERASE
-			int k;
-			int size;
-			int erased;
-			u32 *flash;
+			if (IS_ENABLED(CONFIG_SYS_FLASH_CHECK_BLANK_BEFORE_ERASE)) {
+				int k;
+				int size;
+				int erased;
+				u32 *flash;
+
+				if (manufact_match(info, CY_MANUFACT) &&
+				    flash_blank_check(info, sect)) {
+					if (flash_verbose)
+						putc(',');
+					continue;
+				}
 
-			/*
-			 * Check if whole sector is erased
-			 */
-			size = flash_sector_size(info, sect);
-			erased = 1;
-			flash = (u32 *)info->start[sect];
-			/* divide by 4 for longword access */
-			size = size >> 2;
-			for (k = 0; k < size; k++) {
-				if (flash_read32(flash++) != 0xffffffff) {
-					erased = 0;
-					break;
+				/*
+				 * Check if whole sector is erased
+				 */
+				size = flash_sector_size(info, sect);
+				erased = 1;
+				flash = (u32 *)info->start[sect];
+				/* divide by 4 for longword access */
+				size = size >> 2;
+				for (k = 0; k < size; k++) {
+					if (flash_read32(flash++) != 0xffffffff) {
+						erased = 0;
+						break;
+					}
+				}
+
+				if (erased) {
+					if (flash_verbose)
+						putc(',');
+					continue;
 				}
 			}
-			if (erased) {
-				if (flash_verbose)
-					putc(',');
-				continue;
-			}
-#endif
+
 			switch (info->vendor) {
 			case CFI_CMDSET_INTEL_PROG_REGIONS:
 			case CFI_CMDSET_INTEL_STANDARD:
@@ -1186,6 +1261,9 @@ static int sector_erased(flash_info_t *info, int i)
 	int size;
 	u32 *flash;
 
+	if (manufact_match(info, CY_MANUFACT))
+		return flash_blank_check(info, i);
+
 	/*
 	 * Check if whole sector is erased
 	 */
@@ -1434,11 +1512,6 @@ int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt)
 	return flash_write_cfiword(info, wp, cword);
 }
 
-static inline int manufact_match(flash_info_t *info, u32 manu)
-{
-	return info->manufacturer_id == ((manu & FLASH_VENDMASK) >> 16);
-}
-
 /*-----------------------------------------------------------------------
  */
 #ifdef CONFIG_SYS_FLASH_PROTECTION
@@ -1865,6 +1938,115 @@ static inline int flash_detect_legacy(phys_addr_t base, int banknum)
 }
 #endif
 
+#define S26_CMD_READ_VCR1	0xC7
+#define S26_CMD_READ_VCR2	0xC9
+#define S26_CFR1V_UNIFORM	BIT(9)
+#define S26_CFR1V_TP4KBS	BIT(8)
+#define S26_CFR2V_SP4KBS	BIT(2)
+#define S26_MAX_ERASE_REGIONS	(5)
+
+struct erase_info {
+	uint size;
+	uint blocks;
+};
+
+static struct erase_info regions[S26_MAX_ERASE_REGIONS];
+
+static void flash_add_erase_info(struct erase_info **region, uint size, uint blocks)
+{
+	(*region)->size = size;
+	(*region)->blocks = blocks;
+	(*region)++;
+}
+
+static void flash_fixup_s26(flash_info_t *info, ulong base)
+{
+	struct erase_info *r = regions;
+	ushort cfr1v, cfr2v;
+	uchar btm4ks, top4ks;
+	int i, j, sect_cnt;
+
+	flash_unlock_seq(info, 0);
+	flash_write_cmd(info, 0, info->addr_unlock1, S26_CMD_READ_VCR1);
+	cfr1v = flash_read_word(info, 0);
+
+	flash_unlock_seq(info, 0);
+	flash_write_cmd(info, 0, info->addr_unlock1, S26_CMD_READ_VCR2);
+	cfr2v = flash_read_word(info, 0);
+
+	if (cfr1v & S26_CFR1V_UNIFORM) {
+		btm4ks = 0;
+		top4ks = 0;
+	} else if (cfr2v & S26_CFR2V_SP4KBS) {
+		btm4ks = 16;
+		top4ks = 16;
+	} else if (cfr1v & S26_CFR1V_TP4KBS) {
+		btm4ks = 0;
+		top4ks = 32;
+	} else {
+		btm4ks = 32;
+		top4ks = 0;
+	}
+
+	if (btm4ks) {
+		flash_add_erase_info(&r, SZ_4K, btm4ks);
+		flash_add_erase_info(&r, SZ_256K - SZ_4K * btm4ks, 1);
+	}
+
+	flash_add_erase_info(&r, SZ_256K, info->size / SZ_256K - !!(btm4ks) - !!(top4ks));
+
+	if (top4ks) {
+		flash_add_erase_info(&r, SZ_256K - SZ_4K * top4ks, 1);
+		flash_add_erase_info(&r, SZ_4K, top4ks);
+	}
+
+	sect_cnt = 0;
+	for (i = 0; i < r - regions; i++) {
+		for (j = 0; j < regions[i].blocks; j++) {
+			if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
+				printf("ERROR: too many flash sectors\n");
+				break;
+			}
+			info->start[sect_cnt] = base;
+			base += regions[i].size;
+			sect_cnt++;
+		}
+	}
+	info->sector_count = sect_cnt;
+}
+
+static void flash_fixup_sfdp(flash_info_t *info, ulong base)
+{
+	if (manufact_match(info, CY_MANUFACT))
+		flash_fixup_s26(info, base);
+}
+
+static int flash_detect_sfdp(phys_addr_t base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+	void *addr;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_FLASH_CFI_SFDP))
+		return 0;
+
+	info->start[0] = (ulong)map_physmem(base, 0, MAP_NOCACHE);
+	info->portwidth = FLASH_CFI_16BIT;
+	info->chipwidth = FLASH_CFI_BY16;
+	info->chip_lsb = 0;
+
+	flash_write_cmd(info, 0, FLASH_OFFSET_CFI_ALT, FLASH_CMD_CFI);
+	addr = flash_map(info, 0, 0);
+	ret = sfdp_flash_scan(info, addr);
+	flash_unmap(info, 0, 0, addr);
+	flash_cmd_reset(info);
+
+	if (ret)
+		flash_fixup_sfdp(info, info->start[0]);
+
+	return ret;
+}
+
 /*-----------------------------------------------------------------------
  * detect if flash is compatible with the Common Flash Interface (CFI)
  * http://www.jedec.org/download/search/jesd68.pdf
@@ -2415,6 +2597,8 @@ unsigned long flash_init(void)
 
 #ifdef CONFIG_CFI_FLASH /* for driver model */
 	cfi_flash_init_dm();
+	if (!cfi_flash_num_flash_banks)
+		return 0;
 #endif
 
 	/* Init: no FLASHes known */
@@ -2425,7 +2609,8 @@ unsigned long flash_init(void)
 		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
 					 cfi_flash_config_reg(i));
 
-		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i))
+		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i) &&
+		    !flash_detect_sfdp(cfi_flash_bank_addr(i), i))
 			flash_get_size(cfi_flash_bank_addr(i), i);
 		size += flash_info[i].size;
 		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
@@ -2499,18 +2684,44 @@ static int cfi_flash_probe(struct udevice *dev)
 {
 	fdt_addr_t addr;
 	fdt_size_t size;
-	int idx;
+	struct ofnode_phandle_args args;
+	struct resource res;
+	int idx, ret;
 
-	for (idx = 0; idx < CFI_MAX_FLASH_BANKS; idx++) {
-		addr = dev_read_addr_size_index(dev, idx, &size);
-		if (addr == FDT_ADDR_T_NONE)
-			break;
+	/*
+	 * first, check if parent's node has a "status" property
+	 * if this status property is set to disabled, don't probe cfi
+	 */
+	if (!dev_read_enabled(dev_get_parent(dev)))
+		return -ENODEV;
+
+	ret = dev_read_phandle_with_args(dev_get_parent(dev), "memory-region", NULL, 0, 0, &args);
+	if (!ret) {
+		for (idx = 0; idx < CFI_MAX_FLASH_BANKS; idx++) {
+			ret = ofnode_read_resource(args.node, idx, &res);
+			if (ret) {
+				dev_err(dev, "Can't get mmap base address(%d)\n", ret);
+				return ret;
+			}
 
-		flash_info[cfi_flash_num_flash_banks].dev = dev;
-		flash_info[cfi_flash_num_flash_banks].base = addr;
-		flash_info[cfi_flash_num_flash_banks].addr_size = size;
-		cfi_flash_num_flash_banks++;
+			flash_info[cfi_flash_num_flash_banks].dev = dev;
+			flash_info[cfi_flash_num_flash_banks].base = res.start;
+			flash_info[cfi_flash_num_flash_banks].addr_size = res.end - res.start + 1;
+			cfi_flash_num_flash_banks++;
+		}
+	} else {
+		for (idx = 0; idx < CFI_MAX_FLASH_BANKS; idx++) {
+			addr = dev_read_addr_size_index(dev, idx, &size);
+			if (addr == FDT_ADDR_T_NONE)
+				break;
+
+			flash_info[cfi_flash_num_flash_banks].dev = dev;
+			flash_info[cfi_flash_num_flash_banks].base = addr;
+			flash_info[cfi_flash_num_flash_banks].addr_size = size;
+			cfi_flash_num_flash_banks++;
+		}
 	}
+
 	gd->bd->bi_flashstart = flash_info[0].base;
 
 	return 0;
@@ -2519,6 +2730,7 @@ static int cfi_flash_probe(struct udevice *dev)
 static const struct udevice_id cfi_flash_ids[] = {
 	{ .compatible = "cfi-flash" },
 	{ .compatible = "jedec-flash" },
+	{ .compatible = "sfdp-flash" },
 	{}
 };
 
diff --git a/drivers/mtd/cfi_mtd.c b/drivers/mtd/cfi_mtd.c
index bf4473ba9e..a4d958121a 100644
--- a/drivers/mtd/cfi_mtd.c
+++ b/drivers/mtd/cfi_mtd.c
@@ -10,6 +10,7 @@
 #include <flash.h>
 #include <malloc.h>
 
+#include <asm/io.h>
 #include <linux/errno.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/concat.h>
@@ -71,7 +72,7 @@ static int cfi_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
 	u_char *f = (u_char*)(fi->start[0]) + from;
 
 	if (dma_memcpy(buf, f, len) < 0)
-		memcpy(buf, f, len);
+		memcpy_fromio(buf, f, len);
 	*retlen = len;
 
 	return 0;
diff --git a/drivers/mtd/mtd_uboot.c b/drivers/mtd/mtd_uboot.c
index 14ce726b10..ebcc40255b 100644
--- a/drivers/mtd/mtd_uboot.c
+++ b/drivers/mtd/mtd_uboot.c
@@ -321,16 +321,18 @@ int mtd_probe_devices(void)
 	mtd_probe_uclass_spi_nor_devs();
 
 	/*
-	 * Check if mtdparts/mtdids changed, if the MTD dev list was updated
+	 * Check if the MTD dev list is updated or
+	 * if mtdparts/mtdids changed,
 	 * or if our previous attempt to delete existing partititions failed.
 	 * In any of these cases we want to update the partitions, otherwise,
 	 * everything is up-to-date and we can return 0 directly.
 	 */
-	if ((!mtdparts && !old_mtdparts && !mtdids && !old_mtdids) ||
-	    (mtdparts && old_mtdparts && mtdids && old_mtdids &&
-	     !mtd_dev_list_updated() && !mtd_del_all_parts_failed &&
-	     !strcmp(mtdparts, old_mtdparts) &&
-	     !strcmp(mtdids, old_mtdids)))
+	if (!mtd_dev_list_updated() &&
+	    ((!mtdparts && !old_mtdparts && !mtdids && !old_mtdids) ||
+	     (mtdparts && old_mtdparts && mtdids && old_mtdids &&
+	      !mtd_del_all_parts_failed &&
+	      !strcmp(mtdparts, old_mtdparts) &&
+	      !strcmp(mtdids, old_mtdids))))
 		return 0;
 
 	/* Update the local copy of mtdparts */
diff --git a/drivers/mtd/nand/raw/stm32_fmc2_nand.c b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
index 69dbb629e9..013ba79432 100644
--- a/drivers/mtd/nand/raw/stm32_fmc2_nand.c
+++ b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
@@ -32,7 +32,7 @@
 #define FMC2_RB_DELAY_US		30
 
 /* Max chip enable */
-#define FMC2_MAX_CE			2
+#define FMC2_MAX_CE			4
 
 /* Timings */
 #define FMC2_THIZ			1
@@ -160,6 +160,11 @@ static inline struct stm32_fmc2_nand *to_fmc2_nand(struct nand_chip *chip)
 	return container_of(chip, struct stm32_fmc2_nand, chip);
 }
 
+struct stm32_fmc2_nfc_data {
+	int max_ncs;
+	struct udevice *(*get_cdev)(struct udevice *dev);
+};
+
 struct stm32_fmc2_nfc {
 	struct nand_hw_control base;
 	struct stm32_fmc2_nand nand;
@@ -169,6 +174,7 @@ struct stm32_fmc2_nfc {
 	fdt_addr_t cmd_base[FMC2_MAX_CE];
 	fdt_addr_t addr_base[FMC2_MAX_CE];
 	struct clk clk;
+	const struct stm32_fmc2_nfc_data *data;
 
 	u8 cs_assigned;
 	int cs_sel;
@@ -815,7 +821,7 @@ static int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc, ofnode node)
 	}
 
 	for (i = 0; i < nand->ncs; i++) {
-		if (cs[i] >= FMC2_MAX_CE) {
+		if (cs[i] >= nfc->data->max_ncs) {
 			log_err("Invalid reg value: %d\n", nand->cs_used[i]);
 			return -EINVAL;
 		}
@@ -906,10 +912,18 @@ static int stm32_fmc2_nfc_probe(struct udevice *dev)
 	spin_lock_init(&nfc->controller.lock);
 	init_waitqueue_head(&nfc->controller.wq);
 
-	cdev = stm32_fmc2_nfc_get_cdev(dev);
-	if (!cdev)
+	nfc->data = (void *)dev_get_driver_data(dev);
+	if (!nfc->data)
 		return -EINVAL;
 
+	if (nfc->data->get_cdev) {
+		cdev = nfc->data->get_cdev(dev);
+		if (!cdev)
+			return -EINVAL;
+	} else {
+		cdev = dev->parent;
+	}
+
 	ret = stm32_fmc2_nfc_parse_dt(dev, nfc);
 	if (ret)
 		return ret;
@@ -921,7 +935,7 @@ static int stm32_fmc2_nfc_probe(struct udevice *dev)
 	if (dev == cdev)
 		start_region = 1;
 
-	for (chip_cs = 0, mem_region = start_region; chip_cs < FMC2_MAX_CE;
+	for (chip_cs = 0, mem_region = start_region; chip_cs < nfc->data->max_ncs;
 	     chip_cs++, mem_region += 3) {
 		if (!(nfc->cs_assigned & BIT(chip_cs)))
 			continue;
@@ -1033,9 +1047,28 @@ static int stm32_fmc2_nfc_probe(struct udevice *dev)
 	return nand_register(0, mtd);
 }
 
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp1_data = {
+	.max_ncs = 2,
+	.get_cdev = stm32_fmc2_nfc_get_cdev,
+};
+
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp25_data = {
+	.max_ncs = 4,
+};
+
 static const struct udevice_id stm32_fmc2_nfc_match[] = {
-	{ .compatible = "st,stm32mp15-fmc2" },
-	{ .compatible = "st,stm32mp1-fmc2-nfc" },
+	{
+		.compatible = "st,stm32mp15-fmc2",
+		.data = (ulong)&stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp1-fmc2-nfc",
+		.data = (ulong)&stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-nfc",
+		.data = (ulong)&stm32_fmc2_nfc_mp25_data,
+	},
 	{ /* Sentinel */ }
 };
 
diff --git a/drivers/mtd/sfdp_flash.c b/drivers/mtd/sfdp_flash.c
new file mode 100644
index 0000000000..cf0749b879
--- /dev/null
+++ b/drivers/mtd/sfdp_flash.c
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * (C) Copyright 2022
+ * Takahiro Kuwano, <takahiro.kuwano@infineon.com>
+ */
+
+#include <common.h>
+#include <flash.h>
+#include <asm/byteorder.h>
+#include <mtd/cfi_flash.h>
+
+#define SFDP_SIGNATURE		0x50444653U
+#define SFDP_JESD216_MAJOR	1
+#define SFDP_OFFSET_S26_ID	(0x800)
+
+struct sfdp_header {
+	u32		signature; /* Ox50444653U <=> "SFDP" */
+	u8		minor;
+	u8		major;
+	u8		nph; /* 0-base number of parameter headers */
+	u8		prot;
+};
+
+struct sfdp_flash_info {
+	const ushort mfr_id;
+	const ushort dev_id;
+	const ushort dev_id2;
+	const char *name;
+};
+
+static const struct sfdp_flash_info s26_table[] = {
+	{ 0x0034, 0x006a, 0x001a, "s26hl512t" },
+	{ 0x0034, 0x006a, 0x001b, "s26hl01gt" },
+	{ 0x0034, 0x007b, 0x001a, "s26hs512t" },
+	{ 0x0034, 0x007b, 0x001b, "s26hs01gt" },
+};
+
+static int detect_s26(flash_info_t *info, const void *sfdp)
+{
+	const ushort *id = (const ushort *)sfdp + SFDP_OFFSET_S26_ID;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(s26_table); i++) {
+		if (s26_table[i].mfr_id == le16_to_cpu(id[0]) &&
+		    s26_table[i].dev_id == le16_to_cpu(id[1]) &&
+		    s26_table[i].dev_id2 == le16_to_cpu(id[2])) {
+			info->manufacturer_id = s26_table[i].mfr_id;
+			info->device_id = s26_table[i].dev_id;
+			info->device_id2 = s26_table[i].dev_id2;
+			info->name = s26_table[i].name;
+			info->vendor = CFI_CMDSET_AMD_STANDARD;
+			info->flash_id = FLASH_MAN_CFI;
+			info->interface = FLASH_CFI_X16;
+			info->addr_unlock1 = 0x555;
+			info->addr_unlock2 = 0x2aa;
+			info->sr_supported = 1;
+			info->buffer_size = 512;
+			info->cmd_reset = AMD_CMD_RESET;
+			info->cmd_erase_sector = AMD_CMD_ERASE_SECTOR;
+			info->erase_blk_tout = 3072;
+			info->write_tout = 1;
+			info->buffer_write_tout = 4;
+			info->size = 1ULL << info->device_id2;
+#ifdef CONFIG_SYS_FLASH_PROTECTION
+			info->legacy_unlock = 1;
+#endif
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int sfdp_flash_scan(flash_info_t *info, const void *sfdp)
+{
+	const struct sfdp_header *header = (const struct sfdp_header *)sfdp;
+
+	/* Check the SFDP signature and header version. */
+	if (le32_to_cpu(header->signature) == SFDP_SIGNATURE &&
+	    header->major == SFDP_JESD216_MAJOR) {
+		return detect_s26(info, sfdp);
+	}
+
+	return 0;
+}
diff --git a/drivers/mtd/spi/spi-nor-core.c b/drivers/mtd/spi/spi-nor-core.c
index 6093277f17..6de459b7ab 100644
--- a/drivers/mtd/spi/spi-nor-core.c
+++ b/drivers/mtd/spi/spi-nor-core.c
@@ -168,6 +168,7 @@ struct sfdp_header {
 #define BFPT_DWORD18_CMD_EXT_INV		(0x1UL << 29) /* Invert */
 #define BFPT_DWORD18_CMD_EXT_RES		(0x2UL << 29) /* Reserved */
 #define BFPT_DWORD18_CMD_EXT_16B		(0x3UL << 29) /* 16-bit opcode */
+#define BFPT_DWORD18_BYTE_ORDER_SWAPPED		BIT(31) /* Byte order of 16-bit words */
 
 /* xSPI Profile 1.0 table (from JESD216D.01). */
 #define PROFILE1_DWORD1_RD_FAST_CMD		GENMASK(15, 8)
@@ -273,6 +274,8 @@ void spi_nor_setup_op(const struct spi_nor *nor,
 		 */
 		op->cmd.dtr = op->addr.dtr = op->dummy.dtr =
 			op->data.dtr = true;
+		op->data.dtr_swab16 = (proto == SNOR_PROTO_8_8_8_DTR) &&
+				      (nor->flags & SNOR_F_DTR_SWAB16);
 
 		/* 2 bytes per clock cycle in DTR mode. */
 		op->dummy.nbytes *= 2;
@@ -2409,6 +2412,10 @@ static int spi_nor_parse_bfpt(struct spi_nor *nor,
 		return -ENOTSUPP;
 	}
 
+	/* Byte order in 8D-8D-8D mode */
+	if (bfpt.dwords[BFPT_DWORD(18)] & BFPT_DWORD18_BYTE_ORDER_SWAPPED)
+		nor->flags |= SNOR_F_DTR_SWAB16;
+
 	return spi_nor_post_bfpt_fixups(nor, bfpt_header, &bfpt, params);
 }
 
@@ -4160,6 +4167,8 @@ int spi_nor_scan(struct spi_nor *nor)
 	if (spi_nor_protocol_is_dtr(nor->read_proto)) {
 		 /* Always use 4-byte addresses in DTR mode. */
 		nor->addr_width = 4;
+		if (info->flags & SPI_NOR_4B_OPCODES)
+			spi_nor_set_4byte_opcodes(nor, info);
 	} else if (nor->addr_width) {
 		/* already configured from SFDP */
 	} else if (info->addr_width) {
diff --git a/drivers/mtd/stm32_hyperbus.c b/drivers/mtd/stm32_hyperbus.c
new file mode 100644
index 0000000000..1b4f95e21f
--- /dev/null
+++ b/drivers/mtd/stm32_hyperbus.c
@@ -0,0 +1,356 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+
+/*
+ * STMicroelectronics hyperflash driver
+ * Copyright (C) 2021 STMicroelectronics - All Rights Reserved
+ *
+ */
+
+#include <common.h>
+#include <flash.h>
+#include <mtd.h>
+#include <stm32_omi.h>
+#include <asm/io.h>
+#include <dm/device_compat.h>
+#include <dm/read.h>
+#include <linux/bitfield.h>
+#include <mtd/cfi_flash.h>
+
+#define WRITE	0
+#define READ	1
+#define NSEC_PER_SEC		1000000000L
+
+/* HyperBus Commands */
+#define HYPERBUS_ADDR_UNLOCK1	0x555
+#define HYPERBUS_ADDR_UNLOCK2	0x2AA
+#define HYPERBUS_CMD_UNLOCK1	0xAA
+#define HYPERBUS_CMD_UNLOCK2	0x55
+#define HYPERBUS_CMD_RDSFDP	0x90
+
+struct stm32_hb_priv {
+	struct udevice *dev;
+	struct udevice *omi_dev;
+	ulong real_flash_freq;		/* real flash freq = bus_freq x prescaler */
+};
+
+struct stm32_hb_plat {
+	ulong flash_freq;		/* flash max supported frequency */
+	u32 tacc;
+	u32 cs;
+	bool wzl;
+};
+
+static struct stm32_hb_priv *g_stm32_hb_priv;
+
+static int stm32_hb_xfer(void *addr, u16 wdata, u16 *rdata,
+			 bool read)
+{
+	struct stm32_hb_priv *priv = g_stm32_hb_priv;
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	int ret;
+	u32 cr;
+	u32 offset;
+
+	/* exit from memory map mode by setting ABORT bit */
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_ABORT);
+
+	/* Wait clear of abort bit by hw */
+	ret = readl_poll_timeout(regs_base + OSPI_CR, cr, !(cr & OSPI_CR_ABORT),
+				 OSPI_ABT_TIMEOUT_US);
+
+	if (ret) {
+		dev_err(priv->dev, "%s abort timeout:%d\n", __func__, ret);
+		return ret;
+	}
+
+	offset = (u32)(long)addr - omi_plat->mm_base;
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			FIELD_PREP(OSPI_CR_FMODE_MASK,
+				   read ? OSPI_CR_FMODE_IND_READ :
+				   OSPI_CR_FMODE_IND_WRITE));
+
+	writel((uintptr_t)offset, regs_base + OSPI_AR);
+
+	ret = stm32_omi_tx_poll(priv->omi_dev, read ? (u8 *)rdata : (u8 *)&wdata, 2, read);
+	if (ret)
+		return ret;
+
+	/* Wait end of tx in indirect mode */
+	ret = stm32_omi_wait_cmd(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	dev_dbg(priv->dev, "%s: %s 0x%x @ 0x%x\n", __func__,
+		read ? "read" : "write",
+		read ? *rdata : wdata, offset >> 1);
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			FIELD_PREP(OSPI_CR_FMODE_MASK, OSPI_CR_FMODE_MMAP));
+
+	return ret;
+}
+
+u16 flash_read16(void *addr)
+{
+	struct stm32_hb_priv *priv = g_stm32_hb_priv;
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t mm_base = omi_plat->mm_base;
+	resource_size_t mm_size = omi_plat->mm_size;
+	int ret;
+	u16 rdata = 0;
+
+	/*
+	 * Before going further, check if this read is accessing DDR or Flash
+	 */
+	if (((u32)(long)addr < mm_base) ||
+	    ((u32)(long)addr > mm_base + mm_size))
+		return readw(addr);
+
+	ret = stm32_hb_xfer(addr, 0, &rdata, READ);
+	if (ret)
+		dev_err(priv->dev, "%s failed, ret=%i\n", __func__, ret);
+
+	return rdata;
+}
+
+void flash_write16(u16 value, void *addr)
+{
+	struct stm32_hb_priv *priv = g_stm32_hb_priv;
+	int ret;
+
+	ret = stm32_hb_xfer(addr, value, 0, WRITE);
+	if (ret)
+		dev_err(priv->dev, "%s failed, ret=%i\n", __func__, ret);
+};
+
+static int stm32_hb_test_sfdp(struct udevice *omi_dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+	phys_addr_t mm_base = omi_plat->mm_base;
+	int ret = -EIO;
+	u16 sfdp[2];
+
+	/* Reset */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+	flash_write16(HYPERBUS_CMD_UNLOCK1, (void *)mm_base + (HYPERBUS_ADDR_UNLOCK1 << 1));
+	flash_write16(HYPERBUS_CMD_UNLOCK2, (void *)mm_base + (HYPERBUS_ADDR_UNLOCK2 << 1));
+	flash_write16(HYPERBUS_CMD_RDSFDP, (void *)mm_base + (HYPERBUS_ADDR_UNLOCK1 << 1));
+
+	sfdp[0] = readw(mm_base);
+	sfdp[1] = readw(mm_base + 0x2);
+
+	/* compare with "SF" & "DP" */
+	if (sfdp[0] == 0x4653 && sfdp[1] == 0x5044)
+		ret = 0;
+
+	/* Reset CFI */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+
+	return ret;
+}
+
+static int stm32_hb_test_cfi(struct udevice *omi_dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+	phys_addr_t mm_base = omi_plat->mm_base;
+	int ret = -EIO;
+	u16 qry[3];
+
+	/* Reset/Enter in CFI */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+	flash_write16(FLASH_CMD_CFI, (void *)mm_base + 0xaa);
+
+	qry[0] = readw(mm_base + 0x20);
+	qry[1] = readw(mm_base + 0x22);
+	qry[2] = readw(mm_base + 0x24);
+	if (qry[0] == 'Q' && qry[1] == 'R' && qry[2] == 'Y')
+		ret = 0;
+
+	/* Reset/Exit from CFI */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+	flash_write16(FLASH_CMD_RESET, (void *)mm_base);
+
+	return ret;
+}
+
+static int stm32_hb_check_transfer(struct udevice *omi_dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+
+	if (omi_plat->jedec_flash)
+		return stm32_hb_test_sfdp(omi_dev);
+	else
+		return stm32_hb_test_cfi(omi_dev);
+}
+
+static int stm32_hb_calibrate(struct stm32_hb_priv *priv)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	u32 prescaler;
+	u16 period_ps = 0;
+	u8 window_len = 0;
+	int ret;
+	bool bypass_mode = false;
+
+	prescaler = FIELD_GET(OSPI_DCR2_PRESC_MASK,
+			      readl(omi_plat->regs_base + OSPI_DCR2));
+	if (prescaler)
+		setbits_le32(omi_plat->regs_base + OSPI_TCR, OSPI_TCR_DHQC);
+
+	if (priv->real_flash_freq <= STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (priv->real_flash_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	if (bypass_mode || prescaler)
+		/* perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len);
+	else
+		/* perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, false, &window_len);
+
+	if (ret) {
+		dev_err(priv->omi_dev, "Calibration failed\n");
+		if (!bypass_mode)
+			/* stop delay block when configured in lock mode */
+			stm32_omi_dlyb_stop(priv->omi_dev);
+	}
+
+	return ret;
+}
+
+static void stm32_hb_init(struct udevice *dev)
+{
+	struct stm32_hb_priv *priv = dev_get_priv(dev);
+	struct stm32_hb_plat *plat = dev_get_plat(dev);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	unsigned long period;
+	u32 ccr, dcr1, hlcr, prescaler;
+
+	/* enable IP */
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_EN);
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_CSSEL,
+			FIELD_PREP(OSPI_CR_CSSEL, plat->cs));
+
+	/* set MTYP to HyperBus memory-map mode */
+	dcr1 = FIELD_PREP(OSPI_DCR1_MTYP_MASK, OSPI_DCR1_MTYP_HP_MEMMODE);
+	/* set DEVSIZE to memory map size */
+	dcr1 |= FIELD_PREP(OSPI_DCR1_DEVSIZE_MASK, ffs(omi_plat->mm_size) - 1);
+	writel(dcr1, regs_base + OSPI_DCR1);
+
+	prescaler = DIV_ROUND_UP(omi_plat->clock_rate, plat->flash_freq) - 1;
+	if (prescaler > 255)
+		prescaler = 255;
+
+	clrsetbits_le32(regs_base + OSPI_DCR2, OSPI_DCR2_PRESC_MASK,
+			FIELD_PREP(OSPI_DCR2_PRESC_MASK, prescaler));
+	priv->real_flash_freq = omi_plat->clock_rate / (prescaler + 1);
+
+	writel(1, regs_base + OSPI_DLR);
+
+	/* set access time latency */
+	period = NSEC_PER_SEC / priv->real_flash_freq;
+	hlcr = FIELD_PREP(OSPI_HLCR_TACC_MASK, DIV_ROUND_UP(plat->tacc, period));
+	/* set write zero latency */
+	if (plat->wzl)
+		hlcr |= OSPI_HLCR_WZL;
+
+	writel(hlcr, regs_base + OSPI_HLCR);
+
+	ccr = OSPI_CCR_DQSE | OSPI_CCR_DDTR | OSPI_CCR_ADDTR;
+	ccr |= FIELD_PREP(OSPI_CCR_DMODE_MASK, OSPI_CCR_DMODE_8LINES);
+	ccr |= FIELD_PREP(OSPI_CCR_ADSIZE_MASK, OSPI_CCR_ADSIZE_32BITS);
+	ccr |= FIELD_PREP(OSPI_CCR_ADMODE_MASK, OSPI_CCR_ADMODE_8LINES);
+	writel(ccr, regs_base + OSPI_CCR);
+
+	/* Set FMODE to memory map mode */
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			FIELD_PREP(OSPI_CR_FMODE_MASK, OSPI_CR_FMODE_MMAP));
+}
+
+static int stm32_hb_probe(struct udevice *dev)
+{
+	struct stm32_hb_priv *priv = dev_get_priv(dev);
+	struct stm32_omi_plat *omi_plat;
+	struct stm32_omi_priv *omi_priv;
+	int ret;
+
+	priv->omi_dev = dev->parent;
+	omi_plat = dev_get_plat(priv->omi_dev);
+	omi_priv = dev_get_priv(priv->omi_dev);
+	omi_priv->dev = dev;
+	priv->dev = dev;
+
+	g_stm32_hb_priv = priv;
+
+	/* mandatory for HyperFlash */
+	if (!omi_plat->mm_size) {
+		dev_err(dev, "Memory-map region not found\n");
+		return -EINVAL;
+	}
+
+	/* mandatory for HyperFlash */
+	if (!omi_plat->dlyb_base) {
+		dev_err(dev, "Incorrect delay block base address\n");
+		return -EINVAL;
+	}
+
+	ret = clk_enable(&omi_plat->clk);
+	if (ret) {
+		dev_err(dev, "failed to enable HyperBus clock\n");
+		return ret;
+	}
+
+	reset_assert_bulk(&omi_plat->rst_ctl);
+	udelay(2);
+	reset_deassert_bulk(&omi_plat->rst_ctl);
+
+	omi_priv->check_transfer = stm32_hb_check_transfer;
+	stm32_hb_init(dev);
+
+	return stm32_hb_calibrate(priv);
+}
+
+static int stm32_hb_of_to_plat(struct udevice *dev)
+{
+	struct stm32_hb_plat *plat = dev_get_plat(dev);
+	ofnode flash_node;
+	int ret;
+
+	flash_node = dev_read_first_subnode(dev);
+
+	ret = ofnode_read_u32(flash_node, "reg", &plat->cs);
+	if (ret) {
+		dev_err(dev, "could not retrieve reg property: %d\n", ret);
+		return ret;
+	}
+
+	plat->flash_freq = ofnode_read_u32_default(flash_node, "st,max-frequency", 0);
+	if (!plat->flash_freq) {
+		dev_err(dev, "Can't find st,max-frequency property\n");
+		return -ENOENT;
+	}
+
+	plat->tacc = ofnode_read_u32_default(flash_node, "st,tacc-ns", 0);
+	plat->wzl = ofnode_read_bool(flash_node, "st,wzl");
+
+	return 0;
+}
+
+U_BOOT_DRIVER(stm32_hyperbus) = {
+	.name		= "stm32_hyperbus",
+	.id		= UCLASS_MTD,
+	.bind		= dm_scan_fdt_dev,
+	.of_to_plat	= stm32_hb_of_to_plat,
+	.plat_auto	= sizeof(struct stm32_hb_plat),
+	.priv_auto	= sizeof(struct stm32_hb_priv),
+	.probe		= stm32_hb_probe,
+};
diff --git a/drivers/net/dwc_eth_qos.c b/drivers/net/dwc_eth_qos.c
index 1e92bd9ca9..a6131e97f0 100644
--- a/drivers/net/dwc_eth_qos.c
+++ b/drivers/net/dwc_eth_qos.c
@@ -47,11 +47,13 @@
 #include <asm/cache.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
+#include <dm/device_compat.h>
 #ifdef CONFIG_ARCH_IMX8M
 #include <asm/arch/clock.h>
 #include <asm/mach-imx/sys_proto.h>
 #endif
 #include <linux/delay.h>
+#include <power/regulator.h>
 
 #include "dwc_eth_qos.h"
 
@@ -75,12 +77,37 @@
  */
 static void *eqos_alloc_descs(struct eqos_priv *eqos, unsigned int num)
 {
-	return memalign(ARCH_DMA_MINALIGN, num * eqos->desc_size);
+	void *descs = NULL;
+	ulong desc_pad;
+
+	/*
+	 * if descriptors can to be cache-line aligned with the DSL =
+	 * "Descriptor Skip Length" field of the DMA channel control register
+	 */
+	desc_pad = (eqos->desc_size - sizeof(struct eqos_desc)) /
+		   eqos->config->axi_bus_width;
+	if (desc_pad <= EQOS_DMA_CH0_CONTROL_DSL_MASK) {
+		eqos->use_cached_mem = true;
+		descs = memalign(eqos->desc_size, num * eqos->desc_size);
+	} else {
+		eqos->use_cached_mem = false;
+		eqos->desc_size = sizeof(struct eqos_desc);
+#ifdef CONFIG_SYS_NONCACHED_MEMORY
+		descs = (void *)noncached_alloc(num * eqos->desc_size, ARCH_DMA_MINALIGN);
+#else
+		log_err("DMA descriptors with cached memory.");
+#endif
+	}
+	return descs;
 }
 
-static void eqos_free_descs(void *descs)
+static void eqos_free_descs(struct eqos_priv *eqos)
 {
-	free(descs);
+	if (eqos->use_cached_mem) {
+		free(eqos->rx_descs);
+		free(eqos->tx_descs);
+	};
+	/* memory allocated by noncached_alloc() can't be freed */
 }
 
 static struct eqos_desc *eqos_get_desc(struct eqos_priv *eqos,
@@ -90,22 +117,24 @@ static struct eqos_desc *eqos_get_desc(struct eqos_priv *eqos,
 	       (num * eqos->desc_size);
 }
 
-void eqos_inval_desc_generic(void *desc)
+void eqos_inval_desc_generic(struct eqos_priv *eqos, void *desc)
 {
 	unsigned long start = (unsigned long)desc & ~(ARCH_DMA_MINALIGN - 1);
 	unsigned long end = ALIGN(start + sizeof(struct eqos_desc),
 				  ARCH_DMA_MINALIGN);
 
-	invalidate_dcache_range(start, end);
+	if (eqos->use_cached_mem)
+		invalidate_dcache_range(start, end);
 }
 
-void eqos_flush_desc_generic(void *desc)
+void eqos_flush_desc_generic(struct eqos_priv *eqos, void *desc)
 {
 	unsigned long start = (unsigned long)desc & ~(ARCH_DMA_MINALIGN - 1);
 	unsigned long end = ALIGN(start + sizeof(struct eqos_desc),
 				  ARCH_DMA_MINALIGN);
 
-	flush_dcache_range(start, end);
+	if (eqos->use_cached_mem)
+		flush_dcache_range(start, end);
 }
 
 static void eqos_inval_buffer_tegra186(void *buf, size_t size)
@@ -380,6 +409,27 @@ static int eqos_stop_clks_stm32(struct udevice *dev)
 	return 0;
 }
 
+static int eqos_phy_power_on_stm32(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+#ifdef CONFIG_DM_REGULATOR
+	if (eqos->phy_supply) {
+		ret = regulator_set_enable(eqos->phy_supply, true);
+		if (ret) {
+			printf("%s: Error enabling phy supply\n", dev->name);
+			return ret;
+		}
+	}
+#endif
+
+	debug("%s: OK\n", __func__);
+	return 0;
+}
+
 static int eqos_start_resets_tegra186(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -751,6 +801,12 @@ static int eqos_start(struct udevice *dev)
 	eqos->tx_desc_idx = 0;
 	eqos->rx_desc_idx = 0;
 
+	ret = eqos->config->ops->eqos_phy_power_on(dev);
+	if (ret < 0) {
+		pr_err("eqos_phy_power_on() failed: %d", ret);
+		goto err;
+	}
+
 	ret = eqos->config->ops->eqos_start_resets(dev);
 	if (ret < 0) {
 		pr_err("eqos_start_resets() failed: %d", ret);
@@ -992,12 +1048,17 @@ static int eqos_start(struct udevice *dev)
 			EQOS_MAX_PACKET_SIZE <<
 			EQOS_DMA_CH0_RX_CONTROL_RBSZ_SHIFT);
 
-	desc_pad = (eqos->desc_size - sizeof(struct eqos_desc)) /
-		   eqos->config->axi_bus_width;
+	setbits_le32(&eqos->dma_regs->ch0_control, EQOS_DMA_CH0_CONTROL_PBLX8);
 
-	setbits_le32(&eqos->dma_regs->ch0_control,
-		     EQOS_DMA_CH0_CONTROL_PBLX8 |
-		     (desc_pad << EQOS_DMA_CH0_CONTROL_DSL_SHIFT));
+	/* "Descriptor Skip Length" field of the DMA channel control register */
+	if (eqos->use_cached_mem) {
+		desc_pad = (eqos->desc_size - sizeof(struct eqos_desc)) /
+			    eqos->config->axi_bus_width;
+		setbits_le32(&eqos->dma_regs->ch0_control,
+			     desc_pad << EQOS_DMA_CH0_CONTROL_DSL_SHIFT);
+		if (desc_pad > EQOS_DMA_CH0_CONTROL_DSL_MASK)
+			dev_dbg(dev, "DMA_CH0_CONTROL.DSL overflow");
+	}
 
 	/*
 	 * Burst length must be < 1/2 FIFO size.
@@ -1031,7 +1092,7 @@ static int eqos_start(struct udevice *dev)
 
 	for (i = 0; i < EQOS_DESCRIPTORS_TX; i++) {
 		struct eqos_desc *tx_desc = eqos_get_desc(eqos, i, false);
-		eqos->config->ops->eqos_flush_desc(tx_desc);
+		eqos->config->ops->eqos_flush_desc(eqos, tx_desc);
 	}
 
 	for (i = 0; i < EQOS_DESCRIPTORS_RX; i++) {
@@ -1040,7 +1101,7 @@ static int eqos_start(struct udevice *dev)
 					     (i * EQOS_MAX_PACKET_SIZE));
 		rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
 		mb();
-		eqos->config->ops->eqos_flush_desc(rx_desc);
+		eqos->config->ops->eqos_flush_desc(eqos, rx_desc);
 		eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf +
 						(i * EQOS_MAX_PACKET_SIZE),
 						EQOS_MAX_PACKET_SIZE);
@@ -1168,13 +1229,13 @@ static int eqos_send(struct udevice *dev, void *packet, int length)
 	 */
 	mb();
 	tx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_FD | EQOS_DESC3_LD | length;
-	eqos->config->ops->eqos_flush_desc(tx_desc);
+	eqos->config->ops->eqos_flush_desc(eqos, tx_desc);
 
 	writel((ulong)eqos_get_desc(eqos, eqos->tx_desc_idx, false),
 		&eqos->dma_regs->ch0_txdesc_tail_pointer);
 
 	for (i = 0; i < 1000000; i++) {
-		eqos->config->ops->eqos_inval_desc(tx_desc);
+		eqos->config->ops->eqos_inval_desc(eqos, tx_desc);
 		if (!(readl(&tx_desc->des3) & EQOS_DESC3_OWN))
 			return 0;
 		udelay(1);
@@ -1194,7 +1255,7 @@ static int eqos_recv(struct udevice *dev, int flags, uchar **packetp)
 	debug("%s(dev=%p, flags=%x):\n", __func__, dev, flags);
 
 	rx_desc = eqos_get_desc(eqos, eqos->rx_desc_idx, true);
-	eqos->config->ops->eqos_inval_desc(rx_desc);
+	eqos->config->ops->eqos_inval_desc(eqos, rx_desc);
 	if (rx_desc->des3 & EQOS_DESC3_OWN) {
 		debug("%s: RX packet not available\n", __func__);
 		return -EAGAIN;
@@ -1215,7 +1276,7 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	u32 idx, idx_mask = eqos->desc_per_cacheline - 1;
 	uchar *packet_expected;
-	struct eqos_desc *rx_desc;
+	struct eqos_desc *rx_desc = NULL;
 
 	debug("%s(packet=%p, length=%d)\n", __func__, packet, length);
 
@@ -1236,7 +1297,7 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 			rx_desc = eqos_get_desc(eqos, idx, true);
 			rx_desc->des0 = 0;
 			mb();
-			eqos->config->ops->eqos_flush_desc(rx_desc);
+			eqos->config->ops->eqos_flush_desc(eqos, rx_desc);
 			eqos->config->ops->eqos_inval_buffer(packet, length);
 			rx_desc->des0 = (u32)(ulong)(eqos->rx_dma_buf +
 					     (idx * EQOS_MAX_PACKET_SIZE));
@@ -1249,7 +1310,7 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 			 */
 			mb();
 			rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
-			eqos->config->ops->eqos_flush_desc(rx_desc);
+			eqos->config->ops->eqos_flush_desc(eqos, rx_desc);
 		}
 		writel((ulong)rx_desc, &eqos->dma_regs->ch0_rxdesc_tail_pointer);
 	}
@@ -1351,8 +1412,7 @@ static int eqos_remove_resources_core(struct udevice *dev)
 	free(eqos->rx_pkt);
 	free(eqos->rx_dma_buf);
 	free(eqos->tx_dma_buf);
-	eqos_free_descs(eqos->rx_descs);
-	eqos_free_descs(eqos->tx_descs);
+	eqos_free_descs(eqos);
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -1434,6 +1494,7 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
 	phy_interface_t interface;
+	ulong rate = 0;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
@@ -1444,7 +1505,15 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	ret = board_interface_eth_init(dev, interface);
+	/*  Get ETH_CLK clocks (optional) */
+	ret = clk_get_by_name(dev, "eth-ck", &eqos->clk_ck);
+	if (ret)
+		debug("No phy clock provided %d", ret);
+	else
+		rate = clk_get_rate(&eqos->clk_ck);
+
+	/*  Initialize the soc for the PHY configuration */
+	ret = board_interface_eth_init(dev, interface, rate);
 	if (ret)
 		return -EINVAL;
 
@@ -1466,10 +1535,14 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 		goto err_free_clk_rx;
 	}
 
-	/*  Get ETH_CLK clocks (optional) */
-	ret = clk_get_by_name(dev, "eth-ck", &eqos->clk_ck);
-	if (ret)
-		pr_warn("No phy clock provided %d", ret);
+#ifdef CONFIG_DM_REGULATOR
+	/* check presence of optional regulator */
+	ret = device_get_supply_regulator(dev, "phy-supply", &eqos->phy_supply);
+	if (ret && ret != -ENOENT) {
+		pr_err("device_get_supply_regulator failed: %d", ret);
+		goto err_free_clk_rx;
+	}
+#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -1653,6 +1726,7 @@ static struct eqos_ops eqos_tegra186_ops = {
 	.eqos_stop_clks = eqos_stop_clks_tegra186,
 	.eqos_start_clks = eqos_start_clks_tegra186,
 	.eqos_calibrate_pads = eqos_calibrate_pads_tegra186,
+	.eqos_phy_power_on = eqos_null_ops,
 	.eqos_disable_calibration = eqos_disable_calibration_tegra186,
 	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_tegra186,
 	.eqos_get_enetaddr = eqos_null_ops,
@@ -1682,6 +1756,7 @@ static struct eqos_ops eqos_stm32_ops = {
 	.eqos_stop_clks = eqos_stop_clks_stm32,
 	.eqos_start_clks = eqos_start_clks_stm32,
 	.eqos_calibrate_pads = eqos_null_ops,
+	.eqos_phy_power_on = eqos_phy_power_on_stm32,
 	.eqos_disable_calibration = eqos_null_ops,
 	.eqos_set_tx_clk_speed = eqos_null_ops,
 	.eqos_get_enetaddr = eqos_null_ops,
@@ -1699,6 +1774,28 @@ static const struct eqos_config __maybe_unused eqos_stm32_config = {
 	.ops = &eqos_stm32_ops
 };
 
+static const struct eqos_config __maybe_unused eqos_stm32mp13_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 50,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
+	.axi_bus_width = EQOS_AXI_WIDTH_32,
+	.interface = dev_read_phy_mode,
+	.ops = &eqos_stm32_ops
+};
+
+static const struct eqos_config eqos_stm32mp25_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 50,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
+	.axi_bus_width = EQOS_AXI_WIDTH_64,
+	.interface = dev_read_phy_mode,
+	.ops = &eqos_stm32_ops
+};
+
 static const struct udevice_id eqos_ids[] = {
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_TEGRA186)
 	{
@@ -1711,6 +1808,14 @@ static const struct udevice_id eqos_ids[] = {
 		.compatible = "st,stm32mp1-dwmac",
 		.data = (ulong)&eqos_stm32_config
 	},
+	{
+		.compatible = "st,stm32mp13-dwmac",
+		.data = (ulong)&eqos_stm32mp13_config
+	},
+	{
+		.compatible = "st,stm32mp25-dwmac",
+		.data = (ulong)&eqos_stm32mp25_config
+	},
 #endif
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_IMX)
 	{
diff --git a/drivers/net/dwc_eth_qos.h b/drivers/net/dwc_eth_qos.h
index a6b719af80..0146385a1f 100644
--- a/drivers/net/dwc_eth_qos.h
+++ b/drivers/net/dwc_eth_qos.h
@@ -227,9 +227,11 @@ struct eqos_config {
 	struct eqos_ops *ops;
 };
 
+struct eqos_priv;
+
 struct eqos_ops {
-	void (*eqos_inval_desc)(void *desc);
-	void (*eqos_flush_desc)(void *desc);
+	void (*eqos_inval_desc)(struct eqos_priv *eqos, void *desc);
+	void (*eqos_flush_desc)(struct eqos_priv *eqos, void *desc);
 	void (*eqos_inval_buffer)(void *buf, size_t size);
 	void (*eqos_flush_buffer)(void *buf, size_t size);
 	int (*eqos_probe_resources)(struct udevice *dev);
@@ -239,6 +241,7 @@ struct eqos_ops {
 	int (*eqos_stop_clks)(struct udevice *dev);
 	int (*eqos_start_clks)(struct udevice *dev);
 	int (*eqos_calibrate_pads)(struct udevice *dev);
+	int (*eqos_phy_power_on)(struct udevice *dev);
 	int (*eqos_disable_calibration)(struct udevice *dev);
 	int (*eqos_set_tx_clk_speed)(struct udevice *dev);
 	int (*eqos_get_enetaddr)(struct udevice *dev);
@@ -277,12 +280,16 @@ struct eqos_priv {
 	bool started;
 	bool reg_access_ok;
 	bool clk_ck_enabled;
+	bool use_cached_mem;
 	unsigned int tx_fifo_sz, rx_fifo_sz;
 	u32 reset_delays[3];
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *phy_supply;
+#endif
 };
 
-void eqos_inval_desc_generic(void *desc);
-void eqos_flush_desc_generic(void *desc);
+void eqos_inval_desc_generic(struct eqos_priv *eqos, void *desc);
+void eqos_flush_desc_generic(struct eqos_priv *eqos, void *desc);
 void eqos_inval_buffer_generic(void *buf, size_t size);
 void eqos_flush_buffer_generic(void *buf, size_t size);
 int eqos_null_ops(struct udevice *dev);
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index 7a2d54f71d..ef2431beac 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -172,6 +172,14 @@ config PHY_STM32_USBPHYC
 	  between an HS USB OTG controller and an HS USB Host controller,
 	  selected by an USB switch.
 
+config PHY_STM32_USB2PHY
+	tristate "STMicroelectronics STM32 USB2 PHY Controller driver"
+	depends on PHY && ARCH_STM32MP
+	help
+	  Enable this to support the High-Speed USB2 transceivers that are part
+	  of some STMicroelectronics STM32 SoCs. The PHY integrated is from
+	  synopsys, and called USB2-PHY
+
 config MESON_GXBB_USB_PHY
 	bool "Amlogic Meson GXBB USB PHY"
 	depends on PHY && ARCH_MESON && MESON_GXBB
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index aca365d219..42795b126d 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_STI_USB_PHY) += sti_usb_phy.o
 obj-$(CONFIG_PHY_RCAR_GEN2) += phy-rcar-gen2.o
 obj-$(CONFIG_PHY_RCAR_GEN3) += phy-rcar-gen3.o
 obj-$(CONFIG_PHY_STM32_USBPHYC) += phy-stm32-usbphyc.o
+obj-$(CONFIG_PHY_STM32_USB2PHY) += phy-stm32-usb2phy.o
 obj-$(CONFIG_MESON_GXBB_USB_PHY) += meson-gxbb-usb2.o
 obj-$(CONFIG_MESON_GXL_USB_PHY) += meson-gxl-usb2.o
 obj-$(CONFIG_MESON_G12A_USB_PHY) += meson-g12a-usb2.o meson-g12a-usb3-pcie.o
diff --git a/drivers/phy/phy-stm32-usb2phy.c b/drivers/phy/phy-stm32-usb2phy.c
new file mode 100644
index 0000000000..66610f3aeb
--- /dev/null
+++ b/drivers/phy/phy-stm32-usb2phy.c
@@ -0,0 +1,726 @@
+// SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_PHY
+
+#include <asm/io.h>
+#include <common.h>
+#include <clk.h>
+#include <clk-uclass.h>
+#include <div64.h>
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <dm/of_access.h>
+#include <fdtdec.h>
+#include <generic-phy.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/usb/otg.h>
+#include <log.h>
+#include <power/regulator.h>
+#include <regmap.h>
+#include <reset.h>
+#include <syscon.h>
+#include <usb.h>
+
+#define PHY1CR_OFFSET		0x2400
+#define PHY1TRIM1_OFFSET	0x240C
+#define PHY1TRIM2_OFFSET	0x2410
+#define PHY2CR_OFFSET		0x2800
+#define PHY2TRIM1_OFFSET	0x2808
+#define PHY2TRIM2_OFFSET	0x280C
+
+#define PHYCR_REG      1
+
+/* Retention mode enable (active low) */
+#define SYSCFG_USB2PHY2CR_RETENABLEN2_MASK		BIT(0)
+/*
+ * Auto-resume mode enable. Enables auto-resume logic in USB2PHY so that the PHY automatically
+ * responds to a remote wake-up without initial involvement of the Host controller.
+ */
+#define SYSCFG_USB2PHY2CR_AUTORSMENB2_MASK		BIT(1)
+/* Controls the power down of analog blocks during Suspend and Sleep. */
+#define SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK		BIT(2)
+/* Controls vbus valid input of USB3 DRD controller when in Host mode */
+#define SYSCFG_USB2PHY2CR_VBUSVALID_MASK		BIT(4)
+/* Selects VBUS valid comparator that is used when USB3 DRD controller is in Device mode */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK		BIT(5)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK		BIT(6)
+/*
+ * 0: internal debounce logic is enabled (default).
+ * Bit0: applies to utmiotg_vbusvalid,
+ * Bit1: applies to pipe3_PowerPresent,
+ * Bit2: applies to utmisrp_bvalid,
+ * Bit3: applies to utmiotg_iddig]. (default)
+ */
+#define SYSCFG_USB2PHY2CR_FILTER_BYPASS_MASK		GENMASK(10, 7)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_OTGDISABLE0_MASK		BIT(16)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_DRVVBUS0_MASK			BIT(17)
+
+#define SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK		GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK		GENMASK(5, 2)
+#define SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK		GENMASK(8, 6)
+#define SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK		GENMASK(11, 9)
+#define SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK		GENMASK(13, 12)
+#define SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK		GENMASK(16, 14)
+#define SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK		GENMASK(18, 17)
+#define SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK		GENMASK(22, 19)
+#define SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK		GENMASK(26, 23)
+#define SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK		GENMASK(28, 27)
+#define SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK		GENMASK(30, 29)
+
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK	GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK	BIT(2)
+
+struct stm32_usb2phy {
+	struct regmap *regmap;
+	struct clk clk;
+	struct reset_ctl reset;
+	struct udevice *vdd33;
+	struct udevice *vdda18;
+	struct udevice *vbus;
+	uint init;
+	const struct stm32mp2_usb2phy_hw_data *hw_data;
+};
+
+enum stm32_usb2phy_mode {
+	USB2_MODE_HOST_ONLY = 0x1,
+	USB2_MODE_DRD = 0x3,
+	USB2_MODE_OTG,
+};
+
+struct stm32mp2_usb2phy_hw_data {
+	u32 phyrefsel_mask, phyrefsel_bitpos, cr_offset, trim1_offset, trim2_offset;
+	enum stm32_usb2phy_mode valid_mode;
+};
+
+static const struct stm32mp2_usb2phy_hw_data stm32mp21_usb2phy_hwdata[] = {
+	{
+		.cr_offset = PHY1CR_OFFSET,
+		.trim1_offset = PHY1TRIM1_OFFSET,
+		.trim2_offset = PHY1TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_HOST_ONLY,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 4,
+	},
+	{
+		.cr_offset = PHY2CR_OFFSET,
+		.trim1_offset = PHY2TRIM1_OFFSET,
+		.trim2_offset = PHY2TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_OTG,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 4,
+	},
+	{ }
+};
+
+static const struct stm32mp2_usb2phy_hw_data stm32mp25_usb2phy_hwdata[] = {
+	{
+		.cr_offset = PHY1CR_OFFSET,
+		.trim1_offset = PHY1TRIM1_OFFSET,
+		.trim2_offset = PHY1TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_HOST_ONLY,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 4,
+	},
+	{
+		.cr_offset = PHY2CR_OFFSET,
+		.trim1_offset = PHY2TRIM1_OFFSET,
+		.trim2_offset = PHY2TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_DRD,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 12,
+	},
+	{ }
+};
+
+/*
+ * Two phy instances are found in mp25, and some bitfields are a bit different (shift...)
+ * depending on the instance. So identify the instance by using CR offset to report
+ * the correct bitfields & modes to use
+ */
+static const struct stm32mp2_usb2phy_hw_data *stm32_usb2phy_get_hwdata(struct udevice *dev,
+								       unsigned long offset)
+{
+	int i;
+	struct stm32mp2_usb2phy_hw_data *hwdata;
+
+	hwdata = (struct stm32mp2_usb2phy_hw_data *)dev_get_driver_data(dev);
+	if (!hwdata)
+		return NULL;
+	for (i = 0; (hwdata[i].cr_offset != offset) && hwdata[i].cr_offset; i++)
+		;
+	if (hwdata[i].cr_offset)
+		return &hwdata[i];
+
+	return NULL;
+}
+
+static int stm32_usb2phy_getrefsel(unsigned long rate)
+{
+	switch (rate) {
+	case 19200000:
+		return 0;
+	case 20000000:
+		return 1;
+	case 24000000:
+		return 2;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_usb2phy_regulators_enable(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+
+	ret = regulator_set_enable_if_allowed(phy_dev->vdd33, true);
+	if (ret)
+		return ret;
+
+	if (phy_dev->vdda18) {
+		ret = regulator_set_enable_if_allowed(phy_dev->vdda18, true);
+		if (ret)
+			goto vdd33_disable;
+	}
+
+	return 0;
+
+vdd33_disable:
+	regulator_set_enable(phy_dev->vdd33, false);
+
+	return ret;
+}
+
+static int stm32_usb2phy_regulators_disable(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+
+	if (phy_dev->vdda18) {
+		ret = regulator_set_enable_if_allowed(phy_dev->vdda18, false);
+		if (ret)
+			return ret;
+	}
+
+	ret = regulator_set_enable_if_allowed(phy_dev->vdd33, false);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stm32_usb2phy_init(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	struct udevice *dev = phy->dev;
+	unsigned long phyref_rate;
+	u32 phyrefsel;
+	const struct stm32mp2_usb2phy_hw_data *phy_data = phy_dev->hw_data;
+
+	if (phy_dev->init) {
+		phy_dev->init++;
+		return 0;
+	}
+
+	ret = stm32_usb2phy_regulators_enable(phy);
+	if (ret) {
+		dev_err(dev, "can't enable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_enable(&phy_dev->clk);
+	if (ret) {
+		dev_err(dev, "could not enable clock: %d\n", ret);
+		goto error_regl_dis;
+	}
+
+	phyref_rate = clk_get_rate(&phy_dev->clk);
+
+	ret = stm32_usb2phy_getrefsel(phyref_rate);
+	if (ret < 0) {
+		dev_err(dev, "invalid phyref clk rate\n");
+		goto error_clk_dis;
+	}
+	phyrefsel = (u32)ret;
+	dev_dbg(dev, "phyrefsel value (%d)\n", phyrefsel);
+
+	ret = regmap_update_bits(phy_dev->regmap,
+				 phy_data->cr_offset,
+				 phy_data->phyrefsel_mask << phy_data->phyrefsel_bitpos,
+				 phyrefsel << phy_data->phyrefsel_bitpos);
+	if (ret) {
+		dev_err(dev, "can't set phyrefclksel (%d)\n", ret);
+		goto error_clk_dis;
+	}
+
+	ret = reset_deassert(&phy_dev->reset);
+	if (ret) {
+		dev_err(dev, "can't release reset (%d)\n", ret);
+		goto error_clk_dis;
+	}
+
+	phy_dev->init++;
+
+	return 0;
+
+error_clk_dis:
+	clk_disable(&phy_dev->clk);
+error_regl_dis:
+	stm32_usb2phy_regulators_disable(phy);
+
+	return ret;
+}
+
+static int stm32_usb2phy_exit(struct phy *phy)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	int ret;
+
+        if (!phy_dev->init) {
+		dev_err(phy->dev, "Invalid ref-count for phy\n");
+		return -EINVAL;
+	}
+
+	phy_dev->init--;
+
+	if (phy_dev->init)
+		return 0;
+
+	ret = clk_disable(&phy_dev->clk);
+	if (ret)
+		return ret;
+
+	ret = stm32_usb2phy_regulators_disable(phy);
+	if (ret) {
+		dev_err(phy->dev, "can't disable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	return reset_assert(&phy_dev->reset);
+}
+
+static int stm32_usb2phy_phy_power_on(struct phy *phy)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	int ret;
+
+	if (phy_dev->vbus) {
+		ret = regulator_set_enable_if_allowed(phy_dev->vbus, true);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_phy_power_off(struct phy *phy)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	int ret;
+
+	if (phy_dev->vbus) {
+		ret = regulator_set_enable_if_allowed(phy_dev->vbus, false);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_get_regulator(ofnode node,
+				       char *supply_name,
+				       struct udevice **regulator)
+{
+	struct ofnode_phandle_args regulator_phandle;
+	int ret;
+
+	ret = ofnode_parse_phandle_with_args(node, supply_name,
+					     NULL, 0, 0, &regulator_phandle);
+	if (ret)
+		return ret;
+
+	ret = uclass_get_device_by_ofnode(UCLASS_REGULATOR,
+					  regulator_phandle.node, regulator);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stm32_usb2phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	const struct stm32mp2_usb2phy_hw_data *phy_data = phy_dev->hw_data;
+	struct udevice *dev = phy->dev;
+
+	switch (mode) {
+	case PHY_MODE_USB_HOST:
+		if (phy_data->valid_mode == USB2_MODE_HOST_ONLY ||
+		    phy_data->valid_mode == USB2_MODE_OTG)
+			/*
+			 * CMN bit cleared since OHCI-ctrl registers are inaccessible
+			 * when clocks (clk12+clk48) are turned off in Suspend which
+			 * makes it impossible to resume
+			 */
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK,
+						 0);
+		else {
+			/*
+			 * CMN bit cleared since when running in usb3speed with dwc3-usb
+			 * xHCI ctrl is (most likely) suspending the (unused) usb2phy2
+			 * and when the clocks (utmi_clk) input to usb3dr-ctrl from usb2phy2
+			 * are turned off, there is some internal error inside the usb3dr-ctrl
+			 * while running in usb3-speed
+			 */
+			if (submode == USB_ROLE_NONE) {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK, 0);
+			} else {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK);
+			}
+		}
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	case PHY_MODE_USB_DEVICE:
+		/*
+		 * USB DWC3 gadget driver (in uboot) first sets the RUN bit, and
+		 * later it performs the device-mode conf init.
+		 * Hence USB2PHY2CMN bit of PHY needs to be cleared, since incase
+		 * VBUS is not present then usb-ctrl puts PHY in suspend and inturn
+		 * PHY turns off clocks to ctrl which makes the device-mode init fail
+		 */
+		if (phy_data->valid_mode == USB2_MODE_OTG) {
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK,
+						 0);
+		} else {
+			if (submode == USB_ROLE_NONE) {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK);
+			} else {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK);
+			}
+		}
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_tuning(struct udevice *dev, ofnode node)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(dev);
+	u32 mask_trim1 = 0, value_trim1 = 0, mask_trim2 = 0, value_trim2 = 0, val;
+	int ret;
+
+	ret = ofnode_read_u32(node, "st,pll-ipath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ipath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,pll-ppath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ppath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,comp-dis-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting comp-dis-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,sqrx-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting sqrx-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,vdatref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting vdatref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,otg-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting otg-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txhsxv-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txhsxv-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txfsls-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txfsls-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txvref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txvref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txrise-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txrise-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txres-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txres-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txpreempamp-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK, val)) {
+			mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK;
+			value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txpreempamp-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txpreemppulse-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK, val)) {
+			mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK;
+			value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txpreemppulse-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	if (mask_trim1) {
+		ret = regmap_update_bits(phy_dev->regmap,
+					 phy_dev->hw_data->trim1_offset,
+					 mask_trim1,
+					 value_trim1);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim1 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim1 mask = %x value = %x\n", mask_trim1, value_trim1);
+	}
+
+	if (mask_trim2) {
+		ret = regmap_update_bits(phy_dev->regmap,
+					 phy_dev->hw_data->trim2_offset,
+					 mask_trim2,
+					 value_trim2);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim2 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim2 mask = %x value = %x\n", mask_trim2, value_trim2);
+	}
+
+	return 0;
+}
+
+static const struct phy_ops stm32_usb2phy_ops = {
+	.init = stm32_usb2phy_init,
+	.exit = stm32_usb2phy_exit,
+	.power_on = stm32_usb2phy_phy_power_on,
+	.power_off = stm32_usb2phy_phy_power_off,
+	.set_mode = stm32_usb2phy_set_mode,
+};
+
+static int stm32_usb2phy_probe(struct udevice *dev)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(dev);
+	ofnode node = dev_ofnode(dev), connector;
+	int ret;
+	u32 phycr;
+
+	phy_dev->regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg");
+	if (IS_ERR(phy_dev->regmap)) {
+		dev_err(dev, "unable to find regmap\n");
+		return PTR_ERR(phy_dev->regmap);
+	}
+
+	ret = dev_read_u32_index(dev, "st,syscfg", PHYCR_REG, &phycr);
+	if (ret) {
+		dev_err(dev, "Can't get sysconfig phycr offset (%d)\n", ret);
+		return ret;
+	}
+	dev_dbg(dev, "phycr offset 0x%x\n", phycr);
+
+	ret = clk_get_by_index(dev, 0, &phy_dev->clk);
+	if (ret)
+		return ret;
+
+	ret = reset_get_by_index(dev, 0, &phy_dev->reset);
+	if (ret)
+		return ret;
+
+	ret = device_get_supply_regulator(dev, "vdd33-supply", &phy_dev->vdd33);
+	if (ret) {
+		dev_err(dev, "Can't get vdd33-supply regulator\n");
+		return ret;
+	}
+
+	/* Vdda18 regulator is optional */
+	ret = device_get_supply_regulator(dev, "vdda18-supply", &phy_dev->vdda18);
+	if (ret) {
+		if (ret != -ENOENT)
+			return ret;
+		dev_dbg(dev, "Can't get vdda18-supply regulator\n");
+	}
+
+	phy_dev->hw_data = stm32_usb2phy_get_hwdata(dev, phycr);
+	if (!phy_dev->hw_data) {
+		dev_err(dev, "can't get matching stm32mp2_usb2_of_data\n");
+		return -EINVAL;
+	}
+
+	/* Configure phy tuning */
+	ret = stm32_usb2phy_tuning(dev, node);
+	if (ret) {
+		dev_err(dev, "can't set tuning parameters: %d\n", ret);
+		return ret;
+	}
+
+	connector = ofnode_find_subnode(node, "connector");
+	if (ofnode_valid(connector)) {
+		ret = stm32_usb2phy_get_regulator(connector, "vbus-supply",
+						  &phy_dev->vbus);
+		if (ret) {
+			if (ret != -ENOENT) {
+				dev_err(dev, "Can't get vbus regulator\n");
+				return ret;
+			}
+			phy_dev->vbus = NULL;
+		}
+	} else {
+		phy_dev->vbus = NULL;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id stm32_usb2phy_of_match[] = {
+	{ .compatible = "st,stm32mp25-usb2phy", .data = (ulong)stm32mp25_usb2phy_hwdata },
+	{ .compatible = "st,stm32mp21-usb2phy", .data = (ulong)stm32mp21_usb2phy_hwdata },
+	{ },
+};
+
+U_BOOT_DRIVER(stm32_usb2phy) = {
+	.name = "stm32-usb2phy",
+	.id = UCLASS_PHY,
+	.of_match = stm32_usb2phy_of_match,
+	.ops = &stm32_usb2phy_ops,
+	.probe = stm32_usb2phy_probe,
+	.priv_auto	= sizeof(struct stm32_usb2phy),
+};
diff --git a/drivers/phy/phy-stm32-usbphyc.c b/drivers/phy/phy-stm32-usbphyc.c
index 15bd60ca8c..d7312cd2b9 100644
--- a/drivers/phy/phy-stm32-usbphyc.c
+++ b/drivers/phy/phy-stm32-usbphyc.c
@@ -17,7 +17,9 @@
 #include <syscon.h>
 #include <usb.h>
 #include <asm/io.h>
+#include <dm/device.h>
 #include <dm/device_compat.h>
+#include <dm/device-internal.h>
 #include <dm/lists.h>
 #include <dm/of_access.h>
 #include <linux/bitfield.h>
@@ -633,6 +635,7 @@ U_BOOT_DRIVER(stm32_usb_phyc) = {
 
 struct stm32_usbphyc_clk {
 	bool enable;
+	struct clk clkp;
 };
 
 static ulong stm32_usbphyc_clk48_get_rate(struct clk *clk)
@@ -687,9 +690,25 @@ const struct clk_ops usbphyc_clk48_ops = {
 	.disable = stm32_usbphyc_clk48_disable,
 };
 
+int usbphyc_clk48_probe(struct udevice *dev)
+{
+	struct stm32_usbphyc_clk *priv = dev_get_priv(dev);
+
+	/* prepare clkp to correctly register clock with CCF */
+	priv->clkp.dev = dev;
+	priv->clkp.id = CLK_ID(dev, 0);
+
+	/* Store back pointer to clk from udevice */
+	/* FIXME: This is not allowed...should be allocated by driver model */
+	dev_set_uclass_priv(dev, &priv->clkp);
+
+	return 0;
+}
+
 U_BOOT_DRIVER(stm32_usb_phyc_clk) = {
 	.name = "stm32-usbphyc-clk",
 	.id = UCLASS_CLK,
 	.ops = &usbphyc_clk48_ops,
+	.probe = &usbphyc_clk48_probe,
 	.priv_auto = sizeof(struct stm32_usbphyc_clk),
 };
diff --git a/drivers/phy/phy-uclass.c b/drivers/phy/phy-uclass.c
index 629ef3aa3d..9b36270b32 100644
--- a/drivers/phy/phy-uclass.c
+++ b/drivers/phy/phy-uclass.c
@@ -546,6 +546,22 @@ int generic_shutdown_phy(struct phy *phy)
 	return ret;
 }
 
+int generic_phy_set_mode_bulk(struct phy_bulk *bulk, enum phy_mode mode, int submode)
+{
+	struct phy *phys = bulk->phys;
+	int i, ret;
+
+	for (i = 0; i < bulk->count; i++) {
+		ret = generic_phy_set_mode(&phys[i], mode, submode);
+		if (ret) {
+			pr_err("Can't set mode on PHY%d\n", i);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 UCLASS_DRIVER(phy) = {
 	.id		= UCLASS_PHY,
 	.name		= "phy",
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 75b3ff47a2..221e4fb300 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -210,6 +210,14 @@ config PINCTRL_INTEL
 	  driver which must be separately enabled. The driver supports setting
 	  pins on start-up and changing the GPIO attributes.
 
+config PINCTRL_MCP23017
+	bool "Microchip MCP23017 pinctrl driver"
+	help
+	  I2C driver for Microchip MCP23017 16-Bit I/O Expander.
+	  The driver is controlled by a device tree node which contains both
+	  the GPIO definitions and pin control functions for each available
+	  multiplex function.
+
 config PINCTRL_PIC32
 	bool "Microchip PIC32 pin-control and pin-mux driver"
 	depends on DM && MACH_PIC32
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index fc1f01a02c..0dca96498a 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_PINCTRL_UNIPHIER)	+= uniphier/
 obj-$(CONFIG_PINCTRL_PIC32)	+= pinctrl_pic32.o
 obj-$(CONFIG_PINCTRL_EXYNOS)	+= exynos/
 obj-$(CONFIG_PINCTRL_K210)	+= pinctrl-k210.o
+obj-$(CONFIG_PINCTRL_MCP23017)	+= pinctrl-mcp23017.o
 obj-$(CONFIG_PINCTRL_MESON)	+= meson/
 obj-$(CONFIG_PINCTRL_MTK)	+= mediatek/
 obj-$(CONFIG_PINCTRL_MSCC)	+= mscc/
diff --git a/drivers/pinctrl/pinctrl-mcp23017.c b/drivers/pinctrl/pinctrl-mcp23017.c
new file mode 100644
index 0000000000..78eb9086c0
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-mcp23017.c
@@ -0,0 +1,411 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * Driver for Microchip MCP23017 16-Bit I/O Expander with I2C interface
+ */
+
+#define LOG_CATEGORY UCLASS_PINCTRL
+
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <i2c.h>
+#include <reset.h>
+#include <asm/gpio.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <dm/pinctrl.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <power/regulator.h>
+
+/* register offset for IOCON.BANK = 0, the normal mode at reset */
+#define MCP_REG_IODIR	0x00		/* init/reset:  all ones */
+#define MCP_REG_IOCON	0x0A
+#define IOCON_SEQOP	BIT(5)
+#define MCP_REG_GPPU	0x0C
+#define MCP_REG_GPIO	0x12
+
+#define MCP_REG_SIZE	8
+#define MCP_MAX_GPIO	16
+
+static int mcp23017_read(struct udevice *dev, uint offset)
+{
+	return  dm_i2c_reg_read(dev_get_parent(dev), offset);
+}
+
+static int mcp23017_write(struct udevice *dev, uint reg, unsigned int val)
+{
+	dev_dbg(dev, "%s reg = 0x%x val = 0x%x\n", __func__, reg, val);
+
+	return dm_i2c_reg_write(dev_get_parent(dev), reg, val);
+}
+
+static int mcp23017_read_reg(struct udevice *dev, u8 reg, uint offset)
+{
+	u8 mask = BIT(offset);
+	int ret;
+
+	ret = mcp23017_read(dev, reg);
+
+	dev_dbg(dev, "%s reg = 0x%x offset = %d ret = 0x%x mask = 0x%x\n",
+		__func__, reg, offset, ret, mask);
+
+	return ret < 0 ? ret : !!(ret & mask);
+}
+
+static int mcp23017_write_reg(struct udevice *dev, u8 reg, uint offset,
+			      uint val)
+{
+	u8 mask = BIT(offset);
+	int ret;
+
+	ret = mcp23017_read(dev, reg);
+	if (ret < 0)
+		return ret;
+	ret = (ret & ~mask) | (val ? mask : 0);
+
+	return mcp23017_write(dev, reg, ret);
+}
+
+static int mcp23017_conf_set_gppu(struct udevice *dev, unsigned int offset,
+				  uint pupd)
+{
+	int reg = MCP_REG_GPPU + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	return mcp23017_write_reg(dev, reg, bit, pupd);
+}
+
+static int mcp23017_conf_get_gppu(struct udevice *dev, unsigned int offset)
+{
+	int reg = MCP_REG_GPPU + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+	int ret = mcp23017_read_reg(dev, reg, bit);
+
+	return ret;
+}
+
+static int mcp23017_gpio_get(struct udevice *dev, unsigned int offset)
+{
+	int reg = MCP_REG_GPIO + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+	int ret = mcp23017_read_reg(dev, reg, bit);
+
+	return ret;
+}
+
+static int mcp23017_gpio_set(struct udevice *dev, unsigned int offset, int value)
+{
+	int reg = MCP_REG_GPIO + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	return mcp23017_write_reg(dev, reg, bit, value);
+}
+
+static int mcp23017_gpio_get_function(struct udevice *dev, unsigned int offset)
+{
+	int ret;
+	int reg = MCP_REG_IODIR + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	ret = mcp23017_read_reg(dev, reg, bit);
+
+	if (ret < 0)
+		return ret;
+	/* On mcp23017, gpio pins direction is (0)output, (1)input. */
+	return ret ? GPIOF_INPUT : GPIOF_OUTPUT;
+}
+
+static int mcp23017_gpio_direction_input(struct udevice *dev, unsigned int offset)
+{
+	int reg = MCP_REG_IODIR + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	return mcp23017_write_reg(dev, reg, bit, 1);
+}
+
+static int mcp23017_gpio_direction_output(struct udevice *dev,
+					  unsigned int offset, int value)
+{
+	int reg = MCP_REG_IODIR + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+	int ret = mcp23017_gpio_set(dev, offset, value);
+
+	if (ret < 0)
+		return ret;
+
+	return mcp23017_write_reg(dev, reg, bit, 0);
+}
+
+static int mcp23017_gpio_set_flags(struct udevice *dev, unsigned int offset,
+				   ulong flags)
+{
+	int ret = -ENOTSUPP;
+
+	if (flags & GPIOD_IS_OUT) {
+		bool value = flags & GPIOD_IS_OUT_ACTIVE;
+
+		if (flags & GPIOD_OPEN_SOURCE)
+			return -ENOTSUPP;
+		if (flags & GPIOD_OPEN_DRAIN)
+			return -ENOTSUPP;
+		ret = mcp23017_gpio_direction_output(dev, offset, value);
+	} else if (flags & GPIOD_IS_IN) {
+		ret = mcp23017_gpio_direction_input(dev, offset);
+		if (ret)
+			return ret;
+		if (flags & GPIOD_PULL_UP) {
+			ret = mcp23017_conf_set_gppu(dev, offset, 1);
+			if (ret)
+				return ret;
+		} else {
+			ret = mcp23017_conf_set_gppu(dev, offset, 0);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int mcp23017_gpio_get_flags(struct udevice *dev, unsigned int offset,
+				   ulong *flags)
+{
+	ulong dir_flags = 0;
+	int ret;
+
+	if (mcp23017_gpio_get_function(dev, offset) == GPIOF_OUTPUT) {
+		dir_flags |= GPIOD_IS_OUT;
+
+		ret = mcp23017_gpio_get(dev, offset);
+		if (ret < 0)
+			return ret;
+		if (ret)
+			dir_flags |= GPIOD_IS_OUT_ACTIVE;
+	} else {
+		dir_flags |= GPIOD_IS_IN;
+
+		ret = mcp23017_conf_get_gppu(dev, offset);
+		if (ret < 0)
+			return ret;
+		if (ret == 1)
+			dir_flags |= GPIOD_PULL_UP;
+	}
+	*flags = dir_flags;
+
+	return 0;
+}
+
+static int mcp23017_gpio_probe(struct udevice *dev)
+{
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+
+	uc_priv->bank_name = "mcp_gpio";
+	uc_priv->gpio_count = MCP_MAX_GPIO;
+
+	return 0;
+}
+
+static const struct dm_gpio_ops mcp23017_gpio_ops = {
+	.set_value = mcp23017_gpio_set,
+	.get_value = mcp23017_gpio_get,
+	.get_function = mcp23017_gpio_get_function,
+	.direction_input = mcp23017_gpio_direction_input,
+	.direction_output = mcp23017_gpio_direction_output,
+	.set_flags = mcp23017_gpio_set_flags,
+	.get_flags = mcp23017_gpio_get_flags,
+};
+
+U_BOOT_DRIVER(mcp23017_gpio) = {
+	.name	= "mcp23017-gpio",
+	.id	= UCLASS_GPIO,
+	.probe	= mcp23017_gpio_probe,
+	.ops	= &mcp23017_gpio_ops,
+};
+
+#if CONFIG_IS_ENABLED(PINCONF)
+static const struct pinconf_param mcp23017_pinctrl_conf_params[] = {
+	{ "bias-pull-up", PIN_CONFIG_BIAS_PULL_UP, 0 },
+	{ "output-high", PIN_CONFIG_OUTPUT, 1 },
+	{ "output-low", PIN_CONFIG_OUTPUT, 0 },
+};
+
+static int mcp23017_pinctrl_conf_set(struct udevice *dev, unsigned int pin,
+				     unsigned int param, unsigned int arg)
+{
+	int ret, dir;
+
+	/* directly call the generic gpio function, only based on i2c parent */
+	dir = mcp23017_gpio_get_function(dev, pin);
+
+	if (dir < 0)
+		return dir;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_PULL_UP:
+		ret = mcp23017_conf_set_gppu(dev, pin, 1);
+		break;
+	case PIN_CONFIG_OUTPUT:
+		ret = mcp23017_gpio_direction_output(dev, pin, arg);
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return ret;
+}
+#endif
+
+static int mcp23017_pinctrl_get_pins_count(struct udevice *dev)
+{
+	return MCP_MAX_GPIO;
+}
+
+static char pin_name[PINNAME_SIZE];
+static const char *mcp23017_pinctrl_get_pin_name(struct udevice *dev,
+						 unsigned int selector)
+{
+	snprintf(pin_name, PINNAME_SIZE, "mcp_gpio%u", selector);
+
+	return pin_name;
+}
+
+static const char *mcp23017_pinctrl_get_pin_conf(struct udevice *dev,
+						 unsigned int pin, int func)
+{
+	int pupd;
+
+	pupd = mcp23017_conf_get_gppu(dev, pin);
+	if (pupd < 0)
+		return "";
+
+	if (pupd)
+		return "bias-pull-up";
+	else
+		return "";
+}
+
+static int mcp23017_pinctrl_get_pin_muxing(struct udevice *dev,
+					   unsigned int selector,
+					   char *buf, int size)
+{
+	int func;
+
+	func = mcp23017_gpio_get_function(dev, selector);
+	if (func < 0)
+		return func;
+
+	snprintf(buf, size, "%s ", func == GPIOF_INPUT ? "input" : "output");
+
+	strlcat(buf, mcp23017_pinctrl_get_pin_conf(dev, selector, func), size);
+
+	return 0;
+}
+
+const struct pinctrl_ops mcp23017_pinctrl_ops = {
+	.get_pins_count = mcp23017_pinctrl_get_pins_count,
+	.get_pin_name = mcp23017_pinctrl_get_pin_name,
+	.set_state = pinctrl_generic_set_state,
+	.get_pin_muxing	= mcp23017_pinctrl_get_pin_muxing,
+#if CONFIG_IS_ENABLED(PINCONF)
+	.pinconf_set = mcp23017_pinctrl_conf_set,
+	.pinconf_num_params = ARRAY_SIZE(mcp23017_pinctrl_conf_params),
+	.pinconf_params = mcp23017_pinctrl_conf_params,
+#endif
+};
+
+U_BOOT_DRIVER(mcp23017_pinctrl) = {
+	.name = "mcp23017-pinctrl",
+	.id = UCLASS_PINCTRL,
+	.ops = &mcp23017_pinctrl_ops,
+};
+
+static int mcp23017_bind(struct udevice *dev)
+{
+	int ret;
+
+	ret = device_bind_driver_to_node(dev, "mcp23017-pinctrl", "mcp23017-pinctrl",
+					 dev_ofnode(dev), NULL);
+	if (ret)
+		return ret;
+
+	return device_bind_driver_to_node(dev, "mcp23017-gpio", "mcp23017-gpio",
+					  dev_ofnode(dev), NULL);
+}
+
+static int mcp23017_chip_init(struct udevice *dev)
+{
+	int ret, iocon;
+
+	ret = dm_i2c_reg_read(dev, MCP_REG_IOCON);
+	dev_dbg(dev, "reg = 0x%x val = 0x%x\n", MCP_REG_IOCON, ret);
+	if (ret < 0) {
+		dev_err(dev, "Can't read MCP23017 IOCON register (%d)\n", ret);
+		return ret;
+	}
+
+	/* deactivate Sequential mode if activated */
+	if (ret & IOCON_SEQOP) {
+		iocon = ret & ~IOCON_SEQOP;
+
+		ret = dm_i2c_reg_write(dev, MCP_REG_IOCON, iocon);
+		if (ret < 0) {
+			dev_err(dev, "can't write IOCON register (%d)\n", ret);
+		} else {
+			/* mcp23017 has IOCON twice, make sure they are in sync */
+			ret = dm_i2c_reg_write(dev, MCP_REG_IOCON + 1, iocon);
+			if (ret < 0)
+				dev_err(dev, "can't write IOCON register (%d)\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int mcp23017_probe(struct udevice *dev)
+{
+	struct udevice *vdd;
+	struct reset_ctl reset;
+	int ret;
+
+	if (CONFIG_IS_ENABLED(DM_REGULATOR)) {
+		ret = device_get_supply_regulator(dev, "vdd-supply", &vdd);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "vdd regulator error:%d\n", ret);
+			return ret;
+		}
+		if (!ret) {
+			ret = regulator_set_enable(vdd, true);
+			if (ret) {
+				dev_err(dev, "vdd enable failed: %d\n", ret);
+				return ret;
+			}
+		}
+	}
+
+	ret = reset_get_by_index(dev, 0, &reset);
+	if (!ret) {
+		reset_assert(&reset);
+		udelay(2);
+		reset_deassert(&reset);
+	}
+
+	return mcp23017_chip_init(dev);
+}
+
+static const struct udevice_id mcp23017_match[] = {
+	{ .compatible = "microchip,mcp23017", },
+};
+
+U_BOOT_DRIVER(mcp23017) = {
+	.name = "mcp23017",
+	.id = UCLASS_I2C_GENERIC,
+	.of_match = of_match_ptr(mcp23017_match),
+	.probe = mcp23017_probe,
+	.bind = mcp23017_bind,
+};
diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 509e2a80e9..a82087374a 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -178,9 +178,9 @@ static int stmfx_gpio_set_flags(struct udevice *dev, unsigned int offset,
 		if (flags & GPIOD_OPEN_SOURCE)
 			return -ENOTSUPP;
 		if (flags & GPIOD_OPEN_DRAIN)
-			ret = stmfx_conf_set_type(dev, offset, 0);
-		else /* PUSH-PULL */
 			ret = stmfx_conf_set_type(dev, offset, 1);
+		else /* PUSH-PULL */
+			ret = stmfx_conf_set_type(dev, offset, 0);
 		if (ret)
 			return ret;
 		ret = stmfx_gpio_direction_output(dev, offset, value);
diff --git a/drivers/pinctrl/pinctrl_stm32.c b/drivers/pinctrl/pinctrl_stm32.c
index b06da50b2c..bdc623eb5c 100644
--- a/drivers/pinctrl/pinctrl_stm32.c
+++ b/drivers/pinctrl/pinctrl_stm32.c
@@ -12,6 +12,7 @@
 #include <malloc.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
+#include <dm/device-internal.h>
 #include <dm/device_compat.h>
 #include <dm/lists.h>
 #include <dm/pinctrl.h>
@@ -27,6 +28,13 @@
 #define PUPD_MASK			3
 #define OTYPE_MSK			1
 #define AFR_MASK			0xF
+#define SECCFG_MSK			1
+#define ADVCFGR_MASK			0xF
+#define DELAYR_MASK			0xF
+#define ADVCFGR_DLYPATH_POS		0
+#define ADVCFGR_DE_POS			1
+#define ADVCFGR_INVCLK_POS		2
+#define ADVCFGR_RET_POS			3
 
 struct stm32_pinctrl_priv {
 	struct hwspinlock hws;
@@ -39,6 +47,14 @@ struct stm32_gpio_bank {
 	struct list_head list;
 };
 
+struct stm32_pinctrl_data {
+	bool secure_control;
+	bool io_sync_control;
+	bool rif_control;
+};
+
+static int stm32_pinctrl_get_access(struct udevice *gpio_dev, unsigned int gpio_idx);
+
 #ifndef CONFIG_SPL_BUILD
 
 static char pin_name[PINNAME_SIZE];
@@ -216,6 +232,12 @@ static int stm32_pinctrl_get_pin_muxing(struct udevice *dev,
 	if (!gpio_dev)
 		return -ENODEV;
 
+	/* Check access protection */
+	if (stm32_pinctrl_get_access(gpio_dev, gpio_idx)) {
+		snprintf(buf, size, "NO ACCESS");
+		return 0;
+	}
+
 	mode = gpio_get_raw_function(gpio_dev, gpio_idx, &label);
 	dev_dbg(dev, "selector = %d gpio_idx = %d mode = %d\n",
 		selector, gpio_idx, mode);
@@ -252,6 +274,25 @@ static int stm32_pinctrl_get_pin_muxing(struct udevice *dev,
 
 #endif
 
+static int stm32_pinctrl_get_access(struct udevice *gpio_dev, unsigned int gpio_idx)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(gpio_dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(gpio_dev);
+
+	/* Deny request access if IO is secured */
+	if ((drv_data & STM32_GPIO_FLAG_SEC_CTRL) &&
+	    ((readl(&regs->seccfgr) >> gpio_idx) & SECCFG_MSK))
+		return -EACCES;
+
+	/* Deny request access if IO RIF semaphore is not available */
+	if ((drv_data & STM32_GPIO_FLAG_RIF_CTRL) &&
+	    !stm32_gpio_rif_valid(regs, gpio_idx))
+		return -EACCES;
+
+	return 0;
+}
+
 static int stm32_pinctrl_probe(struct udevice *dev)
 {
 	struct stm32_pinctrl_priv *priv = dev_get_priv(dev);
@@ -277,12 +318,28 @@ static int stm32_gpio_config(ofnode node,
 	struct stm32_gpio_regs *regs = priv->regs;
 	struct stm32_pinctrl_priv *ctrl_priv;
 	int ret;
-	u32 index;
+	u32 index, io_sync, advcfg;
+
+	/* Check access protection */
+	ret = stm32_pinctrl_get_access(desc->dev, desc->offset);
+	if (ret) {
+		dev_err(desc->dev, "Failed to get secure IO %s %d @ %p\n",
+			uc_priv->bank_name, desc->offset, regs);
+		return ret;
+	}
 
 	if (!ctl || ctl->af > 15 || ctl->mode > 3 || ctl->otype > 1 ||
 	    ctl->pupd > 2 || ctl->speed > 3)
 		return -EINVAL;
 
+	io_sync = dev_get_driver_data(desc->dev) & STM32_GPIO_FLAG_IO_SYNC_CTRL;
+	if (io_sync && (ctl->delay_path > STM32_GPIO_DELAY_PATH_IN ||
+			ctl->clk_edge > STM32_GPIO_CLK_EDGE_DOUBLE ||
+			ctl->clk_type > STM32_GPIO_CLK_TYPE_INVERT ||
+			ctl->retime > STM32_GPIO_RETIME_ENABLED ||
+			ctl->delay > STM32_GPIO_DELAY_3_25))
+		return -EINVAL;
+
 	ctrl_priv = dev_get_priv(dev_get_parent(desc->dev));
 	ret = hwspinlock_lock_timeout(&ctrl_priv->hws, 10);
 	if (ret == -ETIME) {
@@ -304,6 +361,20 @@ static int stm32_gpio_config(ofnode node,
 	index = desc->offset;
 	clrsetbits_le32(&regs->otyper, OTYPE_MSK << index, ctl->otype << index);
 
+	if (io_sync) {
+		index = (desc->offset & 0x07) * 4;
+		advcfg = (ctl->delay_path << ADVCFGR_DLYPATH_POS) |
+			 (ctl->clk_edge << ADVCFGR_DE_POS) |
+			 (ctl->clk_type << ADVCFGR_INVCLK_POS) |
+			 (ctl->retime << ADVCFGR_RET_POS);
+
+		clrsetbits_le32(&regs->advcfgr[desc->offset >> 3],
+				ADVCFGR_MASK << index, advcfg << index);
+
+		clrsetbits_le32(&regs->delayr[desc->offset >> 3],
+				DELAYR_MASK << index, ctl->delay << index);
+	}
+
 	uc_priv->name[desc->offset] = strdup(ofnode_get_name(node));
 
 	hwspinlock_unlock(&ctrl_priv->hws);
@@ -356,10 +427,24 @@ static int prep_gpio_ctl(struct stm32_gpio_ctl *gpio_ctl, u32 gpio_fn,
 	else
 		gpio_ctl->pupd = STM32_GPIO_PUPD_NO;
 
+	gpio_ctl->delay_path = ofnode_read_u32_default(node, "st,io-delay-path", 0);
+	gpio_ctl->clk_edge = ofnode_read_u32_default(node, "st,io-clk-edge", 0);
+	gpio_ctl->clk_type = ofnode_read_u32_default(node, "st,io-clk-type", 0);
+	gpio_ctl->retime = ofnode_read_u32_default(node, "st,io-retime", 0);
+	gpio_ctl->delay = ofnode_read_u32_default(node, "st,io-delay", 0);
+
 	log_debug("gpio fn= %d, slew-rate= %x, op type= %x, pull-upd is = %x\n",
 		  gpio_fn, gpio_ctl->speed, gpio_ctl->otype,
 		  gpio_ctl->pupd);
 
+	if (gpio_ctl->retime || gpio_ctl->clk_type || gpio_ctl->clk_edge || gpio_ctl->delay_path ||
+	    gpio_ctl->delay)
+		log_debug("	Retime:%d InvClk:%d DblEdge:%d DelayIn:%d\n",
+			  gpio_ctl->retime, gpio_ctl->clk_type, gpio_ctl->clk_edge,
+			  gpio_ctl->delay_path);
+	if (gpio_ctl->delay)
+		log_debug("	Delay: %d (%d ps)\n", gpio_ctl->delay, gpio_ctl->delay * 250);
+
 	return 0;
 }
 
@@ -414,8 +499,29 @@ static int stm32_pinctrl_bind(struct udevice *dev)
 {
 	ofnode node;
 	const char *name;
+	struct driver *drv;
+	const struct stm32_pinctrl_data *drv_data;
+	ulong gpio_data = 0;
 	int ret;
 
+	drv = lists_driver_lookup_name("gpio_stm32");
+	if (!drv) {
+		debug("Cannot find driver 'gpio_stm32'\n");
+		return -ENOENT;
+	}
+
+	drv_data = (const struct stm32_pinctrl_data *)dev_get_driver_data(dev);
+	if (!drv_data) {
+		debug("Cannot find driver data\n");
+		return -EINVAL;
+	}
+	if (drv_data->secure_control)
+		gpio_data |= STM32_GPIO_FLAG_SEC_CTRL;
+	if (drv_data->io_sync_control)
+		gpio_data |= STM32_GPIO_FLAG_IO_SYNC_CTRL;
+	if (drv_data->rif_control)
+		gpio_data |= STM32_GPIO_FLAG_RIF_CTRL;
+
 	dev_for_each_subnode(node, dev) {
 		dev_dbg(dev, "bind %s\n", ofnode_get_name(node));
 
@@ -431,8 +537,7 @@ static int stm32_pinctrl_bind(struct udevice *dev)
 			return -EINVAL;
 
 		/* Bind each gpio node */
-		ret = device_bind_driver_to_node(dev, "gpio_stm32",
-						 name, node, NULL);
+		ret = device_bind_with_driver_data(dev, drv, name, gpio_data, node, NULL);
 		if (ret)
 			return ret;
 
@@ -495,15 +600,37 @@ static struct pinctrl_ops stm32_pinctrl_ops = {
 #endif
 };
 
+static const struct stm32_pinctrl_data stm32_pinctrl_base = {
+	.secure_control = false,
+	.io_sync_control = false,
+	.rif_control = false,
+};
+
+static const struct stm32_pinctrl_data stm32_pinctrl_sec = {
+	.secure_control = true,
+	.io_sync_control = false,
+	.rif_control = false,
+};
+
+static const struct stm32_pinctrl_data stm32_pinctrl_sec_iosync = {
+	.secure_control = true,
+	.io_sync_control = true,
+	.rif_control = true,
+};
+
 static const struct udevice_id stm32_pinctrl_ids[] = {
-	{ .compatible = "st,stm32f429-pinctrl" },
-	{ .compatible = "st,stm32f469-pinctrl" },
-	{ .compatible = "st,stm32f746-pinctrl" },
-	{ .compatible = "st,stm32f769-pinctrl" },
-	{ .compatible = "st,stm32h743-pinctrl" },
-	{ .compatible = "st,stm32mp157-pinctrl" },
-	{ .compatible = "st,stm32mp157-z-pinctrl" },
-	{ .compatible = "st,stm32mp135-pinctrl" },
+	{ .compatible = "st,stm32f429-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32f469-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32f746-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32f769-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32h743-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32mp157-pinctrl",   .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32mp157-z-pinctrl", .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32mp135-pinctrl",   .data = (ulong)&stm32_pinctrl_sec },
+	{ .compatible = "st,stm32mp215-pinctrl",   .data = (ulong)&stm32_pinctrl_sec_iosync },
+	{ .compatible = "st,stm32mp215-z-pinctrl", .data = (ulong)&stm32_pinctrl_sec_iosync },
+	{ .compatible = "st,stm32mp257-pinctrl",   .data = (ulong)&stm32_pinctrl_sec_iosync },
+	{ .compatible = "st,stm32mp257-z-pinctrl", .data = (ulong)&stm32_pinctrl_sec_iosync },
 	{ }
 };
 
diff --git a/drivers/power/regulator/scmi_regulator.c b/drivers/power/regulator/scmi_regulator.c
index 801148036f..fa690d4a43 100644
--- a/drivers/power/regulator/scmi_regulator.c
+++ b/drivers/power/regulator/scmi_regulator.c
@@ -184,7 +184,7 @@ U_BOOT_DRIVER(scmi_regulator) = {
 	.probe = scmi_regulator_probe,
 	.of_to_plat = scmi_regulator_of_to_plat,
 	.plat_auto = sizeof(struct scmi_regulator_platdata),
-	.priv_auto = sizeof(struct scmi_regulator_priv *),
+	.priv_auto = sizeof(struct scmi_regulator_priv),
 };
 
 static int scmi_regulator_bind(struct udevice *dev)
diff --git a/drivers/ram/stm32mp1/stm32mp1_ram.c b/drivers/ram/stm32mp1/stm32mp1_ram.c
index a6c19af972..2808d07c3a 100644
--- a/drivers/ram/stm32mp1/stm32mp1_ram.c
+++ b/drivers/ram/stm32mp1/stm32mp1_ram.c
@@ -126,7 +126,8 @@ static int stm32mp1_ddr_setup(struct udevice *dev)
 		dev_dbg(dev, "no st,mem-name\n");
 		return -EINVAL;
 	}
-	printf("RAM: %s\n", config.info.name);
+	if (CONFIG_IS_ENABLED(DISPLAY_PRINT))
+		printf("RAM: %s\n", config.info.name);
 
 	for (idx = 0; idx < ARRAY_SIZE(param); idx++) {
 		ret = ofnode_read_u32_array(node, param[idx].name,
diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index 27e4a60ff5..891ef470ae 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -12,6 +12,14 @@ config REMOTEPROC
 	bool
 	depends on DM
 
+config REMOTEPROC_OPTEE
+	bool "Support for the remoteproc in OPTEE"
+	depends on REMOTEPROC
+	depends on OPTEE
+	help
+	  Say y here to support remote processor firmware management by the
+	  trusted execution environment.
+
 # Please keep the configuration alphabetically sorted.
 config K3_SYSTEM_CONTROLLER
 	bool "Support for TI' K3 System Controller"
diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
index fbe9c172bc..394397435d 100644
--- a/drivers/remoteproc/Makefile
+++ b/drivers/remoteproc/Makefile
@@ -5,6 +5,7 @@
 #
 
 obj-$(CONFIG_$(SPL_)REMOTEPROC) += rproc-uclass.o rproc-elf-loader.o
+obj-$(CONFIG_REMOTEPROC_OPTEE) += rproc-optee.o
 
 # Remote proc drivers - Please keep this list alphabetically sorted.
 obj-$(CONFIG_K3_SYSTEM_CONTROLLER) += k3_system_controller.o
diff --git a/drivers/remoteproc/rproc-optee.c b/drivers/remoteproc/rproc-optee.c
new file mode 100644
index 0000000000..20743c4428
--- /dev/null
+++ b/drivers/remoteproc/rproc-optee.c
@@ -0,0 +1,239 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ * Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
+ */
+
+#define LOG_CATEGORY UCLASS_REMOTEPROC
+
+#include <dm.h>
+#include <errno.h>
+#include <remoteproc.h>
+#include <rproc_optee.h>
+#include <tee.h>
+#include <dm/device_compat.h>
+
+#define TA_REMOTEPROC_UUID  { 0x80a4c275, 0x0a47, 0x4905, \
+		   { 0x82, 0x85, 0x14, 0x86, 0xa9, 0x77, 0x1a, 0x08} }
+
+/* The function IDs implemented in the associated TA */
+
+/*
+ * Authentication of the firmware and load in the remote processor memory.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [in]  params[1].memref:	buffer containing the image of the firmware
+ */
+#define TA_RPROC_FW_CMD_LOAD_FW		1
+
+/*
+ * Start the remote processor.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_START_FW	2
+
+/*
+ * Stop the remote processor.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_STOP_FW		3
+
+/*
+ * Return the physical address of the resource table, or 0 if not found
+ * No check is done to verify that the address returned is accessible by the
+ * non secure world. If the resource table is loaded in a protected memory,
+ * then accesses from non-secure world will likely fail.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out] params[1].value.a:	32bit LSB resource table memory address
+ * [out] params[1].value.b:	32bit MSB resource table memory address
+ * [out] params[2].value.a:	32bit LSB resource table memory size
+ * [out] params[2].value.b:	32bit MSB resource table memory size
+ */
+#define TA_RPROC_FW_CMD_GET_RSC_TABLE	4
+
+/*
+ * Get remote processor firmware core dump. If found, return either
+ * TEE_SUCCESS on successful completion or TEE_ERROR_SHORT_BUFFER if output
+ * buffer is too short to store the core dump.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out] params[1].memref:	Core dump, if found
+ */
+#define TA_RPROC_FW_CMD_GET_COREDUMP	5
+
+static void prepare_args(struct rproc_optee *trproc, int cmd,
+			 struct tee_invoke_arg *arg, uint num_param,
+			 struct tee_param *param)
+{
+	memset(arg, 0, sizeof(*arg));
+	memset(param, 0, num_param * sizeof(*param));
+
+	arg->func = cmd;
+	arg->session = trproc->session;
+
+	param[0] = (struct tee_param) {
+		.attr = TEE_PARAM_ATTR_TYPE_VALUE_INPUT,
+		.u.value.a = trproc->proc_id,
+	};
+}
+
+int rproc_optee_load(struct rproc_optee *trproc, ulong addr, ulong size)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param[2];
+	struct tee_shm *fw_shm;
+	int rc;
+
+	rc = tee_shm_register(trproc->tee, (void *)addr, size, 0, &fw_shm);
+	if (rc)
+		return rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_LOAD_FW, &arg, 2, param);
+
+	/* Provide the address and size of the firmware image */
+	param[1] = (struct tee_param){
+		.attr = TEE_PARAM_ATTR_TYPE_MEMREF_INPUT,
+		.u.memref = {
+			.shm = fw_shm,
+			.size = size,
+			.shm_offs = 0,
+		},
+	};
+
+	rc = tee_invoke_func(trproc->tee, &arg, 2, param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_LOAD_FW invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	tee_shm_free(fw_shm);
+
+	return rc;
+}
+
+int rproc_optee_get_rsc_table(struct rproc_optee *trproc, phys_addr_t *rsc_addr,
+			      phys_size_t *rsc_size)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param[3];
+	int rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_GET_RSC_TABLE, &arg, 3, param);
+
+	param[1].attr = TEE_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+	param[2].attr = TEE_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+
+	rc = tee_invoke_func(trproc->tee, &arg, 3, param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_GET_RSC_TABLE invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+
+		return rc;
+	}
+
+	*rsc_size = (phys_size_t)
+			(param[2].u.value.b << 32 | param[2].u.value.a);
+	*rsc_addr = (phys_addr_t)
+			(param[1].u.value.b << 32 | param[1].u.value.a);
+
+	return 0;
+}
+
+int rproc_optee_start(struct rproc_optee *trproc)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param;
+	int rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_START_FW, &arg, 1, &param);
+
+	rc =  tee_invoke_func(trproc->tee, &arg, 1, &param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_START_FW invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	return rc;
+}
+
+int rproc_optee_stop(struct rproc_optee *trproc)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param;
+	int rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_STOP_FW, &arg, 1, &param);
+
+	rc =  tee_invoke_func(trproc->tee, &arg, 1, &param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_STOP_FW invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	return rc;
+}
+
+int rproc_optee_open(struct rproc_optee *trproc)
+{
+	struct udevice *tee = NULL;
+	const struct tee_optee_ta_uuid uuid = TA_REMOTEPROC_UUID;
+	struct tee_open_session_arg arg = { };
+	struct tee_param param;
+	int rc;
+
+	if (!trproc)
+		return -EINVAL;
+
+	tee = tee_find_device(tee, NULL, NULL, NULL);
+	if (!tee)
+		return -ENODEV;
+
+	tee_optee_ta_uuid_to_octets(arg.uuid, &uuid);
+
+	param.attr = TEE_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param.u.value.a = trproc->proc_id;
+
+	rc = tee_open_session(tee, &arg, 1, &param);
+	if (rc < 0 || arg.ret != 0) {
+		if (!rc)
+			rc = -EIO;
+		return rc;
+	}
+
+	trproc->tee = tee;
+	trproc->session = arg.session;
+
+	return 0;
+}
+
+int rproc_optee_close(struct rproc_optee *trproc)
+{
+	int rc;
+
+	if (!trproc->tee)
+		return -ENODEV;
+
+	rc = tee_close_session(trproc->tee, trproc->session);
+	if (rc)
+		return rc;
+
+	trproc->tee = NULL;
+	trproc->session = 0;
+
+	return 0;
+}
diff --git a/drivers/remoteproc/stm32_copro.c b/drivers/remoteproc/stm32_copro.c
index 5271f83bc0..e55537895e 100644
--- a/drivers/remoteproc/stm32_copro.c
+++ b/drivers/remoteproc/stm32_copro.c
@@ -9,12 +9,25 @@
 #include <errno.h>
 #include <fdtdec.h>
 #include <log.h>
+#include <nvmem.h>
 #include <remoteproc.h>
+#include <rproc_optee.h>
 #include <reset.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
 #include <linux/err.h>
 
+#define STM32MP15_M4_FW_ID	0
+#define STM32MP25_M33_FW_ID	1
+
+/* TAMP_COPRO_STATE register values */
+#define TAMP_COPRO_STATE_OFF		0
+#define TAMP_COPRO_STATE_INIT		1
+#define TAMP_COPRO_STATE_CRUN		2
+#define TAMP_COPRO_STATE_CSTOP		3
+#define TAMP_COPRO_STATE_STANDBY	4
+#define TAMP_COPRO_STATE_CRASH		5
+
 /**
  * struct stm32_copro_privdata - power processor private data
  * @reset_ctl:		reset controller handle
@@ -25,30 +38,57 @@ struct stm32_copro_privdata {
 	struct reset_ctl reset_ctl;
 	struct reset_ctl hold_boot;
 	ulong rsc_table_addr;
+	ulong rsc_table_size;
+	struct nvmem_cell rsc_t_addr_cell;
+	struct nvmem_cell rsc_t_size_cell;
+	struct rproc_optee trproc;
 };
 
+static int stm32_copro_stop(struct udevice *dev);
+
 /**
  * stm32_copro_probe() - Basic probe
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_probe(struct udevice *dev)
 {
-	struct stm32_copro_privdata *priv;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
 	int ret;
 
-	priv = dev_get_priv(dev);
+	trproc->proc_id = (u32)dev_get_driver_data(dev);
 
-	ret = reset_get_by_name(dev, "mcu_rst", &priv->reset_ctl);
-	if (ret) {
-		dev_err(dev, "failed to get reset (%d)\n", ret);
-		return ret;
+	if (trproc->proc_id == STM32MP25_M33_FW_ID) {
+		ret = nvmem_cell_get_by_name(dev, "rsc-tbl-addr", &priv->rsc_t_addr_cell);
+		if (ret && ret != -ENODATA)
+			return ret;
+		ret = nvmem_cell_get_by_name(dev, "rsc-tbl-size", &priv->rsc_t_size_cell);
+		if (ret && ret != -ENODATA)
+			return ret;
 	}
 
-	ret = reset_get_by_name(dev, "hold_boot", &priv->hold_boot);
-	if (ret) {
-		dev_err(dev, "failed to get hold boot (%d)\n", ret);
-		return ret;
+	if (device_is_compatible(dev, "st,stm32mp1-m4-tee") ||
+	    device_is_compatible(dev, "st,stm32mp2-m33-tee")) {
+		ret = rproc_optee_open(trproc);
+		if (ret) {
+			dev_err(dev, "failed to delegate to OP-TEE\n");
+			return ret;
+		}
+
+		dev_info(dev, "delegate the firmware management to OP-TEE\n");
+	} else {
+		ret = reset_get_by_name(dev, "mcu_rst", &priv->reset_ctl);
+		if (ret) {
+			dev_err(dev, "failed to get reset (%d)\n", ret);
+			return ret;
+		}
+
+		ret = reset_get_by_name(dev, "hold_boot", &priv->hold_boot);
+		if (ret) {
+			dev_err(dev, "failed to get hold boot (%d)\n", ret);
+			return ret;
+		}
 	}
 
 	dev_dbg(dev, "probed\n");
@@ -57,47 +97,84 @@ static int stm32_copro_probe(struct udevice *dev)
 }
 
 /**
- * stm32_copro_device_to_virt() - Convert device address to virtual address
- * @dev:	corresponding STM32 remote processor device
+ * stm32_copro_optee_remove() - Close the rproc trusted application session
+ * @dev:	 remote processor device
+ * @return 0 if all went ok, else corresponding -ve error
+ */
+static int stm32_copro_remove(struct udevice *dev)
+{
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+
+	if (trproc->tee)
+		return rproc_optee_close(trproc);
+
+	return 0;
+}
+
+/**
+ * stm32_copro_device_to_phys() - Convert device address to physical address
+ * @dev:	remote processor device
  * @da:		device address
  * @size:	Size of the memory region @da is pointing to
- * Return: converted virtual address
+ * Return: converted physical address
  */
-static void *stm32_copro_device_to_virt(struct udevice *dev, ulong da,
-					ulong size)
+static phys_addr_t stm32_copro_device_to_phys(struct udevice *dev, ulong da,
+					      ulong size)
 {
 	fdt32_t in_addr = cpu_to_be32(da), end_addr;
-	u64 paddr;
+	phys_addr_t paddr;
 
 	paddr = dev_translate_dma_address(dev, &in_addr);
 	if (paddr == OF_BAD_ADDR) {
 		dev_err(dev, "Unable to convert address %ld\n", da);
-		return NULL;
+		return 0;
 	}
-
 	end_addr = cpu_to_be32(da + size - 1);
 	if (dev_translate_dma_address(dev, &end_addr) == OF_BAD_ADDR) {
 		dev_err(dev, "Unable to convert address %ld\n", da + size - 1);
-		return NULL;
+		return 0;
 	}
 
+	return paddr;
+}
+/**
+ * stm32_copro_device_to_virt() - Convert device address to virtual address
+ * @dev:	remote processor device
+ * @da:		device address
+ * @size:	Size of the memory region @da is pointing to
+ * Return: converted virtual address
+ */
+static void *stm32_copro_device_to_virt(struct udevice *dev, ulong da,
+					ulong size)
+{
+	phys_addr_t paddr;
+
+	paddr = stm32_copro_device_to_phys(dev, da, size);
+	if (!paddr)
+		return NULL;
+
 	return phys_to_virt(paddr);
 }
 
 /**
  * stm32_copro_load() - Loadup the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * @addr:	Address in memory where image is stored
  * @size:	Size in bytes of the image
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_load(struct udevice *dev, ulong addr, ulong size)
 {
-	struct stm32_copro_privdata *priv;
-	ulong rsc_table_size;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+	ulong rsc_table_size = 0;
+	ulong rsc_table_addr = 0;
+	phys_addr_t paddr;
 	int ret;
 
-	priv = dev_get_priv(dev);
+	if (trproc->tee)
+		return rproc_optee_load(trproc, addr, size);
 
 	ret = reset_assert(&priv->hold_boot);
 	if (ret) {
@@ -111,81 +188,156 @@ static int stm32_copro_load(struct udevice *dev, ulong addr, ulong size)
 		return ret;
 	}
 
-	if (rproc_elf32_load_rsc_table(dev, addr, size, &priv->rsc_table_addr,
-				       &rsc_table_size)) {
-		priv->rsc_table_addr = 0;
-		dev_warn(dev, "No valid resource table for this firmware\n");
+	priv->rsc_table_addr = 0;
+	ret = rproc_elf32_load_rsc_table(dev, addr, size, &rsc_table_addr,
+					 &rsc_table_size);
+	if (ret) {
+		if (ret != -ENODATA)
+			return ret;
+		dev_dbg(dev, "No resource table for this firmware\n");
 	}
 
+	paddr = stm32_copro_device_to_phys(dev, rsc_table_addr, rsc_table_size);
+
+	priv->rsc_table_addr = (ulong)paddr;
+	priv->rsc_table_size = rsc_table_size;
+
 	return rproc_elf32_load_image(dev, addr, size);
 }
 
 /**
  * stm32_copro_start() - Start the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_start(struct udevice *dev)
 {
-	struct stm32_copro_privdata *priv;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+	unsigned int proc_id = (u32)dev_get_driver_data(dev);
+	phys_size_t rsc_size;
+	phys_addr_t rsc_addr;
 	int ret;
 
-	priv = dev_get_priv(dev);
+	if (trproc->tee) {
+		ret = rproc_optee_get_rsc_table(trproc, &rsc_addr, &rsc_size);
+		if (ret)
+			return ret;
+
+		priv->rsc_table_size = (ulong)rsc_size;
+		priv->rsc_table_addr = (ulong)rsc_addr;
+
+		ret = rproc_optee_start(trproc);
+		if (ret)
+			return ret;
+
+	} else {
+		ret = reset_deassert(&priv->hold_boot);
+		if (ret) {
+			dev_err(dev, "Unable to deassert hold boot (ret=%d)\n",
+				ret);
+			return ret;
+		}
+
+		/*
+		 * Once copro running, reset hold boot flag to avoid copro
+		 * rebooting autonomously (error should never occur)
+		 */
+		ret = reset_assert(&priv->hold_boot);
+		if (ret)
+			dev_err(dev, "Unable to assert hold boot (ret=%d)\n",
+				ret);
+	}
 
-	ret = reset_deassert(&priv->hold_boot);
-	if (ret) {
-		dev_err(dev, "Unable to deassert hold boot (ret=%d)\n", ret);
-		return ret;
+	if (proc_id == STM32MP15_M4_FW_ID) {
+#ifdef CONFIG_STM32MP15X
+		/* Indicates that copro is running */
+		writel(TAMP_COPRO_STATE_CRUN, TAMP_COPRO_STATE);
+
+		/* Store rsc_address in bkp register */
+		writel(priv->rsc_table_addr, TAMP_COPRO_RSC_TBL_ADDRESS);
+#else
+		return -EOPNOTSUPP;
+#endif
+	} else if (proc_id == STM32MP25_M33_FW_ID) {
+		/* Store the resource table address and size in 32-bit registers*/
+		ret = nvmem_cell_write(&priv->rsc_t_addr_cell, &priv->rsc_table_addr, sizeof(u32));
+		if (ret)
+			goto error;
+
+		ret = nvmem_cell_write(&priv->rsc_t_size_cell, &priv->rsc_table_size, sizeof(u32));
+		if (ret)
+			goto error;
 	}
 
-	/*
-	 * Once copro running, reset hold boot flag to avoid copro
-	 * rebooting autonomously (error should never occur)
-	 */
-	ret = reset_assert(&priv->hold_boot);
-	if (ret)
-		dev_err(dev, "Unable to assert hold boot (ret=%d)\n", ret);
+	return 0;
 
-	/* indicates that copro is running */
-	writel(TAMP_COPRO_STATE_CRUN, TAMP_COPRO_STATE);
-	/* Store rsc_address in bkp register */
-	writel(priv->rsc_table_addr, TAMP_COPRO_RSC_TBL_ADDRESS);
+error:
+	stm32_copro_stop(dev);
 
-	return 0;
+	return ret;
 }
 
 /**
  * stm32_copro_reset() - Reset the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_reset(struct udevice *dev)
 {
-	struct stm32_copro_privdata *priv;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+	unsigned int proc_id = (u32)dev_get_driver_data(dev);
 	int ret;
 
-	priv = dev_get_priv(dev);
 
-	ret = reset_assert(&priv->hold_boot);
-	if (ret) {
-		dev_err(dev, "Unable to assert hold boot (ret=%d)\n", ret);
-		return ret;
+	if (trproc->tee) {
+		ret = rproc_optee_stop(trproc);
+		if (ret)
+			return ret;
+	} else {
+		ret = reset_assert(&priv->hold_boot);
+		if (ret) {
+			dev_err(dev, "Unable to assert hold boot (ret=%d)\n",
+				ret);
+			return ret;
+		}
+
+		ret = reset_assert(&priv->reset_ctl);
+		if (ret) {
+			dev_err(dev, "Unable to assert reset line (ret=%d)\n",
+				ret);
+			return ret;
+		}
 	}
 
-	ret = reset_assert(&priv->reset_ctl);
-	if (ret) {
-		dev_err(dev, "Unable to assert reset line (ret=%d)\n", ret);
-		return ret;
+	/* Clean-up backup registers */
+	priv->rsc_table_addr = 0;
+	priv->rsc_table_size = 0;
+
+	if (proc_id == STM32MP15_M4_FW_ID) {
+#ifdef CONFIG_STM32MP15X
+		writel(TAMP_COPRO_STATE_OFF, TAMP_COPRO_STATE);
+		writel(priv->rsc_table_addr, TAMP_COPRO_RSC_TBL_ADDRESS);
+#else
+		return -EOPNOTSUPP;
+#endif
+	} else if (proc_id == STM32MP25_M33_FW_ID) {
+		ret = nvmem_cell_write(&priv->rsc_t_addr_cell, &priv->rsc_table_addr, sizeof(u32));
+		if (ret)
+			return ret;
+
+		ret = nvmem_cell_write(&priv->rsc_t_size_cell, &priv->rsc_table_size, sizeof(u32));
+		if (ret)
+			return ret;
 	}
 
-	writel(TAMP_COPRO_STATE_OFF, TAMP_COPRO_STATE);
-
 	return 0;
 }
 
 /**
  * stm32_copro_stop() - Stop the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_stop(struct udevice *dev)
@@ -195,12 +347,18 @@ static int stm32_copro_stop(struct udevice *dev)
 
 /**
  * stm32_copro_is_running() - Is the STM32 remote processor running
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if the remote processor is running, 1 otherwise
  */
 static int stm32_copro_is_running(struct udevice *dev)
 {
-	return (readl(TAMP_COPRO_STATE) == TAMP_COPRO_STATE_OFF);
+#ifdef CONFIG_STM32MP15X
+	unsigned int proc_id = (u32)dev_get_driver_data(dev);
+
+	if (proc_id == STM32MP15_M4_FW_ID)
+		return (readl(TAMP_COPRO_STATE) == TAMP_COPRO_STATE_OFF);
+#endif
+	return -EOPNOTSUPP;
 }
 
 static const struct dm_rproc_ops stm32_copro_ops = {
@@ -213,15 +371,19 @@ static const struct dm_rproc_ops stm32_copro_ops = {
 };
 
 static const struct udevice_id stm32_copro_ids[] = {
-	{.compatible = "st,stm32mp1-m4"},
+	{ .compatible = "st,stm32mp1-m4", .data = STM32MP15_M4_FW_ID },
+	{ .compatible = "st,stm32mp1-m4-tee", .data = STM32MP15_M4_FW_ID },
+	{ .compatible = "st,stm32mp2-m33-tee", .data = STM32MP25_M33_FW_ID },
 	{}
 };
 
 U_BOOT_DRIVER(stm32_copro) = {
-	.name = "stm32_m4_proc",
+	.name = "stm32_copro",
 	.of_match = stm32_copro_ids,
 	.id = UCLASS_REMOTEPROC,
 	.ops = &stm32_copro_ops,
 	.probe = stm32_copro_probe,
-	.priv_auto	= sizeof(struct stm32_copro_privdata),
+	.remove = stm32_copro_remove,
+	.priv_auto = sizeof(struct stm32_copro_privdata),
+	.flags = DM_FLAG_OS_PREPARE,
 };
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index 73bbd30692..35f36fed9b 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -28,13 +28,6 @@ config STI_RESET
 	  Say Y if you want to control reset signals provided by system config
 	  block.
 
-config STM32_RESET
-	bool "Enable the STM32 reset"
-	depends on ARCH_STM32 || ARCH_STM32MP
-	help
-	  Support for reset controllers on STMicroelectronics STM32 family SoCs.
-	  This reset driver is compatible with STM32 F4/F7 and H7 SoCs.
-
 config TEGRA_CAR_RESET
 	bool "Enable Tegra CAR-based reset driver"
 	depends on TEGRA_CAR
@@ -235,4 +228,7 @@ config RESET_AT91
 	  This enables the Reset Controller driver support for Microchip/Atmel
 	  SoCs. Mainly used to expose assert/deassert methods to other drivers
 	  that require it.
+
+source "drivers/reset/stm32/Kconfig"
+
 endmenu
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index e2239a250a..b18df9a868 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -7,7 +7,6 @@ obj-$(CONFIG_DM_RESET) += reset-uclass.o
 obj-$(CONFIG_SANDBOX_MBOX) += sandbox-reset.o
 obj-$(CONFIG_SANDBOX_MBOX) += sandbox-reset-test.o
 obj-$(CONFIG_STI_RESET) += sti-reset.o
-obj-$(CONFIG_STM32_RESET) += stm32-reset.o
 obj-$(CONFIG_TEGRA_CAR_RESET) += tegra-car-reset.o
 obj-$(CONFIG_TEGRA186_RESET) += tegra186-reset.o
 obj-$(CONFIG_RESET_TI_SCI) += reset-ti-sci.o
@@ -33,3 +32,6 @@ obj-$(CONFIG_RESET_ZYNQMP) += reset-zynqmp.o
 obj-$(CONFIG_RESET_DRA7) += reset-dra7.o
 obj-$(CONFIG_RESET_AT91) += reset-at91.o
 obj-$(CONFIG_$(SPL_TPL_)RESET_JH7110) += reset-jh7110.o
+
+obj-$(CONFIG_ARCH_STM32) += stm32/
+obj-$(CONFIG_ARCH_STM32MP) += stm32/
diff --git a/drivers/reset/reset-scmi.c b/drivers/reset/reset-scmi.c
index 122556162e..a2975085c4 100644
--- a/drivers/reset/reset-scmi.c
+++ b/drivers/reset/reset-scmi.c
@@ -93,5 +93,5 @@ U_BOOT_DRIVER(scmi_reset_domain) = {
 	.id = UCLASS_RESET,
 	.ops = &scmi_reset_domain_ops,
 	.probe = scmi_reset_probe,
-	.priv_auto = sizeof(struct scmi_reset_priv *),
+	.priv_auto = sizeof(struct scmi_reset_priv),
 };
diff --git a/drivers/reset/reset-uclass.c b/drivers/reset/reset-uclass.c
index b972faf013..3a7561da0a 100644
--- a/drivers/reset/reset-uclass.c
+++ b/drivers/reset/reset-uclass.c
@@ -246,10 +246,6 @@ int reset_release_all(struct reset_ctl *reset_ctl, int count)
 		if (!reset_ctl[i].dev)
 			continue;
 
-		ret = reset_assert(&reset_ctl[i]);
-		if (ret)
-			return ret;
-
 		ret = reset_free(&reset_ctl[i]);
 		if (ret)
 			return ret;
diff --git a/drivers/reset/stm32-reset.c b/drivers/reset/stm32-reset.c
deleted file mode 100644
index 0bbde29810..0000000000
--- a/drivers/reset/stm32-reset.c
+++ /dev/null
@@ -1,98 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
- * Author(s): Patrice Chotard, <patrice.chotard@foss.st.com> for STMicroelectronics.
- */
-
-#define LOG_CATEGORY UCLASS_RESET
-
-#include <common.h>
-#include <dm.h>
-#include <errno.h>
-#include <log.h>
-#include <malloc.h>
-#include <reset-uclass.h>
-#include <stm32_rcc.h>
-#include <asm/io.h>
-#include <dm/device_compat.h>
-#include <linux/bitops.h>
-
-/* offset of register without set/clear management */
-#define RCC_MP_GCR_OFFSET 0x10C
-
-/* reset clear offset for STM32MP RCC */
-#define RCC_CL 0x4
-
-struct stm32_reset_priv {
-	fdt_addr_t base;
-};
-
-static int stm32_reset_assert(struct reset_ctl *reset_ctl)
-{
-	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
-	int bank = (reset_ctl->id / (sizeof(u32) * BITS_PER_BYTE)) * 4;
-	int offset = reset_ctl->id % (sizeof(u32) * BITS_PER_BYTE);
-
-	dev_dbg(reset_ctl->dev, "reset id = %ld bank = %d offset = %d)\n",
-		reset_ctl->id, bank, offset);
-
-	if (dev_get_driver_data(reset_ctl->dev) == STM32MP1)
-		if (bank != RCC_MP_GCR_OFFSET)
-			/* reset assert is done in rcc set register */
-			writel(BIT(offset), priv->base + bank);
-		else
-			clrbits_le32(priv->base + bank, BIT(offset));
-	else
-		setbits_le32(priv->base + bank, BIT(offset));
-
-	return 0;
-}
-
-static int stm32_reset_deassert(struct reset_ctl *reset_ctl)
-{
-	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
-	int bank = (reset_ctl->id / (sizeof(u32) * BITS_PER_BYTE)) * 4;
-	int offset = reset_ctl->id % (sizeof(u32) * BITS_PER_BYTE);
-
-	dev_dbg(reset_ctl->dev, "reset id = %ld bank = %d offset = %d)\n",
-		reset_ctl->id, bank, offset);
-
-	if (dev_get_driver_data(reset_ctl->dev) == STM32MP1)
-		if (bank != RCC_MP_GCR_OFFSET)
-			/* reset deassert is done in rcc clr register */
-			writel(BIT(offset), priv->base + bank + RCC_CL);
-		else
-			setbits_le32(priv->base + bank, BIT(offset));
-	else
-		clrbits_le32(priv->base + bank, BIT(offset));
-
-	return 0;
-}
-
-static const struct reset_ops stm32_reset_ops = {
-	.rst_assert	= stm32_reset_assert,
-	.rst_deassert	= stm32_reset_deassert,
-};
-
-static int stm32_reset_probe(struct udevice *dev)
-{
-	struct stm32_reset_priv *priv = dev_get_priv(dev);
-
-	priv->base = dev_read_addr(dev);
-	if (priv->base == FDT_ADDR_T_NONE) {
-		/* for MFD, get address of parent */
-		priv->base = dev_read_addr(dev->parent);
-		if (priv->base == FDT_ADDR_T_NONE)
-			return -EINVAL;
-	}
-
-	return 0;
-}
-
-U_BOOT_DRIVER(stm32_rcc_reset) = {
-	.name			= "stm32_rcc_reset",
-	.id			= UCLASS_RESET,
-	.probe			= stm32_reset_probe,
-	.priv_auto	= sizeof(struct stm32_reset_priv),
-	.ops			= &stm32_reset_ops,
-};
diff --git a/drivers/reset/stm32/Kconfig b/drivers/reset/stm32/Kconfig
new file mode 100644
index 0000000000..797fd8f892
--- /dev/null
+++ b/drivers/reset/stm32/Kconfig
@@ -0,0 +1,30 @@
+config RESET_STM32
+	bool "Enable the STM32 reset"
+	depends on ARCH_STM32
+	default y
+	help
+	  Support for reset controllers on STMicroelectronics STM32 family SoCs.
+	  This reset driver is compatible with STM32 F4/F7 and H7 SoCs.
+
+config RESET_STM32MP1
+	bool "Enable the STM32MP1 reset"
+	depends on STM32MP13X || STM32MP15X
+	default y
+	help
+	  Support for reset controllers on STMicroelectronics STM32MP1 family SoCs.
+	  This reset driver is compatible with STM32MP13 and STM32MP15 SoCs.
+
+config RESET_STM32MP21
+	bool "Enable the STM32MP21 reset"
+	default y if STM32MP21X
+	help
+	  Support for reset controllers on STMicroelectronics STM32MP21 family SoCs.
+	  This reset driver is compatible with STM32MP21 SoCs.
+
+config RESET_STM32MP25
+	bool "Enable the STM32MP25 reset"
+	depends on STM32MP23X || STM32MP25X
+	default y
+	help
+	  Support for reset controllers on STMicroelectronics STM32MP2 family SoCs.
+	  This reset driver is compatible with STM32MP23 and STM32MP25 SoCs.
diff --git a/drivers/reset/stm32/Makefile b/drivers/reset/stm32/Makefile
new file mode 100644
index 0000000000..ac4d3c6fc8
--- /dev/null
+++ b/drivers/reset/stm32/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+
+obj-y += stm32-reset-core.o
+
+obj-$(CONFIG_RESET_STM32) += stm32-reset.o
+obj-$(CONFIG_RESET_STM32MP1) += stm32-reset-mp1.o
+obj-$(CONFIG_RESET_STM32MP21) += stm32-reset-mp21.o
+obj-$(CONFIG_RESET_STM32MP25) += stm32-reset-mp25.o
diff --git a/drivers/reset/stm32/stm32-reset-core.c b/drivers/reset/stm32/stm32-reset-core.c
new file mode 100644
index 0000000000..7dd92e07e1
--- /dev/null
+++ b/drivers/reset/stm32/stm32-reset-core.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ * Author(s): Gabriel Fernandez, <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dm.h>
+#include <reset-uclass.h>
+#include <stm32-reset-core.h>
+#include <stm32_rcc.h>
+#include <dm/device_compat.h>
+#include <linux/iopoll.h>
+
+static int stm32_reset_update(struct reset_ctl *reset_ctl, bool status)
+{
+	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
+	const struct stm32_reset_data *data = priv->data;
+	const struct stm32_reset_cfg *ptr_line;
+	fdt_addr_t addr;
+
+	assert(priv->data->get_reset_line);
+
+	ptr_line = priv->data->get_reset_line(reset_ctl);
+	if (!ptr_line)
+		return -EPERM;
+
+	addr = priv->base + ptr_line->offset;
+
+	dev_dbg(reset_ctl->dev, "reset id=%ld offset=0x%x bit=%d status=%d\n",
+		reset_ctl->id, ptr_line->offset, ptr_line->bit_idx, status);
+
+	status = ptr_line->inverted ^ status;
+
+	if (ptr_line->set_clr) {
+		if (!status)
+			addr += data->clear_offset;
+
+		writel(BIT(ptr_line->bit_idx), addr);
+
+	} else {
+		if (status)
+			setbits_le32(addr, BIT(ptr_line->bit_idx));
+		else
+			clrbits_le32(addr, BIT(ptr_line->bit_idx));
+	}
+
+	/* Check deassert */
+	if (!status) {
+		u32 reg;
+
+		return readl_poll_timeout(addr, reg,
+					  !(reg & BIT(ptr_line->bit_idx)),
+					  data->reset_us);
+	}
+
+	return 0;
+}
+
+static int stm32_reset_assert(struct reset_ctl *reset_ctl)
+{
+	return stm32_reset_update(reset_ctl, true);
+}
+
+static int stm32_reset_deassert(struct reset_ctl *reset_ctl)
+{
+	return stm32_reset_update(reset_ctl, false);
+}
+
+const struct reset_ops stm32_reset_ops = {
+	.rst_assert	= stm32_reset_assert,
+	.rst_deassert	= stm32_reset_deassert,
+};
+
+int stm32_reset_core_probe(struct udevice *dev,
+			   const struct stm32_reset_data *data)
+{
+	struct stm32_reset_priv *priv = dev_get_priv(dev);
+
+	priv->base = dev_read_addr(dev);
+	if (priv->base == FDT_ADDR_T_NONE) {
+		/* for MFD, get address of parent */
+		priv->base = dev_read_addr(dev->parent);
+		if (priv->base == FDT_ADDR_T_NONE)
+			return -EINVAL;
+	}
+
+	priv->data = data;
+
+	assert(priv->data);
+
+	return 0;
+}
diff --git a/drivers/reset/stm32/stm32-reset-mp1.c b/drivers/reset/stm32/stm32-reset-mp1.c
new file mode 100644
index 0000000000..6863f6e64b
--- /dev/null
+++ b/drivers/reset/stm32/stm32-reset-mp1.c
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard, <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dm.h>
+#include <stm32-reset-core.h>
+
+/* Reset clear offset for STM32MP RCC */
+#define RCC_CLR_OFFSET			0x4
+
+/* Offset of register without set/clear management */
+#define RCC_MP_GCR_OFFSET		0x10C
+
+/* Timeout for deassert */
+#define STM32_DEASSERT_TIMEOUT_US	10000
+
+static const struct stm32_reset_cfg *stm32_get_reset_line(struct reset_ctl *reset_ctl)
+{
+	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
+	struct stm32_reset_cfg *ptr_line = &priv->reset_line;
+	int bank = (reset_ctl->id / (sizeof(u32) * BITS_PER_BYTE)) * 4;
+	int offset = reset_ctl->id % (sizeof(u32) * BITS_PER_BYTE);
+
+	ptr_line->offset = bank;
+	ptr_line->bit_idx = offset;
+	ptr_line->set_clr = true;
+
+	if (ptr_line->offset == RCC_MP_GCR_OFFSET) {
+		ptr_line->set_clr = false;
+		ptr_line->inverted = true;
+	}
+
+	return ptr_line;
+}
+
+static const struct stm32_reset_data stm32mp1_reset_data = {
+	.get_reset_line	= stm32_get_reset_line,
+	.clear_offset	= RCC_CLR_OFFSET,
+	.reset_us	= STM32_DEASSERT_TIMEOUT_US,
+};
+
+static int stm32_reset_probe(struct udevice *dev)
+{
+	return stm32_reset_core_probe(dev, &stm32mp1_reset_data);
+}
+
+U_BOOT_DRIVER(stm32mp25_rcc_reset) = {
+	.name		= "stm32mp1_reset",
+	.id		= UCLASS_RESET,
+	.probe		= stm32_reset_probe,
+	.priv_auto	= sizeof(struct stm32_reset_priv),
+	.ops		= &stm32_reset_ops,
+};
diff --git a/drivers/reset/stm32/stm32-reset-mp21.c b/drivers/reset/stm32/stm32-reset-mp21.c
new file mode 100644
index 0000000000..1f2129fdce
--- /dev/null
+++ b/drivers/reset/stm32/stm32-reset-mp21.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ * Author(s): Gabriel Fernandez, <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dm.h>
+#include <stm32-reset-core.h>
+#include <stm32mp21_rcc.h>
+#include <dt-bindings/reset/st,stm32mp21-rcc.h>
+
+/* Reset clear offset for STM32MP RCC */
+#define RCC_CLR_OFFSET			0x4
+
+/* Timeout for deassert */
+#define STM32_DEASSERT_TIMEOUT_US	10000
+
+#define RESET(id, _offset, _bit_idx, _set_clr)		\
+	[id] = &(struct stm32_reset_cfg){		\
+		.offset		= (_offset),		\
+		.bit_idx	= (_bit_idx),		\
+		.set_clr	= (_set_clr),		\
+	}
+
+static const struct stm32_reset_cfg *stm32mp21_reset[STM32MP21_LAST_RESET] = {
+	RESET(TIM1_R,		RCC_TIM1CFGR,		0,	0),
+	RESET(TIM2_R,		RCC_TIM2CFGR,		0,	0),
+	RESET(TIM3_R,		RCC_TIM3CFGR,		0,	0),
+	RESET(TIM4_R,		RCC_TIM4CFGR,		0,	0),
+	RESET(TIM5_R,		RCC_TIM5CFGR,		0,	0),
+	RESET(TIM6_R,		RCC_TIM6CFGR,		0,	0),
+	RESET(TIM7_R,		RCC_TIM7CFGR,		0,	0),
+	RESET(TIM8_R,		RCC_TIM8CFGR,		0,	0),
+	RESET(TIM10_R,		RCC_TIM10CFGR,		0,	0),
+	RESET(TIM11_R,		RCC_TIM11CFGR,		0,	0),
+	RESET(TIM12_R,		RCC_TIM12CFGR,		0,	0),
+	RESET(TIM13_R,		RCC_TIM13CFGR,		0,	0),
+	RESET(TIM14_R,		RCC_TIM14CFGR,		0,	0),
+	RESET(TIM15_R,		RCC_TIM15CFGR,		0,	0),
+	RESET(TIM16_R,		RCC_TIM16CFGR,		0,	0),
+	RESET(TIM17_R,		RCC_TIM17CFGR,		0,	0),
+	RESET(LPTIM1_R,		RCC_LPTIM1CFGR,		0,	0),
+	RESET(LPTIM2_R,		RCC_LPTIM2CFGR,		0,	0),
+	RESET(LPTIM3_R,		RCC_LPTIM3CFGR,		0,	0),
+	RESET(LPTIM4_R,		RCC_LPTIM4CFGR,		0,	0),
+	RESET(LPTIM5_R,		RCC_LPTIM5CFGR,		0,	0),
+	RESET(SPI1_R,		RCC_SPI1CFGR,		0,	0),
+	RESET(SPI2_R,		RCC_SPI2CFGR,		0,	0),
+	RESET(SPI3_R,		RCC_SPI3CFGR,		0,	0),
+	RESET(SPI4_R,		RCC_SPI4CFGR,		0,	0),
+	RESET(SPI5_R,		RCC_SPI5CFGR,		0,	0),
+	RESET(SPI6_R,		RCC_SPI6CFGR,		0,	0),
+	RESET(SPDIFRX_R,	RCC_SPDIFRXCFGR,	0,	0),
+	RESET(USART1_R,		RCC_USART1CFGR,		0,	0),
+	RESET(USART2_R,		RCC_USART2CFGR,		0,	0),
+	RESET(USART3_R,		RCC_USART3CFGR,		0,	0),
+	RESET(UART4_R,		RCC_UART4CFGR,		0,	0),
+	RESET(UART5_R,		RCC_UART5CFGR,		0,	0),
+	RESET(USART6_R,		RCC_USART6CFGR,		0,	0),
+	RESET(UART7_R,		RCC_UART7CFGR,		0,	0),
+	RESET(LPUART1_R,	RCC_LPUART1CFGR,	0,	0),
+	RESET(I2C1_R,		RCC_I2C1CFGR,		0,	0),
+	RESET(I2C2_R,		RCC_I2C2CFGR,		0,	0),
+	RESET(I2C3_R,		RCC_I2C3CFGR,		0,	0),
+	RESET(SAI1_R,		RCC_SAI1CFGR,		0,	0),
+	RESET(SAI2_R,		RCC_SAI2CFGR,		0,	0),
+	RESET(SAI3_R,		RCC_SAI3CFGR,		0,	0),
+	RESET(SAI4_R,		RCC_SAI4CFGR,		0,	0),
+	RESET(MDF1_R,		RCC_MDF1CFGR,		0,	0),
+	RESET(FDCAN_R,		RCC_FDCANCFGR,		0,	0),
+	RESET(HDP_R,		RCC_HDPCFGR,		0,	0),
+	RESET(ADC1_R,		RCC_ADC1CFGR,		0,	0),
+	RESET(ADC2_R,		RCC_ADC2CFGR,		0,	0),
+	RESET(ETH1_R,		RCC_ETH1CFGR,		0,	0),
+	RESET(ETH2_R,		RCC_ETH2CFGR,		0,	0),
+	RESET(USBH_R,		RCC_USBHCFGR,		0,	0),
+	RESET(USB2PHY1_R,	RCC_USB2PHY1CFGR,	0,	0),
+	RESET(USB2PHY2_R,	RCC_USB2PHY2CFGR,	0,	0),
+	RESET(SDMMC1_R,		RCC_SDMMC1CFGR,		0,	0),
+	RESET(SDMMC1DLL_R,	RCC_SDMMC1CFGR,		16,	0),
+	RESET(SDMMC2_R,		RCC_SDMMC2CFGR,		0,	0),
+	RESET(SDMMC2DLL_R,	RCC_SDMMC2CFGR,		16,	0),
+	RESET(SDMMC3_R,		RCC_SDMMC3CFGR,		0,	0),
+	RESET(SDMMC3DLL_R,	RCC_SDMMC3CFGR,		16,	0),
+	RESET(LTDC_R,		RCC_LTDCCFGR,		0,	0),
+	RESET(CSI_R,		RCC_CSICFGR,		0,	0),
+	RESET(DCMIPP_R,		RCC_DCMIPPCFGR,		0,	0),
+	RESET(DCMIPSSI_R,	RCC_DCMIPSSICFGR,	0,	0),
+	RESET(WWDG1_R,		RCC_WWDG1CFGR,		0,	0),
+	RESET(VREF_R,		RCC_VREFCFGR,		0,	0),
+	RESET(DTS_R,		RCC_DTSCFGR,		0,	0),
+	RESET(CRC_R,		RCC_CRCCFGR,		0,	0),
+	RESET(SERC_R,		RCC_SERCCFGR,		0,	0),
+	RESET(I3C1_R,		RCC_I3C1CFGR,		0,	0),
+	RESET(I3C2_R,		RCC_I3C2CFGR,		0,	0),
+	RESET(IWDG2_KER_R,	RCC_IWDGC1CFGSETR,	18,	1),
+	RESET(IWDG4_KER_R,	RCC_IWDGC2CFGSETR,	18,	1),
+	RESET(RNG1_R,		RCC_RNG1CFGR,		0,	0),
+	RESET(RNG2_R,		RCC_RNG2CFGR,		0,	0),
+	RESET(PKA_R,		RCC_PKACFGR,		0,	0),
+	RESET(SAES_R,		RCC_SAESCFGR,		0,	0),
+	RESET(HASH1_R,		RCC_HASH1CFGR,		0,	0),
+	RESET(HASH2_R,		RCC_HASH2CFGR,		0,	0),
+	RESET(CRYP1_R,		RCC_CRYP1CFGR,		0,	0),
+	RESET(CRYP2_R,		RCC_CRYP2CFGR,		0,	0),
+	RESET(OTG_R,		RCC_OTGCFGR,		0,	0),
+};
+
+static const struct stm32_reset_cfg *stm32_get_reset_line(struct reset_ctl *reset_ctl)
+{
+	unsigned long id = reset_ctl->id;
+
+	if (id < STM32MP21_LAST_RESET)
+		return stm32mp21_reset[id];
+
+	return NULL;
+}
+
+static const struct stm32_reset_data stm32mp21_reset_data = {
+	.get_reset_line	= stm32_get_reset_line,
+	.clear_offset	= RCC_CLR_OFFSET,
+	.reset_us	= STM32_DEASSERT_TIMEOUT_US,
+};
+
+static int stm32_reset_probe(struct udevice *dev)
+{
+	return stm32_reset_core_probe(dev, &stm32mp21_reset_data);
+}
+
+U_BOOT_DRIVER(stm32mp21_rcc_reset) = {
+	.name		= "stm32mp21_reset",
+	.id		= UCLASS_RESET,
+	.probe		= stm32_reset_probe,
+	.priv_auto	= sizeof(struct stm32_reset_priv),
+	.ops		= &stm32_reset_ops,
+};
diff --git a/drivers/reset/stm32/stm32-reset-mp25.c b/drivers/reset/stm32/stm32-reset-mp25.c
new file mode 100644
index 0000000000..b56c2a8b20
--- /dev/null
+++ b/drivers/reset/stm32/stm32-reset-mp25.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ * Author(s): Gabriel Fernandez, <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dm.h>
+#include <stm32-reset-core.h>
+#include <stm32mp25_rcc.h>
+#include <dt-bindings/reset/st,stm32mp25-rcc.h>
+
+/* Reset clear offset for STM32MP RCC */
+#define RCC_CLR_OFFSET			0x4
+
+/* Timeout for deassert */
+#define STM32_DEASSERT_TIMEOUT_US	10000
+
+#define RESET(id, _offset, _bit_idx, _set_clr)		\
+	[id] = &(struct stm32_reset_cfg){		\
+		.offset		= (_offset),		\
+		.bit_idx	= (_bit_idx),		\
+		.set_clr	= (_set_clr),		\
+	}
+
+static const struct stm32_reset_cfg *stm32mp25_reset[STM32MP25_LAST_RESET] = {
+	RESET(TIM1_R,		RCC_TIM1CFGR,		0,	0),
+	RESET(TIM2_R,		RCC_TIM2CFGR,		0,	0),
+	RESET(TIM3_R,		RCC_TIM3CFGR,		0,	0),
+	RESET(TIM4_R,		RCC_TIM4CFGR,		0,	0),
+	RESET(TIM5_R,		RCC_TIM5CFGR,		0,	0),
+	RESET(TIM6_R,		RCC_TIM6CFGR,		0,	0),
+	RESET(TIM7_R,		RCC_TIM7CFGR,		0,	0),
+	RESET(TIM8_R,		RCC_TIM8CFGR,		0,	0),
+	RESET(TIM10_R,		RCC_TIM10CFGR,		0,	0),
+	RESET(TIM11_R,		RCC_TIM11CFGR,		0,	0),
+	RESET(TIM12_R,		RCC_TIM12CFGR,		0,	0),
+	RESET(TIM13_R,		RCC_TIM13CFGR,		0,	0),
+	RESET(TIM14_R,		RCC_TIM14CFGR,		0,	0),
+	RESET(TIM15_R,		RCC_TIM15CFGR,		0,	0),
+	RESET(TIM16_R,		RCC_TIM16CFGR,		0,	0),
+	RESET(TIM17_R,		RCC_TIM17CFGR,		0,	0),
+	RESET(TIM20_R,		RCC_TIM20CFGR,		0,	0),
+	RESET(LPTIM1_R,		RCC_LPTIM1CFGR,		0,	0),
+	RESET(LPTIM2_R,		RCC_LPTIM2CFGR,		0,	0),
+	RESET(LPTIM3_R,		RCC_LPTIM3CFGR,		0,	0),
+	RESET(LPTIM4_R,		RCC_LPTIM4CFGR,		0,	0),
+	RESET(LPTIM5_R,		RCC_LPTIM5CFGR,		0,	0),
+	RESET(SPI1_R,		RCC_SPI1CFGR,		0,	0),
+	RESET(SPI2_R,		RCC_SPI2CFGR,		0,	0),
+	RESET(SPI3_R,		RCC_SPI3CFGR,		0,	0),
+	RESET(SPI4_R,		RCC_SPI4CFGR,		0,	0),
+	RESET(SPI5_R,		RCC_SPI5CFGR,		0,	0),
+	RESET(SPI6_R,		RCC_SPI6CFGR,		0,	0),
+	RESET(SPI7_R,		RCC_SPI7CFGR,		0,	0),
+	RESET(SPI8_R,		RCC_SPI8CFGR,		0,	0),
+	RESET(SPDIFRX_R,	RCC_SPDIFRXCFGR,	0,	0),
+	RESET(USART1_R,		RCC_USART1CFGR,		0,	0),
+	RESET(USART2_R,		RCC_USART2CFGR,		0,	0),
+	RESET(USART3_R,		RCC_USART3CFGR,		0,	0),
+	RESET(UART4_R,		RCC_UART4CFGR,		0,	0),
+	RESET(UART5_R,		RCC_UART5CFGR,		0,	0),
+	RESET(USART6_R,		RCC_USART6CFGR,		0,	0),
+	RESET(UART7_R,		RCC_UART7CFGR,		0,	0),
+	RESET(UART8_R,		RCC_UART8CFGR,		0,	0),
+	RESET(UART9_R,		RCC_UART9CFGR,		0,	0),
+	RESET(LPUART1_R,	RCC_LPUART1CFGR,	0,	0),
+	RESET(IS2M_R,		RCC_IS2MCFGR,		0,	0),
+	RESET(I2C1_R,		RCC_I2C1CFGR,		0,	0),
+	RESET(I2C2_R,		RCC_I2C2CFGR,		0,	0),
+	RESET(I2C3_R,		RCC_I2C3CFGR,		0,	0),
+	RESET(I2C4_R,		RCC_I2C4CFGR,		0,	0),
+	RESET(I2C5_R,		RCC_I2C5CFGR,		0,	0),
+	RESET(I2C6_R,		RCC_I2C6CFGR,		0,	0),
+	RESET(I2C7_R,		RCC_I2C7CFGR,		0,	0),
+	RESET(I2C8_R,		RCC_I2C8CFGR,		0,	0),
+	RESET(SAI1_R,		RCC_SAI1CFGR,		0,	0),
+	RESET(SAI2_R,		RCC_SAI2CFGR,		0,	0),
+	RESET(SAI3_R,		RCC_SAI3CFGR,		0,	0),
+	RESET(SAI4_R,		RCC_SAI4CFGR,		0,	0),
+	RESET(MDF1_R,		RCC_MDF1CFGR,		0,	0),
+	RESET(MDF2_R,		RCC_ADF1CFGR,		0,	0),
+	RESET(FDCAN_R,		RCC_FDCANCFGR,		0,	0),
+	RESET(HDP_R,		RCC_HDPCFGR,		0,	0),
+	RESET(ADC12_R,		RCC_ADC12CFGR,		0,	0),
+	RESET(ADC3_R,		RCC_ADC3CFGR,		0,	0),
+	RESET(ETH1_R,		RCC_ETH1CFGR,		0,	0),
+	RESET(ETH2_R,		RCC_ETH2CFGR,		0,	0),
+	RESET(USB2_R,		RCC_USB2CFGR,		0,	0),
+	RESET(USB2PHY1_R,	RCC_USB2PHY1CFGR,	0,	0),
+	RESET(USB2PHY2_R,	RCC_USB2PHY2CFGR,	0,	0),
+	RESET(USB3DR_R,		RCC_USB3DRCFGR,		0,	0),
+	RESET(USB3PCIEPHY_R,	RCC_USB3PCIEPHYCFGR,	0,	0),
+	RESET(USBTC_R,		RCC_USBTCCFGR,		0,	0),
+	RESET(ETHSW_R,		RCC_ETHSWCFGR,		0,	0),
+	RESET(SDMMC1_R,		RCC_SDMMC1CFGR,		0,	0),
+	RESET(SDMMC1DLL_R,	RCC_SDMMC1CFGR,		16,	0),
+	RESET(SDMMC2_R,		RCC_SDMMC2CFGR,		0,	0),
+	RESET(SDMMC2DLL_R,	RCC_SDMMC2CFGR,		16,	0),
+	RESET(SDMMC3_R,		RCC_SDMMC3CFGR,		0,	0),
+	RESET(SDMMC3DLL_R,	RCC_SDMMC3CFGR,		16,	0),
+	RESET(GPU_R,		RCC_GPUCFGR,		0,	0),
+	RESET(LTDC_R,		RCC_LTDCCFGR,		0,	0),
+	RESET(DSI_R,		RCC_DSICFGR,		0,	0),
+	RESET(LVDS_R,		RCC_LVDSCFGR,		0,	0),
+	RESET(CSI_R,		RCC_CSICFGR,		0,	0),
+	RESET(DCMIPP_R,		RCC_DCMIPPCFGR,		0,	0),
+	RESET(CCI_R,		RCC_CCICFGR,		0,	0),
+	RESET(VDEC_R,		RCC_VDECCFGR,		0,	0),
+	RESET(VENC_R,		RCC_VENCCFGR,		0,	0),
+	RESET(WWDG1_R,		RCC_WWDG1CFGR,		0,	0),
+	RESET(WWDG2_R,		RCC_WWDG2CFGR,		0,	0),
+	RESET(VREF_R,		RCC_VREFCFGR,		0,	0),
+	RESET(DTS_R,		RCC_DTSCFGR,		0,	0),
+	RESET(CRC_R,		RCC_CRCCFGR,		0,	0),
+	RESET(SERC_R,		RCC_SERCCFGR,		0,	0),
+	RESET(OSPIIOM_R,	RCC_OSPIIOMCFGR,	0,	0),
+	RESET(I3C1_R,		RCC_I3C1CFGR,		0,	0),
+	RESET(I3C2_R,		RCC_I3C2CFGR,		0,	0),
+	RESET(I3C3_R,		RCC_I3C3CFGR,		0,	0),
+	RESET(I3C4_R,		RCC_I3C4CFGR,		0,	0),
+	RESET(IWDG2_KER_R,	RCC_IWDGC1CFGSETR,	18,	1),
+	RESET(IWDG4_KER_R,	RCC_IWDGC2CFGSETR,	18,	1),
+	RESET(RNG_R,		RCC_RNGCFGR,		0,	0),
+	RESET(PKA_R,		RCC_PKACFGR,		0,	0),
+	RESET(SAES_R,		RCC_SAESCFGR,		0,	0),
+	RESET(HASH_R,		RCC_HASHCFGR,		0,	0),
+	RESET(CRYP1_R,		RCC_CRYP1CFGR,		0,	0),
+	RESET(CRYP2_R,		RCC_CRYP2CFGR,		0,	0),
+	RESET(PCIE_R,		RCC_PCIECFGR,		0,	0),
+};
+
+static const struct stm32_reset_cfg *stm32_get_reset_line(struct reset_ctl *reset_ctl)
+{
+	unsigned long id = reset_ctl->id;
+
+	if (id < STM32MP25_LAST_RESET)
+		return stm32mp25_reset[id];
+
+	return NULL;
+}
+
+static const struct stm32_reset_data stm32mp25_reset_data = {
+	.get_reset_line	= stm32_get_reset_line,
+	.clear_offset	= RCC_CLR_OFFSET,
+	.reset_us	= STM32_DEASSERT_TIMEOUT_US,
+};
+
+static int stm32_reset_probe(struct udevice *dev)
+{
+	return stm32_reset_core_probe(dev, &stm32mp25_reset_data);
+}
+
+U_BOOT_DRIVER(stm32mp25_rcc_reset) = {
+	.name		= "stm32mp25_reset",
+	.id		= UCLASS_RESET,
+	.probe		= stm32_reset_probe,
+	.priv_auto	= sizeof(struct stm32_reset_priv),
+	.ops		= &stm32_reset_ops,
+};
diff --git a/drivers/reset/stm32/stm32-reset.c b/drivers/reset/stm32/stm32-reset.c
new file mode 100644
index 0000000000..975f67f712
--- /dev/null
+++ b/drivers/reset/stm32/stm32-reset.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard, <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dm.h>
+#include <stm32-reset-core.h>
+
+/* Timeout for deassert */
+#define STM32_DEASSERT_TIMEOUT_US	10000
+
+static const struct stm32_reset_cfg *stm32_get_reset_line(struct reset_ctl *reset_ctl)
+{
+	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
+	struct stm32_reset_cfg *ptr_line = &priv->reset_line;
+	int bank = (reset_ctl->id / (sizeof(u32) * BITS_PER_BYTE)) * 4;
+	int offset = reset_ctl->id % (sizeof(u32) * BITS_PER_BYTE);
+
+	ptr_line->offset = bank;
+	ptr_line->bit_idx = offset;
+	ptr_line->set_clr = true;
+
+	return ptr_line;
+}
+
+static const struct stm32_reset_data stm32_reset_data = {
+	.get_reset_line	= stm32_get_reset_line,
+	.reset_us	= STM32_DEASSERT_TIMEOUT_US,
+};
+
+static int stm32_reset_probe(struct udevice *dev)
+{
+	return stm32_reset_core_probe(dev, &stm32_reset_data);
+}
+
+U_BOOT_DRIVER(stm32_rcc_reset) = {
+	.name		= "stm32_rcc_reset",
+	.id		= UCLASS_RESET,
+	.probe		= stm32_reset_probe,
+	.priv_auto	= sizeof(struct stm32_reset_priv),
+	.ops		= &stm32_reset_ops,
+};
diff --git a/drivers/rng/Kconfig b/drivers/rng/Kconfig
index 5deb5db5b7..24666bff98 100644
--- a/drivers/rng/Kconfig
+++ b/drivers/rng/Kconfig
@@ -48,11 +48,11 @@ config RNG_OPTEE
 	  accessible to normal world but reserved and used by the OP-TEE
 	  to avoid the weakness of a software PRNG.
 
-config RNG_STM32MP1
-	bool "Enable random number generator for STM32MP1"
-	depends on ARCH_STM32MP
+config RNG_STM32
+	bool "Enable random number generator for STM32"
+	depends on ARCH_STM32 || ARCH_STM32MP
 	help
-	  Enable STM32MP1 rng driver.
+	  Enable STM32 rng driver.
 
 config RNG_ROCKCHIP
 	bool "Enable random number generator for rockchip crypto rng"
diff --git a/drivers/rng/Makefile b/drivers/rng/Makefile
index 78f61051ac..192f911e15 100644
--- a/drivers/rng/Makefile
+++ b/drivers/rng/Makefile
@@ -9,7 +9,7 @@ obj-$(CONFIG_RNG_SANDBOX) += sandbox_rng.o
 obj-$(CONFIG_RNG_MSM) += msm_rng.o
 obj-$(CONFIG_RNG_NPCM) += npcm_rng.o
 obj-$(CONFIG_RNG_OPTEE) += optee_rng.o
-obj-$(CONFIG_RNG_STM32MP1) += stm32mp1_rng.o
+obj-$(CONFIG_RNG_STM32) += stm32_rng.o
 obj-$(CONFIG_RNG_ROCKCHIP) += rockchip_rng.o
 obj-$(CONFIG_RNG_IPROC200) += iproc_rng200.o
 obj-$(CONFIG_RNG_SMCCC_TRNG) += smccc_trng.o
diff --git a/drivers/rng/stm32_rng.c b/drivers/rng/stm32_rng.c
new file mode 100644
index 0000000000..0a2438868f
--- /dev/null
+++ b/drivers/rng/stm32_rng.c
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2019, Linaro Limited
+ */
+
+#define LOG_CATEGORY UCLASS_RNG
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <log.h>
+#include <reset.h>
+#include <rng.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+
+#define RNG_CR			0x00
+#define RNG_CR_RNGEN		BIT(2)
+#define RNG_CR_CED		BIT(5)
+#define RNG_CR_CONFIG1		GENMASK(11, 8)
+#define RNG_CR_NISTC		BIT(12)
+#define RNG_CR_CONFIG2		GENMASK(15, 13)
+#define RNG_CR_CLKDIV_SHIFT	16
+#define RNG_CR_CLKDIV		GENMASK(19, 16)
+#define RNG_CR_CONFIG3		GENMASK(25, 20)
+#define RNG_CR_CONDRST		BIT(30)
+#define RNG_CR_ENTROPY_SRC_MASK	(RNG_CR_CONFIG1 | RNG_CR_NISTC | RNG_CR_CONFIG2 | RNG_CR_CONFIG3)
+#define RNG_CR_CONFIG_MASK	(RNG_CR_ENTROPY_SRC_MASK | RNG_CR_CED | RNG_CR_CLKDIV)
+
+#define RNG_SR		0x04
+#define RNG_SR_SEIS	BIT(6)
+#define RNG_SR_CEIS	BIT(5)
+#define RNG_SR_SECS	BIT(2)
+#define RNG_SR_DRDY	BIT(0)
+
+#define RNG_DR		0x08
+
+#define RNG_NSCR		0x0C
+#define RNG_NSCR_MASK		GENMASK(17, 0)
+
+#define RNG_HTCR	0x10
+
+#define RNG_NB_RECOVER_TRIES	3
+
+/*
+ * struct stm32_rng_data - RNG compat data
+ *
+ * @max_clock_rate:	Max RNG clock frequency, in Hertz
+ * @nb_clock:		Number of clock to handle
+ * @cr:			Entropy source configuration
+ * @nscr:		Noice sources control configuration
+ * @htcr:		Health tests configuration
+ * @has_cond_reset:	True if conditionnal reset is supported
+ *
+ */
+struct stm32_rng_data {
+	uint max_clock_rate;
+	uint nb_clock;
+	u32 cr;
+	u32 nscr;
+	u32 htcr;
+	bool has_cond_reset;
+};
+
+struct stm32_rng_plat {
+	fdt_addr_t base;
+	struct clk clk;
+	struct clk bus_clk;
+	struct reset_ctl rst;
+	const struct stm32_rng_data *data;
+	bool ced;
+};
+
+/*
+ * Extracts from the STM32 RNG specification when RNG supports CONDRST.
+ *
+ * When a noise source (or seed) error occurs, the RNG stops generating
+ * random numbers and sets to “1” both SEIS and SECS bits to indicate
+ * that a seed error occurred. (...)
+ *
+ * 1. Software reset by writing CONDRST at 1 and at 0 (see bitfield
+ * description for details). This step is needed only if SECS is set.
+ * Indeed, when SEIS is set and SECS is cleared it means RNG performed
+ * the reset automatically (auto-reset).
+ * 2. If SECS was set in step 1 (no auto-reset) wait for CONDRST
+ * to be cleared in the RNG_CR register, then confirm that SEIS is
+ * cleared in the RNG_SR register. Otherwise just clear SEIS bit in
+ * the RNG_SR register.
+ * 3. If SECS was set in step 1 (no auto-reset) wait for SECS to be
+ * cleared by RNG. The random number generation is now back to normal.
+ */
+static int stm32_rng_conceal_seed_error_cond_reset(struct stm32_rng_plat *pdata)
+{
+	u32 sr = readl_relaxed(pdata->base + RNG_SR);
+	u32 cr = readl_relaxed(pdata->base + RNG_CR);
+	int err;
+
+	if (sr & RNG_SR_SECS) {
+		/* Conceal by resetting the subsystem (step 1.) */
+		writel_relaxed(cr | RNG_CR_CONDRST, pdata->base + RNG_CR);
+		writel_relaxed(cr & ~RNG_CR_CONDRST, pdata->base + RNG_CR);
+	} else {
+		/* RNG auto-reset (step 2.) */
+		writel_relaxed(sr & ~RNG_SR_SEIS, pdata->base + RNG_SR);
+		return 0;
+	}
+
+	err = readl_relaxed_poll_timeout(pdata->base + RNG_SR, sr, !(sr & RNG_CR_CONDRST), 100000);
+	if (err) {
+		log_err("%s: timeout %x\n", __func__, sr);
+		return err;
+	}
+
+	/* Check SEIS is cleared (step 2.) */
+	if (readl_relaxed(pdata->base + RNG_SR) & RNG_SR_SEIS)
+		return -EINVAL;
+
+	err = readl_relaxed_poll_timeout(pdata->base + RNG_SR, sr, !(sr & RNG_SR_SECS), 100000);
+	if (err) {
+		log_err("%s: timeout %x\n", __func__, sr);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * Extracts from the STM32 RNG specification, when CONDRST is not supported
+ *
+ * When a noise source (or seed) error occurs, the RNG stops generating
+ * random numbers and sets to “1” both SEIS and SECS bits to indicate
+ * that a seed error occurred. (...)
+ *
+ * The following sequence shall be used to fully recover from a seed
+ * error after the RNG initialization:
+ * 1. Clear the SEIS bit by writing it to “0”.
+ * 2. Read out 12 words from the RNG_DR register, and discard each of
+ * them in order to clean the pipeline.
+ * 3. Confirm that SEIS is still cleared. Random number generation is
+ * back to normal.
+ */
+static int stm32_rng_conceal_seed_error_sw_reset(struct stm32_rng_plat *pdata)
+{
+	uint i = 0;
+	u32 sr = readl_relaxed(pdata->base + RNG_SR);
+
+	writel_relaxed(sr & ~RNG_SR_SEIS, pdata->base + RNG_SR);
+
+	for (i = 12; i != 0; i--)
+		(void)readl_relaxed(pdata->base + RNG_DR);
+
+	if (readl_relaxed(pdata->base + RNG_SR) & RNG_SR_SEIS)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int stm32_rng_conceal_seed_error(struct stm32_rng_plat *pdata)
+{
+	log_debug("Concealing RNG seed error\n");
+
+	if (pdata->data->has_cond_reset)
+		return stm32_rng_conceal_seed_error_cond_reset(pdata);
+	else
+		return stm32_rng_conceal_seed_error_sw_reset(pdata);
+};
+
+static int stm32_rng_read(struct udevice *dev, void *data, size_t len)
+{
+	int retval;
+	u32 sr, reg;
+	size_t increment;
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+	uint tries = 0;
+
+	while (len > 0) {
+		retval = readl_poll_timeout(pdata->base + RNG_SR, sr,
+					    sr, 10000);
+		if (retval) {
+			log_err("%s: Timeout RNG no data",  __func__);
+			return retval;
+		}
+
+		if (sr != RNG_SR_DRDY) {
+			if (sr & RNG_SR_SEIS) {
+				retval = stm32_rng_conceal_seed_error(pdata);
+				tries++;
+				if (retval || tries > RNG_NB_RECOVER_TRIES) {
+					log_err("%s: Couldn't recover from seed error",  __func__);
+					return -ENOTRECOVERABLE;
+				}
+
+				/* Start again */
+				continue;
+			}
+
+			if (sr & RNG_SR_CEIS) {
+				log_info("RNG clock too slow");
+				writel_relaxed(0, pdata->base + RNG_SR);
+			}
+		}
+
+		/*
+		 * Once the DRDY bit is set, the RNG_DR register can
+		 * be read up to four consecutive times.
+		 */
+		reg = readl(pdata->base + RNG_DR);
+		/* Late seed error case: DR being 0 is an error status */
+		if (!reg) {
+			retval = stm32_rng_conceal_seed_error(pdata);
+			tries++;
+
+			if (retval || tries > RNG_NB_RECOVER_TRIES) {
+				log_err("%s: Couldn't recover from seed error",  __func__);
+				return -ENOTRECOVERABLE;
+			}
+
+			/* Start again */
+			continue;
+		}
+
+		increment = min(len, sizeof(u32));
+		memcpy(data, &reg, increment);
+		data += increment;
+		len -= increment;
+
+		tries = 0;
+	}
+
+	return 0;
+}
+
+static uint stm32_rng_clock_freq_restrain(struct stm32_rng_plat *pdata)
+{
+	ulong clock_rate = 0;
+	uint clock_div = 0;
+
+	clock_rate = clk_get_rate(&pdata->clk);
+
+	/*
+	 * Get the exponent to apply on the CLKDIV field in RNG_CR register.
+	 * No need to handle the case when clock-div > 0xF as it is physically
+	 * impossible.
+	 */
+	while ((clock_rate >> clock_div) > pdata->data->max_clock_rate)
+		clock_div++;
+
+	log_debug("RNG clk rate : %lu\n", clk_get_rate(&pdata->clk) >> clock_div);
+
+	return clock_div;
+}
+
+static int stm32_rng_init(struct stm32_rng_plat *pdata)
+{
+	int err;
+	u32 cr, sr;
+
+	err = clk_enable(&pdata->clk);
+	if (err)
+		return err;
+
+	if (pdata->data->nb_clock > 1) {
+		err = clk_enable(&pdata->bus_clk);
+		if (err) {
+			clk_disable(&pdata->clk);
+			return err;
+		}
+	}
+
+	cr = readl(pdata->base + RNG_CR);
+
+	/*
+	 * Keep default RNG configuration if none was specified, that is when conf.cr is set to 0.
+	 */
+	if (pdata->data->has_cond_reset && pdata->data->cr) {
+		uint clock_div = stm32_rng_clock_freq_restrain(pdata);
+
+		cr &= ~RNG_CR_CONFIG_MASK;
+		cr |= RNG_CR_CONDRST | (pdata->data->cr & RNG_CR_ENTROPY_SRC_MASK) |
+		      (clock_div << RNG_CR_CLKDIV_SHIFT);
+		if (pdata->ced)
+			cr &= ~RNG_CR_CED;
+		else
+			cr |= RNG_CR_CED;
+		writel(cr, pdata->base + RNG_CR);
+
+		/* Health tests and noise control registers */
+		writel_relaxed(pdata->data->htcr, pdata->base + RNG_HTCR);
+		writel_relaxed(pdata->data->nscr & RNG_NSCR_MASK, pdata->base + RNG_NSCR);
+
+		cr &= ~RNG_CR_CONDRST;
+		cr |= RNG_CR_RNGEN;
+		writel(cr, pdata->base + RNG_CR);
+		err = readl_poll_timeout(pdata->base + RNG_CR, cr,
+					 (!(cr & RNG_CR_CONDRST)), 10000);
+		if (err) {
+			log_err("%s: Timeout!",  __func__);
+			return err;
+		}
+	} else {
+		if (pdata->data->has_cond_reset)
+			cr |= RNG_CR_CONDRST;
+
+		if (pdata->ced)
+			cr &= ~RNG_CR_CED;
+		else
+			cr |= RNG_CR_CED;
+
+		writel(cr, pdata->base + RNG_CR);
+
+		if (pdata->data->has_cond_reset)
+			cr &= ~RNG_CR_CONDRST;
+
+		cr |= RNG_CR_RNGEN;
+
+		writel(cr, pdata->base + RNG_CR);
+	}
+
+	/* clear error indicators */
+	writel(0, pdata->base + RNG_SR);
+
+	err = readl_poll_timeout(pdata->base + RNG_SR, sr,
+				 sr & RNG_SR_DRDY, 10000);
+	if (err)
+		log_err("%s: Timeout!",  __func__);
+
+	return err;
+}
+
+static int stm32_rng_cleanup(struct stm32_rng_plat *pdata)
+{
+	int err;
+
+	writel(0, pdata->base + RNG_CR);
+
+	if (pdata->data->nb_clock > 1) {
+		err = clk_disable(&pdata->bus_clk);
+		if (err)
+			return err;
+	}
+
+	return clk_disable(&pdata->clk);
+}
+
+static int stm32_rng_probe(struct udevice *dev)
+{
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+
+	reset_assert(&pdata->rst);
+	udelay(20);
+	reset_deassert(&pdata->rst);
+
+	return stm32_rng_init(pdata);
+}
+
+static int stm32_rng_remove(struct udevice *dev)
+{
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+
+	return stm32_rng_cleanup(pdata);
+}
+
+static int stm32_rng_of_to_plat(struct udevice *dev)
+{
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+	int err;
+
+	pdata->base = dev_read_addr(dev);
+	if (!pdata->base)
+		return -ENOMEM;
+
+	pdata->data = (struct stm32_rng_data *)dev_get_driver_data(dev);
+
+	if (pdata->data->nb_clock > 1) {
+		err = clk_get_by_name(dev, "rng_clk", &pdata->clk);
+		if (err)
+			return err;
+
+		err = clk_get_by_name(dev, "rng_hclk", &pdata->bus_clk);
+		if (err)
+			return err;
+	} else {
+		err = clk_get_by_index(dev, 0, &pdata->clk);
+		if (err)
+			return err;
+	}
+
+	err = reset_get_by_index(dev, 0, &pdata->rst);
+	if (err)
+		return err;
+
+	pdata->ced = dev_read_bool(dev, "clock-error-detect");
+
+	return 0;
+}
+
+static const struct dm_rng_ops stm32_rng_ops = {
+	.read = stm32_rng_read,
+};
+
+static const struct stm32_rng_data stm32mp25_rng_data = {
+	.has_cond_reset = true,
+	.max_clock_rate = 48000000,
+	.nb_clock = 2,
+	.htcr = 0x969D,
+	.nscr = 0x2B5BB,
+	.cr = 0xF00D00,
+};
+
+static const struct stm32_rng_data stm32mp13_rng_data = {
+	.has_cond_reset = true,
+	.max_clock_rate = 48000000,
+	.nb_clock = 1,
+	.htcr = 0x969D,
+	.nscr = 0x2B5BB,
+	.cr = 0xF00D00,
+};
+
+static const struct stm32_rng_data stm32_rng_data = {
+	.has_cond_reset = false,
+	.max_clock_rate = 48000000,
+	.nb_clock = 1,
+};
+
+static const struct udevice_id stm32_rng_match[] = {
+	{.compatible = "st,stm32mp25-rng", .data = (ulong)&stm32mp25_rng_data},
+	{.compatible = "st,stm32mp13-rng", .data = (ulong)&stm32mp13_rng_data},
+	{.compatible = "st,stm32-rng", .data = (ulong)&stm32_rng_data},
+	{},
+};
+
+U_BOOT_DRIVER(stm32_rng) = {
+	.name = "stm32-rng",
+	.id = UCLASS_RNG,
+	.of_match = stm32_rng_match,
+	.ops = &stm32_rng_ops,
+	.probe = stm32_rng_probe,
+	.remove = stm32_rng_remove,
+	.plat_auto	= sizeof(struct stm32_rng_plat),
+	.of_to_plat = stm32_rng_of_to_plat,
+};
diff --git a/drivers/rng/stm32mp1_rng.c b/drivers/rng/stm32mp1_rng.c
deleted file mode 100644
index 89da78c6c8..0000000000
--- a/drivers/rng/stm32mp1_rng.c
+++ /dev/null
@@ -1,198 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (c) 2019, Linaro Limited
- */
-
-#define LOG_CATEGORY UCLASS_RNG
-
-#include <common.h>
-#include <clk.h>
-#include <dm.h>
-#include <log.h>
-#include <reset.h>
-#include <rng.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
-
-#include <asm/io.h>
-#include <linux/iopoll.h>
-#include <linux/kernel.h>
-
-#define RNG_CR		0x00
-#define RNG_CR_RNGEN	BIT(2)
-#define RNG_CR_CED	BIT(5)
-#define RNG_CR_CONDRST	BIT(30)
-
-#define RNG_SR		0x04
-#define RNG_SR_SEIS	BIT(6)
-#define RNG_SR_CEIS	BIT(5)
-#define RNG_SR_SECS	BIT(2)
-#define RNG_SR_DRDY	BIT(0)
-
-#define RNG_DR		0x08
-
-struct stm32_rng_data {
-	bool has_cond_reset;
-};
-
-struct stm32_rng_plat {
-	fdt_addr_t base;
-	struct clk clk;
-	struct reset_ctl rst;
-	const struct stm32_rng_data *data;
-};
-
-static int stm32_rng_read(struct udevice *dev, void *data, size_t len)
-{
-	int retval, i;
-	u32 sr, count, reg;
-	size_t increment;
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-
-	while (len > 0) {
-		retval = readl_poll_timeout(pdata->base + RNG_SR, sr,
-					    sr & RNG_SR_DRDY, 10000);
-		if (retval)
-			return retval;
-
-		if (sr & (RNG_SR_SEIS | RNG_SR_SECS)) {
-			/* As per SoC TRM */
-			clrbits_le32(pdata->base + RNG_SR, RNG_SR_SEIS);
-			for (i = 0; i < 12; i++)
-				readl(pdata->base + RNG_DR);
-			if (readl(pdata->base + RNG_SR) & RNG_SR_SEIS) {
-				log_err("RNG Noise");
-				return -EIO;
-			}
-			/* start again */
-			continue;
-		}
-
-		/*
-		 * Once the DRDY bit is set, the RNG_DR register can
-		 * be read four consecutive times.
-		 */
-		count = 4;
-		while (len && count) {
-			reg = readl(pdata->base + RNG_DR);
-			memcpy(data, &reg, min(len, sizeof(u32)));
-			increment = min(len, sizeof(u32));
-			data += increment;
-			len -= increment;
-			count--;
-		}
-	}
-
-	return 0;
-}
-
-static int stm32_rng_init(struct stm32_rng_plat *pdata)
-{
-	int err;
-	u32 cr, sr;
-
-	err = clk_enable(&pdata->clk);
-	if (err)
-		return err;
-
-	cr = readl(pdata->base + RNG_CR);
-
-	/* Disable CED */
-	cr |= RNG_CR_CED;
-	if (pdata->data->has_cond_reset) {
-		cr |= RNG_CR_CONDRST;
-		writel(cr, pdata->base + RNG_CR);
-		cr &= ~RNG_CR_CONDRST;
-		writel(cr, pdata->base + RNG_CR);
-		err = readl_poll_timeout(pdata->base + RNG_CR, cr,
-					 (!(cr & RNG_CR_CONDRST)), 10000);
-		if (err)
-			return err;
-	}
-
-	/* clear error indicators */
-	writel(0, pdata->base + RNG_SR);
-
-	cr |= RNG_CR_RNGEN;
-	writel(cr, pdata->base + RNG_CR);
-
-	err = readl_poll_timeout(pdata->base + RNG_SR, sr,
-				 sr & RNG_SR_DRDY, 10000);
-	return err;
-}
-
-static int stm32_rng_cleanup(struct stm32_rng_plat *pdata)
-{
-	writel(0, pdata->base + RNG_CR);
-
-	return clk_disable(&pdata->clk);
-}
-
-static int stm32_rng_probe(struct udevice *dev)
-{
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-
-	pdata->data = (struct stm32_rng_data *)dev_get_driver_data(dev);
-
-	reset_assert(&pdata->rst);
-	udelay(20);
-	reset_deassert(&pdata->rst);
-
-	return stm32_rng_init(pdata);
-}
-
-static int stm32_rng_remove(struct udevice *dev)
-{
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-
-	return stm32_rng_cleanup(pdata);
-}
-
-static int stm32_rng_of_to_plat(struct udevice *dev)
-{
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-	int err;
-
-	pdata->base = dev_read_addr(dev);
-	if (!pdata->base)
-		return -ENOMEM;
-
-	err = clk_get_by_index(dev, 0, &pdata->clk);
-	if (err)
-		return err;
-
-	err = reset_get_by_index(dev, 0, &pdata->rst);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-static const struct dm_rng_ops stm32_rng_ops = {
-	.read = stm32_rng_read,
-};
-
-static const struct stm32_rng_data stm32mp13_rng_data = {
-	.has_cond_reset = true,
-};
-
-static const struct stm32_rng_data stm32_rng_data = {
-	.has_cond_reset = false,
-};
-
-static const struct udevice_id stm32_rng_match[] = {
-	{.compatible = "st,stm32mp13-rng", .data = (ulong)&stm32mp13_rng_data},
-	{.compatible = "st,stm32-rng", .data = (ulong)&stm32_rng_data},
-	{},
-};
-
-U_BOOT_DRIVER(stm32_rng) = {
-	.name = "stm32-rng",
-	.id = UCLASS_RNG,
-	.of_match = stm32_rng_match,
-	.ops = &stm32_rng_ops,
-	.probe = stm32_rng_probe,
-	.remove = stm32_rng_remove,
-	.plat_auto	= sizeof(struct stm32_rng_plat),
-	.of_to_plat = stm32_rng_of_to_plat,
-};
diff --git a/drivers/rtc/stm32_rtc.c b/drivers/rtc/stm32_rtc.c
index 1753283460..a2ae5f8056 100644
--- a/drivers/rtc/stm32_rtc.c
+++ b/drivers/rtc/stm32_rtc.c
@@ -12,6 +12,7 @@
 #include <rtc.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/iopoll.h>
 
@@ -60,10 +61,25 @@
 #define RTC_WPR_2ND_KEY		0x53
 #define RTC_WPR_WRONG_KEY	0xFF
 
+/* STM32_RTC_SECCFGR bit fields */
+#define STM32_RTC_SECCFGR		0x20
+#define STM32_RTC_SECCFGR_INIT_SEC	BIT(14)
+#define STM32_RTC_SECCFGR_SEC		BIT(15)
+
+/* STM32_RTC_R5CIDCFGR bit fields */
+#define STM32_RTC_R5CIDCFGR		0x94
+#define STM32_RTC_R5CIDCFGR_CFEN	BIT(0)
+#define STM32_RTC_R5CIDCFGR_CID		GENMASK(6, 4)
+#define STM32_RTC_R5CIDCFGR_CID1	0x1
+
 struct stm32_rtc_priv {
 	fdt_addr_t base;
 };
 
+struct stm32_rtc_data {
+	bool rif_protected;
+};
+
 static int stm32_rtc_get(struct udevice *dev, struct rtc_time *tm)
 {
 	struct stm32_rtc_priv *priv = dev_get_priv(dev);
@@ -206,6 +222,25 @@ static int stm32_rtc_reset(struct udevice *dev)
 	return stm32_rtc_set_time(dev, 0, 0);
 }
 
+static int stm32_rtc_check_rif(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	u32 rxcidcfgr = readl(priv->base + STM32_RTC_R5CIDCFGR);
+	u32 seccfgr;
+
+	/* Check if RTC available for our CID */
+	if ((rxcidcfgr & STM32_RTC_R5CIDCFGR_CFEN) &&
+	    (FIELD_GET(STM32_RTC_R5CIDCFGR_CID, rxcidcfgr) != STM32_RTC_R5CIDCFGR_CID1))
+		return -EACCES;
+
+	/* Check if RTC available for non-secure world */
+	seccfgr = readl(priv->base + STM32_RTC_SECCFGR);
+	if (seccfgr & (STM32_RTC_SECCFGR_SEC | STM32_RTC_SECCFGR_INIT_SEC))
+		return -EACCES;
+
+	return 0;
+}
+
 static int stm32_rtc_init(struct udevice *dev)
 {
 	struct stm32_rtc_priv *priv = dev_get_priv(dev);
@@ -286,6 +321,7 @@ unlock:
 static int stm32_rtc_probe(struct udevice *dev)
 {
 	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	const struct stm32_rtc_data *data = (const struct stm32_rtc_data *)dev_get_driver_data(dev);
 	struct clk clk;
 	int ret;
 
@@ -303,6 +339,16 @@ static int stm32_rtc_probe(struct udevice *dev)
 		return ret;
 	}
 
+	if (data->rif_protected) {
+		ret = stm32_rtc_check_rif(dev);
+		if (ret) {
+			dev_err(dev, "Failed to probe RTC due to RIF configuration\n");
+			clk_disable(&clk);
+			clk_free(&clk);
+			return ret;
+		}
+	}
+
 	ret = stm32_rtc_init(dev);
 
 	if (ret) {
@@ -313,6 +359,14 @@ static int stm32_rtc_probe(struct udevice *dev)
 	return ret;
 }
 
+static const struct stm32_rtc_data stm32mp1_data = {
+	.rif_protected = false
+};
+
+static const struct stm32_rtc_data stm32mp25_data = {
+	.rif_protected = true
+};
+
 static const struct rtc_ops stm32_rtc_ops = {
 	.get = stm32_rtc_get,
 	.set = stm32_rtc_set,
@@ -320,7 +374,8 @@ static const struct rtc_ops stm32_rtc_ops = {
 };
 
 static const struct udevice_id stm32_rtc_ids[] = {
-	{ .compatible = "st,stm32mp1-rtc" },
+	{ .compatible = "st,stm32mp1-rtc", .data = (ulong)&stm32mp1_data },
+	{ .compatible = "st,stm32mp25-rtc", .data = (ulong)&stm32mp25_data },
 	{ }
 };
 
diff --git a/drivers/serial/serial_stm32.c b/drivers/serial/serial_stm32.c
index 23d476fba2..7d2002bbf6 100644
--- a/drivers/serial/serial_stm32.c
+++ b/drivers/serial/serial_stm32.c
@@ -30,7 +30,10 @@
  */
 #define ONE_BYTE_B115200_US		87
 
-static void _stm32_serial_setbrg(fdt_addr_t base,
+/* This is used to compute a timeout, take the worst possible case: STM32MP2 */
+#define STM32_USART_FIFO_TMO_US		(64 * ONE_BYTE_B115200_US)
+
+static void _stm32_serial_setbrg(void __iomem *base,
 				 struct stm32_uart_info *uart_info,
 				 u32 clock_rate,
 				 int baudrate)
@@ -75,7 +78,7 @@ static int stm32_serial_setconfig(struct udevice *dev, uint serial_config)
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	bool stm32f4 = plat->uart_info->stm32f4;
 	u8 uart_enable_bit = plat->uart_info->uart_enable_bit;
-	u32 cr1 = plat->base + CR1_OFFSET(stm32f4);
+	void __iomem *cr1 = plat->base + CR1_OFFSET(stm32f4);
 	u32 config = 0;
 	uint parity = SERIAL_GET_PARITY(serial_config);
 	uint bits = SERIAL_GET_BITS(serial_config);
@@ -122,7 +125,7 @@ static int stm32_serial_getc(struct udevice *dev)
 {
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	bool stm32f4 = plat->uart_info->stm32f4;
-	fdt_addr_t base = plat->base;
+	void __iomem *base = plat->base;
 	u32 isr = readl(base + ISR_OFFSET(stm32f4));
 
 	if ((isr & USART_ISR_RXNE) == 0)
@@ -141,7 +144,7 @@ static int stm32_serial_getc(struct udevice *dev)
 	return readl(base + RDR_OFFSET(stm32f4));
 }
 
-static int _stm32_serial_putc(fdt_addr_t base,
+static int _stm32_serial_putc(void __iomem *base,
 			      struct stm32_uart_info *uart_info,
 			      const char c)
 {
@@ -166,7 +169,7 @@ static int stm32_serial_pending(struct udevice *dev, bool input)
 {
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	bool stm32f4 = plat->uart_info->stm32f4;
-	fdt_addr_t base = plat->base;
+	void __iomem *base = plat->base;
 
 	if (input)
 		return readl(base + ISR_OFFSET(stm32f4)) &
@@ -176,7 +179,7 @@ static int stm32_serial_pending(struct udevice *dev, bool input)
 			USART_ISR_TXE ? 0 : 1;
 }
 
-static void _stm32_serial_init(fdt_addr_t base,
+static void _stm32_serial_init(void __iomem *base,
 			       struct stm32_uart_info *uart_info)
 {
 	bool stm32f4 = uart_info->stm32f4;
@@ -217,8 +220,8 @@ static int stm32_serial_probe(struct udevice *dev)
 	 * before uart initialization, wait for TC bit (Transmission Complete)
 	 * in case there is still chars from previous bootstage to transmit
 	 */
-	ret = read_poll_timeout(readl, isr, isr & USART_ISR_TC, 50,
-				16 * ONE_BYTE_B115200_US, plat->base + ISR_OFFSET(stm32f4));
+	ret = read_poll_timeout(readl, isr, isr & USART_ISR_TC, 50, STM32_USART_FIFO_TMO_US,
+				plat->base + ISR_OFFSET(stm32f4));
 	if (ret)
 		dev_dbg(dev, "FIFO not empty, some character can be lost (%d)\n", ret);
 
@@ -250,11 +253,14 @@ static const struct udevice_id stm32_serial_id[] = {
 static int stm32_serial_of_to_plat(struct udevice *dev)
 {
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
+	fdt_addr_t addr;
 
-	plat->base = dev_read_addr(dev);
-	if (plat->base == FDT_ADDR_T_NONE)
+	addr = dev_read_addr(dev);
+	if (addr == FDT_ADDR_T_NONE)
 		return -EINVAL;
 
+	plat->base = (void __iomem *)addr;
+
 	return 0;
 }
 
@@ -297,18 +303,24 @@ static inline struct stm32_uart_info *_debug_uart_info(void)
 
 static inline void _debug_uart_init(void)
 {
-	fdt_addr_t base = CONFIG_VAL(DEBUG_UART_BASE);
-	struct stm32_uart_info *uart_info = _debug_uart_info();
+	void __maybe_unused __iomem *base = (void __iomem *)CONFIG_VAL(DEBUG_UART_BASE);
+	struct stm32_uart_info *uart_info __maybe_unused = _debug_uart_info();
 
-	_stm32_serial_init(base, uart_info);
-	_stm32_serial_setbrg(base, uart_info,
-			     CONFIG_DEBUG_UART_CLOCK,
-			     CONFIG_BAUDRATE);
+	/*
+	 * debug_uart_init() is only usable when SPL_BUILD is enabled
+	 * (STM32MP1 case only)
+	 */
+	if (IS_ENABLED(CONFIG_DEBUG_UART) && IS_ENABLED(CONFIG_SPL_BUILD)) {
+		_stm32_serial_init(base, uart_info);
+		_stm32_serial_setbrg(base, uart_info,
+				     CONFIG_DEBUG_UART_CLOCK,
+				     CONFIG_BAUDRATE);
+	}
 }
 
 static inline void _debug_uart_putc(int c)
 {
-	fdt_addr_t base = CONFIG_VAL(DEBUG_UART_BASE);
+	void __iomem *base = (void __iomem *)CONFIG_VAL(DEBUG_UART_BASE);
 	struct stm32_uart_info *uart_info = _debug_uart_info();
 
 	while (_stm32_serial_putc(base, uart_info, c) == -EAGAIN)
diff --git a/drivers/serial/serial_stm32.h b/drivers/serial/serial_stm32.h
index b7e7a90b93..d2c92ba48e 100644
--- a/drivers/serial/serial_stm32.h
+++ b/drivers/serial/serial_stm32.h
@@ -49,7 +49,7 @@ struct stm32_uart_info stm32h7_info = {
 
 /* Information about a serial port */
 struct stm32x7_serial_plat {
-	fdt_addr_t base;  /* address of registers in physical memory */
+	void __iomem *base;  /* address of registers in physical memory */
 	struct stm32_uart_info *uart_info;
 	unsigned long int clock_rate;
 };
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 854b8b88da..71e4b267f3 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -486,6 +486,14 @@ config SPI_SUNXI
 
 	  Same controller driver can reuse in all Allwinner SoC variants.
 
+config STM32_OSPI
+	bool "STM32MP2 OSPI driver"
+	depends on ARCH_STM32MP
+	help
+	  Enable the STM32MP2 Octo-SPI (OSPI) driver. This driver can be
+	  used to access the SPI NOR flash chips on platforms embedding
+	  this ST IP core.
+
 config STM32_QSPI
 	bool "STM32F7 QSPI driver"
 	depends on STM32F4 || STM32F7 || ARCH_STM32MP
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index c27b3327c3..8ce34dd7b3 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -71,6 +71,7 @@ obj-$(CONFIG_SPI_SIFIVE) += spi-sifive.o
 obj-$(CONFIG_SPI_SN_F_OSPI) += spi-sn-f-ospi.o
 obj-$(CONFIG_SPI_SUNXI) += spi-sunxi.o
 obj-$(CONFIG_SH_QSPI) += sh_qspi.o
+obj-$(CONFIG_STM32_OSPI) += stm32_ospi.o
 obj-$(CONFIG_STM32_QSPI) += stm32_qspi.o
 obj-$(CONFIG_STM32_SPI) += stm32_spi.o
 obj-$(CONFIG_TEGRA114_SPI) += tegra114_spi.o
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index b7eca58359..eecc13bec9 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -181,14 +181,6 @@ bool spi_mem_dtr_supports_op(struct spi_slave *slave,
 	if (op->dummy.nbytes && op->dummy.buswidth == 8 && op->dummy.nbytes % 2)
 		return false;
 
-	/*
-	 * Transactions of odd length do not make sense for 8D-8D-8D mode
-	 * because a byte is transferred in just half a cycle.
-	 */
-	if (op->data.dir != SPI_MEM_NO_DATA && op->data.dir != SPI_MEM_DATA_IN &&
-	    op->data.buswidth == 8 && op->data.nbytes % 2)
-		return false;
-
 	return spi_mem_check_buswidth(slave, op);
 }
 EXPORT_SYMBOL_GPL(spi_mem_dtr_supports_op);
diff --git a/drivers/spi/stm32_ospi.c b/drivers/spi/stm32_ospi.c
new file mode 100644
index 0000000000..3af197df01
--- /dev/null
+++ b/drivers/spi/stm32_ospi.c
@@ -0,0 +1,738 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SPI
+
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <regmap.h>
+#include <spi.h>
+#include <spi-mem.h>
+#include <stm32_omi.h>
+#include <syscon.h>
+#include <dm/device_compat.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/sizes.h>
+
+#define NSEC_PER_SEC		1000000000L
+#define MACRONIX_ID		0xc2
+
+struct stm32_ospi_flash {
+	u64 str_idcode;
+	u64 dtr_idcode;
+	bool is_spi_nor;
+	bool is_str_calibration;
+	bool dtr_calibration_done_once;
+	bool octal_dtr;
+};
+
+struct stm32_ospi_priv {
+	struct udevice *omi_dev;
+	struct stm32_ospi_flash flash[OSPI_MAX_CHIP];
+	int cs_used;
+};
+
+static int stm32_ospi_mm(struct udevice *omi_dev,
+			 const struct spi_mem_op *op)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+
+	memcpy_fromio(op->data.buf.in,
+		      (void __iomem *)omi_plat->mm_base + op->addr.val,
+		      op->data.nbytes);
+
+	return 0;
+}
+
+static int stm32_ospi_tx(struct udevice *omi_dev,
+			 const struct spi_mem_op *op,
+			 u8 mode)
+{
+	struct stm32_omi_priv *omi_priv = dev_get_priv(omi_dev);
+	struct stm32_ospi_priv *priv = dev_get_priv(omi_priv->dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	u8 *buf;
+	u8 dummy = 0xff;
+	int ret;
+
+	if (!op->data.nbytes)
+		return 0;
+
+	if (mode == OSPI_CCR_MEM_MAP)
+		return stm32_ospi_mm(omi_dev, op);
+
+	if (op->data.dir == SPI_MEM_DATA_IN)
+		buf = op->data.buf.in;
+	else
+		buf = (u8 *)op->data.buf.out;
+
+	if (flash->octal_dtr && op->addr.val % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi_dev, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	ret = stm32_omi_tx_poll(omi_dev, buf, op->data.nbytes,
+				op->data.dir == SPI_MEM_DATA_IN);
+	if (ret)
+		return ret;
+
+	if (flash->octal_dtr && (op->addr.val + op->data.nbytes) % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi_dev, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_get_mode(u8 buswidth)
+{
+	if (buswidth == 8)
+		return 4;
+
+	if (buswidth == 4)
+		return 3;
+
+	return buswidth;
+}
+
+static int stm32_ospi_send(struct udevice *omi_dev,
+			   const struct spi_mem_op *op, u8 mode)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+	struct stm32_omi_priv *omi_priv = dev_get_priv(omi_dev);
+	struct stm32_ospi_priv *priv = dev_get_priv(omi_priv->dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 cr, ccr = 0;
+	int timeout, ret;
+	int dmode;
+	u8 dcyc = 0;
+	u64 addr = op->addr.val;
+	unsigned int nbytes = op->data.nbytes;
+
+	dev_dbg(omi_priv->dev, "%s: cmd:%#x dtr: %d mode:%d.%d.%d.%d addr:%#llx len:%#x\n",
+		__func__, op->cmd.opcode, op->cmd.dtr, op->cmd.buswidth,
+		op->addr.buswidth, op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	/*
+	 * When DTR mode and indirect read/write mode are set, there is a
+	 * constraint on the address and the number of bytes read or write
+	 * that should be even.
+	 */
+	if (flash->octal_dtr && mode != OSPI_CCR_MEM_MAP && op->data.nbytes) {
+		if (op->addr.val % 2) {
+			addr--;
+			nbytes++;
+		}
+
+		if ((op->addr.val + op->data.nbytes) % 2)
+			nbytes++;
+	}
+
+	clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_MTYP_MASK);
+
+	if (op->data.nbytes && mode != OSPI_CCR_MEM_MAP)
+		writel(nbytes - 1, regs_base + OSPI_DLR);
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			mode << OSPI_CR_FMODE_SHIFT);
+
+	ccr |= ((op->cmd.nbytes - 1) << OSPI_CCR_ISIZE_SHIFT) &
+	       OSPI_CCR_ISIZE_MASK;
+
+	ccr |= (stm32_ospi_get_mode(op->cmd.buswidth) << OSPI_CCR_IMODE_SHIFT) &
+		OSPI_CCR_IMODE_MASK;
+
+	if (op->cmd.dtr) {
+		ccr |= OSPI_CCR_IDTR;
+		ccr |= OSPI_CCR_DQSE;
+	}
+
+	if (op->addr.dtr)
+		ccr |= OSPI_CCR_ADDTR;
+
+	if (op->data.dtr)
+		ccr |= OSPI_CCR_DDTR;
+
+	if (op->data.dtr_swab16)
+		clrsetbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_MTYP_MASK,
+				OSPI_DCR1_MTYP_MX_MODE << OSPI_DCR1_MTYP_SHIFT);
+
+	if (op->addr.nbytes) {
+		ccr |= ((op->addr.nbytes - 1) << OSPI_CCR_ADSIZE_SHIFT);
+		ccr |= (stm32_ospi_get_mode(op->addr.buswidth)
+			<< OSPI_CCR_ADMODE_SHIFT) & OSPI_CCR_ADMODE_MASK;
+	}
+
+	if (op->dummy.buswidth && op->dummy.nbytes) {
+		dcyc = op->dummy.nbytes * 8 / op->dummy.buswidth;
+
+		if (op->dummy.dtr)
+			dcyc /= 2;
+	}
+
+	clrsetbits_le32(regs_base + OSPI_TCR, OSPI_TCR_DCYC_MASK,
+			dcyc << OSPI_TCR_DCYC_SHIFT);
+
+	if (op->data.nbytes) {
+		dmode = stm32_ospi_get_mode(op->data.buswidth);
+		ccr |= (dmode << OSPI_CCR_DMODE_SHIFT) & OSPI_CCR_DMODE_MASK;
+	}
+
+	writel(ccr, regs_base + OSPI_CCR);
+
+	/* Set instruction, must be set after ccr register update */
+	writel(op->cmd.opcode, regs_base + OSPI_IR);
+
+	if (op->addr.nbytes && mode != OSPI_CCR_MEM_MAP)
+		writel(addr, regs_base + OSPI_AR);
+
+	ret = stm32_ospi_tx(omi_dev, op, mode);
+	/*
+	 * Abort in:
+	 * -error case
+	 * -read memory map: prefetching must be stopped if we read the last
+	 *  byte of device (device size - fifo size). like device size is not
+	 *  knows, the prefetching is always stop.
+	 */
+	if (ret || mode == OSPI_CCR_MEM_MAP)
+		goto abort;
+
+	/* Wait end of tx in indirect mode */
+	ret = stm32_omi_wait_cmd(omi_dev);
+	if (ret)
+		goto abort;
+
+	return 0;
+
+abort:
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_ABORT);
+
+	/* Wait clear of abort bit by hw */
+	timeout = readl_poll_timeout(regs_base + OSPI_CR, cr,
+				     !(cr & OSPI_CR_ABORT),
+				     OSPI_ABT_TIMEOUT_US);
+
+	writel(OSPI_FCR_CTCF, regs_base + OSPI_FCR);
+
+	if (!omi_priv->is_calibrating && (ret || timeout))
+		dev_err(omi_priv->dev, "%s ret:%d abort timeout:%d\n", __func__,
+			ret, timeout);
+
+	return ret;
+}
+
+static int stm32_ospi_set_speed(struct udevice *bus, uint speed)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 ospi_clk = omi_plat->clock_rate;
+	u32 prescaler = 255;
+	u32 csht;
+	uint bus_freq;
+	int ret;
+
+	if (speed > 0) {
+		prescaler = 0;
+		if (ospi_clk) {
+			prescaler = DIV_ROUND_UP(ospi_clk, speed) - 1;
+			if (prescaler > 255)
+				prescaler = 255;
+		}
+	}
+
+	csht = (DIV_ROUND_UP((5 * ospi_clk) / (prescaler + 1), 100000000)) - 1;
+
+	ret = stm32_omi_wait_for_not_busy(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	clrsetbits_le32(regs_base + OSPI_DCR2, OSPI_DCR2_PRESC_MASK,
+			prescaler << OSPI_DCR2_PRESC_SHIFT);
+
+	clrsetbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_CSHT_MASK,
+			csht << OSPI_DCR1_CSHT_SHIFT);
+
+	bus_freq = DIV_ROUND_UP(ospi_clk, prescaler + 1);
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD)
+		setbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DLYBYP);
+	else
+		clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DLYBYP);
+
+	return 0;
+}
+
+static int stm32_ospi_readid(struct udevice *omi_dev)
+{
+	struct stm32_omi_priv *omi_priv = dev_get_priv(omi_dev);
+	struct stm32_ospi_priv *priv = dev_get_priv(omi_priv->dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	u64 rx_buf;
+	struct spi_mem_op readid_op;
+	int ret;
+
+	if (flash->is_str_calibration) {
+		u8 nb_dummy_bytes = flash->is_spi_nor ? 0 : 1;
+
+		readid_op = (struct spi_mem_op)
+			    SPI_MEM_OP(SPI_MEM_OP_CMD(0x9f, 1),
+				       SPI_MEM_OP_NO_ADDR,
+				       SPI_MEM_OP_DUMMY(nb_dummy_bytes, 1),
+				       SPI_MEM_OP_DATA_IN(8, (u8 *)&rx_buf, 1));
+	} else {
+		if (flash->octal_dtr && flash->is_spi_nor) {
+			u16 opcode;
+			u8 nb_addr_bytes;
+			u8 nb_dummy_bytes;
+
+			if ((flash->dtr_idcode & 0xff) == MACRONIX_ID) {
+				opcode = 0x9f60;
+				nb_addr_bytes = 4;
+				nb_dummy_bytes = 8;
+			} else {
+				/*
+				 * All memory providers are not currently
+				 * supported, feel free to add them
+				 */
+				return -EOPNOTSUPP;
+			}
+
+			readid_op = (struct spi_mem_op)
+				    SPI_MEM_OP(SPI_MEM_OP_CMD(opcode, 8),
+					       SPI_MEM_OP_ADDR(nb_addr_bytes, 0, 8),
+					       SPI_MEM_OP_DUMMY(nb_dummy_bytes, 8),
+					       SPI_MEM_OP_DATA_IN(8, (u8 *)&rx_buf, 8));
+			readid_op.cmd.dtr = true;
+			readid_op.addr.dtr = true;
+			readid_op.dummy.dtr = true;
+			readid_op.data.dtr = true;
+			readid_op.cmd.nbytes = 2;
+		} else {
+			/*
+			 * Only OCTAL DTR calibration on SPI NOR devices
+			 * is currently supported
+			 */
+			return -EOPNOTSUPP;
+		}
+	}
+
+	ret = stm32_ospi_send(omi_dev, &readid_op, OSPI_CCR_IND_READ);
+	if (ret)
+		return ret;
+
+	dev_dbg(omi_dev, "Flash ID 0x%08llx\n", rx_buf);
+
+	if (flash->is_str_calibration) {
+		/*
+		 * On stm32_ospi_readid() first execution, save the golden
+		 * read id
+		 */
+		if (flash->str_idcode == 0) {
+			flash->str_idcode = rx_buf;
+
+			if (flash->is_spi_nor) {
+				/* Build DTR id code */
+				if ((rx_buf & 0xff) == MACRONIX_ID) {
+					/*
+					 * Retrieve odd array and re-sort id
+					 * because of read id format will be
+					 * A-A-B-B-C-C after enter into octal
+					 * dtr mode for Macronix flashes.
+					 */
+					flash->dtr_idcode = rx_buf & 0xff;
+					flash->dtr_idcode |= (rx_buf & 0xff) << 8;
+					flash->dtr_idcode |= (rx_buf & 0xff00) << 8;
+					flash->dtr_idcode |= (rx_buf & 0xff00) << 16;
+					flash->dtr_idcode |= (rx_buf & 0xff0000) << 16;
+					flash->dtr_idcode |= (rx_buf & 0xff0000) << 24;
+					flash->dtr_idcode |= (rx_buf & 0xff000000) << 24;
+					flash->dtr_idcode |= (rx_buf & 0xff000000) << 32;
+				} else {
+					flash->dtr_idcode = rx_buf;
+				}
+			}
+		}
+
+		if (rx_buf == flash->str_idcode)
+			return 0;
+	} else if (rx_buf == flash->dtr_idcode) {
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static int stm32_ospi_str_calibration(struct udevice *bus)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 dlyb_cr;
+	u8 window_len_tcr0 = 0, window_len_tcr1 = 0;
+	int ret, ret_tcr0, ret_tcr1;
+	u32 dcr2, prescaler;
+	uint bus_freq;
+
+	dcr2 = readl(regs_base + OSPI_DCR2);
+	prescaler = (dcr2 & OSPI_DCR2_PRESC_MASK) >> OSPI_DCR2_PRESC_SHIFT;
+	bus_freq = DIV_ROUND_UP(omi_plat->clock_rate, prescaler + 1);
+
+	/*
+	 * Set memory device at low frequency (50MHz) and sent
+	 * READID (0x9F) command, save the answer as golden answer
+	 */
+	ret = stm32_ospi_set_speed(bus, STM32_DLYB_FREQ_THRESHOLD);
+	if (ret)
+		return ret;
+
+	flash->str_idcode = 0;
+	ret = stm32_ospi_readid(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	/* Set frequency at requested value */
+	ret = stm32_ospi_set_speed(bus, bus_freq);
+	if (ret)
+		return ret;
+
+	/* Calibration needed above 50MHz */
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD)
+		return 0;
+
+	/* Perform calibration */
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, false, 0);
+	if (ret)
+		return ret;
+
+	ret_tcr0 = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len_tcr0);
+	if (!ret_tcr0)
+		stm32_omi_dlyb_get_cr(priv->omi_dev, &dlyb_cr);
+
+	stm32_omi_dlyb_stop(priv->omi_dev);
+
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, false, 0);
+	if (ret)
+		return ret;
+
+	setbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+
+	ret_tcr1 = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len_tcr1);
+	if (ret_tcr0 && ret_tcr1) {
+		dev_info(bus, "Calibration phase failed\n");
+		return ret_tcr0;
+	}
+
+	if (window_len_tcr0 >= window_len_tcr1) {
+		clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+
+		stm32_omi_dlyb_stop(priv->omi_dev);
+
+		ret = stm32_omi_dlyb_set_cr(priv->omi_dev, dlyb_cr);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_dtr_calibration(struct udevice *bus)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 dcr2, prescaler;
+	uint bus_freq;
+	u16 period_ps = 0;
+	u8 window_len = 0;
+	int ret;
+	bool bypass_mode = false;
+
+	clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DLYBYP);
+
+	dcr2 = readl(regs_base + OSPI_DCR2);
+	prescaler = (dcr2 & OSPI_DCR2_PRESC_MASK) >> OSPI_DCR2_PRESC_SHIFT;
+	bus_freq = DIV_ROUND_UP(omi_plat->clock_rate, prescaler + 1);
+
+	if (prescaler)
+		setbits_le32(regs_base + OSPI_TCR, OSPI_TCR_DHQC);
+
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (bus_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	if (bypass_mode || prescaler)
+		/* Perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len);
+	else
+		/* Perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, false, &window_len);
+
+	if (ret) {
+		dev_err(bus, "Calibration failed\n");
+		if (!bypass_mode)
+			/* Stop delay block when configured in lock mode */
+			stm32_omi_dlyb_stop(priv->omi_dev);
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_exec_op(struct spi_slave *slave,
+			      const struct spi_mem_op *op)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(slave->dev->parent);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 addr_max;
+	u8 mode = OSPI_CCR_IND_WRITE;
+	int ret;
+
+	if (op->cmd.dtr && !flash->dtr_calibration_done_once) {
+		stm32_omi_dlyb_stop(priv->omi_dev);
+		clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+		flash->octal_dtr = (op->cmd.nbytes == 2);
+
+		ret = stm32_ospi_dtr_calibration(slave->dev->parent);
+		if (ret)
+			return ret;
+
+		flash->dtr_calibration_done_once = true;
+	}
+
+	addr_max = op->addr.val + op->data.nbytes + 1;
+
+	if (op->data.dir == SPI_MEM_DATA_IN && op->data.nbytes) {
+		if (addr_max < omi_plat->mm_size && op->addr.buswidth)
+			mode = OSPI_CCR_MEM_MAP;
+		else
+			mode = OSPI_CCR_IND_READ;
+	}
+
+	return stm32_ospi_send(priv->omi_dev, op, mode);
+}
+
+static int stm32_ospi_probe(struct udevice *bus)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat;
+	struct stm32_omi_priv *omi_priv;
+	phys_addr_t regs_base;
+	ofnode child;
+	int ret;
+
+	priv->omi_dev = bus->parent;
+	omi_plat = dev_get_plat(priv->omi_dev);
+	omi_priv = dev_get_priv(priv->omi_dev);
+	omi_priv->dev = bus;
+	regs_base = omi_plat->regs_base;
+
+	ret = clk_enable(&omi_plat->clk);
+	if (ret) {
+		dev_err(bus, "failed to enable clock\n");
+		return ret;
+	}
+
+	/* Reset OSPI controller */
+	reset_assert_bulk(&omi_plat->rst_ctl);
+	udelay(2);
+	reset_deassert_bulk(&omi_plat->rst_ctl);
+
+	/* Set dcr devsize to max address */
+	setbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DEVSIZE_MASK);
+
+	priv->cs_used = -1;
+	omi_priv->check_transfer = stm32_ospi_readid;
+
+	/* Find memory model on each child node (SPI NOR or SPI NAND) */
+	dev_for_each_subnode(child, priv->omi_dev) {
+		u32 cs;
+
+		ret = ofnode_read_u32(child, "reg", &cs);
+		if (ret) {
+			dev_err(bus, "could not retrieve reg property: %d\n",
+				ret);
+			return ret;
+		}
+
+		if (cs >= OSPI_MAX_CHIP) {
+			dev_err(bus, "invalid reg value: %d\n", cs);
+			return -EINVAL;
+		}
+
+		if (ofnode_device_is_compatible(child, "jedec,spi-nor")) {
+			struct stm32_ospi_flash *flash = &priv->flash[cs];
+
+			flash->is_spi_nor = true;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_claim_bus(struct udevice *dev)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(dev->parent);
+	struct dm_spi_slave_plat *slave_plat = dev_get_parent_plat(dev);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	struct stm32_ospi_flash *flash;
+	phys_addr_t regs_base = omi_plat->regs_base;
+	int slave_cs = slave_plat->cs;
+	int ret;
+
+	if (slave_cs >= OSPI_MAX_CHIP)
+		return -ENODEV;
+
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_EN);
+
+	if (priv->cs_used == slave_cs)
+		return 0;
+
+	priv->cs_used = slave_cs;
+	flash = &priv->flash[priv->cs_used];
+
+	stm32_omi_dlyb_stop(priv->omi_dev);
+
+	/* Set chip select */
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_CSSEL,
+			priv->cs_used ? OSPI_CR_CSSEL : 0);
+	clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+
+	if (flash->dtr_calibration_done_once) {
+		ret = stm32_ospi_dtr_calibration(dev->parent);
+	} else {
+		flash->is_str_calibration = true;
+
+		ret = stm32_ospi_str_calibration(dev->parent);
+		if (ret) {
+			dev_info(dev->parent, "Set flash frequency to a safe value (%d Hz)\n",
+				 STM32_DLYB_FREQ_THRESHOLD);
+
+			stm32_omi_dlyb_stop(priv->omi_dev);
+
+			clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+			ret = stm32_ospi_set_speed(dev->parent,
+						   STM32_DLYB_FREQ_THRESHOLD);
+		}
+
+		flash->is_str_calibration = false;
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_release_bus(struct udevice *dev)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(dev->parent);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+
+	clrbits_le32(regs_base + OSPI_CR, OSPI_CR_EN);
+
+	return 0;
+}
+
+static int stm32_ospi_set_mode(struct udevice *bus, uint mode)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	const char *str_rx, *str_tx;
+	int ret;
+
+	ret = stm32_omi_wait_for_not_busy(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	if ((mode & SPI_CPHA) && (mode & SPI_CPOL))
+		setbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_CKMODE);
+	else if (!(mode & SPI_CPHA) && !(mode & SPI_CPOL))
+		clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_CKMODE);
+	else
+		return -ENODEV;
+
+	if (mode & SPI_CS_HIGH)
+		return -ENODEV;
+
+	if (mode & SPI_RX_OCTAL)
+		str_rx = "octal";
+	else if (mode & SPI_RX_QUAD)
+		str_rx = "quad";
+	else if (mode & SPI_RX_DUAL)
+		str_rx = "dual";
+	else
+		str_rx = "single";
+
+	if (mode & SPI_TX_OCTAL)
+		str_tx = "octal";
+	else if (mode & SPI_TX_QUAD)
+		str_tx = "quad";
+	else if (mode & SPI_TX_DUAL)
+		str_tx = "dual";
+	else
+		str_tx = "single";
+
+	dev_dbg(bus, "mode=%d rx: %s, tx: %s\n", mode, str_rx, str_tx);
+
+	return 0;
+}
+
+static bool stm32_ospi_mem_supports_op(struct spi_slave *slave,
+				       const struct spi_mem_op *op)
+{
+	if (op->data.buswidth > 8 || op->addr.buswidth > 8 ||
+	    op->dummy.buswidth > 8 || op->cmd.buswidth > 8)
+		return false;
+
+	if (op->cmd.nbytes > 4 || op->addr.nbytes > 4)
+		return false;
+
+	if ((!op->dummy.dtr && op->dummy.nbytes > 32) ||
+	    (op->dummy.dtr && op->dummy.nbytes > 64))
+		return false;
+
+	if (!op->cmd.dtr && !op->addr.dtr && !op->dummy.dtr &&
+	    !op->data.dtr && op->cmd.nbytes == 1)
+		return spi_mem_default_supports_op(slave, op);
+
+	return spi_mem_dtr_supports_op(slave, op);
+}
+
+static const struct spi_controller_mem_ops stm32_ospi_mem_ops = {
+	.exec_op = stm32_ospi_exec_op,
+	.supports_op = stm32_ospi_mem_supports_op,
+};
+
+static const struct dm_spi_ops stm32_ospi_ops = {
+	.claim_bus	= stm32_ospi_claim_bus,
+	.release_bus	= stm32_ospi_release_bus,
+	.set_speed	= stm32_ospi_set_speed,
+	.set_mode	= stm32_ospi_set_mode,
+	.mem_ops	= &stm32_ospi_mem_ops,
+};
+
+U_BOOT_DRIVER(stm32_ospi) = {
+	.name = "stm32_ospi",
+	.id = UCLASS_SPI,
+	.ops = &stm32_ospi_ops,
+	.priv_auto = sizeof(struct stm32_ospi_priv),
+	.probe = stm32_ospi_probe,
+};
diff --git a/drivers/spi/stm32_qspi.c b/drivers/spi/stm32_qspi.c
index eb52ff73b2..e7defff951 100644
--- a/drivers/spi/stm32_qspi.c
+++ b/drivers/spi/stm32_qspi.c
@@ -346,8 +346,8 @@ static int stm32_qspi_probe(struct udevice *bus)
 	if (priv->mm_size > STM32_QSPI_MAX_MMAP_SZ)
 		return -EINVAL;
 
-	dev_dbg(bus, "regs=<0x%p> mapped=<0x%p> mapped_size=<0x%lx>\n",
-		priv->regs, priv->mm_base, priv->mm_size);
+	dev_dbg(bus, "%s: regs=<0x%p> mapped=<0x%p> mapped_size=<0x%x>\n",
+		__func__, priv->regs, priv->mm_base, (u32)priv->mm_size);
 
 	ret = clk_get_by_index(bus, 0, &clk);
 	if (ret < 0)
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index 9a9b697e91..47f845cffe 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -139,6 +139,11 @@ static int enum_services(struct udevice *dev, struct tee_shm **shm, size_t *coun
 	if (ret)
 		return ret;
 
+	if (!shm_size) {
+		*count = 0;
+		return 0;
+	}
+
 	ret = tee_shm_alloc(dev, shm_size, 0, shm);
 	if (ret) {
 		dev_err(dev, "Failed to allocated shared memory: %d\n", ret);
@@ -185,14 +190,15 @@ static int bind_service_drivers(struct udevice *dev)
 
 	ret = enum_services(dev, &service_list, &service_count, tee_sess,
 			    PTA_CMD_GET_DEVICES);
-	if (!ret)
+	if (!ret && service_count)
 		ret = bind_service_list(dev, service_list, service_count);
 
 	tee_shm_free(service_list);
+	service_list = NULL;
 
 	ret2 = enum_services(dev, &service_list, &service_count, tee_sess,
 			     PTA_CMD_GET_DEVICES_SUPP);
-	if (!ret2)
+	if (!ret2 && service_count)
 		ret2 = bind_service_list(dev, service_list, service_count);
 
 	tee_shm_free(service_list);
@@ -841,7 +847,7 @@ static int optee_probe(struct udevice *dev)
 	if (IS_ENABLED(CONFIG_OPTEE_SERVICE_DISCOVERY)) {
 		ret = bind_service_drivers(dev);
 		if (ret)
-			return ret;
+			dev_warn(dev, "optee service enumeration failed: %d\n", ret);
 	} else if (IS_ENABLED(CONFIG_RNG_OPTEE)) {
 		/*
 		 * Discovery of TAs on the TEE bus is not supported in U-Boot:
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index a972d87c7a..952e36385e 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -85,6 +85,8 @@ source "drivers/usb/emul/Kconfig"
 
 source "drivers/usb/phy/Kconfig"
 
+source "drivers/usb/typec/Kconfig"
+
 source "drivers/usb/ulpi/Kconfig"
 
 if USB_HOST
diff --git a/drivers/usb/cdns3/core.h b/drivers/usb/cdns3/core.h
index 0668d646fc..52d6d01cd6 100644
--- a/drivers/usb/cdns3/core.h
+++ b/drivers/usb/cdns3/core.h
@@ -16,12 +16,6 @@
 #ifndef __LINUX_CDNS3_CORE_H
 #define __LINUX_CDNS3_CORE_H
 
-enum usb_role {
-	USB_ROLE_NONE,
-	USB_ROLE_HOST,
-	USB_ROLE_DEVICE,
-};
-
 struct cdns3;
 
 /**
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 49f6a1900b..393187caa8 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -775,12 +775,6 @@ static int dwc3_core_init_mode(struct dwc3 *dwc)
 	return 0;
 }
 
-static void dwc3_gadget_run(struct dwc3 *dwc)
-{
-	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_RUN_STOP);
-	mdelay(100);
-}
-
 static void dwc3_core_stop(struct dwc3 *dwc)
 {
 	u32 reg;
@@ -812,7 +806,6 @@ static void dwc3_core_exit_mode(struct dwc3 *dwc)
 	 * This enables the phy to enter idle and then, if enabled, suspend.
 	 */
 	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
-	dwc3_gadget_run(dwc);
 }
 
 #define DWC3_ALIGN_MASK		(16 - 1)
@@ -1014,6 +1007,8 @@ MODULE_DESCRIPTION("DesignWare USB3 DRD Controller Driver");
 int dwc3_setup_phy(struct udevice *dev, struct phy_bulk *phys)
 {
 	int ret;
+	enum usb_dr_mode dr_mode;
+	enum phy_mode phymode;
 
 	ret = generic_phy_get_bulk(dev, phys);
 	if (ret)
@@ -1025,7 +1020,33 @@ int dwc3_setup_phy(struct udevice *dev, struct phy_bulk *phys)
 
 	ret = generic_phy_power_on_bulk(phys);
 	if (ret)
-		generic_phy_exit_bulk(phys);
+		goto err_power_on;
+
+	dr_mode = usb_get_dr_mode(dev_ofnode(dev));
+
+	switch(dr_mode)
+	{
+		case USB_DR_MODE_HOST:
+			phymode = PHY_MODE_USB_HOST;
+			break;
+		case USB_DR_MODE_PERIPHERAL:
+			phymode = PHY_MODE_USB_DEVICE;
+			break;
+		default:
+			goto err_mode;
+	}
+
+	ret = generic_phy_set_mode_bulk(phys, phymode, (dr_mode == USB_DR_MODE_HOST) ?
+					USB_ROLE_HOST : USB_ROLE_DEVICE);
+	if (ret)
+		goto err_mode;
+
+	return ret;
+
+err_mode:
+	generic_phy_power_off_bulk(phys);
+err_power_on:
+	generic_phy_exit_bulk(phys);
 
 	return ret;
 }
@@ -1133,7 +1154,8 @@ void dwc3_of_parse(struct dwc3 *dwc)
 				       i, &val))
 			break;
 
-		dwc->incrx_mode = INCRX_UNDEF_LENGTH_BURST_MODE;
+		if (i > 0)
+			dwc->incrx_mode = INCRX_UNDEF_LENGTH_BURST_MODE;
 		dwc->incrx_size = max(dwc->incrx_size, val);
 	}
 }
diff --git a/drivers/usb/dwc3/dwc3-generic.c b/drivers/usb/dwc3/dwc3-generic.c
index 7f0af05855..5236dea29d 100644
--- a/drivers/usb/dwc3/dwc3-generic.c
+++ b/drivers/usb/dwc3/dwc3-generic.c
@@ -7,26 +7,32 @@
  * Based on dwc3-omap.c.
  */
 
+#define LOG_CATEGORY UCLASS_USB
+
+#include <asm/gpio.h>
+#include <clk.h>
 #include <common.h>
 #include <cpu_func.h>
-#include <log.h>
 #include <dm.h>
 #include <dm/device-internal.h>
+#include <dm/device_compat.h>
 #include <dm/lists.h>
 #include <dwc3-uboot.h>
 #include <generic-phy.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <log.h>
 #include <malloc.h>
+#include <regmap.h>
+#include <reset.h>
+#include <syscon.h>
 #include <usb.h>
+#include <usb/xhci.h>
 #include "core.h"
 #include "gadget.h"
-#include <reset.h>
-#include <clk.h>
-#include <usb/xhci.h>
-#include <asm/gpio.h>
 
 #include "dwc3-generic.h"
 
@@ -173,7 +179,7 @@ static int dwc3_generic_of_to_plat(struct udevice *dev)
 
 	plat->maximum_speed = usb_get_maximum_speed(node);
 	if (plat->maximum_speed == USB_SPEED_UNKNOWN) {
-		pr_info("No USB maximum speed specified. Using super speed\n");
+		dev_info(dev, "No USB maximum speed specified. Using super speed\n");
 		plat->maximum_speed = USB_SPEED_SUPER;
 	}
 
@@ -183,7 +189,7 @@ static int dwc3_generic_of_to_plat(struct udevice *dev)
 		node = dev_ofnode(dev->parent);
 		plat->dr_mode = usb_get_dr_mode(node);
 		if (plat->dr_mode == USB_DR_MODE_UNKNOWN) {
-			pr_err("Invalid usb mode setup\n");
+			dev_err(dev, "Invalid usb mode setup\n");
 			return -ENODEV;
 		}
 	}
@@ -406,6 +412,62 @@ struct dwc3_glue_ops ti_ops = {
 	.glue_configure = dwc3_ti_glue_configure,
 };
 
+void dwc3_stm32_glue_configure(struct udevice *dev, int index, enum usb_dr_mode mode)
+{
+#define SYSCFG_USB3DRCR_USB2ONLYH_MASK        BIT(3U) /*!< 0x00000008 : USB2-only Mode for Host */
+#define SYSCFG_USB3DRCR_USB2ONLYD_MASK        BIT(4U) /*!< 0x00000010 : USB2-only Mode for Device */
+	int ret;
+	struct regmap *regmap;
+	struct dwc3_glue_data *glue = dev_get_plat(dev);
+	u32 syscfg_usb3drcr_reg_off;
+	bool usb2only_conf;
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "unable to find regmap\n");
+		return;
+	}
+	ret = ofnode_count_phandle_with_args(ofnode_first_subnode(dev_ofnode(dev)),
+					     "phys", "#phy-cells", 0);
+	if (ret < 1) {
+		dev_err(dev, "unable to find phys\n");
+		return;
+	}
+	if (ret < 2)
+		usb2only_conf = true;
+	else
+		usb2only_conf = false;
+	dev_info(dev, "configured in %s mode\n", usb2only_conf ? "usb2" : "usb3");
+	ret = dev_read_u32_index(dev, "st,syscfg", 1, &syscfg_usb3drcr_reg_off);
+	if (ret) {
+		dev_err(dev, "Can't get sysconfig usb3drcr offset (%d)\n", ret);
+		return;
+	}
+	dev_dbg(dev, "syscfg-usb3drcr-reg offset 0x%x\n", syscfg_usb3drcr_reg_off);
+	ret = regmap_update_bits(regmap, syscfg_usb3drcr_reg_off, SYSCFG_USB3DRCR_USB2ONLYD_MASK |
+			SYSCFG_USB3DRCR_USB2ONLYH_MASK,
+			FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYD_MASK, usb2only_conf ? 1 : 0) |
+			FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYH_MASK, usb2only_conf ? 1 : 0));
+	if (ret) {
+		dev_err(dev, "regmap_write error: %d\n", ret);
+		return;
+	}
+	// Assert + Deassert Reset for DWC3-ctrl to sample syscfg settings
+	ret = reset_assert_bulk(&glue->resets);
+	if (ret) {
+		dev_err(dev, "reset_assert_bulk error: %d\n", ret);
+		return;
+	}
+	ret = reset_deassert_bulk(&glue->resets);
+	if (ret) {
+		dev_err(dev, "reset_deassert_bulk error: %d\n", ret);
+		return;
+	}
+}
+
+struct dwc3_glue_ops stm32_ops = {
+	.glue_configure = dwc3_stm32_glue_configure,
+};
+
 static int dwc3_rk_glue_get_ctrl_dev(struct udevice *dev, ofnode *node)
 {
 	*node = dev_ofnode(dev);
@@ -538,7 +600,7 @@ int dwc3_glue_probe(struct udevice *dev)
 		ret = generic_phy_init(&phy);
 		if (ret)
 			return ret;
-	} else if (ret != -ENOENT && ret != -ENODATA) {
+	} else if (ret != -ENOENT && ret != -ENODATA && ret != -EINVAL) {
 		debug("could not get phy (err %d)\n", ret);
 		return ret;
 	} else {
@@ -615,6 +677,7 @@ static const struct udevice_id dwc3_glue_ids[] = {
 	{ .compatible = "fsl,imx8mp-dwc3", .data = (ulong)&imx8mp_ops },
 	{ .compatible = "fsl,imx8mq-dwc3" },
 	{ .compatible = "intel,tangier-dwc3" },
+	{ .compatible = "st,stm32mp25-dwc3", .data = (ulong)&stm32_ops },
 	{ }
 };
 
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index eb416b832a..97d5a27928 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -2455,6 +2455,10 @@ static irqreturn_t dwc3_process_event_buf(struct dwc3 *dwc, u32 buf)
 	evt = dwc->ev_buffs[buf];
 	left = evt->count;
 
+	/* Invalidate the evt->buf area before reading */
+	invalidate_dcache_range((uintptr_t)evt->buf,
+				(uintptr_t)evt->buf + ROUND(evt->length, CACHELINE_SIZE));
+
 	if (!(evt->flags & DWC3_EVENT_PENDING))
 		return IRQ_NONE;
 
diff --git a/drivers/usb/gadget/dwc2_udc_otg.c b/drivers/usb/gadget/dwc2_udc_otg.c
index 2bf7ed8d60..cb00335572 100644
--- a/drivers/usb/gadget/dwc2_udc_otg.c
+++ b/drivers/usb/gadget/dwc2_udc_otg.c
@@ -24,8 +24,10 @@
 #include <log.h>
 #include <malloc.h>
 #include <reset.h>
+#include <typec.h>
 #include <dm/device_compat.h>
 #include <dm/devres.h>
+#include <wait_bit.h>
 #include <linux/bug.h>
 #include <linux/delay.h>
 
@@ -463,13 +465,24 @@ static void reconfig_usbd(struct dwc2_udc *dev)
 {
 	/* 2. Soft-reset OTG Core and then unreset again. */
 	int i;
-	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
+	unsigned int uTemp;
 	uint32_t dflt_gusbcfg;
 	uint32_t rx_fifo_sz, tx_fifo_sz, np_tx_fifo_sz;
 	u32 max_hw_ep;
 	int pdata_hw_ep;
+	int ret, snpsid = readl(&reg->gsnpsid); /* Read SNPSID before performing core reset */
 
 	debug("Resetting OTG controller\n");
+	writel(CORE_SOFT_RESET, &reg->grstctl);
+	if ((snpsid & SNPSID_REV_MASK) >=
+		(SNPSID_REV_VER_4_20a & SNPSID_REV_MASK)) {
+		ret = wait_for_bit_le32(&reg->grstctl, GRSTCTL_CSRSTDONE,
+					true, 1000, false);
+		if (ret == 0)
+			clrbits_le32(&reg->grstctl, CORE_SOFT_RESET);
+		else
+			pr_warn("%s: Timeout!\n", __func__);
+	}
 
 	dflt_gusbcfg =
 		0<<15		/* PHY Low Power Clock sel*/
@@ -990,6 +1003,7 @@ static void dwc2_phy_shutdown(struct udevice *dev, struct phy_bulk *phys)
 static int dwc2_udc_otg_of_to_plat(struct udevice *dev)
 {
 	struct dwc2_plat_otg_data *plat = dev_get_plat(dev);
+	struct udevice *typec;
 	ulong drvdata;
 	void (*set_params)(struct dwc2_plat_otg_data *data);
 	int ret;
@@ -1018,11 +1032,23 @@ static int dwc2_udc_otg_of_to_plat(struct udevice *dev)
 			return ret;
 	}
 
-	plat->force_b_session_valid =
-		dev_read_bool(dev, "u-boot,force-b-session-valid");
+	/*
+	 * check for High speed port/endpoint subnode presence and retrieve Type-C
+	 * device if exist. HS port subnode is always port number 0 => port@0
+	 */
+	ret = typec_get_device_from_usb(dev, &typec, 0);
+	if (!ret) {
+		ret = typec_get_data_role(typec, 0);
+		plat->force_b_session_valid = (ret == TYPEC_DEVICE);
+	} else {
+		enum usb_dr_mode dft_mode = usb_get_role_switch_default_mode(dev_ofnode(dev));
 
-	plat->force_vbus_detection =
-		dev_read_bool(dev, "u-boot,force-vbus-detection");
+		plat->force_b_session_valid =
+			(dft_mode == USB_DR_MODE_PERIPHERAL) ||
+			dev_read_bool(dev, "u-boot,force-b-session-valid");
+		plat->force_vbus_detection =
+			dev_read_bool(dev, "u-boot,force-vbus-detection");
+	}
 
 	/* force plat according compatible */
 	drvdata = dev_get_driver_data(dev);
@@ -1049,6 +1075,22 @@ static void dwc2_set_stm32mp1_hsotg_params(struct dwc2_plat_otg_data *p)
 		p->usb_gusbcfg |= 1 << 30; /* FDMOD: Force device mode */
 }
 
+static void dwc2_set_stm32mp21_hsotg_params(struct dwc2_plat_otg_data *p)
+{
+	p->activate_stm_ggpio_idpullup_dis = true;
+	p->activate_stm_ggpio_vbvaloval = true;
+	p->usb_gusbcfg =
+		0 << 15		/* PHY Low Power Clock sel*/
+		| 0x9 << 10	/* USB Turnaround time (0x9 for HS phy) */
+		| 0 << 9	/* [0:HNP disable,1:HNP enable]*/
+		| 0 << 8	/* [0:SRP disable 1:SRP enable]*/
+		| 0 << 6	/* 0: high speed utmi+, 1: full speed serial*/
+		| 0x7 << 0;	/* FS timeout calibration**/
+
+	if (p->force_b_session_valid)
+		p->usb_gusbcfg |= 1 << 30; /* FDMOD: Force device mode */
+}
+
 static int dwc2_udc_otg_reset_init(struct udevice *dev,
 				   struct reset_ctl_bulk *resets)
 {
@@ -1155,6 +1197,12 @@ static int dwc2_udc_otg_probe(struct udevice *dev)
 		}
 	}
 
+	if (plat->activate_stm_ggpio_idpullup_dis)
+		setbits_le32(&usbotg_reg->ggpio, GGPIO_STM32_OTG_GCCFG_IDPULLUP_DIS);
+
+	if (plat->activate_stm_ggpio_vbvaloval && plat->force_b_session_valid)
+		setbits_le32(&usbotg_reg->ggpio, GGPIO_STM32_OTG_GCCFG_VBVALOVAL);
+
 	ret = dwc2_udc_probe(plat);
 	if (ret)
 		return ret;
@@ -1186,6 +1234,8 @@ static const struct udevice_id dwc2_udc_otg_ids[] = {
 	{ .compatible = "brcm,bcm2835-usb" },
 	{ .compatible = "st,stm32mp15-hsotg",
 	  .data = (ulong)dwc2_set_stm32mp1_hsotg_params },
+	{ .compatible = "st,stm32mp21-hsotg",
+	  .data = (ulong)dwc2_set_stm32mp21_hsotg_params },
 	{},
 };
 
diff --git a/drivers/usb/gadget/dwc2_udc_otg_regs.h b/drivers/usb/gadget/dwc2_udc_otg_regs.h
index 9ca6f42375..73ff1b06c5 100644
--- a/drivers/usb/gadget/dwc2_udc_otg_regs.h
+++ b/drivers/usb/gadget/dwc2_udc_otg_regs.h
@@ -63,24 +63,26 @@ struct dwc2_usbotg_reg {
 	u32 gnptxfsiz; /* Non-Periodic Transmit FIFO Size */
 	u8  res0[12];
 	u32 ggpio;     /* 0x038 */
-	u8  res1[20];
+	u8  res1[4];
+	u32 gsnpsid;   /* 0x040 */
+	u8  res2[12];
 	u32 ghwcfg4; /* User HW Config4 */
-	u8  res2[176];
+	u8  res3[176];
 	u32 dieptxf[15]; /* Device Periodic Transmit FIFO size register */
-	u8  res3[1728];
+	u8  res4[1728];
 	/* Device Configuration */
 	u32 dcfg; /* Device Configuration Register */
 	u32 dctl; /* Device Control */
 	u32 dsts; /* Device Status */
-	u8  res4[4];
+	u8  res5[4];
 	u32 diepmsk; /* Device IN Endpoint Common Interrupt Mask */
 	u32 doepmsk; /* Device OUT Endpoint Common Interrupt Mask */
 	u32 daint; /* Device All Endpoints Interrupt */
 	u32 daintmsk; /* Device All Endpoints Interrupt Mask */
-	u8  res5[224];
+	u8  res6[224];
 	struct dwc2_dev_in_endp in_endp[16];
 	struct dwc2_dev_out_endp out_endp[16];
-	u8  res6[768];
+	u8  res7[768];
 	struct ep_fifo ep[16];
 };
 
@@ -118,6 +120,7 @@ struct dwc2_usbotg_reg {
 /* DWC2_UDC_OTG_GRSTCTL */
 #define AHB_MASTER_IDLE		(1u<<31)
 #define CORE_SOFT_RESET		(0x1<<0)
+#define GRSTCTL_CSRSTDONE	BIT(29)
 
 /* DWC2_UDC_OTG_GINTSTS/DWC2_UDC_OTG_GINTMSK core interrupt register */
 #define INT_RESUME			(1u<<31)
@@ -292,5 +295,12 @@ struct dwc2_usbotg_reg {
 /* OTG general core configuration register (OTG_GCCFG:0x38) for STM32MP1 */
 #define GGPIO_STM32_OTG_GCCFG_VBDEN               BIT(21)
 #define GGPIO_STM32_OTG_GCCFG_IDEN                BIT(22)
-
+/* OTG general core configuration register (OTG_GCCFG:0x38) for STM32MP21 */
+#define GGPIO_STM32_OTG_GCCFG_VBVALOVAL		  BIT(23)
+#define GGPIO_STM32_OTG_GCCFG_IDPULLUP_DIS        BIT(28)
+
+/*Synopsys ID Register (GSNPSID) */
+#define SNPSID_REV_VER_4_20a			(0x4f54400a)
+#define SNPSID_REV_MASK				(0x0000ffff)
+#define SNPSID_DEVID_OFFSET			12
 #endif
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index f46829eb7a..4fc877add0 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -678,6 +678,7 @@ static int sleep_thread(struct fsg_common *common)
 				return -EIO;
 
 			k = 0;
+			schedule();
 		}
 
 		usb_gadget_handle_interrupts(controller_index);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 1a883babf4..062c4cd55e 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -461,3 +461,17 @@ config USB_MAX_CONTROLLER_COUNT
 	depends on USB_EHCI_FSL || USB_XHCI_FSL || \
 		(SPL_USB_HOST && !DM_SPL_USB) || (USB_HOST && !DM_USB)
 	default 1
+
+config USB_STM32_USBH
+	bool "Support for STMicroelectronics STM32 Family USBH controller"
+	depends on DM && OF_CONTROL
+	select USB_HOST
+	select USB_EHCI_HCD
+	select USB_EHCI_GENERIC
+	select USB_OHCI_HCD
+	select USB_OHCI_GENERIC
+	help
+	  STM32 Family USB 2.0 Host Controller includes generic EHCI and OHCI
+	  controller blocks to support High-Speed and Full+Low-Speed respectively
+	  This driver is to configure the glue logic to enable EHCI+OHCI controllers
+	  inside the USBH block.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 8dad36f936..e8ae1d618c 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -58,3 +58,6 @@ obj-$(CONFIG_USB_XHCI_OCTEON) += dwc3-octeon-glue.o
 
 # designware
 obj-$(CONFIG_USB_DWC2) += dwc2.o
+
+# STM32
+obj-$(CONFIG_USB_STM32_USBH) += usbh-stm32.o
diff --git a/drivers/usb/host/dwc2.c b/drivers/usb/host/dwc2.c
index 9818f9be94..06427e0ee7 100644
--- a/drivers/usb/host/dwc2.c
+++ b/drivers/usb/host/dwc2.c
@@ -159,6 +159,7 @@ static void dwc_otg_core_reset(struct udevice *dev,
 			       struct dwc2_core_regs *regs)
 {
 	int ret;
+	uint32_t snpsid;
 
 	/* Wait for AHB master IDLE state. */
 	ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_AHBIDLE,
@@ -166,10 +167,20 @@ static void dwc_otg_core_reset(struct udevice *dev,
 	if (ret)
 		dev_info(dev, "%s: Timeout!\n", __func__);
 
+	snpsid = readl(&regs->gsnpsid);
+
 	/* Core Soft Reset */
 	writel(DWC2_GRSTCTL_CSFTRST, &regs->grstctl);
-	ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_CSFTRST,
-				false, 1000, false);
+	if ((snpsid & DWC2_SNPSID_REV_MASK) <
+		(DWC2_SNPSID_REV_VER_4_20a & DWC2_SNPSID_REV_MASK)) {
+		ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_CSFTRST,
+					false, 1000, false);
+	} else {
+		ret = wait_for_bit_le32(&regs->grstctl, DWC2_GRSTCTL_CSRSTDONE,
+					true, 1000, false);
+		if (ret == 0)
+			clrbits_le32(&regs->grstctl, DWC2_GRSTCTL_CSFTRST);
+	}
 	if (ret)
 		dev_info(dev, "%s: Timeout!\n", __func__);
 
@@ -1182,7 +1193,8 @@ static int dwc2_init_common(struct udevice *dev, struct dwc2_priv *priv)
 		 snpsid >> 12 & 0xf, snpsid & 0xfff);
 
 	if ((snpsid & DWC2_SNPSID_DEVID_MASK) != DWC2_SNPSID_DEVID_VER_2xx &&
-	    (snpsid & DWC2_SNPSID_DEVID_MASK) != DWC2_SNPSID_DEVID_VER_3xx) {
+	    (snpsid & DWC2_SNPSID_DEVID_MASK) != DWC2_SNPSID_DEVID_VER_3xx &&
+	    (snpsid & DWC2_SNPSID_DEVID_MASK) != DWC2_SNPSID_DEVID_VER_4xx) {
 		dev_info(dev, "SNPSID invalid (not DWC2 OTG device): %08x\n",
 			 snpsid);
 		return -ENODEV;
diff --git a/drivers/usb/host/dwc2.h b/drivers/usb/host/dwc2.h
index 6f022e33a1..15eb196149 100644
--- a/drivers/usb/host/dwc2.h
+++ b/drivers/usb/host/dwc2.h
@@ -207,6 +207,7 @@ struct dwc2_core_regs {
 #define DWC2_GRSTCTL_TXFFLSH_OFFSET			5
 #define DWC2_GRSTCTL_TXFNUM_MASK			(0x1F << 6)
 #define DWC2_GRSTCTL_TXFNUM_OFFSET			6
+#define DWC2_GRSTCTL_CSRSTDONE				(1 << 29)
 #define DWC2_GRSTCTL_DMAREQ				(1 << 30)
 #define DWC2_GRSTCTL_DMAREQ_OFFSET			30
 #define DWC2_GRSTCTL_AHBIDLE				(1 << 31)
@@ -739,7 +740,10 @@ struct dwc2_core_regs {
 #define DWC2_PCGCCTL_DEEP_SLEEP_OFFSET			7
 #define DWC2_SNPSID_DEVID_VER_2xx			(0x4f542 << 12)
 #define DWC2_SNPSID_DEVID_VER_3xx			(0x4f543 << 12)
+#define DWC2_SNPSID_DEVID_VER_4xx			(0x4f544 << 12)
 #define DWC2_SNPSID_DEVID_MASK				(0xfffff << 12)
+#define DWC2_SNPSID_REV_VER_4_20a			(0x4f54400a)
+#define DWC2_SNPSID_REV_MASK				(0x0000ffff)
 #define DWC2_SNPSID_DEVID_OFFSET			12
 
 /* Host controller specific */
diff --git a/drivers/usb/host/ehci-generic.c b/drivers/usb/host/ehci-generic.c
index a765a307a3..ee81fd65e4 100644
--- a/drivers/usb/host/ehci-generic.c
+++ b/drivers/usb/host/ehci-generic.c
@@ -100,6 +100,12 @@ static int ehci_usb_probe(struct udevice *dev)
 	if (err)
 		goto regulator_err;
 
+	err = generic_phy_set_mode(&priv->phy, PHY_MODE_USB_HOST, 0);
+	if (err) {
+		dev_dbg(dev, "failed to set mode on usb phy\n");
+		goto phy_err;
+	}
+
 	hccr = map_physmem(dev_read_addr(dev), 0x100, MAP_NOCACHE);
 	hcor = (struct ehci_hcor *)((uintptr_t)hccr +
 				    HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9839aa1749..d973eae30e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -178,8 +178,26 @@ static int handshake(uint32_t *ptr, uint32_t mask, uint32_t done, int usec)
 
 static int ehci_reset(struct ehci_ctrl *ctrl)
 {
-	uint32_t cmd;
-	int ret = 0;
+	uint32_t cmd, reg;
+	int ret = 0, i;
+	int max_ports = HCS_N_PORTS(ehci_readl(&ctrl->hccr->cr_hcsparams));
+
+	for (i = 0; i < max_ports; i++) {
+		reg = ehci_readl(&ctrl->hcor->or_portsc[i]);
+		if (reg & EHCI_PS_SUSP) {
+			reg &= ~EHCI_PS_CLEAR;
+			reg |= EHCI_PS_FPR;
+			ehci_writel(&ctrl->hcor->or_portsc[i], reg);
+		}
+	}
+	mdelay(USB_RESUME_TIMEOUT);
+	for (i = 0; i < max_ports; i++) {
+		reg = ehci_readl(&ctrl->hcor->or_portsc[i]);
+		if (reg & EHCI_PS_FPR) {
+			reg &= ~(EHCI_PS_CLEAR | EHCI_PS_SUSP | EHCI_PS_FPR);
+			ehci_writel(&ctrl->hcor->or_portsc[i], reg);
+		}
+	}
 
 	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
 	cmd = (cmd & ~CMD_RUN) | CMD_RESET;
diff --git a/drivers/usb/host/ohci-generic.c b/drivers/usb/host/ohci-generic.c
index 2d8d38ce9a..57d6bb9f2a 100644
--- a/drivers/usb/host/ohci-generic.c
+++ b/drivers/usb/host/ohci-generic.c
@@ -16,79 +16,49 @@
 
 struct generic_ohci {
 	ohci_t ohci;
-	struct clk *clocks;	/* clock list */
-	struct reset_ctl *resets; /* reset list */
+	struct clk_bulk clocks;	/* clock list */
+	struct reset_ctl_bulk resets; /* reset list */
 	struct phy phy;
-	int clock_count;	/* number of clock in clock list */
-	int reset_count;	/* number of reset in reset list */
 };
 
 static int ohci_usb_probe(struct udevice *dev)
 {
 	struct ohci_regs *regs = dev_read_addr_ptr(dev);
 	struct generic_ohci *priv = dev_get_priv(dev);
-	int i, err, ret, clock_nb, reset_nb;
-
-	err = 0;
-	priv->clock_count = 0;
-	clock_nb = dev_count_phandle_with_args(dev, "clocks", "#clock-cells",
-					       0);
-	if (clock_nb > 0) {
-		priv->clocks = devm_kcalloc(dev, clock_nb, sizeof(struct clk),
-					    GFP_KERNEL);
-		if (!priv->clocks)
-			return -ENOMEM;
-
-		for (i = 0; i < clock_nb; i++) {
-			err = clk_get_by_index(dev, i, &priv->clocks[i]);
-			if (err < 0)
-				break;
-
-			err = clk_enable(&priv->clocks[i]);
-			if (err && err != -ENOSYS) {
-				dev_err(dev, "failed to enable clock %d\n", i);
-				clk_free(&priv->clocks[i]);
-				goto clk_err;
-			}
-			priv->clock_count++;
-		}
-	} else if (clock_nb != -ENOENT) {
-		dev_err(dev, "failed to get clock phandle(%d)\n", clock_nb);
-		return clock_nb;
+	int err, ret;
+
+	ret = clk_get_bulk(dev, &priv->clocks);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Failed to get clocks (ret=%d)\n", ret);
+		return ret;
+	}
+
+	err = clk_enable_bulk(&priv->clocks);
+	if (err) {
+		dev_err(dev, "Failed to enable clocks (err=%d)\n", err);
+		goto clk_err;
 	}
 
-	priv->reset_count = 0;
-	reset_nb = dev_count_phandle_with_args(dev, "resets", "#reset-cells",
-					       0);
-	if (reset_nb > 0) {
-		priv->resets = devm_kcalloc(dev, reset_nb,
-					    sizeof(struct reset_ctl),
-					    GFP_KERNEL);
-		if (!priv->resets)
-			return -ENOMEM;
-
-		for (i = 0; i < reset_nb; i++) {
-			err = reset_get_by_index(dev, i, &priv->resets[i]);
-			if (err < 0)
-				break;
-
-			err = reset_deassert(&priv->resets[i]);
-			if (err) {
-				dev_err(dev, "failed to deassert reset %d\n", i);
-				reset_free(&priv->resets[i]);
-				goto reset_err;
-			}
-			priv->reset_count++;
-		}
-	} else if (reset_nb != -ENOENT) {
-		dev_err(dev, "failed to get reset phandle(%d)\n", reset_nb);
+	err = reset_get_bulk(dev, &priv->resets);
+	if (err && err != -ENOENT) {
+		dev_err(dev, "failed to get resets (err=%d)\n", err);
 		goto clk_err;
 	}
 
+	err = reset_deassert_bulk(&priv->resets);
+	if (err) {
+		dev_err(dev, "failed to get deassert resets (err=%d)\n", err);
+		goto reset_err;
+	}
+
 	err = generic_setup_phy(dev, &priv->phy, 0);
 	if (err)
 		goto reset_err;
 
+	err = generic_phy_set_mode(&priv->phy, PHY_MODE_USB_HOST, 0);
+	if (err)
+		goto phy_err;
+
 	err = ohci_register(dev, regs);
 	if (err)
 		goto phy_err;
@@ -101,13 +71,13 @@ phy_err:
 		dev_err(dev, "failed to shutdown usb phy\n");
 
 reset_err:
-	ret = reset_release_all(priv->resets, priv->reset_count);
+	ret = reset_release_bulk(&priv->resets);
 	if (ret)
-		dev_err(dev, "failed to assert all resets\n");
+		dev_err(dev, "failed to release resets (ret=%d)\n", ret);
 clk_err:
-	ret = clk_release_all(priv->clocks, priv->clock_count);
+	ret = clk_release_bulk(&priv->clocks);
 	if (ret)
-		dev_err(dev, "failed to disable all clocks\n");
+		dev_err(dev, "failed to release clocks (ret=%d)\n", ret);
 
 	return err;
 }
@@ -125,11 +95,11 @@ static int ohci_usb_remove(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	ret = reset_release_all(priv->resets, priv->reset_count);
+	ret = reset_release_bulk(&priv->resets);
 	if (ret)
 		return ret;
 
-	return clk_release_all(priv->clocks, priv->clock_count);
+	return clk_release_bulk(&priv->clocks);
 }
 
 static const struct udevice_id ohci_usb_ids[] = {
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 3f4418198c..883c8215ae 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -935,7 +935,8 @@ static void td_submit_job(ohci_t *ohci, struct usb_device *dev,
 	__u32 info = 0;
 	unsigned int toggle = 0;
 
-	flush_dcache_buffer(buffer, data_len);
+	if (data_len)
+		flush_dcache_buffer(buffer, data_len);
 
 	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
 	 * bits for resetting */
diff --git a/drivers/usb/host/usb-uclass.c b/drivers/usb/host/usb-uclass.c
index 7a03435ba7..e5fe949f25 100644
--- a/drivers/usb/host/usb-uclass.c
+++ b/drivers/usb/host/usb-uclass.c
@@ -249,6 +249,37 @@ static void remove_inactive_children(struct uclass *uc, struct udevice *bus)
 	}
 }
 
+static int usb_probe_companion(struct udevice *bus)
+{
+	struct udevice *companion_dev;
+	int ret;
+
+	/*
+	 * Enforce optional companion controller is marked as such in order to
+	 * 1st scan the primary controller, before the companion controller
+	 * (ownership is given to companion when low or full speed devices
+	 * have been detected).
+	 */
+	ret = uclass_get_device_by_phandle(UCLASS_USB, bus, "companion", &companion_dev);
+	if (!ret) {
+		struct usb_bus_priv *companion_bus_priv;
+
+		debug("%s is the companion of %s\n", companion_dev->name, bus->name);
+		companion_bus_priv = dev_get_uclass_priv(companion_dev);
+		companion_bus_priv->companion = true;
+	} else if (ret && ret != -ENOENT && ret != -ENODEV) {
+		/*
+		 * Treat everything else than no companion or disabled
+		 * companion as an error. (It may not be enabled on boards
+		 * that have a High-Speed HUB to handle FS and LS traffic).
+		 */
+		printf("Failed to get companion (ret=%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 int usb_init(void)
 {
 	int controllers_initialized = 0;
@@ -299,6 +330,11 @@ int usb_init(void)
 			printf("probe failed, error %d\n", ret);
 			continue;
 		}
+
+		ret = usb_probe_companion(bus);
+		if (ret)
+			continue;
+
 		controllers_initialized++;
 		usb_started = true;
 	}
diff --git a/drivers/usb/host/usbh-stm32.c b/drivers/usb/host/usbh-stm32.c
new file mode 100644
index 0000000000..f7ae0ad67b
--- /dev/null
+++ b/drivers/usb/host/usbh-stm32.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STM32 USB2 EHCI/OHCI (USBH) controller glue driver
+ *
+ * Copyright (C) 2023 STMicroelectronics – All Rights Reserved
+ *
+ * Author: Pankaj Dev <pankaj.dev@st.com>
+ */
+
+#define LOG_CATEGORY UCLASS_USB
+
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/devres.h>
+#include <dm/ofnode.h>
+#include <linux/bitfield.h>
+#include <regmap.h>
+#include <reset.h>
+#include <syscon.h>
+
+#define SYSCFG_USBHCR_OVRCUR_POLARITY_MASK      BIT(0)
+#define SYSCFG_USBHCR_VBUSEN_POLARITY_MASK      BIT(1)
+
+/**
+ * struct stm32_usbh_data - usbh-stm32 driver private structure
+ * @dev:		device pointer
+ * @regmap:		regmap pointer for getting syscfg
+ * @syscfg_usbhcr_reg_off:	usbhcr syscfg control offset
+ * @vbusen_polarity_low:	vbusen signal polarity
+ * @ovrcur_polarity_low:	ovrcur signal polarity
+ */
+struct stm32_usbh_data {
+	struct udevice *dev;
+	struct regmap *regmap;
+	int syscfg_usbhcr_reg_off;
+	bool vbusen_polarity_low;
+	bool ovrcur_polarity_low;
+};
+
+/**
+ * stm32_usbh_init: init the controller via glue logic
+ * @usbh_data: driver private structure
+ */
+static int stm32_usbh_init(struct stm32_usbh_data *usbh_data)
+{
+	return regmap_update_bits(usbh_data->regmap, usbh_data->syscfg_usbhcr_reg_off,
+				  SYSCFG_USBHCR_OVRCUR_POLARITY_MASK |
+				  SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+				  FIELD_PREP(SYSCFG_USBHCR_OVRCUR_POLARITY_MASK,
+					     usbh_data->ovrcur_polarity_low) |
+				  FIELD_PREP(SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+					     usbh_data->vbusen_polarity_low));
+}
+
+static int stm32_usbh_probe(struct udevice *dev)
+{
+	ofnode node = dev_ofnode(dev);
+	struct regmap *regmap;
+	struct stm32_usbh_data *usbh_data = dev_get_plat(dev);
+	int ret;
+
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "no st,syscfg node found(%ld)\n", PTR_ERR(regmap));
+		ret = PTR_ERR(regmap);
+		return ret;
+	}
+
+	ret = ofnode_read_u32_index(node, "st,syscfg", 1, &usbh_data->syscfg_usbhcr_reg_off);
+	if (ret) {
+		dev_err(dev, "can't get usbhcr offset(%d)\n", ret);
+		return ret;
+	}
+
+	dev_vdbg(dev, "syscfg-usbhcr-reg offset 0x%x\n", usbh_data->syscfg_usbhcr_reg_off);
+
+	usbh_data->dev = dev;
+	usbh_data->regmap = regmap;
+
+	if (ofnode_read_bool(node, "st,vbusen-active-low"))
+		usbh_data->vbusen_polarity_low = true;
+	if (ofnode_read_bool(node, "st,ovrcur-active-low"))
+		usbh_data->ovrcur_polarity_low = true;
+
+	/* ST USBH glue logic init */
+	ret = stm32_usbh_init(usbh_data);
+	if (ret) {
+		dev_err(dev, "err setting syscfg_usbhcr_reg(%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id stm32_usbh_ids[] = {
+	{ .compatible = "st,stm32mp25-usbh" },
+	{ .compatible = "st,stm32mp21-usbh" },
+	{ /* sentinel */ },
+};
+
+U_BOOT_DRIVER(stm32_usbh_glue) = {
+	.name = "stm32-usbh-glue",
+	.id = UCLASS_NOP,
+	.of_match = stm32_usbh_ids,
+	.bind = dm_scan_fdt_dev,
+	.probe = stm32_usbh_probe,
+	.plat_auto = sizeof(struct stm32_usbh_data),
+};
diff --git a/drivers/usb/typec/Kconfig b/drivers/usb/typec/Kconfig
new file mode 100644
index 0000000000..c9930320ca
--- /dev/null
+++ b/drivers/usb/typec/Kconfig
@@ -0,0 +1,24 @@
+menuconfig TYPEC
+	bool "USB Type-C support"
+	depends on DM
+	help
+	  Enable this configurations option if you have USB Type-C connectors on
+	  your system and 1) you know your USB Type-C hardware requires OS
+	  control (a driver) to function, or 2) if you need to be able to read
+	  the status of the USB Type-C ports in your system, or 3) if you need
+	  to be able to swap the power role (decide are you supplying or
+	  consuming power over the cable) or data role (host or device) when
+	  both roles are supported.
+
+if TYPEC
+
+config TYPEC_STUSB160X
+    bool "STMicroelectronics STUSB160x Type-C controller driver"
+	depends on DM && DM_I2C
+	help
+	  Say Y or M here if your system has STMicroelectronics STUSB160x
+	  Type-C port controller.
+
+source "drivers/usb/typec/ucsi/Kconfig"
+
+endif
diff --git a/drivers/usb/typec/Makefile b/drivers/usb/typec/Makefile
new file mode 100644
index 0000000000..e0b66ae8ef
--- /dev/null
+++ b/drivers/usb/typec/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_TYPEC) += typec-uclass.o
+obj-$(CONFIG_TYPEC_STUSB160X) += typec-stusb160x.o
+obj-$(CONFIG_TYPEC_UCSI) += ucsi/
diff --git a/drivers/usb/typec/typec-stusb160x.c b/drivers/usb/typec/typec-stusb160x.c
new file mode 100644
index 0000000000..28e9bf1c74
--- /dev/null
+++ b/drivers/usb/typec/typec-stusb160x.c
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_USB_TYPEC
+
+#include <common.h>
+#include <dm.h>
+#include <i2c.h>
+#include <typec.h>
+#include <dm/device_compat.h>
+
+#define STUSB160X_ALERT_STATUS			0x0B /* RC */
+#define STUSB160X_CC_CONNECTION			BIT(6)
+
+#define STUSB160X_CC_CONNECTION_STATUS_TRANS	0x0D /* RC */
+#define STUSB160X_CC_ATTACH_TRANS		BIT(0)
+
+#define STUSB160X_CC_CONNECTION_STATUS		0x0E /* RO */
+#define STUSB160X_CC_ATTACH			BIT(0)
+#define STUSB160X_CC_DATA_ROLE			BIT(2)
+
+#define STUSB160X_CC_POWER_MODE_CTRL		0x28 /* RW */
+#define STUSB160X_DUAL_WITH_ACCESSORY		3
+
+struct stusb160x_priv {
+	enum typec_state attached;
+	enum typec_data_role data_role;
+};
+
+static int stusb160x_get_status(struct udevice *dev, bool force)
+{
+	struct stusb160x_priv *priv = dev_get_priv(dev);
+	int alert, trans, status;
+
+	alert = dm_i2c_reg_read(dev, STUSB160X_ALERT_STATUS);
+	if (alert < 0)
+		return alert;
+
+	/* If no update, exit */
+	if ((!(alert & STUSB160X_CC_CONNECTION)) && !force)
+		goto exit;
+
+	trans = dm_i2c_reg_read(dev, STUSB160X_CC_CONNECTION_STATUS_TRANS);
+	if (trans < 0)
+		return trans;
+
+	status = dm_i2c_reg_read(dev, STUSB160X_CC_CONNECTION_STATUS);
+	if (status < 0)
+		return status;
+
+	priv->data_role = status & STUSB160X_CC_DATA_ROLE ? TYPEC_HOST : TYPEC_DEVICE;
+	priv->attached = status & STUSB160X_CC_ATTACH ? TYPEC_ATTACHED : TYPEC_UNATTACHED;
+exit:
+	dev_dbg(dev, "status: %s data role: %s\n",
+		priv->attached == TYPEC_ATTACHED ? "Attached" : "Unattached",
+		priv->data_role == TYPEC_HOST ? "Host" : "Device");
+
+	return 0;
+}
+
+static int stusb160x_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	struct stusb160x_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = stusb160x_get_status(dev, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->data_role;
+}
+
+static int stusb160x_is_attached(struct udevice *dev, u8 con_idx)
+{
+	struct stusb160x_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = stusb160x_get_status(dev, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->attached;
+}
+
+static u8 stusb160x_get_nb_connector(struct udevice *dev)
+{
+	/* only one connector supported */
+	return 1;
+}
+
+static int stusb160x_probe(struct udevice *dev)
+{
+	int power_mode_ctrl;
+	int ret;
+
+	/* configure STUSB160X_CC_POWER_MODE_CTRL */
+	power_mode_ctrl = dm_i2c_reg_read(dev, STUSB160X_CC_POWER_MODE_CTRL);
+	if (power_mode_ctrl < 0)
+		return power_mode_ctrl;
+
+	power_mode_ctrl |= STUSB160X_DUAL_WITH_ACCESSORY;
+	ret = dm_i2c_reg_write(dev, STUSB160X_CC_POWER_MODE_CTRL, power_mode_ctrl);
+	if (ret < 0)
+		return ret;
+
+	/* get current status : attached/unattached, device/host */
+	return stusb160x_get_status(dev, true);
+}
+
+static const struct typec_ops stusb160x_typec_ops = {
+	.is_attached = stusb160x_is_attached,
+	.get_data_role = stusb160x_get_data_role,
+	.get_nb_connector = stusb160x_get_nb_connector,
+};
+
+static const struct udevice_id typec_of_match[] = {
+	{ .compatible = "st,stusb1600"},
+	{}
+};
+
+U_BOOT_DRIVER(typec_stusb160x) = {
+	.id			= UCLASS_USB_TYPEC,
+	.name			= "typec_stusb160x",
+	.of_match		= typec_of_match,
+	.ops			= &stusb160x_typec_ops,
+	.priv_auto		= sizeof(struct stusb160x_priv),
+	.probe			= stusb160x_probe,
+};
diff --git a/drivers/usb/typec/typec-uclass.c b/drivers/usb/typec/typec-uclass.c
new file mode 100644
index 0000000000..6b870c7ff6
--- /dev/null
+++ b/drivers/usb/typec/typec-uclass.c
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_USB_TYPEC
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <typec.h>
+#include <dm/device_compat.h>
+#include <dm/device-internal.h>
+#include <dm/uclass-internal.h>
+
+int typec_get_device_from_usb(struct udevice *dev, struct udevice **typec, u8 index)
+{
+	ofnode node, child;
+	u32 endpoint_phandle;
+	u32 reg;
+	int ret;
+
+	/* 'port' nodes can be grouped under an optional 'ports' node */
+	node = dev_read_subnode(dev, "ports");
+	if (!ofnode_valid(node)) {
+		node = dev_read_subnode(dev, "port");
+	} else {
+		/* several 'port' nodes, found the requested port@index one */
+		ofnode_for_each_subnode(child, node) {
+			ofnode_read_u32(child, "reg", &reg);
+			if (index == reg) {
+				node = child;
+				break;
+			}
+		}
+		node = child;
+	}
+
+	if (!ofnode_valid(node)) {
+		dev_dbg(dev, "connector port or port@%d subnode not found\n", index);
+		return -ENODEV;
+	}
+
+	/* get endpoint node */
+	node = ofnode_first_subnode(node);
+	if (!ofnode_valid(node))
+		return -EINVAL;
+
+	ret = ofnode_read_u32(node, "remote-endpoint", &endpoint_phandle);
+	if (ret)
+		return ret;
+
+	/* retrieve connector endpoint phandle */
+	node = ofnode_get_by_phandle(endpoint_phandle);
+	if (!ofnode_valid(node))
+		return -EINVAL;
+	/*
+	 * Use a while to retrieve an USB Type-C device either at connector
+	 * level or just above (depending if UCSI uclass is used or not)
+	 */
+	while (ofnode_valid(node)) {
+		node = ofnode_get_parent(node);
+		if (!ofnode_valid(node)) {
+			dev_err(dev, "No UCLASS_USB_TYPEC for remote-endpoint\n");
+			return -EINVAL;
+		}
+
+		uclass_find_device_by_ofnode(UCLASS_USB_TYPEC, node, typec);
+		if (*typec)
+			break;
+	}
+
+	ret = device_probe(*typec);
+	if (ret) {
+		dev_err(dev, "Type-C won't probe (ret=%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int typec_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	const struct typec_ops *ops = device_get_ops(dev);
+	int ret;
+
+	if (!ops->get_data_role)
+		return -ENOSYS;
+
+	ret = ops->get_data_role(dev, con_idx);
+	dev_dbg(dev, "%s\n", ret == TYPEC_HOST ? "Host" : "Device");
+
+	return ret;
+}
+
+int typec_is_attached(struct udevice *dev, u8 con_idx)
+{
+	const struct typec_ops *ops = device_get_ops(dev);
+	int ret;
+
+	if (!ops->is_attached)
+		return -ENOSYS;
+
+	ret = ops->is_attached(dev, con_idx);
+	dev_dbg(dev, "%s\n", ret == TYPEC_ATTACHED ? "Attached" : "Not attached");
+
+	return ret;
+}
+
+int typec_get_nb_connector(struct udevice *dev)
+{
+	const struct typec_ops *ops = device_get_ops(dev);
+	int ret;
+
+	if (!ops->get_nb_connector)
+		return -ENOSYS;
+
+	ret = ops->get_nb_connector(dev);
+	dev_dbg(dev, "%d connector(s)\n", ret);
+
+	return ret;
+}
+
+UCLASS_DRIVER(typec) = {
+	.id	= UCLASS_USB_TYPEC,
+	.name	= "typec",
+};
diff --git a/drivers/usb/typec/ucsi/Kconfig b/drivers/usb/typec/ucsi/Kconfig
new file mode 100644
index 0000000000..928106b1db
--- /dev/null
+++ b/drivers/usb/typec/ucsi/Kconfig
@@ -0,0 +1,26 @@
+menuconfig TYPEC_UCSI
+	bool "USB Type-C Connector System Software Interface (UCSI)"
+	depends on DM && TYPEC
+	help
+	  USB Type-C Connector System Software Interface (UCSI) is a
+	  specification for an interface that allows the operating system to
+	  control the USB Type-C ports. On UCSI system the USB Type-C ports
+	  function autonomously by default, but in order to get the status of
+	  the ports and support basic operations like role swapping, the driver
+	  is required. UCSI is available on most of the new Intel based systems
+	  that are equipped with Embedded Controller and USB Type-C ports.
+
+	  UCSI specification does not define the interface method, so depending
+	  on the platform, ACPI, PCI, I2C, etc. may be used. Therefore this
+	  driver only provides the core part, and separate drivers are needed
+	  for every supported interface method.
+
+	  The UCSI specification can be downloaded from:
+	  https://www.intel.com/content/www/us/en/io/universal-serial-bus/usb-type-c-ucsi-spec.html
+
+config UCSI_STM32G0
+	bool "Support for STM32G0 UCSI controller"
+	depends on TYPEC_UCSI && DM_I2C
+	help
+	  This driver enables UCSI support on platforms that expose a STM32G0
+	  Type-C controller over I2C interface.
diff --git a/drivers/usb/typec/ucsi/Makefile b/drivers/usb/typec/ucsi/Makefile
new file mode 100644
index 0000000000..043000e238
--- /dev/null
+++ b/drivers/usb/typec/ucsi/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-y +=  ucsi-uclass.o
+obj-$(CONFIG_UCSI_STM32G0) += ucsi-stm32g0.o
diff --git a/drivers/usb/typec/ucsi/ucsi-stm32g0.c b/drivers/usb/typec/ucsi/ucsi-stm32g0.c
new file mode 100644
index 0000000000..e3a1bc4889
--- /dev/null
+++ b/drivers/usb/typec/ucsi/ucsi-stm32g0.c
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_UCSI
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <ucsi.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+
+static int stm32_ucsi_read(struct udevice *dev, unsigned int offset, void *val, size_t len)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
+	u8 reg = offset;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= chip->chip_addr,
+			.flags  = 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= chip->chip_addr,
+			.flags  = I2C_M_RD,
+			.len	= len,
+			.buf	= val,
+		},
+	};
+	int ret;
+
+	ret = dm_i2c_xfer(dev, msg, ARRAY_SIZE(msg));
+	if (ret)
+		dev_err(dev, "i2c read failed @offset 0x%x (%d)\n", offset, ret);
+
+	/*
+	 * Add this delay to ensure that PPM has completed the current command,
+	 * before sending it another one.
+	 */
+	udelay(20);
+
+	return ret;
+}
+
+static int stm32_ucsi_write(struct udevice *dev, unsigned int offset,
+			    const void *val, size_t len)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
+	struct i2c_msg msg[] = {
+		{
+			.addr	= chip->chip_addr,
+			.flags  = 0,
+		}
+	};
+	unsigned char *buf;
+	int ret;
+
+	buf = kzalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = offset;
+	memcpy(&buf[1], val, len);
+	msg[0].len = len + 1;
+	msg[0].buf = buf;
+
+	ret = dm_i2c_xfer(dev, msg, ARRAY_SIZE(msg));
+	kfree(buf);
+	if (ret)
+		dev_err(dev, "i2c write failed @offset 0x%x (%d)\n", offset, ret);
+
+	/*
+	 * Add this delay to ensure that PPM has completed the current command,
+	 * before sending it another one.
+	 */
+	mdelay(2);
+
+	return ret;
+}
+
+int stm32_ucsi_probe(struct udevice *dev)
+{
+	u16 ucsi_version;
+	int ret;
+
+	ret = stm32_ucsi_read(dev, UCSI_VERSION, &ucsi_version, sizeof(ucsi_version));
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(dev, "STM32G0 version 0x%x\n", ucsi_version);
+
+	return 0;
+}
+
+static const struct ucsi_ops stm32_ucsi_ops = {
+	.read = stm32_ucsi_read,
+	.write = stm32_ucsi_write,
+};
+
+static const struct udevice_id stm32_ucsi_of_match[] = {
+	{ .compatible = "st,stm32g0-typec"},
+	{}
+};
+
+U_BOOT_DRIVER(ucsi_stm32g0) = {
+	.id		= UCLASS_UCSI,
+	.name		= "ucsi-stm32g0",
+	.of_match	= stm32_ucsi_of_match,
+	.probe		= stm32_ucsi_probe,
+	.ops		= &stm32_ucsi_ops,
+	.bind		= dm_scan_fdt_dev,
+};
diff --git a/drivers/usb/typec/ucsi/ucsi-uclass.c b/drivers/usb/typec/ucsi/ucsi-uclass.c
new file mode 100644
index 0000000000..8744497ebf
--- /dev/null
+++ b/drivers/usb/typec/ucsi/ucsi-uclass.c
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * Code inspired from kernel drivers/usb/typec/ucsi/ucsi.c
+ *
+ */
+
+#define LOG_CATEGORY UCLASS_UCSI
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <typec.h>
+#include <ucsi.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+
+/*
+ * UCSI_TIMEOUT_US - PPM communication timeout
+ *
+ * Ideally we could use MIN_TIME_TO_RESPOND_WITH_BUSY (which is defined in UCSI
+ * specification) here as reference, but unfortunately we can't. It is very
+ * difficult to estimate the time it takes for the system to process the command
+ * before it is actually passed to the PPM.
+ */
+#define UCSI_TIMEOUT_US		50000000
+
+struct connector {
+	enum typec_state attached;
+	enum typec_data_role data_role;
+};
+
+struct ucsi_priv {
+	struct connector *con;
+	u8 nb_connector;
+};
+
+static int ucsi_read(struct udevice *dev, int offset, void *buf, int size)
+{
+	const struct ucsi_ops *ops = device_get_ops(dev);
+
+	if (!ops->read)
+		return -ENOSYS;
+
+	return ops->read(dev, offset, buf, size);
+}
+
+static int ucsi_write(struct udevice *dev, int offset, void *buf, int size)
+{
+	const struct ucsi_ops *ops = device_get_ops(dev);
+
+	if (!ops->write)
+		return -ENOSYS;
+
+	return ops->write(dev, offset, buf, size);
+}
+
+static int ucsi_acknowledge_command(struct udevice *dev)
+{
+	u64 ctrl;
+
+	ctrl = UCSI_ACK_CC_CI;
+	ctrl |= UCSI_ACK_COMMAND_COMPLETE;
+
+	return ucsi_write(dev, UCSI_CONTROL, &ctrl, sizeof(ctrl));
+}
+
+static int ucsi_acknowledge_connector_change(struct udevice *dev)
+{
+	u64 ctrl;
+
+	ctrl = UCSI_ACK_CC_CI;
+	ctrl |= UCSI_ACK_CONNECTOR_CHANGE;
+
+	return ucsi_write(dev, UCSI_CONTROL, &ctrl, sizeof(ctrl));
+}
+
+static int ucsi_exec_command(struct udevice *dev, u64 command);
+
+static int ucsi_read_error(struct udevice *dev)
+{
+	u16 error;
+	int ret;
+
+	/* Acknowlege the command that failed */
+	ret = ucsi_acknowledge_command(dev);
+
+	if (ret)
+		return ret;
+
+	ret = ucsi_exec_command(dev, UCSI_GET_ERROR_STATUS);
+
+	if (ret < 0)
+		return ret;
+
+	ret = ucsi_read(dev, UCSI_MESSAGE_IN, &error, sizeof(error));
+	if (ret)
+		return ret;
+
+	switch (error) {
+	case UCSI_ERROR_INCOMPATIBLE_PARTNER:
+		return -EOPNOTSUPP;
+	case UCSI_ERROR_CC_COMMUNICATION_ERR:
+		return -ECOMM;
+	case UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL:
+		return -EPROTO;
+	case UCSI_ERROR_DEAD_BATTERY:
+		dev_warn(dev, "Dead battery condition!\n");
+		return -EPERM;
+	case UCSI_ERROR_INVALID_CON_NUM:
+	case UCSI_ERROR_UNREGONIZED_CMD:
+	case UCSI_ERROR_INVALID_CMD_ARGUMENT:
+		dev_err(dev, "possible UCSI driver bug %u\n", error);
+		return -EINVAL;
+	case UCSI_ERROR_OVERCURRENT:
+		dev_warn(dev, "Overcurrent condition\n");
+		break;
+	case UCSI_ERROR_PARTNER_REJECTED_SWAP:
+		dev_warn(dev, "Partner rejected swap\n");
+		break;
+	case UCSI_ERROR_HARD_RESET:
+		dev_warn(dev, "Hard reset occurred\n");
+		break;
+	case UCSI_ERROR_PPM_POLICY_CONFLICT:
+		dev_warn(dev, "PPM Policy conflict\n");
+		break;
+	case UCSI_ERROR_SWAP_REJECTED:
+		dev_warn(dev, "Swap rejected\n");
+		break;
+	case UCSI_ERROR_UNDEFINED:
+	default:
+		dev_err(dev, "unknown error %u\n", error);
+		break;
+	}
+
+	return -EIO;
+}
+
+static int ucsi_exec_command(struct udevice *dev, u64 cmd)
+{
+	u32 cci;
+	int ret;
+
+	ret = ucsi_write(dev, UCSI_CONTROL, &cmd, sizeof(cmd));
+	if (ret)
+		return ret;
+
+	ret = ucsi_read(dev, UCSI_CCI, &cci, sizeof(cci));
+	if (ret)
+		return ret;
+
+	if (cci & UCSI_CCI_BUSY)
+		return -EBUSY;
+
+	if (!(cci & UCSI_CCI_COMMAND_COMPLETE))
+		return -EIO;
+
+	if (cci & UCSI_CCI_NOT_SUPPORTED)
+		return -EOPNOTSUPP;
+
+	if (cci & UCSI_CCI_ERROR) {
+		if (cmd == UCSI_GET_ERROR_STATUS)
+			return -EIO;
+		return ucsi_read_error(dev);
+	}
+
+	return UCSI_CCI_LENGTH(cci);
+}
+
+static int ucsi_send_command(struct udevice *dev, u64 command,
+			     void *data, size_t size)
+{
+	u8 length;
+	int ret;
+
+	ret = ucsi_exec_command(dev, command);
+	if (ret < 0)
+		goto out;
+
+	length = ret;
+
+	if (data) {
+		ret = ucsi_read(dev, UCSI_MESSAGE_IN, data, size);
+		if (ret)
+			goto out;
+	}
+
+	ret = ucsi_acknowledge_command(dev);
+	if (ret)
+		goto out;
+
+	ret = length;
+out:
+
+	return ret;
+}
+
+static int ucsi_reset_ppm(struct udevice *dev)
+{
+	u64 command = UCSI_PPM_RESET;
+	unsigned long tmo;
+	u32 cci;
+	int ret;
+
+	ret = ucsi_write(dev, UCSI_CONTROL, &command, sizeof(command));
+	if (ret < 0)
+		goto out;
+
+	tmo = timer_get_us() + UCSI_TIMEOUT_US;
+
+	do {
+		if (time_before(tmo, timer_get_us())) {
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+
+		ret = ucsi_read(dev, UCSI_CCI, &cci, sizeof(cci));
+		if (ret)
+			goto out;
+
+		/* If the PPM is still doing something else, reset it again. */
+		if (cci & ~UCSI_CCI_RESET_COMPLETE) {
+			ret = ucsi_write(dev, UCSI_CONTROL, &command,
+					 sizeof(command));
+			if (ret < 0)
+				goto out;
+		}
+
+		mdelay(20);
+	} while (!(cci & UCSI_CCI_RESET_COMPLETE));
+
+out:
+	return ret;
+}
+
+static int ucsi_get_status(struct udevice *child, u8 con_idx, bool force)
+{
+	struct udevice *parent = dev_get_parent(child);
+	struct ucsi_priv *priv = dev_get_priv(child);
+	struct ucsi_connector_status status;
+	u64 command;
+	u32 cci;
+	int ret = 0;
+
+	if (con_idx > (priv->nb_connector - 1))
+		return -EINVAL;
+
+	ret = ucsi_read(parent, UCSI_CCI, &cci, sizeof(cci));
+	if (ret)
+		return ret;
+
+	/* is there any change ? */
+	if (!UCSI_CCI_CONNECTOR(cci) && !force)
+		goto exit;
+
+	command = UCSI_GET_CONNECTOR_STATUS | UCSI_CONNECTOR_NUMBER(con_idx + 1);
+	ret = ucsi_send_command(parent, command, &status, sizeof(status));
+	if (ret < 0)
+		return ret;
+
+	priv->con[con_idx].attached = status.flags & UCSI_CONSTAT_CONNECTED ?
+		TYPEC_ATTACHED : TYPEC_UNATTACHED;
+
+	switch (UCSI_CONSTAT_PARTNER_TYPE(status.flags)) {
+	case UCSI_CONSTAT_PARTNER_TYPE_UFP:
+	case UCSI_CONSTAT_PARTNER_TYPE_CABLE_AND_UFP:
+	case UCSI_CONSTAT_PARTNER_TYPE_CABLE:
+		priv->con[con_idx].data_role = TYPEC_HOST;
+		break;
+	case UCSI_CONSTAT_PARTNER_TYPE_DFP:
+		priv->con[con_idx].data_role = TYPEC_DEVICE;
+		break;
+	}
+
+	ret = ucsi_acknowledge_connector_change(parent);
+exit:
+	dev_dbg(child, "connector[%d] status: %s data role: %s\n",
+		con_idx,
+		priv->con[con_idx].attached == TYPEC_ATTACHED ? "Attached" : "Unattached",
+		priv->con[con_idx].data_role == TYPEC_HOST ? "Host" : "Device");
+
+	return ret;
+}
+
+int ucsi_post_probe(struct udevice *dev)
+{
+	struct connector *con;
+	struct ucsi_priv *priv;
+	struct udevice *child;
+	struct ucsi_capability cap;
+	u64 command;
+	int ret;
+	u8 i;
+
+	/* Reset the PPM */
+	ret = ucsi_reset_ppm(dev);
+	if (ret) {
+		dev_err(dev, "failed to reset PPM!\n");
+		return ret;
+	}
+
+	/* enable connector change notification */
+	command = UCSI_SET_NOTIFICATION_ENABLE | UCSI_ENABLE_NTFY_CONNECTOR_CHANGE;
+	ret = ucsi_send_command(dev, command, NULL, 0);
+	if (ret < 0)
+		return ret;
+
+	/* get current status : attached/unattached, device/host */
+	ret = device_get_child(dev, 0, &child);
+	if (ret < 0)
+		return ret;
+
+	/* Get PPM capabilities */
+	command = UCSI_GET_CAPABILITY;
+	ret = ucsi_send_command(dev, command, &cap, sizeof(cap));
+	if (ret < 0)
+		return ret;
+
+	if (!cap.num_connectors)
+		return -ENODEV;
+
+	priv = dev_get_priv(child);
+	priv->nb_connector = cap.num_connectors;
+	priv->con = kcalloc(priv->nb_connector, sizeof(*con), GFP_KERNEL);
+	if (!priv->con)
+		return -ENOMEM;
+
+	for (i = 0; i < priv->nb_connector; i++) {
+		ret = ucsi_get_status(child, i, true);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+UCLASS_DRIVER(ucsi) = {
+	.id		= UCLASS_UCSI,
+	.name		= "ucsi",
+	.post_probe	= ucsi_post_probe,
+};
+
+static int ucsi_is_attached(struct udevice *dev, u8 con_idx)
+{
+	struct ucsi_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ucsi_get_status(dev, con_idx, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->con[con_idx].attached;
+}
+
+static int ucsi_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	struct ucsi_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ucsi_get_status(dev, con_idx, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->con[con_idx].data_role;
+}
+
+static u8 usci_get_nb_connector(struct udevice *dev)
+{
+	struct ucsi_priv *priv = dev_get_priv(dev);
+
+	return priv->nb_connector;
+}
+
+static const struct typec_ops ucsi_typec_ops = {
+	.is_attached = ucsi_is_attached,
+	.get_data_role = ucsi_get_data_role,
+	.get_nb_connector = usci_get_nb_connector,
+};
+
+static const struct udevice_id typec_of_match[] = {
+	{ .compatible = "usb-c-connector"},
+	{}
+};
+
+U_BOOT_DRIVER(typec_ucsi) = {
+	.id		= UCLASS_USB_TYPEC,
+	.name		= "typec_ucsi",
+	.of_match	= typec_of_match,
+	.ops		= &ucsi_typec_ops,
+	.priv_auto	= sizeof(struct ucsi_priv),
+};
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 69f4809cf4..d92d5be8d0 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -547,6 +547,15 @@ config VIDEO_LCD_RENESAS_R69328
 	  IPS-LCD module with Renesas R69328 IC. The panel has a 720x1280
 	  resolution and uses 24 bit RGB per pixel.
 
+config VIDEO_LCD_ROCKTECH_HX8394
+	bool "ROCKTECH HX8394 DSI LCD panel support"
+	depends on VIDEO
+	select VIDEO_MIPI_DSI
+	default n
+	help
+	Say Y here if you want to enable support for Rocktech HX8394
+	720x1280 DSI video mode panel.
+
 config VIDEO_LCD_SSD2828
 	bool "SSD2828 bridge chip"
 	---help---
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index d13af9f3b1..cd61293d10 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -61,6 +61,7 @@ obj-$(CONFIG_VIDEO_LCD_ORISETECH_OTM8009A) += orisetech_otm8009a.o
 obj-$(CONFIG_VIDEO_LCD_RAYDIUM_RM68200) += raydium-rm68200.o
 obj-$(CONFIG_VIDEO_LCD_RENESAS_R61307) += renesas-r61307.o
 obj-$(CONFIG_VIDEO_LCD_RENESAS_R69328) += renesas-r69328.o
+obj-$(CONFIG_VIDEO_LCD_ROCKTECH_HX8394) += rocktech-hx8394.o
 obj-$(CONFIG_VIDEO_LCD_SSD2828) += ssd2828.o
 obj-$(CONFIG_VIDEO_LCD_TDO_TL070WSH30) += tdo-tl070wsh30.o
 obj-$(CONFIG_VIDEO_MCDE_SIMPLE) += mcde_simple.o
diff --git a/drivers/video/dw_mipi_dsi.c b/drivers/video/dw_mipi_dsi.c
index 22fef7e882..73ccb27342 100644
--- a/drivers/video/dw_mipi_dsi.c
+++ b/drivers/video/dw_mipi_dsi.c
@@ -561,9 +561,75 @@ static void dw_mipi_dsi_packet_handler_config(struct dw_mipi_dsi *dsi)
 	dsi_write(dsi, DSI_PCKHDL_CFG, CRC_RX_EN | ECC_RX_EN | BTA_EN);
 }
 
+static int dw_mipi_dsi_video_get_panel(struct udevice *dev, struct udevice **panel)
+{
+	ofnode ep_node, node, ports, remote;
+	u32 remote_phandle;
+	int ret;
+
+	ports = ofnode_find_subnode(dev_ofnode(dev), "ports");
+	if (!ofnode_valid(ports)) {
+		dev_dbg(dev, "Remote bridge subnode\n");
+		return ret;
+	}
+
+	for (node = ofnode_first_subnode(ports);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ep_node = ofnode_first_subnode(node);
+		if (!ofnode_valid(ep_node))
+			continue;
+
+		ret = ofnode_read_u32(ep_node, "remote-endpoint", &remote_phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(remote_phandle);
+		if (!ofnode_valid(remote)) {
+			dev_dbg(dev, "%s(%s): Remote is not valid\n", __func__, dev_read_name(dev));
+			return -EINVAL;
+		}
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_DISPLAY for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				continue;
+			}
+
+			uclass_get_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel)
+				break;
+		}
+	}
+
+	/* Sanity check, we can get out of the loop without having a clean ofnode */
+	if (!(*panel))
+		ret = -EINVAL;
+	else
+		if (!ofnode_valid(dev_ofnode(*panel)))
+			ret = -EINVAL;
+
+	return ret;
+}
+
 static void dw_mipi_dsi_video_packet_config(struct dw_mipi_dsi *dsi,
 					    struct display_timing *timings)
 {
+	struct mipi_dsi_device *device = dsi->device;
+	struct udevice *panel;
+	int rotation = 0;
+
+	/* Rotation supported only by mp25 SOCs */
+	if (ofnode_device_is_compatible(dev_ofnode(device->dev), "st,stm32mp25-dsi")) {
+		if (!dw_mipi_dsi_video_get_panel(device->dev, &panel))
+			rotation = dev_read_u32_default(panel, "rotation", 0);
+	}
+
 	/*
 	 * TODO dw drv improvements
 	 * only burst mode is supported here. For non-burst video modes,
@@ -571,7 +637,10 @@ static void dw_mipi_dsi_video_packet_config(struct dw_mipi_dsi *dsi,
 	 * DSI_VNPCR.NPSIZE... especially because this driver supports
 	 * non-burst video modes, see dw_mipi_dsi_video_mode_config()...
 	 */
-	dsi_write(dsi, DSI_VID_PKT_SIZE, VID_PKT_SIZE(timings->hactive.typ));
+	if (rotation == 90 || rotation == 270)
+		dsi_write(dsi, DSI_VID_PKT_SIZE, VID_PKT_SIZE(timings->vactive.typ));
+	else
+		dsi_write(dsi, DSI_VID_PKT_SIZE, VID_PKT_SIZE(timings->hactive.typ));
 }
 
 static void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)
@@ -616,13 +685,28 @@ static u32 dw_mipi_dsi_get_hcomponent_lbcc(struct dw_mipi_dsi *dsi,
 static void dw_mipi_dsi_line_timer_config(struct dw_mipi_dsi *dsi,
 					  struct display_timing *timings)
 {
+	struct mipi_dsi_device *device = dsi->device;
 	u32 htotal, hsa, hbp, lbcc;
+	struct udevice *panel;
+	int rotation = 0;
 
-	htotal = timings->hactive.typ + timings->hfront_porch.typ +
-		 timings->hback_porch.typ + timings->hsync_len.typ;
+	/* Rotation supported only by mp25 SOCs */
+	if (ofnode_device_is_compatible(dev_ofnode(device->dev), "st,stm32mp25-dsi")) {
+		if (!dw_mipi_dsi_video_get_panel(device->dev, &panel))
+			rotation = dev_read_u32_default(panel, "rotation", 0);
+	}
 
-	hsa = timings->hsync_len.typ;
-	hbp = timings->hback_porch.typ;
+	if (rotation == 90 || rotation == 270) {
+		htotal = timings->vactive.typ + timings->vfront_porch.typ +
+			 timings->vback_porch.typ + timings->vsync_len.typ;
+		hsa = timings->vsync_len.typ;
+		hbp = timings->vback_porch.typ;
+	} else {
+		htotal = timings->hactive.typ + timings->hfront_porch.typ +
+			 timings->hback_porch.typ + timings->hsync_len.typ;
+		hsa = timings->hsync_len.typ;
+		hbp = timings->hback_porch.typ;
+	}
 
 	/*
 	 * TODO dw drv improvements
@@ -641,12 +725,28 @@ static void dw_mipi_dsi_line_timer_config(struct dw_mipi_dsi *dsi,
 static void dw_mipi_dsi_vertical_timing_config(struct dw_mipi_dsi *dsi,
 					       struct display_timing *timings)
 {
+	struct mipi_dsi_device *device = dsi->device;
 	u32 vactive, vsa, vfp, vbp;
+	struct udevice *panel;
+	int rotation = 0;
 
-	vactive = timings->vactive.typ;
-	vsa =  timings->vsync_len.typ;
-	vfp =  timings->vfront_porch.typ;
-	vbp = timings->vback_porch.typ;
+	/* Rotation supported only by mp25 SOCs */
+	if (ofnode_device_is_compatible(dev_ofnode(device->dev), "st,stm32mp25-dsi")) {
+		if (!dw_mipi_dsi_video_get_panel(device->dev, &panel))
+			rotation = dev_read_u32_default(panel, "rotation", 0);
+	}
+
+	if (rotation == 90 || rotation == 270) {
+		vactive = timings->hactive.typ;
+		vsa =  timings->hsync_len.typ;
+		vfp =  timings->hfront_porch.typ;
+		vbp = timings->hback_porch.typ;
+	} else {
+		vactive = timings->vactive.typ;
+		vsa =  timings->vsync_len.typ;
+		vfp =  timings->vfront_porch.typ;
+		vbp = timings->vback_porch.typ;
+	}
 
 	dsi_write(dsi, DSI_VID_VACTIVE_LINES, vactive);
 	dsi_write(dsi, DSI_VID_VSA_LINES, vsa);
diff --git a/drivers/video/rocktech-hx8394.c b/drivers/video/rocktech-hx8394.c
new file mode 100644
index 0000000000..9a2689600b
--- /dev/null
+++ b/drivers/video/rocktech-hx8394.c
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2022 STMicroelectronics - All Rights Reserved
+ * Author: Yannick Fertre <yannick.fertre@foss.st.com> for STMicroelectronics.
+ *
+ * This hx8394 panel driver is inspired from the Linux Kernel driver
+ * drivers/gpu/drm/panel/panel-rocktech-hx8394.c.
+ */
+#include <common.h>
+#include <backlight.h>
+#include <dm.h>
+#include <mipi_dsi.h>
+#include <panel.h>
+#include <asm/gpio.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+#include <power/regulator.h>
+
+#define MCS_SETPOWER	0xB1
+#define MCS_SETDISP	0xB2
+#define MCS_SETCYC	0xB4
+#define MCS_SETVCOM	0xB6
+#define MCS_SETEXTC	0xB9
+#define MCS_SETMIPI	0xBA
+#define MCS_SET_BANK	0xBD
+#define MCS_NO_DOC1	0xBF
+#define MCS_NO_DOC2	0xC0
+#define MCS_NO_DOC3	0xC6
+#define MCS_NO_DOC4	0xD8
+#define MCS_NO_DOC5	0xD4
+#define MCS_SETPANEL	0xCC
+#define MCS_SETGIP_0	0xD3
+#define MCS_SETGIP_1	0xD5
+#define MCS_SETGIP_2	0xD6
+
+#define MCS_SETGAMMA	0xE0
+#define MCS_READ_ID1	0xDA
+#define MCS_READ_ID2	0xDB
+#define MCS_READ_ID3	0xDC
+
+#define MY	BIT(7)	/* Row Address Order */
+#define MX	BIT(6)	/* Column Address Order */
+#define MV	BIT(5)	/* Row/Column Exchange */
+#define ML	BIT(4)	/* Vertical Refresh Order */
+#define RGB	BIT(3)	/* RGB-BGR Order */
+#define DDL	BIT(2)	/* Display Data Latch Order */
+#define FH	BIT(1)	/* Flip Horizontal */
+#define FV	BIT(0)	/* Flip Vertical */
+
+struct hx8394_panel_priv {
+	struct udevice *reg;
+	struct udevice *backlight;
+	struct gpio_desc reset;
+};
+
+static const struct display_timing default_timing = {
+	.pixelclock.typ		= 54000000,
+	.hactive.typ		= 720,
+	.hfront_porch.typ	= 48,
+	.hback_porch.typ	= 48,
+	.hsync_len.typ		= 9,
+	.vactive.typ		= 1280,
+	.vfront_porch.typ	= 12,
+	.vback_porch.typ	= 12,
+	.vsync_len.typ		= 5,
+};
+
+static void hx8394_dcs_write_buf(struct udevice *dev, const void *data,
+				 size_t len)
+{
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);
+	struct mipi_dsi_device *device = plat->device;
+	int err;
+
+	err = mipi_dsi_dcs_write_buffer(device, data, len);
+	if (err < 0)
+		dev_err(dev, "MIPI DSI DCS write buffer failed: %d\n", err);
+}
+
+#define dcs_write_seq(dev, seq...)				\
+({								\
+	static const u8 d[] = { seq };				\
+								\
+	hx8394_dcs_write_buf(dev, d, ARRAY_SIZE(d));	\
+})
+
+#define dcs_write_cmd_seq(dev, cmd, seq...)				\
+({									\
+	static const u8 d[] = { seq };					\
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);		\
+	struct mipi_dsi_device *device = plat->device;			\
+	int err;							\
+	err = mipi_dsi_dcs_write(device, cmd, d, ARRAY_SIZE(d));	\
+	if (err < 0)							\
+		dev_err(dev, "MIPI DSI DCS write failed: %d\n", err);	\
+})
+
+static void hx8394_init_sequence(struct udevice *dev)
+{
+	dcs_write_cmd_seq(dev, MCS_SETEXTC, 0xFF, 0x83, 0x94);
+	dcs_write_cmd_seq(dev, MCS_SETMIPI, 0x61, 0x03, 0x68, 0x6B, 0xB2, 0xC0);
+	dcs_write_seq(dev, MCS_SETPOWER, 0x48, 0x12, 0x72, 0x09, 0x32, 0x54, 0x71, 0x71, 0x57,
+		      0x47);
+	dcs_write_cmd_seq(dev, MCS_SETDISP, 0x00, 0x80, 0x64, 0x0C, 0x0D, 0x2F);
+	dcs_write_seq(dev, MCS_SETCYC, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86, 0x75,
+		      0x00, 0x3F, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86);
+	dcs_write_seq(dev, MCS_SETGIP_0, 0x00, 0x00, 0x07, 0x07, 0x40, 0x07, 0x0C, 0x00, 0x08, 0x10,
+		      0x08, 0x00, 0x08, 0x54, 0x15, 0x0A, 0x05, 0x0A, 0x02, 0x15, 0x06, 0x05, 0x06,
+		      0x47, 0x44, 0x0A, 0x0A, 0x4B, 0x10, 0x07, 0x07, 0x0C, 0x40);
+	dcs_write_seq(dev, MCS_SETGIP_1, 0x1C, 0x1C, 0x1D, 0x1D, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
+		      0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x24, 0x25, 0x18, 0x18, 0x26, 0x27, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x20, 0x21, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_seq(dev, MCS_SETGIP_2, 0x1C, 0x1C, 0x1D, 0x1D, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
+		      0x01, 0x00, 0x0B, 0x0A, 0x09, 0x08, 0x21, 0x20, 0x18, 0x18, 0x27, 0x26, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x25, 0x24, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_cmd_seq(dev, MCS_SETVCOM, 0x92, 0x92);
+	dcs_write_seq(dev, MCS_SETGAMMA, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24, 0x22, 0x47, 0x56,
+		      0x65, 0x66, 0x6E, 0x82, 0x88, 0x8B, 0x9A, 0x9D, 0x98, 0xA8, 0xB9, 0x5D, 0x5C,
+		      0x61, 0x66, 0x6A, 0x6F, 0x7F, 0x7F, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24,
+		      0x22, 0x47, 0x56, 0x65, 0x65, 0x6E, 0x81, 0x87, 0x8B, 0x98, 0x9D, 0x99, 0xA8,
+		      0xBA, 0x5D, 0x5D, 0x62, 0x67, 0x6B, 0x72, 0x7F,  0x7F);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC2, 0x1F, 0x31);
+	dcs_write_cmd_seq(dev, MCS_SETPANEL, 0x03);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC5, 0x02);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x02);
+	dcs_write_seq(dev, MCS_NO_DOC4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		      0xFF, 0xFF);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x01);
+	dcs_write_cmd_seq(dev, MCS_SETPOWER, 0x00);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC1, 0x40, 0x81, 0x50, 0x00, 0x1A, 0xFC, 0x01);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC3, 0xED);
+	dcs_write_cmd_seq(dev, MIPI_DCS_SET_ADDRESS_MODE, FH);
+}
+
+static int hx8394_panel_enable_backlight(struct udevice *dev)
+{
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);
+	struct mipi_dsi_device *device = plat->device;
+	struct hx8394_panel_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = mipi_dsi_attach(device);
+	if (ret < 0)
+		return ret;
+
+	hx8394_init_sequence(dev);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(device);
+	if (ret)
+		return ret;
+
+	mdelay(120);
+
+	ret = mipi_dsi_dcs_set_display_on(device);
+	if (ret)
+		return ret;
+
+	mdelay(50);
+
+	ret = backlight_enable(priv->backlight);
+
+	return ret;
+}
+
+static int hx8394_panel_get_display_timing(struct udevice *dev,
+					   struct display_timing *timings)
+{
+	memcpy(timings, &default_timing, sizeof(*timings));
+
+	return 0;
+}
+
+static int hx8394_panel_of_to_plat(struct udevice *dev)
+{
+	struct hx8394_panel_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret =  device_get_supply_regulator(dev, "power-supply",
+					   &priv->reg);
+	if (ret) {
+		dev_err(dev, "Warning: cannot get power supply\n");
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0, &priv->reset,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		dev_err(dev, "Warning: cannot get reset GPIO\n");
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
+					   "backlight", &priv->backlight);
+	if (ret)
+		dev_err(dev, "Cannot get backlight: ret=%d\n", ret);
+
+	return ret;
+}
+
+static int hx8394_panel_probe(struct udevice *dev)
+{
+	struct hx8394_panel_priv *priv = dev_get_priv(dev);
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);
+	int ret;
+
+	ret = regulator_set_enable(priv->reg, true);
+	if (ret)
+		return ret;
+
+	/* reset panel */
+	dm_gpio_set_value(&priv->reset, true);
+	mdelay(1);
+	dm_gpio_set_value(&priv->reset, false);
+	mdelay(50);
+
+	/* fill characteristics of DSI data link */
+	plat->lanes = 2;
+	plat->format = MIPI_DSI_FMT_RGB888;
+	plat->mode_flags = MIPI_DSI_MODE_VIDEO |
+			   MIPI_DSI_MODE_VIDEO_BURST |
+			   MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct panel_ops hx8394_panel_ops = {
+	.enable_backlight = hx8394_panel_enable_backlight,
+	.get_display_timing = hx8394_panel_get_display_timing,
+};
+
+static const struct udevice_id hx8394_panel_ids[] = {
+	{ .compatible = "rocktech,hx8394" },
+	{ }
+};
+
+U_BOOT_DRIVER(hx8394_panel) = {
+	.name			  = "hx8394_panel",
+	.id			  = UCLASS_PANEL,
+	.of_match		  = hx8394_panel_ids,
+	.ops			  = &hx8394_panel_ops,
+	.of_to_plat	  = hx8394_panel_of_to_plat,
+	.probe			  = hx8394_panel_probe,
+	.plat_auto	= sizeof(struct mipi_dsi_panel_plat),
+	.priv_auto	= sizeof(struct hx8394_panel_priv),
+};
diff --git a/drivers/video/simple_panel.c b/drivers/video/simple_panel.c
index 6a6473eb0e..35b0233ea2 100644
--- a/drivers/video/simple_panel.c
+++ b/drivers/video/simple_panel.c
@@ -151,6 +151,8 @@ static const struct udevice_id simple_panel_ids[] = {
 	{ .compatible = "boe,nv101wxmn51" },
 	{ .compatible = "panasonic,vvx10f004b00",
 	  .data = PANASONIC_VVX10F004B00 },
+	{ .compatible = "panel-dpi" },
+	{ .compatible = "panel-lvds" },
 	{ }
 };
 
diff --git a/drivers/video/stm32/Kconfig b/drivers/video/stm32/Kconfig
index 48066063e4..62feaa17b2 100644
--- a/drivers/video/stm32/Kconfig
+++ b/drivers/video/stm32/Kconfig
@@ -22,6 +22,15 @@ config VIDEO_STM32_DSI
 	  This option enables support DSI internal bridge which can be used on
 	  devices which have DSI devices connected.
 
+config VIDEO_STM32_LVDS
+	bool "Enable STM32 LVDS video support"
+	depends on VIDEO_STM32
+	select VIDEO_BRIDGE
+	select VIDEO_DW_MIPI_DSI
+	help
+	  This enables Low Voltage Differential Signaling (LVDS) display
+	  support.
+
 config VIDEO_STM32_MAX_XRES
 	int "Maximum horizontal resolution (for memory allocation purposes)"
 	depends on VIDEO_STM32
diff --git a/drivers/video/stm32/Makefile b/drivers/video/stm32/Makefile
index f8b42d1a4d..059d9000c1 100644
--- a/drivers/video/stm32/Makefile
+++ b/drivers/video/stm32/Makefile
@@ -7,3 +7,4 @@
 
 obj-${CONFIG_VIDEO_STM32} = stm32_ltdc.o
 obj-${CONFIG_VIDEO_STM32_DSI} += stm32_dsi.o
+obj-${CONFIG_VIDEO_STM32_LVDS} += stm32_lvds.o
diff --git a/drivers/video/stm32/stm32_dsi.c b/drivers/video/stm32/stm32_dsi.c
index a7420fb2ee..9e46d72947 100644
--- a/drivers/video/stm32/stm32_dsi.c
+++ b/drivers/video/stm32/stm32_dsi.c
@@ -30,6 +30,7 @@
 
 #define HWVER_130			0x31333000	/* IP version 1.30 */
 #define HWVER_131			0x31333100	/* IP version 1.31 */
+#define HWVER_141			0x31343100	/* IP version 1.41 */
 
 /* DSI digital registers & bit definitions */
 #define DSI_VERSION			0x00
@@ -68,6 +69,11 @@
 #define ODF_MIN		1
 #define ODF_MAX		8
 
+#define IDF_PHY_141_MIN		1
+#define IDF_PHY_141_MAX		16
+#define NDIV_PHY_141_MIN	64
+#define NDIV_PHY_141_MAX	625
+
 /* dsi color format coding according to the datasheet */
 enum dsi_color {
 	DSI_RGB565_CONF1,
@@ -81,6 +87,50 @@ enum dsi_color {
 #define LANE_MIN_KBPS	31250
 #define LANE_MAX_KBPS	500000
 
+/* specific registers for hardware version 1.41 */
+#define DSI_WPCR1	0x0430		/* Wrapper Phy Conf Reg 1 */
+#define WPCR1_CCF	GENMASK(5, 0)	/* Configuration clock frequency */
+#define WPCR1_HSFR	GENMASK(14, 8)	/* High speed frequency range in Tx mode */
+#define WPCR1_DLD	BIT(16)		/* Data lanes 0 direction */
+
+#define DSI_WRPCR0	0x0434		/* Wrapper regulator and PLL configuration register 0 */
+#define WRPCR0_IDF	GENMASK(3, 0)	/* PLL input division ratio */
+#define WRPCR0_NDIV	GENMASK(13, 4)	/* PLL InLoop division ratio */
+#define WRPCR0_PSC	BIT(16)		/* PLL shadow control */
+
+#define DSI_WRPCR1	0x0438		/* Wrapper regulator and PLL configuration register 1 */
+#define WRPCR1_PROP	GENMASK(5, 0)	/* Proportional charge pump */
+#define WRPCR1_GMP	GENMASK(7, 6)	/* Loop filter resistance */
+#define WRPCR1_INT	GENMASK(13, 8)	/* Integral of charge pump */
+#define WRPCR1_BIAS	GENMASK(22, 16)	/* Charge pump bias */
+#define WRPCR1_VCO	GENMASK(27, 24)	/* VCO operating range */
+#define WRPCR1_ODF	GENMASK(29, 28)	/* Output division factor */
+
+#define DSI_WRPCR2	0x043C		/* Wrapper regulator and PLL configuration register 2 */
+#define WRPCR2_SEL	GENMASK(1, 0)	/* Output selection for PLL Clock */
+#define WRPCR2_PLLEN	BIT(8)		/* PLL ENable */
+#define WRPCR2_UPD	BIT(16)		/* Update (copies) the PLL shadow registers */
+#define WRPCR2_CLR	BIT(24)		/* Clears the PLL shadow registers to their reset values */
+#define WRPCR2_FPLL	BIT(28)		/* Force PLL lock signal */
+
+#define DSI_PTCR0	0x00B4		/* Host PHY test control register 0 */
+#define PTCR0_TRSEN	BIT(0)		/* Test-interface reset enable for the TDI bus */
+#define PTCR0_TCKEN	BIT(1)		/* Test-interface clock enable for the TDI bus */
+
+#define DSI_PCTLR	0x00A0		/* Host PHY control register */
+#define PCTLR_PWEN	BIT(0)		/* Power enable */
+#define PCTLR_DEN	BIT(1)		/* Digital enable */
+#define PCTLR_CKEN	BIT(2)		/* Clock enable */
+#define PCTLR_UCKEN	BIT(3)		/* ULPS clock enable */
+
+#define DSI_PSR		0x00B0		/* Host PHY status register */
+#define PSR_PSSC	BIT(2)		/* PHY stop state clock lane */
+
+#define LANE_MIN_PHY_141_KBPS	80000
+#define LANE_MAX_PHY_141_KBPS	2500000
+#define FVCO_MIN_PHY_141_KBPS	320000
+#define FVCO_MAX_PHY_141_KBPS	1250000
+
 /* Timeout for regulator on/off, pll lock/unlock & fifo empty */
 #define TIMEOUT_US	200000
 
@@ -93,7 +143,10 @@ struct stm32_dsi_priv {
 	int lane_min_kbps;
 	int lane_max_kbps;
 	struct udevice *vdd_reg;
+	struct udevice *vdda18_reg;
 	struct udevice *dsi_host;
+	unsigned int lane_mbps;
+	u32 format;
 };
 
 static inline void dsi_write(struct stm32_dsi_priv *dsi, u32 reg, u32 val)
@@ -338,6 +391,476 @@ static const struct mipi_dsi_phy_ops dsi_stm_phy_ops = {
 	.post_set_mode = dsi_phy_post_set_mode,
 };
 
+struct hstt {
+	unsigned int maxfreq;
+	struct mipi_dsi_phy_timing timing;
+};
+
+#define HSTT(_maxfreq, _c_lp2hs, _c_hs2lp, _d_lp2hs, _d_hs2lp)	\
+{					\
+	.maxfreq = _maxfreq,		\
+	.timing = {			\
+		.clk_lp2hs = _c_lp2hs,	\
+		.clk_hs2lp = _c_hs2lp,	\
+		.data_lp2hs = _d_lp2hs,	\
+		.data_hs2lp = _d_hs2lp,	\
+	}				\
+}
+
+/* Table High-Speed Transition Times */
+static const struct hstt hstt_phy_141_table[] = {
+	HSTT(80, 21, 17, 15, 10),
+	HSTT(90, 23, 17, 16, 10),
+	HSTT(100, 22, 17, 16, 10),
+	HSTT(110, 25, 18, 17, 11),
+	HSTT(120, 26, 20, 18, 11),
+	HSTT(130, 27, 19, 19, 11),
+	HSTT(140, 27, 19, 19, 11),
+	HSTT(150, 28, 20, 20, 12),
+	HSTT(160, 30, 21, 22, 13),
+	HSTT(170, 30, 21, 23, 13),
+	HSTT(180, 31, 21, 23, 13),
+	HSTT(190, 32, 22, 24, 13),
+	HSTT(205, 35, 22, 25, 13),
+	HSTT(220, 37, 26, 27, 15),
+	HSTT(235, 38, 28, 27, 16),
+	HSTT(250, 41, 29, 30, 17),
+	HSTT(275, 43, 29, 32, 18),
+	HSTT(300, 45, 32, 35, 19),
+	HSTT(325, 48, 33, 36, 18),
+	HSTT(350, 51, 35, 40, 20),
+	HSTT(400, 59, 37, 44, 21),
+	HSTT(450, 65, 40, 49, 23),
+	HSTT(500, 71, 41, 54, 24),
+	HSTT(550, 77, 44, 57, 26),
+	HSTT(600, 82, 46, 64, 27),
+	HSTT(650, 87, 48, 67, 28),
+	HSTT(700, 94, 52, 71, 29),
+	HSTT(750, 99, 52, 75, 31),
+	HSTT(800, 105, 55, 82, 32),
+	HSTT(850, 110, 58, 85, 32),
+	HSTT(900, 115, 58, 88, 35),
+	HSTT(950, 120, 62, 93, 36),
+	HSTT(1000, 128, 63, 99, 38),
+	HSTT(1050, 132, 65, 102, 38),
+	HSTT(1100, 138, 67, 106, 39),
+	HSTT(1150, 146, 69, 112, 42),
+	HSTT(1200, 151, 71, 117, 43),
+	HSTT(1250, 153, 74, 120, 45),
+	HSTT(1300, 160, 73, 124, 46),
+	HSTT(1350, 165, 76, 130, 47),
+	HSTT(1400, 172, 78, 134, 49),
+	HSTT(1450, 177, 80, 138, 49),
+	HSTT(1500, 183, 81, 143, 52),
+	HSTT(1550, 191, 84, 147, 52),
+	HSTT(1600, 194, 85, 152, 52),
+	HSTT(1650, 201, 86, 155, 53),
+	HSTT(1700, 208, 88, 161, 53),
+	HSTT(1750, 212, 89, 165, 53),
+	HSTT(1800, 220, 90, 171, 54),
+	HSTT(1850, 223, 92, 175, 55),
+	HSTT(1900, 231, 91, 180, 56),
+	HSTT(1950, 236, 95, 185, 56),
+	HSTT(2000, 243, 97, 190, 58),
+	HSTT(2050, 248, 99, 194, 59),
+	HSTT(2100, 252, 100, 199, 61),
+	HSTT(2150, 259, 102, 204, 62),
+	HSTT(2200, 266, 105, 210, 63),
+	HSTT(2250, 269, 109, 213, 65),
+	HSTT(2300, 272, 109, 217, 66),
+	HSTT(2350, 281, 112, 225, 66),
+	HSTT(2400, 283, 115, 226, 67),
+	HSTT(2450, 282, 115, 226, 67),
+	HSTT(2500, 281, 118, 227, 68)
+};
+
+struct dphy_pll_parameter_map {
+	u32 data_rate;	/* upper margin of frequency range */
+	u8 hs_freq;	/* hsfreqrange */
+	u8 odf;
+	u8 vco;
+	u8 prop;
+};
+
+static const struct dphy_pll_parameter_map dppa_map_phy_141[] = {
+	{80, 0x00, 0x03, 0x0F, 0x0B},
+	{90, 0x10, 0x03, 0x0F, 0x0B},
+	{100, 0x20, 0x03, 0x0F, 0x0B},
+	{110, 0x30, 0x03, 0x09, 0x0B},
+	{120, 0x01, 0x03, 0x09, 0x0B},
+	{130, 0x11, 0x03, 0x09, 0x0B},
+	{140, 0x21, 0x03, 0x09, 0x0B},
+	{150, 0x31, 0x03, 0x09, 0x0B},
+	{160, 0x02, 0x02, 0x0F, 0x0B},
+	{170, 0x12, 0x02, 0x0F, 0x0B},
+	{180, 0x22, 0x02, 0x0F, 0x0B},
+	{190, 0x32, 0x02, 0x0F, 0x0B},
+	{205, 0x03, 0x02, 0x0F, 0x0B},
+	{220, 0x13, 0x02, 0x09, 0x0B},
+	{235, 0x23, 0x02, 0x09, 0x0B},
+	{250, 0x33, 0x02, 0x09, 0x0B},
+	{275, 0x04, 0x02, 0x09, 0x0B},
+	{300, 0x14, 0x02, 0x09, 0x0B},
+	{325, 0x25, 0x01, 0x0F, 0x0B},
+	{350, 0x35, 0x01, 0x0F, 0x0B},
+	{400, 0x05, 0x01, 0x0F, 0x0B},
+	{450, 0x16, 0x01, 0x09, 0x0B},
+	{500, 0x26, 0x01, 0x09, 0x0B},
+	{550, 0x37, 0x01, 0x09, 0x0B},
+	{600, 0x07, 0x01, 0x09, 0x0B},
+	{650, 0x18, 0x00, 0x0F, 0x0B},
+	{700, 0x28, 0x00, 0x0F, 0x0B},
+	{750, 0x39, 0x00, 0x0F, 0x0B},
+	{800, 0x09, 0x00, 0x0F, 0x0B},
+	{850, 0x19, 0x00, 0x09, 0x0B},
+	{900, 0x29, 0x00, 0x09, 0x0B},
+	{950, 0x3A, 0x00, 0x09, 0x0B},
+	{1000, 0x0A, 0x00, 0x09, 0x0B},
+	{1050, 0x1A, 0x00, 0x09, 0x0B},
+	{1100, 0x2A, 0x00, 0x09, 0x0B},
+	{1150, 0x3B, 0x00, 0x09, 0x0B},
+	{1200, 0x0B, 0x00, 0x09, 0x0B},
+	{1250, 0x1B, 0x00, 0x09, 0x0B},
+	{1300, 0x2B, 0x00, 0x03, 0x0B},
+	{1350, 0x3C, 0x00, 0x03, 0x0B},
+	{1400, 0x0C, 0x00, 0x03, 0x0B},
+	{1450, 0x1C, 0x00, 0x03, 0x0B},
+	{1500, 0x2C, 0x00, 0x03, 0x0B},
+	{1550, 0x3D, 0x00, 0x03, 0x0B},
+	{1600, 0x0D, 0x00, 0x03, 0x0B},
+	{1650, 0x1D, 0x00, 0x03, 0x0B},
+	{1700, 0x2E, 0x00, 0x03, 0x0B},
+	{1750, 0x3E, 0x00, 0x03, 0x0B},
+	{1800, 0x0E, 0x00, 0x03, 0x0B},
+	{1850, 0x1E, 0x00, 0x03, 0x0B},
+	{1900, 0x2F, 0x00, 0x03, 0x0B},
+	{1950, 0x3F, 0x00, 0x03, 0x0B},
+	{2000, 0x0F, 0x00, 0x03, 0x0B},
+	{2050, 0x40, 0x00, 0x03, 0x0B},
+	{2100, 0x41, 0x00, 0x03, 0x0B},
+	{2150, 0x42, 0x00, 0x03, 0x0B},
+	{2200, 0x43, 0x00, 0x01, 0x0B},
+	{2250, 0x44, 0x00, 0x01, 0x0B},
+	{2300, 0x45, 0x00, 0x01, 0x0C},
+	{2350, 0x46, 0x00, 0x01, 0x0C},
+	{2400, 0x47, 0x00, 0x01, 0x0C},
+	{2450, 0x48, 0x00, 0x01, 0x0C},
+	{2500, 0x49, 0x00, 0x01, 0x0C}
+};
+
+static int dsi_phy_141_pll_get_params(struct stm32_dsi_priv *dsi,
+				      int clkin_khz, int clkout_khz,
+				      int *idf, int *ndiv, int *odf)
+{
+	int i, n;
+	int delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = IDF_PHY_141_MIN; i <= IDF_PHY_141_MAX; i++) {
+		for (n = NDIV_PHY_141_MIN; n <= NDIV_PHY_141_MAX; n++) {
+			/* Check if new delta is better & saves parameters */
+			delta = dsi_pll_get_clkout_khz(clkin_khz, i, n, *odf) - clkout_khz;
+
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				*idf = i;
+				*ndiv = n;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int dsi_phy_141_init(void *priv_data)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	struct stm32_dsi_priv *dsi = dev_get_priv(dev);
+	u32 val, ccf, prop, gmp, int1, bias, vco, ndiv, odf, idf;
+	unsigned int pll_in_khz, pll_out_khz, hsfreq;
+	int ret, i;
+
+	dev_dbg(dev, "Initialize DSI physical layer\n");
+
+	/* Select video mode by resetting DSIM bit */
+	dsi_clear(dsi, DSI_WCFGR, WCFGR_DSIM);
+
+	/* Select the color coding */
+	dsi_update_bits(dsi, DSI_WCFGR, WCFGR_COLMUX,
+			dsi_color_from_mipi(dsi->format) << 1);
+
+	dsi_write(dsi, DSI_PCTLR, 0x00);
+
+	/* clear the pll shadow regs */
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	/* set testclr = 1 */
+	dsi_set(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	/* Compute requested pll out, pll out is the half of the lane data rate */
+	pll_out_khz = dsi->lane_mbps * 1000 / 2;
+	pll_in_khz = dsi->pllref_clk / 1000;
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map_phy_141); i++) {
+		if (dsi->lane_mbps < dppa_map_phy_141[i].data_rate) {
+			i--;
+			break;
+		}
+	}
+
+	switch (dppa_map_phy_141[i].odf) {
+	case(3):
+		odf = 8;
+		break;
+	case(2):
+		odf = 4;
+		break;
+	case(1):
+		odf = 2;
+		break;
+	default:
+		odf = 1;
+		break;
+	}
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+
+	ccf = ((pll_in_khz / 1000 - 17)) * 4;
+	hsfreq = dppa_map_phy_141[i].hs_freq;
+
+	vco = dppa_map_phy_141[i].vco;
+	bias = 0x10;
+	int1 = 0x00;
+	gmp = 0x01;
+	prop = dppa_map_phy_141[i].prop;
+
+	/* set DLD, HSFR & CCF */
+	val = (hsfreq << 8) | ccf;
+	dsi_write(dsi, DSI_WPCR1, val);
+
+	val = ((ndiv - 2) << 4) | (idf - 1);
+	dsi_write(dsi, DSI_WRPCR0, val);
+
+	val = ((odf - 1) << 28) | (vco << 24) | (bias << 16) | (int1 << 8) | (gmp << 6) | prop;
+	dsi_write(dsi, DSI_WRPCR1, val);
+
+	dsi_write(dsi, DSI_PCTLR, PCTLR_CKEN);
+
+	dsi_update_bits(dsi, DSI_WRPCR2, WRPCR2_SEL, 0x01);
+
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_UPD);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_UPD);
+	mdelay(1);
+
+	dsi_set(dsi, DSI_PCTLR, PCTLR_PWEN | PCTLR_DEN);
+
+	ret = readl_poll_timeout(dsi->base + DSI_PSR, val, val & PSR_PSSC, TIMEOUT_US);
+	if (ret)
+		dev_err(dev, "!TIMEOUT! waiting PLL, let's continue\n");
+
+	dev_dbg(dev, "IDF %d ODF %d NDIV %d\n", idf, odf, ndiv);
+	dev_dbg(dev, "VCO %d BIAS %d INT %d GMP %d PROP %d\n", vco, bias, int1, gmp, prop);
+
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_PLLEN);
+
+	return 0;
+}
+
+static void dsi_phy_141_post_set_mode(void *priv_data, unsigned long mode_flags)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	struct stm32_dsi_priv *dsi = dev_get_priv(dev);
+
+	dev_dbg(dev, "Set mode %p enable %ld\n", dsi,
+		mode_flags & MIPI_DSI_MODE_VIDEO);
+
+	if (!dsi)
+		return;
+
+	/*
+	 * DSI wrapper must be enabled in video mode & disabled in command mode.
+	 * If wrapper is enabled in command mode, the display controller
+	 * register access will hang.
+	 */
+
+	if (mode_flags & MIPI_DSI_MODE_VIDEO)
+		dsi_set(dsi, DSI_WCR, WCR_DSIEN);
+	else
+		dsi_clear(dsi, DSI_WCR, WCR_DSIEN);
+}
+
+static int dsi_phy_141_get_lane_mbps(void *priv_data, struct display_timing *timings,
+				     u32 lanes, u32 format, unsigned int *lane_mbps)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	struct stm32_dsi_priv *dsi = dev_get_priv(dev);
+	int idf, ndiv, odf, pll_in_khz, pll_out_khz;
+	int bpp, i;
+
+	/* Update lane capabilities according to hw version */
+	dsi->lane_min_kbps = LANE_MIN_PHY_141_KBPS;
+	dsi->lane_max_kbps = LANE_MAX_PHY_141_KBPS;
+
+	pll_in_khz = dsi->pllref_clk / 1000;
+
+	/* Compute requested pll out */
+	bpp = mipi_dsi_pixel_format_to_bpp(format);
+	pll_out_khz = (timings->pixelclock.typ / 1000) * bpp / (lanes * 2);
+	/* Add 20% to pll out to be higher than pixel bw (burst mode only) */
+	pll_out_khz = (pll_out_khz * 12) / 10;
+	if (pll_out_khz > dsi->lane_max_kbps) {
+		pll_out_khz = dsi->lane_max_kbps;
+		dev_warn(dev, "Warning max phy mbps is used\n");
+	}
+	if (pll_out_khz < dsi->lane_min_kbps) {
+		pll_out_khz = dsi->lane_min_kbps;
+		dev_warn(dev, "Warning min phy mbps is used\n");
+	}
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map_phy_141); i++) {
+		if (dsi->lane_mbps < dppa_map_phy_141[i].data_rate) {
+			i--;
+			break;
+		}
+	}
+
+	switch (dppa_map_phy_141[i].odf) {
+	case(3):
+		odf = 8;
+		break;
+	case(2):
+		odf = 4;
+		break;
+	case(1):
+		odf = 2;
+		break;
+	default:
+		odf = 1;
+		break;
+	}
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+
+	/* Get the adjusted lane data rate value, lane data rate = 2 * pll output */
+	*lane_mbps = 2 * dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf) / 1000;
+	dsi->lane_mbps = *lane_mbps;
+
+	dev_dbg(dev, "pll_in %ukHz pll_out %ukHz lane_mbps %uMHz\n",
+		pll_in_khz, pll_out_khz, *lane_mbps);
+
+	return 0;
+}
+
+static int dsi_phy_141_get_timing(void *priv_data, unsigned int lane_mbps,
+				  struct mipi_dsi_phy_timing *timing)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hstt_phy_141_table); i++)
+		if (lane_mbps < hstt_phy_141_table[i].maxfreq)
+			break;
+
+	if (i == ARRAY_SIZE(hstt_phy_141_table))
+		i--;
+
+	*timing = hstt_phy_141_table[i].timing;
+
+	dev_dbg(dev, "data hs2lp %d data lp2hs %d\n", timing->data_hs2lp, timing->data_lp2hs);
+	dev_dbg(dev, "data hs2lp %d data lp2hs %d\n", timing->clk_hs2lp, timing->clk_lp2hs);
+
+	return 0;
+}
+
+static const struct mipi_dsi_phy_ops dsi_stm_phy_141_ops = {
+	.init = dsi_phy_141_init,
+	.get_lane_mbps = dsi_phy_141_get_lane_mbps,
+	.post_set_mode = dsi_phy_141_post_set_mode,
+	.get_timing = dsi_phy_141_get_timing,
+};
+
+static int stm32_dsi_get_panel(struct udevice *dev, struct udevice **panel)
+{
+	ofnode ep_node, node, ports, remote;
+	u32 remote_phandle;
+	int ret;
+
+	ports = ofnode_find_subnode(dev_ofnode(dev), "ports");
+	if (!ofnode_valid(ports)) {
+		dev_dbg(dev, "Remote bridge subnode\n");
+		return ret;
+	}
+
+	for (node = ofnode_first_subnode(ports);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ep_node = ofnode_first_subnode(node);
+		if (!ofnode_valid(ep_node))
+			continue;
+
+		ret = ofnode_read_u32(ep_node, "remote-endpoint", &remote_phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(remote_phandle);
+		if (!ofnode_valid(remote)) {
+			dev_dbg(dev, "%s(%s): Remote is not valid\n", __func__, dev_read_name(dev));
+			return -EINVAL;
+		}
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_DISPLAY for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				continue;
+			}
+
+			uclass_get_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel)
+				break;
+		}
+	}
+
+	/* Sanity check, we can get out of the loop without having a clean ofnode */
+	if (!(*panel))
+		ret = -EINVAL;
+	else
+		if (!ofnode_valid(dev_ofnode(*panel)))
+			ret = -EINVAL;
+
+	return ret;
+}
+
 static int stm32_dsi_attach(struct udevice *dev)
 {
 	struct stm32_dsi_priv *priv = dev_get_priv(dev);
@@ -346,13 +869,18 @@ static int stm32_dsi_attach(struct udevice *dev)
 	struct display_timing timings;
 	int ret;
 
-	ret = uclass_first_device_err(UCLASS_PANEL, &priv->panel);
+	ret = stm32_dsi_get_panel(dev, &priv->panel);
 	if (ret) {
-		dev_err(dev, "panel device error %d\n", ret);
+		dev_err(dev, "No panel found %d\n", ret);
 		return ret;
 	}
 
 	mplat = dev_get_plat(priv->panel);
+
+	/* check that the panel contains platform data */
+	if (!mplat)
+		return -EINVAL;
+
 	mplat->device = &priv->device;
 	device->lanes = mplat->lanes;
 	device->format = mplat->format;
@@ -374,11 +902,25 @@ static int stm32_dsi_attach(struct udevice *dev)
 		return ret;
 	}
 
-	ret = dsi_host_init(priv->dsi_host, device, &timings, 2,
-			    &dsi_stm_phy_ops);
-	if (ret) {
-		dev_err(dev, "failed to initialize mipi dsi host\n");
-		return ret;
+	if (priv->hw_version == HWVER_141 &&
+	    (IS_ENABLED(CONFIG_STM32MP25X) || IS_ENABLED(CONFIG_STM32MP23X))) {
+		ret = dsi_host_init(priv->dsi_host, device, &timings, 4,
+				    &dsi_stm_phy_141_ops);
+		if (ret) {
+			dev_err(dev, "failed to initialize mipi dsi host\n");
+			return ret;
+		}
+	} else if ((priv->hw_version == HWVER_131 || priv->hw_version == HWVER_130) &&
+		   IS_ENABLED(CONFIG_STM32MP15X)) {
+		ret = dsi_host_init(priv->dsi_host, device, &timings, 2,
+				    &dsi_stm_phy_ops);
+		if (ret) {
+			dev_err(dev, "failed to initialize mipi dsi host\n");
+			return ret;
+		}
+	} else {
+		dev_err(dev, "Hardware version not supported\n");
+		return -EINVAL;
 	}
 
 	return 0;
@@ -433,17 +975,47 @@ static int stm32_dsi_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	ret =  device_get_supply_regulator(dev, "phy-dsi-supply",
-					   &priv->vdd_reg);
-	if (ret && ret != -ENOENT) {
-		dev_err(dev, "Warning: cannot get phy dsi supply\n");
-		return -ENODEV;
+	if (device_is_compatible(dev, "st,stm32-dsi")) {
+		ret =  device_get_supply_regulator(dev, "phy-dsi-supply",
+						   &priv->vdd_reg);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Warning: cannot get phy dsi supply\n");
+			return -ENODEV;
+		}
+
+		if (ret != -ENOENT) {
+			ret = regulator_set_enable(priv->vdd_reg, true);
+			if (ret)
+				return ret;
+		}
 	}
 
-	if (ret != -ENOENT) {
-		ret = regulator_set_enable(priv->vdd_reg, true);
-		if (ret)
+	if (device_is_compatible(dev, "st,stm32mp25-dsi")) {
+		ret =  device_get_supply_regulator(dev, "vdd-supply",
+						   &priv->vdd_reg);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Warning: cannot get phy dsi supply\n");
+			return -ENODEV;
+		}
+
+		if (ret != -ENOENT) {
+			ret = regulator_set_enable(priv->vdd_reg, true);
+			if (ret)
+				return ret;
+		}
+
+		ret =  device_get_supply_regulator(dev, "vdda18",
+						   &priv->vdda18_reg);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Warning: cannot get vdda18 supply\n");
 			return ret;
+		}
+
+		if (ret != -ENOENT) {
+			ret = regulator_set_enable(priv->vdda18_reg, true);
+			if (ret)
+				return ret;
+		}
 	}
 
 	ret = clk_get_by_name(device->dev, "pclk", &clk);
@@ -478,7 +1050,8 @@ static int stm32_dsi_probe(struct udevice *dev)
 	/* check hardware version */
 	priv->hw_version = dsi_read(priv, DSI_VERSION) & VERSION;
 	if (priv->hw_version != HWVER_130 &&
-	    priv->hw_version != HWVER_131) {
+	    priv->hw_version != HWVER_131 &&
+	    priv->hw_version != HWVER_141) {
 		dev_err(dev, "DSI version 0x%x not supported\n", priv->hw_version);
 		dev_dbg(dev, "remove and unbind all DSI child\n");
 		device_chld_remove(dev, NULL, DM_REMOVE_NORMAL);
@@ -491,6 +1064,7 @@ static int stm32_dsi_probe(struct udevice *dev)
 err_clk:
 	clk_disable(&clk);
 err_reg:
+	regulator_set_enable(priv->vdda18_reg, false);
 	regulator_set_enable(priv->vdd_reg, false);
 
 	return ret;
@@ -503,6 +1077,7 @@ struct video_bridge_ops stm32_dsi_ops = {
 
 static const struct udevice_id stm32_dsi_ids[] = {
 	{ .compatible = "st,stm32-dsi"},
+	{ .compatible = "st,stm32mp25-dsi"},
 	{ }
 };
 
diff --git a/drivers/video/stm32/stm32_ltdc.c b/drivers/video/stm32/stm32_ltdc.c
index f48badc517..a62affa600 100644
--- a/drivers/video/stm32/stm32_ltdc.c
+++ b/drivers/video/stm32/stm32_ltdc.c
@@ -4,7 +4,6 @@
  * Author(s): Philippe Cornu <philippe.cornu@st.com> for STMicroelectronics.
  *	      Yannick Fertre <yannick.fertre@st.com> for STMicroelectronics.
  */
-
 #define LOG_CATEGORY UCLASS_VIDEO
 
 #include <common.h>
@@ -13,14 +12,32 @@
 #include <dm.h>
 #include <log.h>
 #include <panel.h>
+#include <regmap.h>
 #include <reset.h>
+#include <syscon.h>
 #include <video.h>
 #include <video_bridge.h>
 #include <asm/io.h>
 #include <dm/device-internal.h>
+#include <dm/uclass-internal.h>
 #include <dm/device_compat.h>
+#include <dm/pinctrl.h>
 #include <linux/bitops.h>
 
+#if CONFIG_IS_ENABLED(ARCH_STM32MP)
+/* direct access to RIFSC function, waiting firewall uclass */
+#include <mach/rif.h>
+static int stm32_check_access_by_id(ofnode device_node, u32 id)
+{
+	return stm32_rifsc_check_access_by_id(device_node, id);
+}
+#else
+static int stm32_check_access_by_id(ofnode device_node, u32 id)
+{
+	return -EACCES;
+}
+#endif
+
 struct stm32_ltdc_priv {
 	void __iomem *regs;
 	enum video_log2_bpp l2bpp;
@@ -30,6 +47,8 @@ struct stm32_ltdc_priv {
 	u32 crop_x, crop_y, crop_w, crop_h;
 	u32 alpha;
 	u32 hw_version;
+	struct udevice *bridge;
+	struct udevice *panel;
 };
 
 /* Layer register offsets */
@@ -154,6 +173,9 @@ static const u32 layer_regs_a2[] = {
 #define LTDC_LIPCR	0x40	/* Line Interrupt Position Conf. */
 #define LTDC_CPSR	0x44	/* Current Position Status */
 #define LTDC_CDSR	0x48	/* Current Display Status */
+#define LTDC_RB0AR	0x80	/* Rotation Buffer 0 address */
+#define LTDC_RB1AR	0x84	/* Rotation Buffer 1 address */
+#define LTDC_RBPR	0x88	/* Rotation Buffer Pitch */
 
 /* Layer register offsets */
 #define LTDC_L1C0R	(priv->layer_regs[0])	/* L1 configuration 0 */
@@ -177,6 +199,12 @@ static const u32 layer_regs_a2[] = {
 #define LTDC_L1AFBLR	(priv->layer_regs[18])	/* L1 auxiliary frame buffer length */
 #define LTDC_L1AFBLNR	(priv->layer_regs[19])	/* L1 auxiliary frame buffer line number */
 #define LTDC_L1CLUTWR	(priv->layer_regs[20])	/* L1 CLUT write */
+#define LTDC_L1SISR	(priv->layer_regs[21])	/* L1 scaler input size */
+#define LTDC_L1SOSR	(priv->layer_regs[22])	/* L1 scaler output size */
+#define LTDC_L1SVSFR	(priv->layer_regs[23])	/* L1 scaler vertical scaling factor */
+#define LTDC_L1SVSPR	(priv->layer_regs[24])	/* L1 scaler vertical scaling phase */
+#define LTDC_L1SHSFR	(priv->layer_regs[25])	/* L1 scaler horizontal scaling factor */
+#define LTDC_L1SHSPR	(priv->layer_regs[26])	/* L1 scaler horizontal scaling phase */
 #define LTDC_L1CYR0R	(priv->layer_regs[27])	/* L1 Conversion YCbCr RGB 0 */
 #define LTDC_L1CYR1R	(priv->layer_regs[28])	/* L1 Conversion YCbCr RGB 1 */
 #define LTDC_L1FPF0R	(priv->layer_regs[29])	/* L1 Flexible Pixel Format 0 */
@@ -196,6 +224,7 @@ static const u32 layer_regs_a2[] = {
 #define TWCR_TOTALW	GENMASK(27, 16)	/* TOTAL Width */
 
 #define GCR_LTDCEN	BIT(0)		/* LTDC ENable */
+#define GCR_ROTEN	BIT(2)		/* ROTation ENable */
 #define GCR_DEN		BIT(16)		/* Dither ENable */
 #define GCR_PCPOL	BIT(28)		/* Pixel Clock POLarity-Inverted */
 #define GCR_DEPOL	BIT(29)		/* Data Enable POLarity-High */
@@ -232,6 +261,8 @@ static const u32 layer_regs_a2[] = {
 #define LXCR_LEN	BIT(0)		/* Layer ENable */
 #define LXCR_COLKEN	BIT(1)		/* Color Keying Enable */
 #define LXCR_CLUTEN	BIT(4)		/* Color Look-Up Table ENable */
+#define LXCR_HMEN	BIT(8)		/* Horizontal Mirroring ENable */
+#define LXCR_SCEN	BIT(10)		/* SCaler ENable */
 
 #define LXWHPCR_WHSTPOS	GENMASK(11, 0)	/* Window Horizontal StarT POSition */
 #define LXWHPCR_WHSPPOS	GENMASK(27, 16)	/* Window Horizontal StoP POSition */
@@ -262,6 +293,11 @@ static const u32 layer_regs_a2[] = {
 #define HWVER_10300 0x010300
 #define HWVER_20101 0x020101
 #define HWVER_40100 0x040100
+#define HWVER_40101 0x040101
+
+#define SYSCFG_DISPLAYCLKCR 0x5000
+#define DISPLAYCLKCR_LVDS	0x01
+#define DISPLAYCLKCR_DPI	0x02
 
 enum stm32_ltdc_pix_fmt {
 	PF_ARGB8888 = 0,	/* ARGB [32 bits] */
@@ -369,13 +405,25 @@ static void stm32_ltdc_enable(struct stm32_ltdc_priv *priv)
 	setbits_le32(priv->regs + LTDC_GCR, GCR_LTDCEN);
 }
 
-static void stm32_ltdc_set_mode(struct stm32_ltdc_priv *priv,
+static void stm32_ltdc_set_mode(struct udevice *dev,
 				struct display_timing *timings)
 {
+	struct stm32_ltdc_priv *priv = dev_get_priv(dev);
 	void __iomem *regs = priv->regs;
 	u32 hsync, vsync, acc_hbp, acc_vbp, acc_act_w, acc_act_h;
+	u32 pitch, rota0_buf, rota1_buf;
 	u32 total_w, total_h;
+	u32 out_values[4];
+	u32 rotation;
+	u32 phandle;
+	u32 base;
 	u32 val;
+	int size;
+	ofnode remote;
+
+	/* Rotation supported only by mp25 SOCs */
+	if (ofnode_device_is_compatible(dev_ofnode(dev), "st,stm32mp25-ltdc"))
+		rotation = dev_read_u32_default(priv->panel, "rotation", 0);
 
 	/* Convert video timings to ltdc timings */
 	hsync = timings->hsync_len.typ - 1;
@@ -387,23 +435,99 @@ static void stm32_ltdc_set_mode(struct stm32_ltdc_priv *priv,
 	total_w = acc_act_w + timings->hfront_porch.typ;
 	total_h = acc_act_h + timings->vfront_porch.typ;
 
-	/* Synchronization sizes */
-	val = (hsync << 16) | vsync;
-	clrsetbits_le32(regs + LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+	/* check that an output rotation is required */
+	if (rotation == 90 || rotation == 270) {
+		if (ofnode_read_u32(dev_ofnode(dev), "rotation-memory", &phandle)) {
+			dev_err(dev, "%s(%s): Could not find rotation-memory property\n",
+				__func__, dev_read_name(dev));
+			return;
+		}
+
+		remote = ofnode_get_by_phandle(phandle);
+		if (!ofnode_valid(remote)) {
+			dev_err(dev, "%s(%s): Could not get rotation memory handle\n",
+				__func__, dev_read_name(dev));
+			return;
+		}
+
+		if (ofnode_read_u32_array(remote, "reg", out_values, 4)) {
+			dev_err(dev, "%s(%s): Could not get rotation memory reg property\n",
+				__func__, dev_read_name(dev));
+			return;
+		}
+
+		/* get base & size of memory rotation buffer */
+		base = out_values[1];
+		size = out_values[3];
+
+		/*
+		 * Size of the rotation buffer must be larger than the size
+		 * of two frames (format RGB24).
+		 */
+		if (size <  timings->hactive.typ *  timings->vactive.typ * 2 * 3) {
+			dev_err(dev, "%s(%s): Rotation buffer too small: %d\n",
+				__func__, dev_read_name(dev), size);
+			return;
+		}
+
+		/* Panel width should not exceed 1366 pixels */
+		if (timings->hactive.typ > 1366) {
+			dev_err(dev, "%s(%s): Panel width should not exceed 1366 pixels: %d\n",
+				__func__, dev_read_name(dev), size);
+			return;
+		}
+
+		rota0_buf = (u32)base;
+		rota1_buf = (u32)base + (size >> 1);
+
+		writel(rota0_buf, regs + LTDC_RB0AR);
+		writel(rota1_buf, regs + LTDC_RB1AR);
+
+		/*
+		 * LTDC_RBPR register is used define the pitch (line-to-line address increment)
+		 * of the stored rotation buffer. The pitch is proportional to the width of the
+		 * composed display (before rotation) and,(after rotation) proportional to the
+		 * non-raster dimension of the display panel.
+		 */
+		pitch = ((timings->hactive.typ - 1 + 9) / 10) * 64;
+		writel(pitch, regs + LTDC_RBPR);
+
+		/* Synchronization sizes */
+		val = (vsync << 16) | hsync;
+		clrsetbits_le32(regs + LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
 
-	/* Accumulated back porch */
-	val = (acc_hbp << 16) | acc_vbp;
-	clrsetbits_le32(regs + LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+		/* Accumulated back porch */
+		val = (acc_vbp << 16) | acc_hbp;
+		clrsetbits_le32(regs + LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
 
-	/* Accumulated active width */
-	val = (acc_act_w << 16) | acc_act_h;
-	clrsetbits_le32(regs + LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+		/* Accumulated active width */
+		val = (acc_act_h << 16) | acc_act_w;
+		clrsetbits_le32(regs + LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
 
-	/* Total width & height */
-	val = (total_w << 16) | total_h;
-	clrsetbits_le32(regs + LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+		/* Total width & height */
+		val = (total_h << 16) | total_w;
+		clrsetbits_le32(regs + LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
 
-	setbits_le32(regs + LTDC_LIPCR, acc_act_h + 1);
+		setbits_le32(regs + LTDC_LIPCR, acc_act_w + 1);
+	} else {
+		/* Synchronization sizes */
+		val = (hsync << 16) | vsync;
+		clrsetbits_le32(regs + LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+
+		/* Accumulated back porch */
+		val = (acc_hbp << 16) | acc_vbp;
+		clrsetbits_le32(regs + LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+
+		/* Accumulated active width */
+		val = (acc_act_w << 16) | acc_act_h;
+		clrsetbits_le32(regs + LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+
+		/* Total width & height */
+		val = (total_w << 16) | total_h;
+		clrsetbits_le32(regs + LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+
+		setbits_le32(regs + LTDC_LIPCR, acc_act_h + 1);
+	}
 
 	/* Signal polarities */
 	val = 0;
@@ -416,6 +540,10 @@ static void stm32_ltdc_set_mode(struct stm32_ltdc_priv *priv,
 		val |= GCR_DEPOL;
 	if (timings->flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
 		val |= GCR_PCPOL;
+
+	if (rotation == 90 || rotation == 270)
+		val |= GCR_ROTEN;
+
 	clrsetbits_le32(regs + LTDC_GCR,
 			GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL, val);
 
@@ -423,32 +551,48 @@ static void stm32_ltdc_set_mode(struct stm32_ltdc_priv *priv,
 	writel(priv->bg_col_argb, priv->regs + LTDC_BCCR);
 }
 
-static void stm32_ltdc_set_layer1(struct stm32_ltdc_priv *priv, ulong fb_addr)
+static void stm32_ltdc_set_layer1(struct udevice *dev, ulong fb_addr)
 {
+	struct stm32_ltdc_priv *priv = dev_get_priv(dev);
 	void __iomem *regs = priv->regs;
 	u32 x0, x1, y0, y1;
 	u32 pitch_in_bytes;
 	u32 line_length;
 	u32 bus_width;
-	u32 val, tmp, bpp;
+	u32 val, avbp, ahbp, bpp;
 	u32 format;
+	u32 rotation;
 
 	x0 = priv->crop_x;
 	x1 = priv->crop_x + priv->crop_w - 1;
 	y0 = priv->crop_y;
 	y1 = priv->crop_y + priv->crop_h - 1;
 
-	/* Horizontal start and stop position */
-	tmp = (readl(regs + LTDC_BPCR) & BPCR_AHBP) >> 16;
-	val = ((x1 + 1 + tmp) << 16) + (x0 + 1 + tmp);
-	clrsetbits_le32(regs + LTDC_L1WHPCR, LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS,
-			val);
-
-	/* Vertical start & stop position */
-	tmp = readl(regs + LTDC_BPCR) & BPCR_AVBP;
-	val = ((y1 + 1 + tmp) << 16) + (y0 + 1 + tmp);
-	clrsetbits_le32(regs + LTDC_L1WVPCR, LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS,
-			val);
+	if (ofnode_device_is_compatible(dev_ofnode(dev), "st,stm32mp25-ltdc"))
+		rotation = dev_read_u32_default(priv->panel, "rotation", 0);
+
+	/* check that an output rotation is required */
+	if (rotation == 90 || rotation == 270) {
+		/* Horizontal start and stop position */
+		ahbp = (readl(regs + LTDC_BPCR) & BPCR_AVBP);
+		val = ((x1 + 1 + ahbp) << 16) + (x0 + 1 + ahbp);
+		clrsetbits_le32(regs + LTDC_L1WHPCR, LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
+
+		/* Vertical start & stop position */
+		avbp = (readl(regs + LTDC_BPCR) & BPCR_AHBP) >> 16;
+		val = ((y1 + 1 + avbp) << 16) + (y0 + 1 + avbp);
+		clrsetbits_le32(regs + LTDC_L1WVPCR, LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS,	val);
+	} else {
+		/* Horizontal start and stop position */
+		ahbp = (readl(regs + LTDC_BPCR) & BPCR_AHBP) >> 16;
+		val = ((x1 + 1 + ahbp) << 16) + (x0 + 1 + ahbp);
+		clrsetbits_le32(regs + LTDC_L1WHPCR, LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
+
+		/* Vertical start & stop position */
+		avbp = readl(regs + LTDC_BPCR) & BPCR_AVBP;
+		val = ((y1 + 1 + avbp) << 16) + (y0 + 1 + avbp);
+		clrsetbits_le32(regs + LTDC_L1WVPCR, LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS,	val);
+	}
 
 	/* Layer background color */
 	writel(priv->bg_col_argb, regs + LTDC_L1DCCR);
@@ -458,7 +602,11 @@ static void stm32_ltdc_set_layer1(struct stm32_ltdc_priv *priv, ulong fb_addr)
 	pitch_in_bytes = priv->crop_w * (bpp >> 3);
 	bus_width = 8 << ((readl(regs + LTDC_GC2R) & GC2R_BW) >> 4);
 	line_length = ((bpp >> 3) * priv->crop_w) + (bus_width >> 3) - 1;
-	val = (pitch_in_bytes << 16) | line_length;
+	if (rotation == 270 || rotation == 180)
+		/* Compute negative value (signed on 16 bits) for the picth */
+		val = ((0x10000 - pitch_in_bytes) << 16) | line_length;
+	else
+		val = (pitch_in_bytes << 16) | line_length;
 	clrsetbits_le32(regs + LTDC_L1CFBLR, LXCFBLR_CFBLL | LXCFBLR_CFBP, val);
 
 	/* Pixel format */
@@ -488,10 +636,155 @@ static void stm32_ltdc_set_layer1(struct stm32_ltdc_priv *priv, ulong fb_addr)
 	clrsetbits_le32(regs + LTDC_L1CFBLNR, LXCFBLNR_CFBLN, priv->crop_h);
 
 	/* Frame buffer address */
-	writel(fb_addr, regs + LTDC_L1CFBAR);
+	switch (rotation) {
+	case 270:
+		writel(fb_addr + (pitch_in_bytes * (y1 - y0 + 1) - 1), regs + LTDC_L1CFBAR);
+		break;
+	case 180:
+		writel(fb_addr + (pitch_in_bytes * (y1 - y0 + 1) - 1) +
+		       (bpp >> 3) * (x1 - x0 + 1) - 1, regs + LTDC_L1CFBAR);
+		break;
+	case 90:
+		writel(fb_addr + (bpp >> 3) * (x1 - x0 + 1) - 1, regs + LTDC_L1CFBAR);
+		break;
+	default:
+		writel(fb_addr, regs + LTDC_L1CFBAR);
+	}
 
-	/* Enable layer 1 */
-	setbits_le32(priv->regs + LTDC_L1CR, LXCR_LEN);
+	/* Enable layer 1 & set mirroring */
+	if (rotation == 90 || rotation == 180)
+		setbits_le32(priv->regs + LTDC_L1CR, LXCR_LEN | LXCR_HMEN);
+	else
+		setbits_le32(priv->regs + LTDC_L1CR, LXCR_LEN);
+}
+
+static int stm32_ltdc_get_panel(struct udevice *dev, struct udevice **panel)
+{
+	ofnode ep_node, node, ports, remote;
+	u32 phandle;
+	int ret = 0;
+
+	if (!dev)
+		return -EINVAL;
+
+	ports = ofnode_find_subnode(dev_ofnode(dev), "ports");
+	if (!ofnode_valid(ports)) {
+		dev_err(dev, "Remote bridge subnode\n");
+		return ret;
+	}
+
+	for (node = ofnode_first_subnode(ports);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ep_node = ofnode_first_subnode(node);
+		if (!ofnode_valid(ep_node))
+			continue;
+
+		ret = ofnode_read_u32(ep_node, "remote-endpoint", &phandle);
+		if (ret) {
+			dev_err(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(phandle);
+		if (!ofnode_valid(remote))
+			return -EINVAL;
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_DISPLAY for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				continue;
+			}
+
+			uclass_find_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel)
+				if (ofnode_valid(dev_ofnode(*panel)))
+					return 0;
+		};
+	}
+
+	/* Sanity check, we can get out of the loop without having a clean ofnode */
+	if (!(*panel))
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static int stm32_ltdc_display_init(struct udevice *dev, ofnode *ep_node,
+				   struct udevice **panel, struct udevice **bridge)
+{
+	ofnode remote;
+	u32 phandle;
+	int ret;
+
+	if (*panel)
+		return -EINVAL;
+
+	if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
+		ret = ofnode_read_u32(*ep_node, "remote-endpoint", &phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(phandle);
+		if (!ofnode_valid(remote))
+			return -EINVAL;
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_VIDEO_BRIDGE for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				return -EINVAL;
+			}
+
+			uclass_find_device_by_ofnode(UCLASS_VIDEO_BRIDGE, remote, bridge);
+			if (*bridge && !ret) {
+				ret = uclass_get_device_by_ofnode(UCLASS_VIDEO_BRIDGE,
+								  remote, bridge);
+				if (ret)
+					dev_dbg(dev,
+						"No video bridge, or no backlight on bridge\n");
+				break;
+			}
+		}
+
+		ret = stm32_ltdc_get_panel(*bridge, panel);
+	} else {
+		/* no bridge , search a panel from display controller node */
+		ret = ofnode_read_u32(*ep_node, "remote-endpoint", &phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(phandle);
+		if (!ofnode_valid(remote))
+			return -EINVAL;
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_VIDEO_BRIDGE for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				return -EINVAL;
+			}
+
+			ret = uclass_find_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel && !ret) {
+				ret = uclass_get_device_by_ofnode(UCLASS_PANEL, remote, panel);
+				break;
+			}
+		}
+	}
+
+	return ret;
 }
 
 static int stm32_ltdc_probe(struct udevice *dev)
@@ -499,13 +792,79 @@ static int stm32_ltdc_probe(struct udevice *dev)
 	struct video_uc_plat *uc_plat = dev_get_uclass_plat(dev);
 	struct video_priv *uc_priv = dev_get_uclass_priv(dev);
 	struct stm32_ltdc_priv *priv = dev_get_priv(dev);
-	struct udevice *bridge = NULL;
-	struct udevice *panel = NULL;
 	struct display_timing timings;
-	struct clk pclk;
+	struct clk pclk, bclk;
 	struct reset_ctl rst;
+	struct regmap *regmap = NULL;
+	struct udevice *syscon;
+	ofnode node, port;
 	ulong rate;
-	int ret;
+	int ret, idx;
+
+	if (IS_ENABLED(CONFIG_STM32MP25X) || IS_ENABLED(CONFIG_STM32MP23X) ||
+	    IS_ENABLED(CONFIG_STM32MP21X)) {
+		struct ofnode_phandle_args args;
+
+		node = dev_ofnode(dev);
+
+		idx = ofnode_stringlist_search(node, "access-controller-names", "cmn");
+		if (idx < 0)
+			return idx;
+
+		ret = ofnode_parse_phandle_with_args(node, "access-controllers",
+						     "#access-controller-cells",
+						     0, idx, &args);
+		if (ret < 0) {
+			dev_err(dev, "Can not get access-controllers to common registers\n");
+			return ret;
+		}
+
+		ret = stm32_check_access_by_id(dev_ofnode(dev), args.args[0]);
+		if (ret < 0) {
+			dev_err(dev, "Fail to get access to common registers\n");
+			return ret;
+		}
+
+		node = dev_read_subnode(dev, "l1l2");
+
+		idx = ofnode_stringlist_search(node, "access-controller-names", "l1l2");
+		if (idx < 0)
+			return idx;
+
+		ret = ofnode_parse_phandle_with_args(node, "access-controllers",
+						     "#access-controller-cells",
+						     0, idx, &args);
+		if (ret < 0) {
+			dev_err(dev, "Can not get access-controllers to l1l2 registers\n");
+			return ret;
+		}
+
+		ret = stm32_check_access_by_id(dev_ofnode(dev), args.args[0]);
+		if (ret < 0) {
+			dev_err(dev, "Fail to get access to l1l2 registers\n");
+			return ret;
+		}
+	}
+
+	if (IS_ENABLED(CONFIG_SYSCON) &&
+	    (IS_ENABLED(CONFIG_STM32MP25X) || IS_ENABLED(CONFIG_STM32MP23X))) {
+		ret = uclass_get_device_by_phandle(UCLASS_SYSCON, dev, "st,syscon", &syscon);
+		if (ret) {
+			if (ret != -ENOENT) {
+				dev_err(dev, "unable to find syscon device\n");
+				return ret;
+			}
+		} else {
+			regmap = syscon_get_regmap(syscon);
+			if (IS_ERR(regmap)) {
+				dev_err(dev, "Fail to get Syscon regmap\n");
+				return PTR_ERR(regmap);
+			}
+
+			/* Set default pixel clock to enable register access */
+			regmap_write(regmap, SYSCFG_DISPLAYCLKCR, DISPLAYCLKCR_DPI);
+		}
+	}
 
 	priv->regs = dev_read_addr_ptr(dev);
 	if (!priv->regs) {
@@ -513,7 +872,21 @@ static int stm32_ltdc_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	ret = clk_get_by_index(dev, 0, &pclk);
+	ret = clk_get_by_name(dev, "bus", &bclk);
+	if (ret) {
+		if (ret != -ENODATA) {
+			dev_err(dev, "bus clock get error %d\n", ret);
+			return ret;
+		}
+	} else {
+		ret = clk_enable(&bclk);
+		if (ret) {
+			dev_err(dev, "bus clock enable error %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = clk_get_by_name(dev, "lcd", &pclk);
 	if (ret) {
 		dev_err(dev, "peripheral clock get error %d\n", ret);
 		return ret;
@@ -526,7 +899,7 @@ static int stm32_ltdc_probe(struct udevice *dev)
 	}
 
 	priv->hw_version = readl(priv->regs + LTDC_IDR);
-	debug("%s: LTDC hardware 0x%x\n", __func__, priv->hw_version);
+	dev_dbg(dev, "%s: LTDC hardware 0x%x\n", __func__, priv->hw_version);
 
 	switch (priv->hw_version) {
 	case HWVER_10200:
@@ -539,6 +912,7 @@ static int stm32_ltdc_probe(struct udevice *dev)
 		priv->pix_fmt_hw = pix_fmt_a1;
 		break;
 	case HWVER_40100:
+	case HWVER_40101:
 		priv->layer_regs = layer_regs_a2;
 		priv->pix_fmt_hw = pix_fmt_a2;
 		break;
@@ -546,16 +920,40 @@ static int stm32_ltdc_probe(struct udevice *dev)
 		return -ENODEV;
 	}
 
-	ret = uclass_first_device_err(UCLASS_PANEL, &panel);
-	if (ret) {
-		if (ret != -ENODEV)
-			dev_err(dev, "panel device error %d\n", ret);
-		return ret;
+	/*
+	 * Try all the ports until one working.
+	 *
+	 * This means that it will search first for the DSI node
+	 * and then for the LVDS.
+	 * This is done in two times. First is checks for the
+	 * UCLASS_VIDEO_BRIDGE available, and then for this bridge
+	 * it scans for a UCLASS_PANEL.
+	 */
+
+	port = dev_read_subnode(dev, "port");
+	if (!ofnode_valid(port)) {
+		dev_err(dev, "%s(%s): 'port' subnode not found\n",
+			__func__, dev_read_name(dev));
+		return -EINVAL;
+	}
+
+	for (node = ofnode_first_subnode(port);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ret = stm32_ltdc_display_init(dev, &node, &priv->panel, &priv->bridge);
+		if (ret)
+			dev_dbg(dev, "Device failed ret=%d\n", ret);
+		else
+			break;
 	}
 
-	ret = panel_get_display_timing(panel, &timings);
+	/* Sanity check */
+	if (ret)
+		return ret;
+
+	ret = panel_get_display_timing(priv->panel, &timings);
 	if (ret) {
-		ret = ofnode_decode_display_timing(dev_ofnode(panel),
+		ret = ofnode_decode_display_timing(dev_ofnode(priv->panel),
 						   0, &timings);
 		if (ret) {
 			dev_err(dev, "decode display timing error %d\n", ret);
@@ -581,17 +979,26 @@ static int stm32_ltdc_probe(struct udevice *dev)
 	reset_deassert(&rst);
 
 	if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
-		ret = uclass_get_device(UCLASS_VIDEO_BRIDGE, 0, &bridge);
-		if (ret)
-			dev_dbg(dev,
-				"No video bridge, or no backlight on bridge\n");
+		if (priv->bridge) {
+			/* Set the pixel clock according to the encoder */
+			if (IS_ENABLED(CONFIG_SYSCON) &&
+			    (IS_ENABLED(CONFIG_STM32MP25X) || IS_ENABLED(CONFIG_STM32MP23X))) {
+				if (!strcmp(priv->bridge->name, "stm32-display-dsi"))
+					regmap_write(regmap, SYSCFG_DISPLAYCLKCR,
+						     DISPLAYCLKCR_DPI);
+				else if (!strncmp(priv->bridge->name, "lvds", 4))
+					regmap_write(regmap, SYSCFG_DISPLAYCLKCR,
+						     DISPLAYCLKCR_LVDS);
+			}
 
-		if (bridge) {
-			ret = video_bridge_attach(bridge);
+			ret = video_bridge_attach(priv->bridge);
 			if (ret) {
-				dev_err(bridge, "fail to attach bridge\n");
+				dev_dbg(priv->bridge, "fail to attach bridge\n");
 				return ret;
 			}
+
+			/* set state the pinctrl to sleep to avoid noise */
+			pinctrl_select_state(dev, "sleep");
 		}
 	}
 
@@ -612,23 +1019,23 @@ static int stm32_ltdc_probe(struct udevice *dev)
 		priv->bg_col_argb, priv->alpha);
 
 	/* Configure & start LTDC */
-	stm32_ltdc_set_mode(priv, &timings);
-	stm32_ltdc_set_layer1(priv, uc_plat->base);
+	stm32_ltdc_set_mode(dev, &timings);
+	stm32_ltdc_set_layer1(dev, uc_plat->base);
 	stm32_ltdc_enable(priv);
 
 	uc_priv->xsize = timings.hactive.typ;
 	uc_priv->ysize = timings.vactive.typ;
 	uc_priv->bpix = priv->l2bpp;
 
-	if (!bridge) {
-		ret = panel_enable_backlight(panel);
+	if (!priv->bridge) {
+		ret = panel_enable_backlight(priv->panel);
 		if (ret) {
 			dev_err(dev, "panel %s enable backlight error %d\n",
-				panel->name, ret);
+				priv->panel->name, ret);
 			return ret;
 		}
 	} else if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
-		ret = video_bridge_set_backlight(bridge, 80);
+		ret = video_bridge_set_backlight(priv->bridge, 80);
 		if (ret) {
 			dev_err(dev, "fail to set backlight\n");
 			return ret;
@@ -657,6 +1064,8 @@ static int stm32_ltdc_bind(struct udevice *dev)
 
 static const struct udevice_id stm32_ltdc_ids[] = {
 	{ .compatible = "st,stm32-ltdc" },
+	{ .compatible = "st,stm32mp21-ltdc" },
+	{ .compatible = "st,stm32mp25-ltdc" },
 	{ }
 };
 
diff --git a/drivers/video/stm32/stm32_lvds.c b/drivers/video/stm32/stm32_lvds.c
new file mode 100644
index 0000000000..fe2c539a7c
--- /dev/null
+++ b/drivers/video/stm32/stm32_lvds.c
@@ -0,0 +1,716 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2023 STMicroelectronics - All Rights Reserved
+ * Author(s): Raphaël Gallais-Pou <raphael.gallais-pou@foss.st.com> for STMicroelectronics.
+ *
+ * This Low Voltage Differential Signal controller driver is based on the Linux Kernel driver from
+ * drivers/gpu/drm/stm/ltdc.c
+ */
+
+#define LOG_CATEGORY UCLASS_VIDEO_BRIDGE
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <log.h>
+#include <media_bus_format.h>
+#include <panel.h>
+#include <reset.h>
+#include <video.h>
+#include <video_bridge.h>
+#include <asm/io.h>
+#include <dm/device_compat.h>
+#include <dm/ofnode.h>
+#include <linux/iopoll.h>
+#include <power/regulator.h>
+
+/* LVDS Host registers */
+#define LVDS_CR		0x0000  /* configuration register */
+#define LVDS_DMLCR0	0x0004  /* data mapping lsb configuration register 0	*/
+#define LVDS_DMMCR0	0x0008  /* data mapping msb configuration register 0	*/
+#define LVDS_DMLCR1	0x000C  /* data mapping lsb configuration register 1	*/
+#define LVDS_DMMCR1	0x0010  /* data mapping msb configuration register 1	*/
+#define LVDS_DMLCR2	0x0014  /* data mapping lsb configuration register 2	*/
+#define LVDS_DMMCR2	0x0018  /* data mapping msb configuration register 2	*/
+#define LVDS_DMLCR3	0x001C  /* data mapping lsb configuration register 3	*/
+#define LVDS_DMMCR3	0x0020  /* data mapping msb configuration register 3	*/
+#define LVDS_DMLCR4	0x0024  /* data mapping lsb configuration register 4	*/
+#define LVDS_DMMCR4	0x0028  /* data mapping msb configuration register 4	*/
+#define LVDS_DMLCR(id)	(LVDS_DMLCR0 + 8U * (id))
+#define LVDS_DMMCR(id)	(LVDS_DMMCR0 + 8U * (id))
+#define LVDS_CDL1CR	0x002C  /* channel distrib link 1 configuration register	*/
+#define LVDS_CDL2CR	0x0030  /* channel distrib link 2 configuration register	*/
+
+#define CDL1CR_DEFAULT		0x04321 /* Default value for CDL1CR */
+#define CDL2CR_4DL_DEFAULT	0x04321 /* Default value for CDL2CR with SINGLE link */
+#define CDL2CR_8DL_DEFAULT	0x59876 /* Default value for CDL2CR with DUAL link */
+
+/* LVDS Host registers */
+#define LVDS_PHY_MASTER	0x0
+#define LVDS_PHY_SLAVE	0x100
+
+/* phy parameter can only be one of those two above */
+#define LVDS_PxGCR(phy)		((phy) + 0x1000)   /* Global Control Register	*/
+#define LVDS_PxCMCR1(phy)	((phy) + 0x100C)   /* Current Mode Control Register 1 */
+#define LVDS_PxCMCR2(phy)	((phy) + 0x1010)  /* Current Mode Control Register 2 */
+#define LVDS_PxSCR(phy)		((phy) + 0x1020)  /* Serial Control Register	*/
+#define LVDS_PxBCR1(phy)	((phy) + 0x102C)  /* Bias Control Register 1	*/
+#define LVDS_PxBCR2(phy)	((phy) + 0x1030)  /* Bias Control Register 2	*/
+#define LVDS_PxBCR3(phy)	((phy) + 0x1034)  /* Bias Control Register 3	*/
+#define LVDS_PxMPLCR(phy)	((phy) + 0x1064)  /* Monitor PLL Lock Control Register */
+#define LVDS_PxDCR(phy)		((phy) + 0x1084)  /* Debug Control Register	*/
+#define LVDS_PxSSR1(phy)	((phy) + 0x1088)  /* Spare Status Register 1	*/
+#define LVDS_PxCFGCR(phy)	((phy) + 0x10A0)  /* Configuration Control Register */
+#define LVDS_PxPLLCR1(phy)	((phy) + 0x10C0)  /* PLL_MODE 1 Control Register	*/
+#define LVDS_PxPLLCR2(phy)	((phy) + 0x10C4)  /* PLL_MODE 2 Control Register	*/
+#define LVDS_PxPLLSR(phy)	((phy) + 0x10C8)  /* PLL Status Register	*/
+#define LVDS_PxPLLSDCR1(phy)	((phy) + 0x10CC)  /* PLL_SD_1 Control Register	*/
+#define LVDS_PxPLLSDCR2(phy)	((phy) + 0x10D0)  /* PLL_SD_2 Control Register	*/
+#define LVDS_PxPLLTWGCR1(phy)	((phy) + 0x10D4)  /* PLL_TWG_1 Control Register	*/
+#define LVDS_PxPLLTWGCR2(phy)	((phy) + 0x10D8)  /* PLL_TWG_2 Control Register	*/
+#define LVDS_PxPLLCPCR(phy)	((phy) + 0x10E0)  /* PLL_CP Control Register	*/
+#define LVDS_PxPLLTESTCR(phy)	((phy) + 0x10E8)  /* PLL_TEST Control Register	*/
+
+/* LVDS Wrapper registers */
+#define LVDS_WCLKCR	0x11B0  /* Wrapper clock control register */
+#define LVDS_HWCFGR	0x1FF0  /* HW configuration register	*/
+#define LVDS_VERR	0x1FF4  /* Version register	*/
+#define LVDS_IPIDR	0x1FF8  /* Identification register	*/
+#define LVDS_SIDR	0x1FFC  /* Size Identification register	*/
+
+#define CR_LVDSEN	BIT(0)  /* LVDS PHY Enable */
+#define CR_HSPOL	BIT(1)  /* HS Polarity (horizontal sync) */
+#define CR_VSPOL	BIT(2)  /* VS Polarity (vertical sync) */
+#define CR_DEPOL	BIT(3)  /* DE Polarity (data enable) */
+#define CR_CI		BIT(4)  /* Control Internal (software controlled bit) */
+#define CR_LKMOD	BIT(5)  /* Link Mode, for both Links */
+#define CR_LKPHA	BIT(6)  /* Link Phase, for both Links */
+#define CR_LK1POL	GENMASK(20, 16)  /* Link-1 output Polarity */
+#define CR_LK2POL	GENMASK(25, 21)  /* Link-2 output Polarity */
+
+#define DMMCRx_MAP0	GENMASK(4, 0)
+#define DMMCRx_MAP1	GENMASK(9, 5)
+#define DMMCRx_MAP2	GENMASK(14, 10)
+#define DMMCRx_MAP3	GENMASK(19, 15)
+#define DMLCRx_MAP4	GENMASK(4, 0)
+#define DMLCRx_MAP5	GENMASK(9, 5)
+#define DMLCRx_MAP6	GENMASK(14, 10)
+
+#define CDLCRx_DISTR0	GENMASK(3, 0)
+#define CDLCRx_DISTR1	GENMASK(7, 4)
+#define CDLCRx_DISTR2	GENMASK(11, 8)
+#define CDLCRx_DISTR3	GENMASK(15, 12)
+#define CDLCRx_DISTR4	GENMASK(19, 16)
+
+#define FREF_INDEX	0
+#define NDIV_INDEX	1
+#define FPFD_INDEX	2
+#define MDIV_INDEX	3
+#define FVCO_INDEX	4
+#define BDIV_INDEX	5
+#define FBIT_INDEX	6
+#define FLS_INDEX	7
+#define FDP_INDEX	8
+
+#define PHY_GCR_BIT_CLK_OUT	BIT(0)
+#define PHY_GCR_LS_CLK_OUT	BIT(4)
+#define PHY_GCR_DP_CLK_OUT	BIT(8)
+#define PHY_GCR_RSTZ		BIT(24)
+#define PHY_GCR_DIV_RSTN	BIT(25)
+
+#define PHY_PxPLLTESTCR_TDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_NDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_BDIV	GENMASK(9, 0)
+#define PHY_PxPLLSDCR1_MDIV	GENMASK(9, 0)
+
+#define PLL_EN		BIT(0)
+#define PLL_LOCK	BIT(0)
+#define CM_EN_DL	(BIT(28) | BIT(20) | BIT(12) | BIT(4))
+#define CM_EN_DL4	BIT(4)
+#define VM_EN_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_BIAS_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_DIG_DL	GENMASK(4, 0)
+#define BIAS_EN		BIT(28)
+#define POWER_OK	BIT(12)
+
+#define WCLKCR_SLV_CLKPIX_SEL	BIT(0)
+#define WCLKCR_SRCSEL		BIT(8)
+
+/* Sleep & timeout for pll lock/unlock */
+#define SLEEP_US	1000
+#define TIMEOUT_US	20000000
+
+#define PHY_SLV_OFS	0x100
+
+struct stm32_lvds {
+	void __iomem *base;
+	struct udevice *panel;
+	u32 refclk;
+	int link_type;
+	int bus_format;
+	struct udevice *vdd_reg;
+	struct udevice *vdda18_reg;
+};
+
+/*
+ * enum lvds_pixels_order - Pixel order of an LVDS connection
+ * @LVDS_DUAL_LINK_EVEN_ODD_PIXELS: Even pixels are expected to be generated
+ *    from the first port, odd pixels from the second port
+ * @LVDS_DUAL_LINK_ODD_EVEN_PIXELS: Odd pixels are expected to be generated
+ *    from the first port, even pixels from the second port
+ */
+enum lvds_pixels_order {
+	LVDS_SINGLE_LINK_PRIMARY = BIT(0),
+	LVDS_SINGLE_LINK_SECONDARY = BIT(1),
+	LVDS_DUAL_LINK_EVEN_ODD_PIXELS = BIT(2),
+	LVDS_DUAL_LINK_ODD_EVEN_PIXELS = BIT(3),
+};
+
+enum lvds_pixel {
+	PIX_R_0		= 0x00,
+	PIX_R_1		= 0x01,
+	PIX_R_2		= 0x02,
+	PIX_R_3		= 0x03,
+	PIX_R_4		= 0x04,
+	PIX_R_5		= 0x05,
+	PIX_R_6		= 0x06,
+	PIX_R_7		= 0x07,
+	PIX_G_0		= 0x08,
+	PIX_G_1		= 0x09,
+	PIX_G_2		= 0x0A,
+	PIX_G_3		= 0x0B,
+	PIX_G_4		= 0x0C,
+	PIX_G_5		= 0x0D,
+	PIX_G_6		= 0x0E,
+	PIX_G_7		= 0x0F,
+	PIX_B_0		= 0x10,
+	PIX_B_1		= 0x11,
+	PIX_B_2		= 0x12,
+	PIX_B_3		= 0x13,
+	PIX_B_4		= 0x14,
+	PIX_B_5		= 0x15,
+	PIX_B_6		= 0x16,
+	PIX_B_7		= 0x17,
+	PIX_H_S		= 0x18,
+	PIX_V_S		= 0x19,
+	PIX_D_E		= 0x1A,
+	PIX_C_E		= 0x1B,
+	PIX_C_I		= 0x1C,
+	PIX_TOG		= 0x1D,
+	PIX_ONE		= 0x1E,
+	PIX_ZER		= 0x1F,
+};
+
+/*
+ * Expected JEIDA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ */
+const enum lvds_pixel lvds_bitmap_jeida_rgb888[5][7] = {
+	{ PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE },
+	{ PIX_G_2, PIX_R_7, PIX_R_6, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2 },
+	{ PIX_B_3, PIX_B_2, PIX_G_7, PIX_G_6, PIX_G_5, PIX_G_4, PIX_G_3 },
+	{ PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_7, PIX_B_6, PIX_B_5, PIX_B_4 },
+	{ PIX_C_E, PIX_B_1, PIX_B_0, PIX_G_1, PIX_G_0, PIX_R_1, PIX_R_0 }
+};
+
+/*
+ * Expected VESA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ */
+const enum lvds_pixel lvds_bitmap_vesa_rgb888[5][7] = {
+	{ PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE },
+	{ PIX_G_0, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2, PIX_R_1, PIX_R_0 },
+	{ PIX_B_1, PIX_B_0, PIX_G_5, PIX_G_4, PIX_G_3, PIX_G_2, PIX_G_1 },
+	{ PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_5, PIX_B_4, PIX_B_3, PIX_B_2 },
+	{ PIX_C_E, PIX_B_7, PIX_B_6, PIX_G_7, PIX_G_6, PIX_R_7, PIX_R_6 }
+};
+
+static inline void lvds_writel(struct stm32_lvds *lvds, u32 reg, u32 val)
+{
+	writel(val, lvds->base + reg);
+}
+
+static inline u32 lvds_readl(struct stm32_lvds *lvds, u32 reg)
+{
+	return readl(lvds->base + reg);
+}
+
+static inline void lvds_set(struct stm32_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_writel(lvds, reg, lvds_readl(lvds, reg) | mask);
+}
+
+static inline void lvds_clear(struct stm32_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_writel(lvds, reg, lvds_readl(lvds, reg) & ~mask);
+}
+
+/* Integer mode */
+#define EN_SD		0
+#define EN_TWG		0
+#define DOWN_SPREAD	0
+#define TEST_DIV	70
+
+static u32 pll_get_clkout_khz(u32 clkin_khz, u32 bdiv, u32 mdiv, u32 ndiv)
+{
+	int divisor = ndiv * bdiv;
+
+	/* Prevents from division by 0 */
+	if (!divisor)
+		return 0;
+
+	return clkin_khz * mdiv / divisor;
+}
+
+#define NDIV_MIN	2
+#define NDIV_MAX	6
+#define BDIV_MIN	2
+#define BDIV_MAX	6
+#define MDIV_MIN	1
+#define MDIV_MAX	1023
+
+static int lvds_pll_get_params(u32 clkin_khz, u32 clkout_khz,
+			       u32 *bdiv, u32 *mdiv, u32 *ndiv)
+{
+	u32 i, o, n;
+	u32 delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = NDIV_MIN; i <= NDIV_MAX; i++) {
+		for (o = BDIV_MIN; o <= BDIV_MAX; o++) {
+			n = DIV_ROUND_CLOSEST(i * o * clkout_khz, clkin_khz);
+			/* Check ndiv according to vco range */
+			if (n < MDIV_MIN || n > MDIV_MAX)
+				continue;
+			/* Check if new delta is better & saves parameters */
+			delta = abs(pll_get_clkout_khz(clkin_khz, i, n, o) - clkout_khz);
+			if (delta < best_delta) {
+				*ndiv = i;
+				*mdiv = n;
+				*bdiv = o;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_lvds_pll_enable(struct stm32_lvds *lvds,
+				 struct display_timing *timings,
+				 int phy)
+{
+	u32 pll_in_khz, bdiv = 0, mdiv = 0, ndiv = 0;
+	int ret, val, multiplier;
+
+	/* Release PHY from reset */
+	lvds_set(lvds, LVDS_PxGCR(phy), PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+
+	/* lvds_pll_config */
+	/* Set PLL Slv & Mst configs and timings */
+	pll_in_khz = lvds->refclk / 1000;
+
+	if (lvds->link_type & LVDS_DUAL_LINK_EVEN_ODD_PIXELS ||
+	    lvds->link_type & LVDS_DUAL_LINK_ODD_EVEN_PIXELS)
+		multiplier = 2;
+	else
+		multiplier = 1;
+
+	ret = lvds_pll_get_params(pll_in_khz, timings->pixelclock.typ * 7 / 1000 / multiplier,
+				  &bdiv, &mdiv, &ndiv);
+	if (ret)
+		return ret;
+
+	/* Set PLL parameters */
+	lvds_writel(lvds, LVDS_PxPLLCR2(phy), (ndiv << 16) | bdiv);
+	lvds_writel(lvds, LVDS_PxPLLSDCR1(phy), mdiv);
+	lvds_writel(lvds, LVDS_PxPLLTESTCR(phy), TEST_DIV << 16);
+
+	/* Disable TWG and SD: for now, PLL just need to be in integer mode */
+	lvds_clear(lvds, LVDS_PxPLLCR1(phy), EN_TWG | EN_SD);
+
+	/* Power up bias and PLL dividers */
+	lvds_set(lvds, LVDS_PxDCR(phy), POWER_OK);
+
+	lvds_set(lvds, LVDS_PxCMCR1(phy), CM_EN_DL);
+	lvds_set(lvds, LVDS_PxCMCR2(phy), CM_EN_DL4);
+
+	lvds_set(lvds, LVDS_PxPLLCPCR(phy), 0x1);
+	lvds_set(lvds, LVDS_PxBCR3(phy), VM_EN_DL);
+	lvds_set(lvds, LVDS_PxBCR1(phy), EN_BIAS_DL);
+	lvds_set(lvds, LVDS_PxCFGCR(phy), EN_DIG_DL);
+
+	/* lvds_pll_enable */
+	/* PLL lock timing control for the monitor unmask after startup (pll_en) */
+	/* Adjust the value so that the masking window is opened at start-up */
+	/* MST_MON_PLL_LOCK_UNMASK_TUNE */
+	lvds_writel(lvds, LVDS_PxMPLCR(phy), (0x200 - 0x160) << 16);
+
+	lvds_writel(lvds, LVDS_PxBCR2(phy), BIAS_EN);
+
+	lvds_set(lvds, LVDS_PxGCR(phy),
+		 PHY_GCR_DP_CLK_OUT | PHY_GCR_LS_CLK_OUT | PHY_GCR_BIT_CLK_OUT);
+
+	/* TODO hardcoded values for now */
+	lvds_set(lvds, LVDS_PxPLLTESTCR(phy), BIT(8) /* PLL_TEST_DIV_EN */);
+	lvds_set(lvds, LVDS_PxPLLCR1(phy), BIT(8) /* PLL_DIVIDERS_ENABLE */);
+
+	lvds_set(lvds, LVDS_PxSCR(phy), BIT(16) /* SER_DATA_OK */);
+
+	/* Enable the LVDS PLL & wait for its lock */
+	lvds_set(lvds, LVDS_PxPLLCR1(phy), PLL_EN);
+	ret = readl_poll_sleep_timeout(lvds->base + LVDS_PxPLLSR(phy),
+				       val, val & PLL_LOCK, SLEEP_US, TIMEOUT_US);
+	if (ret)
+		return ret;
+
+	/* Select MST PHY clock as pixel clock for the LDITX instead of FREF */
+	/* WCLKCR_SLV_CLKPIX_SEL is for dual link */
+	lvds_writel(lvds, LVDS_WCLKCR, WCLKCR_SLV_CLKPIX_SEL);
+
+	lvds_set(lvds, LVDS_PxPLLTESTCR(phy), BIT(0));
+
+	return 0;
+}
+
+static int stm32_lvds_enable(struct udevice *dev,
+			     const struct display_timing *timings)
+{
+	struct stm32_lvds *lvds = dev_get_priv(dev);
+	u32 lvds_cdl1cr = 0;
+	u32 lvds_cdl2cr = 0;
+	u32 lvds_dmlcr = 0;
+	u32 lvds_dmmcr = 0;
+	u32 lvds_cr = 0;
+	int i;
+
+	lvds_clear(lvds, LVDS_CDL1CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+	lvds_clear(lvds, LVDS_CDL2CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+
+	/* Set channel distribution */
+	lvds_cr &= ~CR_LKMOD;
+	lvds_cdl1cr = CDL1CR_DEFAULT;
+
+	if (lvds->link_type & LVDS_DUAL_LINK_EVEN_ODD_PIXELS ||
+	    lvds->link_type & LVDS_DUAL_LINK_ODD_EVEN_PIXELS) {
+		lvds_cr |= CR_LKMOD;
+		lvds_cdl2cr = CDL2CR_8DL_DEFAULT;
+	}
+
+	if (lvds->link_type & LVDS_SINGLE_LINK_SECONDARY)
+		lvds_cdl2cr = CDL2CR_4DL_DEFAULT;
+
+	/* Set signal polarity */
+	if (timings->flags & DISPLAY_FLAGS_DE_LOW)
+		lvds_cr |= CR_DEPOL;
+
+	if (timings->flags & DISPLAY_FLAGS_HSYNC_LOW)
+		lvds_cr |= CR_HSPOL;
+
+	if (timings->flags & DISPLAY_FLAGS_VSYNC_LOW)
+		lvds_cr |= CR_VSPOL;
+
+	/* Set link phase */
+	switch (lvds->link_type) {
+	case LVDS_DUAL_LINK_EVEN_ODD_PIXELS: /* LKPHA = 0 */
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	case LVDS_DUAL_LINK_ODD_EVEN_PIXELS: /* LKPHA = 1 */
+		lvds_cr |= CR_LKPHA;
+		break;
+	default:
+		dev_dbg(dev, "No phase precised, setting default\n");
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	}
+
+	/* Set Data Mapping */
+	switch (lvds->bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG: /* VESA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr = ((lvds_bitmap_vesa_rgb888[i][0])
+				      + (lvds_bitmap_vesa_rgb888[i][1] << 5)
+				      + (lvds_bitmap_vesa_rgb888[i][2] << 10)
+				      + (lvds_bitmap_vesa_rgb888[i][3] << 15));
+			lvds_dmmcr = ((lvds_bitmap_vesa_rgb888[i][4])
+				      + (lvds_bitmap_vesa_rgb888[i][5] << 5)
+				      + (lvds_bitmap_vesa_rgb888[i][6] << 10));
+
+			/* Write registers at the end of computations */
+			lvds_writel(lvds, LVDS_DMLCR(i), lvds_dmlcr);
+			lvds_writel(lvds, LVDS_DMMCR(i), lvds_dmmcr);
+		}
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA: /* JEIDA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr = ((lvds_bitmap_jeida_rgb888[i][0])
+				      + (lvds_bitmap_jeida_rgb888[i][1] << 5)
+				      + (lvds_bitmap_jeida_rgb888[i][2] << 10)
+				      + (lvds_bitmap_jeida_rgb888[i][3] << 15));
+			lvds_dmmcr = ((lvds_bitmap_jeida_rgb888[i][4])
+				      + (lvds_bitmap_jeida_rgb888[i][5] << 5)
+				      + (lvds_bitmap_jeida_rgb888[i][6] << 10));
+
+			/* Write registers at the end of computations */
+			lvds_writel(lvds, LVDS_DMLCR(i), lvds_dmlcr);
+			lvds_writel(lvds, LVDS_DMMCR(i), lvds_dmmcr);
+		}
+		break;
+	default:
+		dev_dbg(dev, "Unsupported LVDS bus format 0x%04x\n", lvds->bus_format);
+	}
+
+	/* Turn the output on */
+	lvds_cr |= CR_LVDSEN;
+
+	/* Commit config to registers */
+	lvds_set(lvds, LVDS_CR, lvds_cr);
+	lvds_writel(lvds, LVDS_CDL1CR, lvds_cdl1cr);
+	lvds_writel(lvds, LVDS_CDL2CR, lvds_cdl2cr);
+
+	return 0;
+}
+
+static int stm32_lvds_attach(struct udevice *dev)
+{
+	struct stm32_lvds *lvds = dev_get_priv(dev);
+	struct display_timing timings;
+	int ret;
+
+	ret = panel_get_display_timing(lvds->panel, &timings);
+	if (ret) {
+		ret = ofnode_decode_display_timing(dev_ofnode(lvds->panel),
+						   0, &timings);
+		if (ret) {
+			dev_err(dev, "decode display timing error %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = stm32_lvds_enable(dev, &timings);
+
+	return ret;
+}
+
+static int stm32_lvds_set_backlight(struct udevice *dev, int percent)
+{
+	struct stm32_lvds *lvds = dev_get_priv(dev);
+	int ret;
+
+	ret = panel_enable_backlight(lvds->panel);
+	if (ret) {
+		dev_err(dev, "panel %s enable backlight error %d\n",
+			lvds->panel->name, ret);
+	}
+
+	return ret;
+}
+
+static int lvds_handle_pixel_order(struct stm32_lvds *lvds)
+{
+	ofnode parent, panel_port0, panel_port1;
+	bool even_pixels_port0, odd_pixels_port0;
+	bool even_pixels_port1, odd_pixels_port1;
+
+	/*
+	 * In case we are operating in single link,
+	 * there is only one port linked to the LVDS.
+	 * Check whether we are in this case and exit if yes.
+	 */
+	parent = ofnode_find_subnode(dev_ofnode(lvds->panel), "ports");
+	if (!ofnode_valid(parent))
+		return LVDS_SINGLE_LINK_PRIMARY;
+
+	panel_port0 = ofnode_first_subnode(parent);
+	if (!ofnode_valid(panel_port0))
+		return -EPIPE;
+
+	panel_port1 = ofnode_next_subnode(panel_port0);
+	if (!ofnode_valid(panel_port1))
+		return -EPIPE;
+
+	even_pixels_port0 = ofnode_read_bool(panel_port0, "dual-lvds-even-pixels");
+	odd_pixels_port0 = ofnode_read_bool(panel_port0, "dual-lvds-odd-pixels");
+	even_pixels_port1 = ofnode_read_bool(panel_port1, "dual-lvds-even-pixels");
+	odd_pixels_port1 = ofnode_read_bool(panel_port1, "dual-lvds-odd-pixels");
+
+	/*
+	 * A valid dual-LVDS bus is found when one port is marked with
+	 * "dual-lvds-even-pixels", and the other port is marked with
+	 * "dual-lvds-odd-pixels"
+	 */
+	if (even_pixels_port0 && odd_pixels_port1 && !odd_pixels_port0 && !even_pixels_port1)
+		return LVDS_DUAL_LINK_EVEN_ODD_PIXELS;
+
+	if (odd_pixels_port0 && even_pixels_port1 && !even_pixels_port0 && !odd_pixels_port1)
+		return LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+
+	/* Ports have no tags even or odd. Both must be defined as single link */
+	if (!odd_pixels_port0 && !even_pixels_port0 && !odd_pixels_port1 && !even_pixels_port1)
+		return LVDS_SINGLE_LINK_PRIMARY | LVDS_SINGLE_LINK_SECONDARY;
+
+	return -EINVAL;
+}
+
+static int stm32_lvds_probe(struct udevice *dev)
+{
+	struct stm32_lvds *priv = dev_get_priv(dev);
+	struct display_timing timings;
+	struct reset_ctl rst;
+	struct clk pclk, refclk;
+	const char *data_mapping;
+	int ret;
+
+	ret =  device_get_supply_regulator(dev, "vdd",
+					   &priv->vdd_reg);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Warning: cannot get vdd supply\n");
+		return ret;
+	}
+
+	if (ret != -ENOENT) {
+		ret = regulator_set_enable(priv->vdd_reg, true);
+		if (ret)
+			return ret;
+	}
+
+	ret =  device_get_supply_regulator(dev, "vdda18",
+					   &priv->vdda18_reg);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Warning: cannot get vdda18 supply\n");
+		return ret;
+	}
+
+	if (ret != -ENOENT) {
+		ret = regulator_set_enable(priv->vdda18_reg, true);
+		if (ret)
+			return ret;
+	}
+
+	priv->base = dev_read_addr_ptr(dev);
+	if ((fdt_addr_t)priv->base == FDT_ADDR_T_NONE) {
+		dev_err(dev, "Unable to read LVDS base address\n");
+		return -EINVAL;
+	}
+
+	ret = clk_get_by_name(dev, "pclk", &pclk);
+	if (ret) {
+		dev_err(dev, "Unable to get peripheral clock: %d\n", ret);
+		goto err_reg;
+	}
+
+	ret = clk_enable(&pclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable peripheral clock: %d\n", ret);
+		goto err_reg;
+	}
+
+	ret = clk_get_by_name(dev, "ref", &refclk);
+	if (ret) {
+		dev_err(dev, "Unable to get reference clock: %d\n", ret);
+		goto err_reg;
+	}
+
+	ret = clk_enable(&refclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable reference clock: %d\n", ret);
+		goto err_clk;
+	}
+
+	priv->refclk = (unsigned int)clk_get_rate(&refclk);
+
+	ret = reset_get_by_index(dev, 0, &rst);
+	if (ret) {
+		dev_err(dev, "Failed to get LVDS reset: %d\n", ret);
+		goto err_rst;
+	}
+
+	reset_deassert(&rst);
+
+	ret = uclass_get_device_by_driver(UCLASS_PANEL,
+					  DM_DRIVER_GET(simple_panel), &priv->panel);
+	if (ret) {
+		dev_err(dev, "panel device error %d\n", ret);
+		goto err_rst;
+	}
+
+	ret = panel_get_display_timing(priv->panel, &timings);
+	if (ret) {
+		ret = ofnode_decode_display_timing(dev_ofnode(priv->panel),
+						   0, &timings);
+		if (ret) {
+			dev_err(dev, "decode display timing error %d\n", ret);
+			goto err_rst;
+		}
+	}
+
+	data_mapping = ofnode_read_string(dev_ofnode(priv->panel), "data-mapping");
+	if (!strcmp(data_mapping, "vesa-24"))
+		priv->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
+	else if (!strcmp(data_mapping, "jeida-24"))
+		priv->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA;
+	else
+		priv->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
+
+	/* Handle dual link config */
+	priv->link_type = lvds_handle_pixel_order(priv);
+	if (priv->link_type < 0)
+		goto err_rst;
+
+	if (priv->link_type & LVDS_SINGLE_LINK_SECONDARY ||
+	    priv->link_type & LVDS_DUAL_LINK_ODD_EVEN_PIXELS ||
+	    priv->link_type & LVDS_DUAL_LINK_EVEN_ODD_PIXELS) {
+		ret = stm32_lvds_pll_enable(priv, &timings, LVDS_PHY_SLAVE);
+		if (ret)
+			goto err_rst;
+	}
+
+	if (priv->link_type & LVDS_SINGLE_LINK_PRIMARY ||
+	    priv->link_type & LVDS_DUAL_LINK_ODD_EVEN_PIXELS ||
+	    priv->link_type & LVDS_DUAL_LINK_EVEN_ODD_PIXELS) {
+		ret = stm32_lvds_pll_enable(priv, &timings, LVDS_PHY_MASTER);
+		if (ret)
+			goto err_rst;
+	}
+
+	return 0;
+
+err_rst:
+	clk_disable(&refclk);
+err_clk:
+	clk_disable(&pclk);
+err_reg:
+	regulator_set_enable(priv->vdda18_reg, false);
+	regulator_set_enable(priv->vdd_reg, false);
+
+	return ret;
+}
+
+static const struct video_bridge_ops stm32_lvds_ops = {
+	.attach = stm32_lvds_attach,
+	.set_backlight = stm32_lvds_set_backlight,
+};
+
+static const struct udevice_id stm32_lvds_ids[] = {
+	{.compatible = "st,stm32mp25-lvds"},
+	{}
+};
+
+U_BOOT_DRIVER(stm32_lvds) = {
+	.name		= "stm32-display-lvds",
+	.id		= UCLASS_VIDEO_BRIDGE,
+	.of_match	= stm32_lvds_ids,
+	.ops		= &stm32_lvds_ops,
+	.probe		= stm32_lvds_probe,
+	.priv_auto	= sizeof(struct stm32_lvds),
+};
diff --git a/drivers/watchdog/arm_smc_wdt.c b/drivers/watchdog/arm_smc_wdt.c
index 0ea4444570..ee8a41fd47 100644
--- a/drivers/watchdog/arm_smc_wdt.c
+++ b/drivers/watchdog/arm_smc_wdt.c
@@ -46,6 +46,8 @@ static int smcwd_call(struct udevice *dev, enum smcwd_call call,
 		return -ENODEV;
 	if (res->a0 == PSCI_RET_INVALID_PARAMS)
 		return -EINVAL;
+	if (res->a0 == PSCI_RET_DISABLED)
+		return -ENODATA;
 	if (res->a0 != PSCI_RET_SUCCESS)
 		return -EIO;
 
@@ -99,6 +101,21 @@ static int smcwd_probe(struct udevice *dev)
 	priv->min_timeout = res.a1;
 	priv->max_timeout = res.a2;
 
+	/* If already started, then force u-boot to use it */
+	err = smcwd_call(dev, SMCWD_GET_TIMELEFT, 0, NULL);
+	switch (err) {
+	case 0:
+		dev_dbg(dev, "Already started\n");
+		wdt_set_force_start(dev);
+		break;
+	case -ENODATA:
+		dev_dbg(dev, "Not already started\n");
+		break;
+	default:
+		/* Optional SMCWD_GET_TIMELEFT not implemented */
+		break;
+	}
+
 	return 0;
 }
 
diff --git a/drivers/watchdog/stm32mp_wdt.c b/drivers/watchdog/stm32mp_wdt.c
index 4be616c1b6..4f2c92eb1f 100644
--- a/drivers/watchdog/stm32mp_wdt.c
+++ b/drivers/watchdog/stm32mp_wdt.c
@@ -21,11 +21,13 @@
 #define IWDG_PR		0x04	/* Prescaler Register */
 #define IWDG_RLR	0x08	/* ReLoad Register */
 #define IWDG_SR		0x0C	/* Status Register */
+#define IWDG_VERR	0x3F4	/* Version Register */
 
 /* IWDG_KR register bit mask */
 #define KR_KEY_RELOAD	0xAAAA	/* Reload counter enable */
 #define KR_KEY_ENABLE	0xCCCC	/* Peripheral enable */
 #define KR_KEY_EWA	0x5555	/* Write access enable */
+#define KR_KEY_DWA	0x0000	/* Write access disable*/
 
 /* IWDG_PR register bit values */
 #define PR_256		0x06	/* Prescaler set to 256 */
@@ -36,10 +38,17 @@
 /* IWDG_SR register bit values */
 #define SR_PVU		BIT(0)	/* Watchdog prescaler value update */
 #define SR_RVU		BIT(1)	/* Watchdog counter reload value update */
+#define SR_ONF		BIT(8)	/* Watchdog enable status bit */
+
+/* IWDG Compatibility */
+#define ONF_MIN_VER	0x31
+
+#define TIMEOUT_US	10000
 
 struct stm32mp_wdt_priv {
 	fdt_addr_t base;		/* registers addr in physical memory */
 	unsigned long wdt_clk_rate;	/* Watchdog dedicated clock rate */
+	unsigned int hw_version;	/* Peripheral version */
 };
 
 static int stm32mp_wdt_reset(struct udevice *dev)
@@ -90,6 +99,7 @@ static int stm32mp_wdt_start(struct udevice *dev, u64 timeout_ms, ulong flags)
 static int stm32mp_wdt_probe(struct udevice *dev)
 {
 	struct stm32mp_wdt_priv *priv = dev_get_priv(dev);
+	u32 rlr, sr;
 	struct clk clk;
 	int ret;
 
@@ -115,6 +125,29 @@ static int stm32mp_wdt_probe(struct udevice *dev)
 
 	priv->wdt_clk_rate = clk_get_rate(&clk);
 
+	priv->hw_version = readl(priv->base + IWDG_VERR);
+
+	if (priv->hw_version >= ONF_MIN_VER) {
+		if (readl(priv->base + IWDG_SR) & SR_ONF)
+			wdt_set_force_start(dev);
+	} else {
+		/*
+		 * Workaround for old versions without IWDG_SR_ONF bit:
+		 * - write in IWDG_RLR_OFFSET
+		 * - wait for sync
+		 * - if sync succeeds, then iwdg is running
+		 */
+		writel(KR_KEY_EWA, priv->base + IWDG_KR);
+		rlr = readl(priv->base + IWDG_RLR);
+		writel(rlr, priv->base + IWDG_RLR);
+		ret = readl_poll_timeout(priv->base + IWDG_SR, sr, sr & SR_RVU,
+					 TIMEOUT_US);
+		if (!ret)
+			wdt_set_force_start(dev);
+
+		writel(KR_KEY_DWA, priv->base + IWDG_KR);
+	}
+
 	dev_dbg(dev, "IWDG init done\n");
 
 	return 0;
diff --git a/drivers/watchdog/wdt-uclass.c b/drivers/watchdog/wdt-uclass.c
index 509896a1b8..6a4ab69b99 100644
--- a/drivers/watchdog/wdt-uclass.c
+++ b/drivers/watchdog/wdt-uclass.c
@@ -39,10 +39,20 @@ struct wdt_priv {
 	bool running;
 	/* autostart */
 	bool autostart;
+	/* Force start */
+	bool force_start;
 
 	struct cyclic_info *cyclic;
 };
 
+int wdt_set_force_start(struct udevice *dev)
+{
+	struct wdt_priv *priv;
+	priv = dev_get_uclass_priv(dev);
+	priv->force_start = true;
+	return 0;
+}
+
 static void wdt_cyclic(void *ctx)
 {
 	struct udevice *dev = ctx;
@@ -72,7 +82,8 @@ static void init_watchdog_dev(struct udevice *dev)
 			       dev->name);
 	}
 
-	if (!priv->autostart) {
+	if (!priv->force_start &&
+	    (!IS_ENABLED(CONFIG_WATCHDOG_AUTOSTART) || !priv->autostart)) {
 		printf("WDT:   Not starting %s\n", dev->name);
 		return;
 	}
diff --git a/dts/Makefile b/dts/Makefile
index 3437e54033..c5888832fb 100644
--- a/dts/Makefile
+++ b/dts/Makefile
@@ -30,7 +30,7 @@ endif
 
 targets += dt.dtb
 
-$(DTB): arch-dtbs
+$(DTB): arch-dtbs arch-ext-dtbs
 	$(Q)test -e $@ || (						\
 	echo >&2;							\
 	echo >&2 "Device Tree Source ($@) is not correctly specified.";	\
@@ -43,6 +43,15 @@ PHONY += arch-dtbs
 arch-dtbs:
 	$(Q)$(MAKE) $(build)=arch/$(ARCH)/dts dtbs
 
+PHONY += arch-ext-dtbs
+arch-ext-dtbs: arch-dtbs
+	$(Q)if [ -e $(EXT_DTS) ]; then \
+		echo "  EXT_DTS in $(EXT_DTS)"; \
+		$(MAKE) $(build)=$(EXT_DTS) dtbs && \
+		(cp $(EXT_DTS)/*.dtb arch/$(ARCH)/dts/ || \
+		/bin/true) || /bin/false; \
+	else /bin/true; fi
+
 ifeq ($(CONFIG_SPL_BUILD),y)
 obj-$(CONFIG_OF_EMBED) := dt-spl.dtb.o
 # support "out-of-tree" build for dtb-spl
@@ -66,3 +75,4 @@ clean-files := dt.dtb.S
 subdir- += ../arch/arc/dts ../arch/arm/dts ../arch/m68k/dts ../arch/microblaze/dts	\
 	   ../arch/mips/dts ../arch/nios2/dts ../arch/powerpc/dts ../arch/riscv/dts	\
 	   ../arch/sandbox/dts ../arch/sh/dts ../arch/x86/dts ../arch/xtensa/dts
+subdir- += $(EXT_DTS)
\ No newline at end of file
diff --git a/env/common.c b/env/common.c
index 0ecdb248a0..32203e6673 100644
--- a/env/common.c
+++ b/env/common.c
@@ -15,6 +15,7 @@
 #include <log.h>
 #include <sort.h>
 #include <asm/global_data.h>
+#include <asm/io.h>
 #include <linux/stddef.h>
 #include <search.h>
 #include <errno.h>
@@ -172,7 +173,7 @@ static int env_get_from_linear(const char *env, const char *name, char *buf,
 		value = &p[name_len + 1];
 
 		res = end - value;
-		memcpy(buf, value, min(len, res + 1));
+		memcpy_fromio(buf, value, min(len, res + 1));
 
 		if (len <= res) {
 			buf[len - 1] = '\0';
diff --git a/env/flash.c b/env/flash.c
index 1e75f8c004..31b81f56b0 100644
--- a/env/flash.c
+++ b/env/flash.c
@@ -15,6 +15,7 @@
 #include <env_internal.h>
 #include <log.h>
 #include <asm/global_data.h>
+#include <asm/io.h>
 #include <linux/stddef.h>
 #include <malloc.h>
 #include <search.h>
@@ -73,16 +74,34 @@ static ulong __maybe_unused end_addr_new =
 static int env_flash_init(void)
 {
 	int crc1_ok = 0, crc2_ok = 0;
+	uchar flag1, flag2;
+	ulong addr1, addr2;
+	env_t *tmp_env1, *tmp_env2;
 
-	uchar flag1 = flash_addr->flags;
-	uchar flag2 = flash_addr_new->flags;
+	gd->env_valid = ENV_INVALID;
+
+	if (!is_flash_available())
+		return 0;
+
+	tmp_env1 = (env_t *)malloc(CONFIG_ENV_SIZE);
+	tmp_env2 = (env_t *)malloc(CONFIG_ENV_SIZE);
+
+	if (!tmp_env1 || !tmp_env2) {
+		env_set_default("malloc() failed", 0);
+		return -EIO;
+	}
+
+	memcpy_fromio(tmp_env1, flash_addr, CONFIG_ENV_SIZE);
+	memcpy_fromio(tmp_env2, flash_addr_new, CONFIG_ENV_SIZE);
 
-	ulong addr1 = (ulong)&(flash_addr->data);
-	ulong addr2 = (ulong)&(flash_addr_new->data);
+	flag1 = tmp_env1->flags;
+	flag2 = tmp_env2->flags;
 
-	crc1_ok = crc32(0, flash_addr->data, ENV_SIZE) == flash_addr->crc;
-	crc2_ok =
-		crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc;
+	addr1 = (ulong)&(flash_addr->data);
+	addr2 = (ulong)&(flash_addr_new->data);
+
+	crc1_ok = crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc;
+	crc2_ok = crc32(0, tmp_env2->data, ENV_SIZE) == tmp_env2->crc;
 
 	if (crc1_ok && !crc2_ok) {
 		gd->env_addr	= addr1;
@@ -111,10 +130,92 @@ static int env_flash_init(void)
 		gd->env_valid	= ENV_REDUND;
 	}
 
+	free(tmp_env1);
+	free(tmp_env2);
+
 	return 0;
 }
+
+#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+static int save_rest_of_sector(ulong start, ulong end, char **saved_data)
+{
+	ulong up_data = 0;
+
+	up_data = end + 1 - (start + CONFIG_ENV_SIZE);
+	debug("Data to save 0x%lX\n", up_data);
+	if (up_data) {
+		*saved_data = malloc(up_data);
+		if (!saved_data) {
+			printf("Can't allocate the rest of sector\n");
+			return -ENOMEM;
+		}
+		memcpy_fromio(*saved_data, (void *)(start + CONFIG_ENV_SIZE),
+			      up_data);
+		debug("Data (start 0x%lX, len 0x%lX) saved at 0x%p\n",
+		      start + CONFIG_ENV_SIZE, up_data, *saved_data);
+	}
+
+	return 0;
+}
+
+static int restore_rest_of_sector(ulong start, ulong end, char *saved_data)
+{
+	ulong up_data;
+	int ret = 0;
+
+	up_data = end + 1 - (start + CONFIG_ENV_SIZE);
+	if (up_data) {
+		debug("Restoring the rest of data to 0x%lX len 0x%lX\n",
+		      start + CONFIG_ENV_SIZE, up_data);
+		ret = flash_write(saved_data, start + CONFIG_ENV_SIZE, up_data);
+	}
+
+	return ret;
+}
+#endif
+#endif
+
+static int env_update_flag(char flag, env_t *start, ulong end)
+{
+	env_t tmp_env;
+	char *saved_data = NULL;
+	int ret;
+
+	memcpy_fromio(&tmp_env, start, CONFIG_ENV_SIZE);
+	tmp_env.flags = flag;
+
+#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+	ret = save_rest_of_sector((ulong)start, end, &saved_data);
+	if (ret)
+		return ret;
+#endif
+	puts("Erasing Flash...");
+	debug(" %08lX ... %08lX ...", (ulong)start, end);
+
+	if (flash_sect_erase((ulong)start, end))
+		goto done;
+
+	puts("Writing to Flash... ");
+	debug(" %08lX ... %08lX ...",
+	      (ulong)&start,
+	      sizeof(tmp_env.data) + (ulong)&start->data);
+
+	ret = flash_write((char *)&tmp_env, (ulong)start, sizeof(tmp_env));
+	if (ret)
+		goto perror;
+
+#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+	ret = restore_rest_of_sector((long)start, end, saved_data);
 #endif
 
+perror:
+	flash_perror(ret);
+done:
+	free(saved_data);
+
+	return ret;
+}
+
 #ifdef CMD_SAVEENV
 static int env_flash_save(void)
 {
@@ -122,9 +223,6 @@ static int env_flash_save(void)
 	char	*saved_data = NULL;
 	char	flag = ENV_REDUND_OBSOLETE, new_flag = ENV_REDUND_ACTIVE;
 	int	rc = 1;
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	ulong	up_data = 0;
-#endif
 
 	debug("Protect off %08lX ... %08lX\n", (ulong)flash_addr, end_addr);
 
@@ -143,22 +241,10 @@ static int env_flash_save(void)
 	env_new.flags	= new_flag;
 
 #if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	up_data = end_addr_new + 1 - ((long)flash_addr_new + CONFIG_ENV_SIZE);
-	debug("Data to save 0x%lX\n", up_data);
-	if (up_data) {
-		saved_data = malloc(up_data);
-		if (saved_data == NULL) {
-			printf("Unable to save the rest of sector (%ld)\n",
-				up_data);
-			goto done;
-		}
-		memcpy(saved_data,
-			(void *)((long)flash_addr_new + CONFIG_ENV_SIZE),
-			up_data);
-		debug("Data (start 0x%lX, len 0x%lX) saved at 0x%p\n",
-			(long)flash_addr_new + CONFIG_ENV_SIZE,
-			up_data, saved_data);
-	}
+	rc = save_rest_of_sector((long)flash_addr_new, end_addr_new, &saved_data);
+	if (rc)
+		goto done;
+
 #endif
 	puts("Erasing Flash...");
 	debug(" %08lX ... %08lX ...", (ulong)flash_addr_new, end_addr_new);
@@ -168,27 +254,22 @@ static int env_flash_save(void)
 
 	puts("Writing to Flash... ");
 	debug(" %08lX ... %08lX ...",
-		(ulong)&(flash_addr_new->data),
+		(ulong)&(flash_addr_new),
 		sizeof(env_ptr->data) + (ulong)&(flash_addr_new->data));
 	rc = flash_write((char *)&env_new, (ulong)flash_addr_new,
 			 sizeof(env_new));
 	if (rc)
 		goto perror;
 
-	rc = flash_write(&flag, (ulong)&(flash_addr->flags),
-			 sizeof(flash_addr->flags));
+	rc = env_update_flag(flag, flash_addr, end_addr);
 	if (rc)
 		goto perror;
 
 #if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	if (up_data) { /* restore the rest of sector */
-		debug("Restoring the rest of data to 0x%lX len 0x%lX\n",
-			(long)flash_addr_new + CONFIG_ENV_SIZE, up_data);
-		if (flash_write(saved_data,
-				(long)flash_addr_new + CONFIG_ENV_SIZE,
-				up_data))
-			goto perror;
-	}
+	rc = restore_rest_of_sector((long)flash_addr_new, end_addr_new, saved_data);
+	if (rc)
+		goto perror;
+
 #endif
 	puts("done\n");
 
@@ -222,13 +303,28 @@ done:
 #ifdef INITENV
 static int env_flash_init(void)
 {
-	if (crc32(0, env_ptr->data, ENV_SIZE) == env_ptr->crc) {
-		gd->env_addr	= (ulong)&(env_ptr->data);
-		gd->env_valid	= ENV_VALID;
+	env_t *tmp_env;
+
+	gd->env_valid = ENV_INVALID;
+
+	if (!is_flash_available())
 		return 0;
+
+	tmp_env = malloc(CONFIG_ENV_SIZE);
+	if (!tmp_env) {
+		env_set_default("malloc() failed", 0);
+		return -EIO;
 	}
 
-	gd->env_valid = ENV_INVALID;
+	memcpy_fromio(tmp_env, env_ptr, CONFIG_ENV_SIZE);
+
+	if (crc32(0, tmp_env->data, ENV_SIZE) == tmp_env->crc) {
+		gd->env_addr = (ulong)&(env_ptr->data);
+		gd->env_valid = ENV_VALID;
+	}
+
+	free(tmp_env);
+
 	return 0;
 }
 #endif
@@ -306,6 +402,17 @@ done:
 #ifdef LOADENV
 static int env_flash_load(void)
 {
+	env_t *tmp_env;
+	int ret = 0;
+
+	tmp_env = malloc(CONFIG_ENV_SIZE);
+	if (!tmp_env) {
+		env_set_default("malloc() failed", 0);
+		return -EIO;
+	}
+
+	memcpy_fromio(tmp_env, flash_addr, CONFIG_ENV_SIZE);
+
 #ifdef CONFIG_ENV_ADDR_REDUND
 	if (gd->env_addr != (ulong)&(flash_addr->data)) {
 		env_t *etmp = flash_addr;
@@ -319,35 +426,36 @@ static int env_flash_load(void)
 	}
 
 	if (flash_addr_new->flags != ENV_REDUND_OBSOLETE &&
-	    crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc) {
-		char flag = ENV_REDUND_OBSOLETE;
-
+	    crc32(0, tmp_env->data, ENV_SIZE) == tmp_env->crc) {
 		gd->env_valid = ENV_REDUND;
 		flash_sect_protect(0, (ulong)flash_addr_new, end_addr_new);
-		flash_write(&flag,
-			    (ulong)&(flash_addr_new->flags),
-			    sizeof(flash_addr_new->flags));
+		ret = env_update_flag(ENV_REDUND_OBSOLETE, flash_addr_new, end_addr_new);
 		flash_sect_protect(1, (ulong)flash_addr_new, end_addr_new);
 	}
 
 	if (flash_addr->flags != ENV_REDUND_ACTIVE &&
 	    (flash_addr->flags & ENV_REDUND_ACTIVE) == ENV_REDUND_ACTIVE) {
-		char flag = ENV_REDUND_ACTIVE;
-
 		gd->env_valid = ENV_REDUND;
 		flash_sect_protect(0, (ulong)flash_addr, end_addr);
-		flash_write(&flag,
-			    (ulong)&(flash_addr->flags),
-			    sizeof(flash_addr->flags));
+		ret = env_update_flag(ENV_REDUND_ACTIVE, flash_addr, end_addr);
 		flash_sect_protect(1, (ulong)flash_addr, end_addr);
 	}
 
-	if (gd->env_valid == ENV_REDUND)
-		puts("*** Warning - some problems detected "
-		     "reading environment; recovered successfully\n\n");
+	if (gd->env_valid == ENV_REDUND) {
+		if (ret)
+			puts("*** Error - some problems detected "
+			     "environment can't be recovered\n\n");
+		else
+			puts("*** Warning - some problems detected "
+			     "reading environment; recovered successfully\n\n");
+	}
+
 #endif /* CONFIG_ENV_ADDR_REDUND */
 
-	return env_import((char *)flash_addr, 1, H_EXTERNAL);
+	ret = env_import((char *)tmp_env, 1, H_EXTERNAL);
+	free(tmp_env);
+
+	return ret;
 }
 #endif /* LOADENV */
 
diff --git a/env/mmc.c b/env/mmc.c
index cb14bbb58f..995d177041 100644
--- a/env/mmc.c
+++ b/env/mmc.c
@@ -136,6 +136,13 @@ static inline s64 mmc_offset(struct mmc *mmc, int copy)
 			return val;
 	}
 
+	/* try the GPT partition with "U-Boot ENV" TYPE GUID */
+	if (IS_ENABLED(CONFIG_PARTITION_TYPE_GUID)) {
+		err = mmc_offset_try_partition(NULL, copy, &val);
+		if (!err)
+			return val;
+	}
+
 	defvalue = ENV_MMC_OFFSET;
 	propname = dt_prop.offset;
 
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index c4a7fd2843..5a7488befc 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -110,6 +110,7 @@ enum gpio_func_t {
 	GPIOF_UNUSED,		/* Not claimed */
 	GPIOF_UNKNOWN,		/* Not known */
 	GPIOF_FUNC,		/* Not used as a GPIO */
+	GPIOF_PROTECTED,	/* Protected access */
 
 	GPIOF_COUNT,
 };
diff --git a/include/clk.h b/include/clk.h
index d91285235f..0d4e1777e1 100644
--- a/include/clk.h
+++ b/include/clk.h
@@ -13,6 +13,15 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 
+#ifdef CONFIG_CLK_AUTO_ID
+#define CLK_ID_SZ	24
+#define CLK_ID_MSK	GENMASK(23, 0)
+#define CLK_ID(dev, id)	(((dev_seq(dev) + 1) << CLK_ID_SZ) | ((id) & CLK_ID_MSK))
+#else
+#define CLK_ID_MSK	(~0UL)
+#define CLK_ID(dev, id)	id
+#endif
+
 /**
  * DOC: Overview
  *
@@ -225,7 +234,7 @@ static inline struct clk *devm_clk_get_optional(struct udevice *dev,
 {
 	struct clk *clk = devm_clk_get(dev, id);
 
-	if (PTR_ERR(clk) == -ENODATA)
+	if (PTR_ERR(clk) == -ENODATA || PTR_ERR(clk) == -ENOENT)
 		return NULL;
 
 	return clk;
@@ -585,6 +594,16 @@ int clk_get_by_id(ulong id, struct clk **clkp);
  */
 bool clk_dev_binded(struct clk *clk);
 
+/**
+ * clk_get_id - get clk id
+ *
+ * @clk:	A clock struct
+ *
+ * Return: the clock identifier as it is defined by the clock provider in
+ * device tree or in platdata
+ */
+ulong clk_get_id(const struct clk *clk);
+
 #else /* CONFIG_IS_ENABLED(CLK) */
 
 static inline int clk_request(struct udevice *dev, struct clk *clk)
@@ -661,6 +680,11 @@ static inline bool clk_dev_binded(struct clk *clk)
 {
 	return false;
 }
+
+static inline ulong clk_get_id(const struct clk *clk)
+{
+	return 0;
+}
 #endif /* CONFIG_IS_ENABLED(CLK) */
 
 /**
diff --git a/include/configs/stm32f746-disco.h b/include/configs/stm32f746-disco.h
index 9bf01cac47..00ec9efba5 100644
--- a/include/configs/stm32f746-disco.h
+++ b/include/configs/stm32f746-disco.h
@@ -23,6 +23,10 @@
 #define BOOT_TARGET_DEVICES(func) \
 	func(MMC, mmc, 0)
 
+#define STM32F746_BOARD_EXTRA_ENV \
+	"splashimage=0xC0448000\0" \
+	"splashpos=m,m\0"
+
 #include <config_distro_bootcmd.h>
 #define CFG_EXTRA_ENV_SETTINGS				\
 			"kernel_addr_r=0xC0008000\0"		\
@@ -31,7 +35,8 @@
 			"scriptaddr=0xC0418000\0"		\
 			"pxefile_addr_r=0xC0428000\0" \
 			"ramdisk_addr_r=0xC0438000\0"		\
-			BOOTENV
+			BOOTENV	\
+			STM32F746_BOARD_EXTRA_ENV
 
 #define CFG_SYS_UBOOT_BASE		(CFG_SYS_FLASH_BASE + \
 					 CONFIG_SPL_PAD_TO)
diff --git a/include/configs/stm32mp13_common.h b/include/configs/stm32mp13_common.h
index 7c59c69e0b..09b4ebc088 100644
--- a/include/configs/stm32mp13_common.h
+++ b/include/configs/stm32mp13_common.h
@@ -21,7 +21,9 @@
  */
 #define CFG_SYS_BOOTMAPSZ		SZ_256M
 
-/* NAND support */
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
 
 /*****************************************************************************/
 #ifdef CONFIG_DISTRO_DEFAULTS
@@ -35,19 +37,49 @@
 #define BOOT_TARGET_MMC1(func)
 #endif
 
+#ifdef CONFIG_NET
+#define BOOT_TARGET_PXE(func)	func(PXE, pxe, na)
+#else
+#define BOOT_TARGET_PXE(func)
+#endif
+
+#ifdef CONFIG_CMD_UBIFS
+#define BOOT_TARGET_UBIFS(func)	func(UBIFS, ubifs, 0, UBI, boot)
+#else
+#define BOOT_TARGET_UBIFS(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func)	func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
 #define BOOT_TARGET_DEVICES(func)	\
 	BOOT_TARGET_MMC1(func)		\
-	BOOT_TARGET_MMC0(func)
+	BOOT_TARGET_MMC0(func)		\
+	BOOT_TARGET_UBIFS(func)		\
+	BOOT_TARGET_USB(func)		\
+	BOOT_TARGET_PXE(func)
 
 /*
  * default bootcmd for stm32mp13:
+ * for serial/usb: execute the stm32prog command
  * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition
+ * for nor boot, use the default distro order in ${boot_targets}
  */
 #define STM32MP_BOOTCMD "bootcmd_stm32mp=" \
 	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
 		"run env_check;" \
 		"if test ${boot_device} = mmc;" \
 		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
 		"run distro_bootcmd;" \
 	"fi;\0"
 
@@ -67,11 +99,11 @@
  * and the ramdisk at the end.
  */
 #define __KERNEL_ADDR_R     __stringify(0xc2000000)
-#define __FDT_ADDR_R        __stringify(0xc4000000)
-#define __SCRIPT_ADDR_R     __stringify(0xc4100000)
-#define __PXEFILE_ADDR_R    __stringify(0xc4200000)
-#define __FDTOVERLAY_ADDR_R __stringify(0xc4300000)
-#define __RAMDISK_ADDR_R    __stringify(0xc4400000)
+#define __FDT_ADDR_R        __stringify(0xc6000000)
+#define __SCRIPT_ADDR_R     __stringify(0xc6100000)
+#define __PXEFILE_ADDR_R    __stringify(0xc6200000)
+#define __FDTOVERLAY_ADDR_R __stringify(0xc6300000)
+#define __RAMDISK_ADDR_R    __stringify(0xc6400000)
 
 #define STM32MP_MEM_LAYOUT \
 	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
diff --git a/include/configs/stm32mp13_st_common.h b/include/configs/stm32mp13_st_common.h
index 20ec11477d..813fec0bf7 100644
--- a/include/configs/stm32mp13_st_common.h
+++ b/include/configs/stm32mp13_st_common.h
@@ -19,4 +19,39 @@
 					 230400, 460800, 921600, \
 					 1000000, 2000000, 4000000}
 
+#ifdef CFG_EXTRA_ENV_SETTINGS
+/*
+ * default bootcmd for stm32mp13 STMicroelectronics boards:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition or
+ * sdcard
+ * for nor boot, distro boot on SD card = mmc0 ONLY !
+ */
+#define ST_STM32MP13_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0 mmc0; fi;" \
+		"if test ${boot_device} = nor;" \
+		"then env set boot_targets mmc0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#undef CFG_EXTRA_ENV_SETTINGS
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	ST_STM32MP13_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+
 #endif
diff --git a/include/configs/stm32mp15_common.h b/include/configs/stm32mp15_common.h
index 29a1197b5a..19b989cba2 100644
--- a/include/configs/stm32mp15_common.h
+++ b/include/configs/stm32mp15_common.h
@@ -21,10 +21,6 @@
  */
 #define CFG_SYS_BOOTMAPSZ		SZ_256M
 
-/* NAND support */
-
-/* Ethernet need */
-
 #define STM32MP_FIP_IMAGE_GUID \
 	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
 		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
@@ -108,11 +104,11 @@
  * and the ramdisk at the end.
  */
 #define __KERNEL_ADDR_R     __stringify(0xc2000000)
-#define __FDT_ADDR_R        __stringify(0xc4000000)
-#define __SCRIPT_ADDR_R     __stringify(0xc4100000)
-#define __PXEFILE_ADDR_R    __stringify(0xc4200000)
-#define __FDTOVERLAY_ADDR_R __stringify(0xc4300000)
-#define __RAMDISK_ADDR_R    __stringify(0xc4400000)
+#define __FDT_ADDR_R        __stringify(0xc6000000)
+#define __SCRIPT_ADDR_R     __stringify(0xc6100000)
+#define __PXEFILE_ADDR_R    __stringify(0xc6200000)
+#define __FDTOVERLAY_ADDR_R __stringify(0xc6300000)
+#define __RAMDISK_ADDR_R    __stringify(0xc6400000)
 
 #define STM32MP_MEM_LAYOUT \
 	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
diff --git a/include/configs/stm32mp15_dh_dhsom.h b/include/configs/stm32mp15_dh_dhsom.h
index 9192169062..8ff882264f 100644
--- a/include/configs/stm32mp15_dh_dhsom.h
+++ b/include/configs/stm32mp15_dh_dhsom.h
@@ -20,7 +20,26 @@
 
 #define STM32MP_BOARD_EXTRA_ENV \
 	"usb_pgood_delay=1000\0" \
-	"update_sf=" /* Erase SPI NOR and install U-Boot from SD */	\
+	"dh_update_sd_to_emmc=" /* Install U-Boot from SD to eMMC */	\
+		"setexpr loadaddr1 ${loadaddr} + 0x1000000 && "		\
+		"load mmc 0:4 ${loadaddr1} boot/u-boot-spl.stm32 && "	\
+		"setexpr sblkcnt ${filesize} + 0x1ff && "		\
+		"setexpr sblkcnt ${sblkcnt} / 0x200 && "		\
+		"load mmc 0:4 ${loadaddr} boot/u-boot.itb && "		\
+		"setexpr ublkcnt ${filesize} + 0x1ff && "		\
+		"setexpr ublkcnt ${ublkcnt} / 0x200 && "		\
+		"mmc partconf 1 1 1 1 && mmc dev 1 1 && "		\
+		"mmc write ${loadaddr1} 0 ${sblkcnt} && "		\
+		"mmc dev 1 2 && "					\
+		"mmc write ${loadaddr1} 0 ${sblkcnt} && "		\
+		"mmc dev 1 && "						\
+		"gpt write mmc 1 'name=ssbl,size=2MiB' && "		\
+		"mmc write ${loadaddr} 0x22 ${ublkcnt} && "		\
+		"mmc partconf 1 1 1 0 && "				\
+		"setenv loadaddr1 && "					\
+		"setenv sblkcnt && "					\
+		"setenv ublkcnt\0"					\
+	"dh_update_sd_to_sf=" /* Erase SPI NOR and install U-Boot from SD */ \
 		"setexpr loadaddr1 ${loadaddr} + 0x1000000 && "		\
 		"load mmc 0:4 ${loadaddr1} /boot/u-boot-spl.stm32 && "	\
 		"env set filesize1 ${filesize} && "			\
@@ -29,7 +48,9 @@
 		"sf update ${loadaddr1} 0 ${filesize1} && "		\
 		"sf update ${loadaddr1} 0x40000 ${filesize1} && "	\
 		"sf update ${loadaddr} 0x80000 ${filesize} && "		\
-		"env set filesize1 && env set loadaddr1\0"
+		"env set filesize1 && env set loadaddr1\0"		\
+	"update_sf=run dh_update_sd_to_sf\0"
+
 
 #include <configs/stm32mp15_common.h>
 
diff --git a/include/configs/stm32mp15_st_common.h b/include/configs/stm32mp15_st_common.h
index 60838cb0e3..271ac74a78 100644
--- a/include/configs/stm32mp15_st_common.h
+++ b/include/configs/stm32mp15_st_common.h
@@ -26,7 +26,8 @@
  * default bootcmd for stm32mp1 STMicroelectronics boards:
  * for serial/usb: execute the stm32prog command
  * for mmc boot (eMMC, SD card), distro boot on the same mmc device
- * for nand or spi-nand boot, distro boot with ubifs on UBI partition
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition or
+ * sdcard
  * for nor boot, distro boot on SD card = mmc0 ONLY !
  */
 #define ST_STM32MP1_BOOTCMD "bootcmd_stm32mp=" \
@@ -39,7 +40,7 @@
 		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
 		"if test ${boot_device} = nand ||" \
 		  " test ${boot_device} = spi-nand ;" \
-		"then env set boot_targets ubifs0; fi;" \
+		"then env set boot_targets ubifs0 mmc0; fi;" \
 		"if test ${boot_device} = nor;" \
 		"then env set boot_targets mmc0; fi;" \
 		"run distro_bootcmd;" \
diff --git a/include/configs/stm32mp21_common.h b/include/configs/stm32mp21_common.h
new file mode 100644
index 0000000000..1b0daf4b5b
--- /dev/null
+++ b/include/configs/stm32mp21_common.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STM32MP21x CPU
+ */
+
+#ifndef __CONFIG_STM32MP21_COMMMON_H
+#define __CONFIG_STM32MP21_COMMMON_H
+#include <linux/sizes.h>
+#include <asm/arch/stm32.h>
+
+/*
+ * Configuration of the external SRAM memory used by U-Boot
+ */
+#define CFG_SYS_SDRAM_BASE	STM32_DDR_BASE
+
+/*
+ * For booting Linux, use the first 256 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_SYS_BOOTMAPSZ		SZ_256M
+
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
+/*****************************************************************************/
+#ifdef CONFIG_DISTRO_DEFAULTS
+/*****************************************************************************/
+
+#ifdef CONFIG_NET
+#define BOOT_TARGET_PXE(func)	func(PXE, pxe, na)
+#else
+#define BOOT_TARGET_PXE(func)
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#define BOOT_TARGET_MMC0(func)	func(MMC, mmc, 0)
+#define BOOT_TARGET_MMC1(func)	func(MMC, mmc, 1)
+#define BOOT_TARGET_MMC2(func)	func(MMC, mmc, 2)
+#else
+#define BOOT_TARGET_MMC0(func)
+#define BOOT_TARGET_MMC1(func)
+#define BOOT_TARGET_MMC2(func)
+#endif
+
+#ifdef CONFIG_CMD_UBIFS
+#define BOOT_TARGET_UBIFS(func)	func(UBIFS, ubifs, 0, UBI, boot)
+#else
+#define BOOT_TARGET_UBIFS(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func)	func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func)	\
+	BOOT_TARGET_MMC1(func)		\
+	BOOT_TARGET_UBIFS(func)		\
+	BOOT_TARGET_MMC0(func)		\
+	BOOT_TARGET_MMC2(func)		\
+	BOOT_TARGET_USB(func)		\
+	BOOT_TARGET_PXE(func)
+
+/*
+ * default bootcmd for stm32mp21:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for NAND or SPI-NAND boot, distro boot with UBIFS on UBI partition
+ * for other boot, use the default distro order in ${boot_targets}
+ */
+#define STM32MP_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#ifndef STM32MP_BOARD_EXTRA_ENV
+#define STM32MP_BOARD_EXTRA_ENV
+#endif
+
+#define STM32MP_EXTRA \
+	"env_check=if env info -p -d -q; then env save; fi\0" \
+	"boot_net_usb_start=true\0"
+/*
+ * memory layout for 96MB uncompressed/compressed kernel,
+ * 1M fdt, 1M script, 1M pxe and 1M for overlay
+ * and the ramdisk at the end.
+ */
+#define __KERNEL_COMP_ADDR_R	__stringify(0x84000000)
+#define __KERNEL_COMP_SIZE_R	__stringify(0x04000000)
+#define __KERNEL_ADDR_R		__stringify(0x8a000000)
+#define __FDT_ADDR_R		__stringify(0x90000000)
+#define __SCRIPT_ADDR_R		__stringify(0x90100000)
+#define __PXEFILE_ADDR_R	__stringify(0x90200000)
+#define __FDTOVERLAY_ADDR_R	__stringify(0x90300000)
+#define __RAMDISK_ADDR_R	__stringify(0x90400000)
+
+#define STM32MP_MEM_LAYOUT \
+	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
+	"fdt_addr_r=" __FDT_ADDR_R "\0" \
+	"scriptaddr=" __SCRIPT_ADDR_R "\0" \
+	"pxefile_addr_r=" __PXEFILE_ADDR_R "\0" \
+	"fdtoverlay_addr_r=" __FDTOVERLAY_ADDR_R "\0" \
+	"ramdisk_addr_r=" __RAMDISK_ADDR_R "\0" \
+	"kernel_comp_addr_r=" __KERNEL_COMP_ADDR_R "\0"	\
+	"kernel_comp_size=" __KERNEL_COMP_SIZE_R "\0"
+
+#include <config_distro_bootcmd.h>
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	STM32MP_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+
+#endif /* __CONFIG_STM32MP21_COMMMON_H */
diff --git a/include/configs/stm32mp21_st_common.h b/include/configs/stm32mp21_st_common.h
new file mode 100644
index 0000000000..f1af7b2254
--- /dev/null
+++ b/include/configs/stm32mp21_st_common.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STMicroelectonics STM32MP21x boards
+ */
+
+#ifndef __CONFIG_STM32MP21_ST_COMMON_H__
+#define __CONFIG_STM32MP21_ST_COMMON_H__
+
+#define STM32MP_BOARD_EXTRA_ENV \
+	"usb_pgood_delay=2000\0" \
+	"console=ttySTM0\0"
+
+#include <configs/stm32mp21_common.h>
+
+#ifdef CFG_EXTRA_ENV_SETTINGS
+/*
+ * default bootcmd for stm32mp21 STMicroelectronics boards:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition or
+ * sdcard
+ * for nor boot, distro boot on SD card = mmc0 ONLY !
+ */
+#define ST_STM32MP21_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0 mmc0; fi;" \
+		"if test ${boot_device} = nor;" \
+		"then env set boot_targets mmc0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#undef CFG_EXTRA_ENV_SETTINGS
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	ST_STM32MP21_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+#endif /* __CONFIG_STM32MP21_ST_COMMON_H__ */
diff --git a/include/configs/stm32mp23_common.h b/include/configs/stm32mp23_common.h
new file mode 100644
index 0000000000..d9cb8b2392
--- /dev/null
+++ b/include/configs/stm32mp23_common.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STM32MP23x CPU
+ */
+
+#ifndef __CONFIG_STM32MP23_COMMMON_H
+#define __CONFIG_STM32MP23_COMMMON_H
+#include <linux/sizes.h>
+#include <asm/arch/stm32.h>
+
+/*
+ * Configuration of the external SRAM memory used by U-Boot
+ */
+#define CFG_SYS_SDRAM_BASE	STM32_DDR_BASE
+
+/*
+ * For booting Linux, use the first 256 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_SYS_BOOTMAPSZ		SZ_256M
+
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
+/*****************************************************************************/
+#ifdef CONFIG_DISTRO_DEFAULTS
+/*****************************************************************************/
+
+#ifdef CONFIG_NET
+#define BOOT_TARGET_PXE(func)	func(PXE, pxe, na)
+#else
+#define BOOT_TARGET_PXE(func)
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#define BOOT_TARGET_MMC0(func)	func(MMC, mmc, 0)
+#define BOOT_TARGET_MMC1(func)	func(MMC, mmc, 1)
+#define BOOT_TARGET_MMC2(func)	func(MMC, mmc, 2)
+#else
+#define BOOT_TARGET_MMC0(func)
+#define BOOT_TARGET_MMC1(func)
+#define BOOT_TARGET_MMC2(func)
+#endif
+
+#ifdef CONFIG_CMD_UBIFS
+#define BOOT_TARGET_UBIFS(func)	func(UBIFS, ubifs, 0, UBI, boot)
+#else
+#define BOOT_TARGET_UBIFS(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func)	func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func)	\
+	BOOT_TARGET_MMC1(func)		\
+	BOOT_TARGET_UBIFS(func)		\
+	BOOT_TARGET_MMC0(func)		\
+	BOOT_TARGET_MMC2(func)		\
+	BOOT_TARGET_USB(func)		\
+	BOOT_TARGET_PXE(func)
+
+/*
+ * default bootcmd for stm32mp23:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for NAND or SPI-NAND boot, distro boot with UBIFS on UBI partition
+ * for other boot, use the default distro order in ${boot_targets}
+ */
+#define STM32MP_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#ifndef STM32MP_BOARD_EXTRA_ENV
+#define STM32MP_BOARD_EXTRA_ENV
+#endif
+
+#define STM32MP_EXTRA \
+	"env_check=if env info -p -d -q; then env save; fi\0" \
+	"boot_net_usb_start=true\0"
+/*
+ * memory layout for 96MB uncompressed/compressed kernel,
+ * 1M fdt, 1M script, 1M pxe and 1M for overlay
+ * and the ramdisk at the end.
+ */
+#define __KERNEL_COMP_ADDR_R	__stringify(0x84000000)
+#define __KERNEL_COMP_SIZE_R	__stringify(0x04000000)
+#define __KERNEL_ADDR_R		__stringify(0x8a000000)
+#define __FDT_ADDR_R		__stringify(0x90000000)
+#define __SCRIPT_ADDR_R		__stringify(0x90100000)
+#define __PXEFILE_ADDR_R	__stringify(0x90200000)
+#define __FDTOVERLAY_ADDR_R	__stringify(0x90300000)
+#define __RAMDISK_ADDR_R	__stringify(0x90400000)
+
+#define STM32MP_MEM_LAYOUT \
+	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
+	"fdt_addr_r=" __FDT_ADDR_R "\0" \
+	"scriptaddr=" __SCRIPT_ADDR_R "\0" \
+	"pxefile_addr_r=" __PXEFILE_ADDR_R "\0" \
+	"fdtoverlay_addr_r=" __FDTOVERLAY_ADDR_R "\0" \
+	"ramdisk_addr_r=" __RAMDISK_ADDR_R "\0" \
+	"kernel_comp_addr_r=" __KERNEL_COMP_ADDR_R "\0"	\
+	"kernel_comp_size=" __KERNEL_COMP_SIZE_R "\0"
+
+#include <config_distro_bootcmd.h>
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	STM32MP_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+
+#endif /* __CONFIG_STM32MP23_COMMMON_H */
diff --git a/include/configs/stm32mp23_st_common.h b/include/configs/stm32mp23_st_common.h
new file mode 100644
index 0000000000..91469b4587
--- /dev/null
+++ b/include/configs/stm32mp23_st_common.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STMicroelectonics STM32MP23x boards
+ */
+
+#ifndef __CONFIG_STM32MP23_ST_COMMON_H__
+#define __CONFIG_STM32MP23_ST_COMMON_H__
+
+#define STM32MP_BOARD_EXTRA_ENV \
+	"usb_pgood_delay=2000\0" \
+	"console=ttySTM0\0"
+
+#include <configs/stm32mp23_common.h>
+
+#ifdef CFG_EXTRA_ENV_SETTINGS
+/*
+ * default bootcmd for stm32mp23 STMicroelectronics boards:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition or
+ * sdcard
+ * for nor boot, distro boot on SD card = mmc0 ONLY !
+ */
+#define ST_STM32MP23_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0 mmc0; fi;" \
+		"if test ${boot_device} = nor;" \
+		"then env set boot_targets mmc0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#undef CFG_EXTRA_ENV_SETTINGS
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	ST_STM32MP23_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+#endif
diff --git a/include/configs/stm32mp25_common.h b/include/configs/stm32mp25_common.h
new file mode 100644
index 0000000000..711b82430e
--- /dev/null
+++ b/include/configs/stm32mp25_common.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STM32MP25x CPU
+ */
+
+#ifndef __CONFIG_STM32MP25_COMMMON_H
+#define __CONFIG_STM32MP25_COMMMON_H
+#include <linux/sizes.h>
+#include <asm/arch/stm32.h>
+
+/*
+ * Configuration of the external SRAM memory used by U-Boot
+ */
+#define CFG_SYS_SDRAM_BASE	STM32_DDR_BASE
+
+/*
+ * For booting Linux, use the first 256 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CFG_SYS_BOOTMAPSZ		SZ_256M
+
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
+/*****************************************************************************/
+#ifdef CONFIG_DISTRO_DEFAULTS
+/*****************************************************************************/
+
+#ifdef CONFIG_NET
+#define BOOT_TARGET_PXE(func)	func(PXE, pxe, na)
+#else
+#define BOOT_TARGET_PXE(func)
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#define BOOT_TARGET_MMC0(func)	func(MMC, mmc, 0)
+#define BOOT_TARGET_MMC1(func)	func(MMC, mmc, 1)
+#define BOOT_TARGET_MMC2(func)	func(MMC, mmc, 2)
+#else
+#define BOOT_TARGET_MMC0(func)
+#define BOOT_TARGET_MMC1(func)
+#define BOOT_TARGET_MMC2(func)
+#endif
+
+#ifdef CONFIG_CMD_UBIFS
+#define BOOT_TARGET_UBIFS(func)	func(UBIFS, ubifs, 0, UBI, boot)
+#else
+#define BOOT_TARGET_UBIFS(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func)	func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func)	\
+	BOOT_TARGET_MMC1(func)		\
+	BOOT_TARGET_UBIFS(func)		\
+	BOOT_TARGET_MMC0(func)		\
+	BOOT_TARGET_MMC2(func)		\
+	BOOT_TARGET_USB(func)		\
+	BOOT_TARGET_PXE(func)
+
+/*
+ * default bootcmd for stm32mp25:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for NAND or SPI-NAND boot, distro boot with UBIFS on UBI partition
+ * for other boot, use the default distro order in ${boot_targets}
+ */
+#define STM32MP_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#ifndef STM32MP_BOARD_EXTRA_ENV
+#define STM32MP_BOARD_EXTRA_ENV
+#endif
+
+#define STM32MP_EXTRA \
+	"env_check=if env info -p -d -q; then env save; fi\0" \
+	"boot_net_usb_start=true\0"
+/*
+ * memory layout for 96MB uncompressed/compressed kernel,
+ * 1M fdt, 1M script, 1M pxe and 1M for overlay
+ * and the ramdisk at the end.
+ */
+#define __KERNEL_COMP_ADDR_R	__stringify(0x84000000)
+#define __KERNEL_COMP_SIZE_R	__stringify(0x04000000)
+#define __KERNEL_ADDR_R		__stringify(0x8a000000)
+#define __FDT_ADDR_R		__stringify(0x90000000)
+#define __SCRIPT_ADDR_R		__stringify(0x90100000)
+#define __PXEFILE_ADDR_R	__stringify(0x90200000)
+#define __FDTOVERLAY_ADDR_R	__stringify(0x90300000)
+#define __RAMDISK_ADDR_R	__stringify(0x90400000)
+
+#define STM32MP_MEM_LAYOUT \
+	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
+	"fdt_addr_r=" __FDT_ADDR_R "\0" \
+	"scriptaddr=" __SCRIPT_ADDR_R "\0" \
+	"pxefile_addr_r=" __PXEFILE_ADDR_R "\0" \
+	"fdtoverlay_addr_r=" __FDTOVERLAY_ADDR_R "\0" \
+	"ramdisk_addr_r=" __RAMDISK_ADDR_R "\0" \
+	"kernel_comp_addr_r=" __KERNEL_COMP_ADDR_R "\0"	\
+	"kernel_comp_size=" __KERNEL_COMP_SIZE_R "\0"
+
+#include <config_distro_bootcmd.h>
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	STM32MP_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+
+#endif /* __CONFIG_STM32MP25_COMMMON_H */
diff --git a/include/configs/stm32mp25_st_common.h b/include/configs/stm32mp25_st_common.h
new file mode 100644
index 0000000000..ab5a4a9164
--- /dev/null
+++ b/include/configs/stm32mp25_st_common.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STMicroelectonics STM32MP25x boards
+ */
+
+#ifndef __CONFIG_STM32MP25_ST_COMMON_H__
+#define __CONFIG_STM32MP25_ST_COMMON_H__
+
+#define STM32MP_BOARD_EXTRA_ENV \
+	"usb_pgood_delay=2000\0" \
+	"console=ttySTM0\0"
+
+#include <configs/stm32mp25_common.h>
+
+#ifdef CFG_EXTRA_ENV_SETTINGS
+/*
+ * default bootcmd for stm32mp25 STMicroelectronics boards:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition or
+ * sdcard
+ * for nor boot, distro boot on SD card = mmc0 ONLY !
+ */
+#define ST_STM32MP25_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0 mmc0; fi;" \
+		"if test ${boot_device} = nor;" \
+		"then env set boot_targets mmc0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#undef CFG_EXTRA_ENV_SETTINGS
+#define CFG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	ST_STM32MP25_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+#endif
diff --git a/include/dm/pinctrl.h b/include/dm/pinctrl.h
index e3e50afeaf..84a1bf916d 100644
--- a/include/dm/pinctrl.h
+++ b/include/dm/pinctrl.h
@@ -6,7 +6,7 @@
 #ifndef __PINCTRL_H
 #define __PINCTRL_H
 
-#define PINNAME_SIZE	10
+#define PINNAME_SIZE	16
 #define PINMUX_SIZE	80
 
 /**
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index 0432c95c9e..5a34a40665 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -141,10 +141,12 @@ enum uclass_id {
 	UCLASS_TIMER,		/* Timer device */
 	UCLASS_TPM,		/* Trusted Platform Module TIS interface */
 	UCLASS_UFS,		/* Universal Flash Storage */
+	UCLASS_UCSI,		/* USB Type-C Connector System Software Interface */
 	UCLASS_USB,		/* USB bus */
 	UCLASS_USB_DEV_GENERIC,	/* USB generic device */
 	UCLASS_USB_HUB,		/* USB hub */
 	UCLASS_USB_GADGET_GENERIC,	/* USB generic device */
+	UCLASS_USB_TYPEC,	/* USB Type-C */
 	UCLASS_VIDEO,		/* Video or LCD device */
 	UCLASS_VIDEO_BRIDGE,	/* Video bridge, e.g. DisplayPort to LVDS */
 	UCLASS_VIDEO_CONSOLE,	/* Text console driver for video device */
diff --git a/include/dt-bindings/arm/coresight-cti-dt.h b/include/dt-bindings/arm/coresight-cti-dt.h
new file mode 100644
index 0000000000..61e7bdf8ea
--- /dev/null
+++ b/include/dt-bindings/arm/coresight-cti-dt.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for the defined trigger signal
+ * types on CoreSight CTI.
+ */
+
+#ifndef _DT_BINDINGS_ARM_CORESIGHT_CTI_DT_H
+#define _DT_BINDINGS_ARM_CORESIGHT_CTI_DT_H
+
+#define GEN_IO		0
+#define GEN_INTREQ	1
+#define GEN_INTACK	2
+#define GEN_HALTREQ	3
+#define GEN_RESTARTREQ	4
+#define PE_EDBGREQ	5
+#define PE_DBGRESTART	6
+#define PE_CTIIRQ	7
+#define PE_PMUIRQ	8
+#define PE_DBGTRIGGER	9
+#define ETM_EXTOUT	10
+#define ETM_EXTIN	11
+#define SNK_FULL	12
+#define SNK_ACQCOMP	13
+#define SNK_FLUSHCOMP	14
+#define SNK_FLUSHIN	15
+#define SNK_TRIGIN	16
+#define STM_ASYNCOUT	17
+#define STM_TOUT_SPTE	18
+#define STM_TOUT_SW	19
+#define STM_TOUT_HETE	20
+#define STM_HWEVENT	21
+#define ELA_TSTART	22
+#define ELA_TSTOP	23
+#define ELA_DBGREQ	24
+#define CTI_TRIG_MAX	25
+
+#endif /*_DT_BINDINGS_ARM_CORESIGHT_CTI_DT_H */
diff --git a/include/dt-bindings/bus/stm32mp13_sys_bus.h b/include/dt-bindings/bus/stm32mp13_sys_bus.h
new file mode 100644
index 0000000000..1160de87bc
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp13_sys_bus.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H
+
+/* ETZPC IDs */
+#define STM32MP1_ETZPC_VREFBUF_ID	0
+#define STM32MP1_ETZPC_LPTIM2_ID	1
+#define STM32MP1_ETZPC_LPTIM3_ID	2
+#define STM32MP1_ETZPC_LTDC_ID		3
+#define STM32MP1_ETZPC_DCMIPP_ID	4
+#define STM32MP1_ETZPC_USBPHYCTRL_ID	5
+#define STM32MP1_ETZPC_DDRCTRLPHY_ID	6
+/* IDs 7-11 reserved */
+#define STM32MP1_ETZPC_IWDG1_ID		12
+#define STM32MP1_ETZPC_STGENC_ID	13
+/* IDs 14-15 reserved */
+#define STM32MP1_ETZPC_USART1_ID	16
+#define STM32MP1_ETZPC_USART2_ID	17
+#define STM32MP1_ETZPC_SPI4_ID		18
+#define STM32MP1_ETZPC_SPI5_ID		19
+#define STM32MP1_ETZPC_I2C3_ID		20
+#define STM32MP1_ETZPC_I2C4_ID		21
+#define STM32MP1_ETZPC_I2C5_ID		22
+#define STM32MP1_ETZPC_TIM12_ID		23
+#define STM32MP1_ETZPC_TIM13_ID		24
+#define STM32MP1_ETZPC_TIM14_ID		25
+#define STM32MP1_ETZPC_TIM15_ID		26
+#define STM32MP1_ETZPC_TIM16_ID		27
+#define STM32MP1_ETZPC_TIM17_ID		28
+/* IDs 29-31 reserved */
+#define STM32MP1_ETZPC_ADC1_ID		32
+#define STM32MP1_ETZPC_ADC2_ID		33
+#define STM32MP1_ETZPC_OTG_ID		34
+/* IDs 35-39 reserved */
+#define STM32MP1_ETZPC_TSC_ID		37
+#define STM32MP1_ETZPC_RNG_ID		40
+#define STM32MP1_ETZPC_HASH_ID		41
+#define STM32MP1_ETZPC_CRYP_ID		42
+#define STM32MP1_ETZPC_SAES_ID		43
+#define STM32MP1_ETZPC_PKA_ID		44
+#define STM32MP1_ETZPC_BKPSRAM_ID	45
+/* IDs 46-47 reserved */
+#define STM32MP1_ETZPC_ETH1_ID		48
+#define STM32MP1_ETZPC_ETH2_ID		49
+#define STM32MP1_ETZPC_SDMMC1_ID	50
+#define STM32MP1_ETZPC_SDMMC2_ID	51
+/* ID 52 reserved */
+#define STM32MP1_ETZPC_MCE_ID		53
+#define STM32MP1_ETZPC_FMC_ID		54
+#define STM32MP1_ETZPC_QSPI_ID		55
+/* IDs 56-59 reserved */
+#define STM32MP1_ETZPC_SRAM1_ID		60
+#define STM32MP1_ETZPC_SRAM2_ID		61
+#define STM32MP1_ETZPC_SRAM3_ID		62
+/* ID 63 reserved */
+
+#endif /* _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H */
diff --git a/include/dt-bindings/bus/stm32mp15_sys_bus.h b/include/dt-bindings/bus/stm32mp15_sys_bus.h
new file mode 100644
index 0000000000..97eacc7b5f
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp15_sys_bus.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H
+
+/* ETZPC IDs */
+#define STM32MP1_ETZPC_STGENC_ID	0
+#define STM32MP1_ETZPC_BKPSRAM_ID	1
+#define STM32MP1_ETZPC_IWDG1_ID		2
+#define STM32MP1_ETZPC_USART1_ID	3
+#define STM32MP1_ETZPC_SPI6_ID		4
+#define STM32MP1_ETZPC_I2C4_ID		5
+/* ID 6 reserved */
+#define STM32MP1_ETZPC_RNG1_ID		7
+#define STM32MP1_ETZPC_HASH1_ID		8
+#define STM32MP1_ETZPC_CRYP1_ID		9
+#define STM32MP1_ETZPC_DDRCTRL_ID	10
+#define STM32MP1_ETZPC_DDRPHYC_ID	11
+#define STM32MP1_ETZPC_I2C6_ID		12
+/* IDs 13-15 reserved */
+#define STM32MP1_ETZPC_TIM2_ID		16
+#define STM32MP1_ETZPC_TIM3_ID		17
+#define STM32MP1_ETZPC_TIM4_ID		18
+#define STM32MP1_ETZPC_TIM5_ID		19
+#define STM32MP1_ETZPC_TIM6_ID		20
+#define STM32MP1_ETZPC_TIM7_ID		21
+#define STM32MP1_ETZPC_TIM12_ID		22
+#define STM32MP1_ETZPC_TIM13_ID		23
+#define STM32MP1_ETZPC_TIM14_ID		24
+#define STM32MP1_ETZPC_LPTIM1_ID	25
+#define STM32MP1_ETZPC_WWDG1_ID		26
+#define STM32MP1_ETZPC_SPI2_ID		27
+#define STM32MP1_ETZPC_SPI3_ID		28
+#define STM32MP1_ETZPC_SPDIFRX_ID	29
+#define STM32MP1_ETZPC_USART2_ID	30
+#define STM32MP1_ETZPC_USART3_ID	31
+#define STM32MP1_ETZPC_UART4_ID		32
+#define STM32MP1_ETZPC_UART5_ID		33
+#define STM32MP1_ETZPC_I2C1_ID		34
+#define STM32MP1_ETZPC_I2C2_ID		35
+#define STM32MP1_ETZPC_I2C3_ID		36
+#define STM32MP1_ETZPC_I2C5_ID		37
+#define STM32MP1_ETZPC_CEC_ID		38
+#define STM32MP1_ETZPC_DAC_ID		39
+#define STM32MP1_ETZPC_UART7_ID		40
+#define STM32MP1_ETZPC_UART8_ID		41
+/* IDs 42-43 reserved */
+#define STM32MP1_ETZPC_MDIOS_ID		44
+/* IDs 45-47 reserved */
+#define STM32MP1_ETZPC_TIM1_ID		48
+#define STM32MP1_ETZPC_TIM8_ID		49
+/* ID 50 reserved */
+#define STM32MP1_ETZPC_USART6_ID	51
+#define STM32MP1_ETZPC_SPI1_ID		52
+#define STM32MP1_ETZPC_SPI4_ID		53
+#define STM32MP1_ETZPC_TIM15_ID		54
+#define STM32MP1_ETZPC_TIM16_ID		55
+#define STM32MP1_ETZPC_TIM17_ID		56
+#define STM32MP1_ETZPC_SPI5_ID		57
+#define STM32MP1_ETZPC_SAI1_ID		58
+#define STM32MP1_ETZPC_SAI2_ID		59
+#define STM32MP1_ETZPC_SAI3_ID		60
+#define STM32MP1_ETZPC_DFSDM_ID		61
+#define STM32MP1_ETZPC_TT_FDCAN_ID	62
+/* IDs 63 reserved */
+#define STM32MP1_ETZPC_LPTIM2_ID	64
+#define STM32MP1_ETZPC_LPTIM3_ID	65
+#define STM32MP1_ETZPC_LPTIM4_ID	66
+#define STM32MP1_ETZPC_LPTIM5_ID	67
+#define STM32MP1_ETZPC_SAI4_ID		68
+#define STM32MP1_ETZPC_VREFBUF_ID	69
+#define STM32MP1_ETZPC_DCMI_ID		70
+#define STM32MP1_ETZPC_CRC2_ID		71
+#define STM32MP1_ETZPC_ADC_ID		72
+#define STM32MP1_ETZPC_HASH2_ID		73
+#define STM32MP1_ETZPC_RNG2_ID		74
+#define STM32MP1_ETZPC_CRYP2_ID		75
+/* IDs 76-79 reserved */
+#define STM32MP1_ETZPC_SRAM1_ID		80
+#define STM32MP1_ETZPC_SRAM2_ID		81
+#define STM32MP1_ETZPC_SRAM3_ID		82
+#define STM32MP1_ETZPC_SRAM4_ID		83
+#define STM32MP1_ETZPC_RETRAM_ID	84
+#define STM32MP1_ETZPC_OTG_ID		85
+#define STM32MP1_ETZPC_SDMMC3_ID	86
+#define STM32MP1_ETZPC_DLYBSD3_ID	87
+#define STM32MP1_ETZPC_DMA1_ID		88
+#define STM32MP1_ETZPC_DMA2_ID		89
+#define STM32MP1_ETZPC_DMAMUX_ID	90
+#define STM32MP1_ETZPC_FMC_ID		91
+#define STM32MP1_ETZPC_QSPI_ID		92
+#define STM32MP1_ETZPC_DLYBQ_ID		93
+#define STM32MP1_ETZPC_ETH_ID		94
+/* ID 95 reserved */
+
+#endif /* _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H */
diff --git a/include/dt-bindings/clock/st,stm32mp21-rcc.h b/include/dt-bindings/clock/st,stm32mp21-rcc.h
new file mode 100644
index 0000000000..1b6d533e1e
--- /dev/null
+++ b/include/dt-bindings/clock/st,stm32mp21-rcc.h
@@ -0,0 +1,430 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP21_CLKS_H_
+#define _DT_BINDINGS_STM32MP21_CLKS_H_
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL4_CK			10
+#define PLL5_CK			11
+#define PLL6_CK			12
+#define PLL7_CK			13
+#define PLL8_CK			14
+
+#define CK_CPU1			15
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		16
+#define CK_ICN_APB2		17
+#define CK_ICN_APB3		18
+#define CK_ICN_APB4		19
+#define CK_ICN_APB5		20
+#define CK_ICN_APBDBG		21
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		22
+#define TIMG2_CK		23
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		24
+#define CK_ICN_SDMMC		25
+#define CK_ICN_DDR		26
+#define CK_ICN_DISPLAY		27
+#define CK_ICN_HSL		28
+#define CK_ICN_NIC		29
+#define CK_ICN_VID		30
+#define CK_FLEXGEN_07		31
+#define CK_FLEXGEN_08		32
+#define CK_FLEXGEN_09		33
+#define CK_FLEXGEN_10		34
+#define CK_FLEXGEN_11		35
+#define CK_FLEXGEN_12		36
+#define CK_FLEXGEN_13		37
+#define CK_FLEXGEN_14		38
+#define CK_FLEXGEN_15		39
+#define CK_FLEXGEN_16		40
+#define CK_FLEXGEN_17		41
+#define CK_FLEXGEN_18		42
+#define CK_FLEXGEN_19		43
+#define CK_FLEXGEN_20		44
+#define CK_FLEXGEN_21		45
+#define CK_FLEXGEN_22		46
+#define CK_FLEXGEN_23		47
+#define CK_FLEXGEN_24		48
+#define CK_FLEXGEN_25		49
+#define CK_FLEXGEN_26		50
+#define CK_FLEXGEN_27		51
+#define CK_FLEXGEN_28		52
+#define CK_FLEXGEN_29		53
+#define CK_FLEXGEN_30		54
+#define CK_FLEXGEN_31		55
+#define CK_FLEXGEN_32		56
+#define CK_FLEXGEN_33		57
+#define CK_FLEXGEN_34		58
+#define CK_FLEXGEN_35		59
+#define CK_FLEXGEN_36		60
+#define CK_FLEXGEN_37		61
+#define CK_FLEXGEN_38		62
+#define CK_FLEXGEN_39		63
+#define CK_FLEXGEN_40		64
+#define CK_FLEXGEN_41		65
+#define CK_FLEXGEN_42		66
+#define CK_FLEXGEN_43		67
+#define CK_FLEXGEN_44		68
+#define CK_FLEXGEN_45		69
+#define CK_FLEXGEN_46		70
+#define CK_FLEXGEN_47		71
+#define CK_FLEXGEN_48		72
+#define CK_FLEXGEN_49		73
+#define CK_FLEXGEN_50		74
+#define CK_FLEXGEN_51		75
+#define CK_FLEXGEN_52		76
+#define CK_FLEXGEN_53		77
+#define CK_FLEXGEN_54		78
+#define CK_FLEXGEN_55		79
+#define CK_FLEXGEN_56		80
+#define CK_FLEXGEN_57		81
+#define CK_FLEXGEN_58		82
+#define CK_FLEXGEN_59		83
+#define CK_FLEXGEN_60		84
+#define CK_FLEXGEN_61		85
+#define CK_FLEXGEN_62		86
+#define CK_FLEXGEN_63		87
+
+/* LOW SPEED MCU CLOCK */
+#define CK_ICN_LS_MCU		88
+
+#define CK_BUS_STM		89
+#define CK_BUS_FMC		90
+#define CK_BUS_ETH1		91
+#define CK_BUS_ETH2		92
+#define CK_BUS_DDRPHYC		93
+#define CK_BUS_SYSCPU1		94
+#define CK_BUS_HPDMA1		95
+#define CK_BUS_HPDMA2		96
+#define CK_BUS_HPDMA3		97
+#define CK_BUS_ADC1		98
+#define CK_BUS_ADC2		99
+#define CK_BUS_IPCC1		100
+#define CK_BUS_DCMIPSSI		101
+#define CK_BUS_CRC		102
+#define CK_BUS_MDF1		103
+#define CK_BUS_BKPSRAM		104
+#define CK_BUS_HASH1		105
+#define CK_BUS_HASH2		106
+#define CK_BUS_RNG1		107
+#define CK_BUS_RNG2		108
+#define CK_BUS_CRYP1		109
+#define CK_BUS_CRYP2		110
+#define CK_BUS_SAES		111
+#define CK_BUS_PKA		112
+#define CK_BUS_GPIOA		113
+#define CK_BUS_GPIOB		114
+#define CK_BUS_GPIOC		115
+#define CK_BUS_GPIOD		116
+#define CK_BUS_GPIOE		117
+#define CK_BUS_GPIOF		118
+#define CK_BUS_GPIOG		119
+#define CK_BUS_GPIOH		120
+#define CK_BUS_GPIOI		121
+#define CK_BUS_GPIOZ		122
+#define CK_BUS_CCB		123
+#define CK_BUS_RTC		124
+#define CK_BUS_LPUART1		125
+#define CK_BUS_LPTIM3		126
+#define CK_BUS_LPTIM4		127
+#define CK_BUS_LPTIM5		128
+#define CK_BUS_TIM2		129
+#define CK_BUS_TIM3		130
+#define CK_BUS_TIM4		131
+#define CK_BUS_TIM5		132
+#define CK_BUS_TIM6		133
+#define CK_BUS_TIM7		134
+#define CK_BUS_TIM10		135
+#define CK_BUS_TIM11		136
+#define CK_BUS_TIM12		137
+#define CK_BUS_TIM13		138
+#define CK_BUS_TIM14		139
+#define CK_BUS_LPTIM1		140
+#define CK_BUS_LPTIM2		141
+#define CK_BUS_SPI2		142
+#define CK_BUS_SPI3		143
+#define CK_BUS_SPDIFRX		144
+#define CK_BUS_USART2		145
+#define CK_BUS_USART3		146
+#define CK_BUS_UART4		147
+#define CK_BUS_UART5		148
+#define CK_BUS_I2C1		149
+#define CK_BUS_I2C2		150
+#define CK_BUS_I2C3		151
+#define CK_BUS_I3C1		152
+#define CK_BUS_I3C2		153
+#define CK_BUS_I3C3		154
+#define CK_BUS_TIM1		155
+#define CK_BUS_TIM8		156
+#define CK_BUS_TIM15		157
+#define CK_BUS_TIM16		158
+#define CK_BUS_TIM17		159
+#define CK_BUS_SAI1		160
+#define CK_BUS_SAI2		161
+#define CK_BUS_SAI3		162
+#define CK_BUS_SAI4		163
+#define CK_BUS_USART1		164
+#define CK_BUS_USART6		165
+#define CK_BUS_UART7		166
+#define CK_BUS_FDCAN		167
+#define CK_BUS_SPI1		168
+#define CK_BUS_SPI4		169
+#define CK_BUS_SPI5		170
+#define CK_BUS_SPI6		171
+#define CK_BUS_BSEC		172
+#define CK_BUS_IWDG1		173
+#define CK_BUS_IWDG2		174
+#define CK_BUS_IWDG3		175
+#define CK_BUS_IWDG4		176
+#define CK_BUS_WWDG1		177
+#define CK_BUS_VREF		178
+#define CK_BUS_DTS		179
+#define CK_BUS_SERC		180
+#define CK_BUS_HDP		181
+#define CK_BUS_DDRPERFM		182
+#define CK_BUS_OTG		183
+#define CK_BUS_LTDC		184
+#define CK_BUS_CSI		185
+#define CK_BUS_DCMIPP		186
+#define CK_BUS_DDRC		187
+#define CK_BUS_DDRCFG		188
+#define CK_BUS_STGEN		189
+#define CK_SYSDBG		190
+#define CK_KER_TIM2		191
+#define CK_KER_TIM3		192
+#define CK_KER_TIM4		193
+#define CK_KER_TIM5		194
+#define CK_KER_TIM6		195
+#define CK_KER_TIM7		196
+#define CK_KER_TIM10		197
+#define CK_KER_TIM11		198
+#define CK_KER_TIM12		199
+#define CK_KER_TIM13		200
+#define CK_KER_TIM14		201
+#define CK_KER_TIM1		202
+#define CK_KER_TIM8		203
+#define CK_KER_TIM15		204
+#define CK_KER_TIM16		205
+#define CK_KER_TIM17		206
+#define CK_BUS_SYSRAM		207
+#define CK_BUS_RETRAM		208
+#define CK_BUS_OSPI1		209
+#define CK_BUS_OTFD1		210
+#define CK_BUS_SRAM1		211
+#define CK_BUS_SDMMC1		212
+#define CK_BUS_SDMMC2		213
+#define CK_BUS_SDMMC3		214
+#define CK_BUS_DDR		215
+#define CK_BUS_RISAF4		216
+#define CK_BUS_USBHOHCI		217
+#define CK_BUS_USBHEHCI		218
+#define CK_KER_LPTIM1		219
+#define CK_KER_LPTIM2		220
+#define CK_KER_USART2		221
+#define CK_KER_UART4		222
+#define CK_KER_USART3		223
+#define CK_KER_UART5		224
+#define CK_KER_SPI2		225
+#define CK_KER_SPI3		226
+#define CK_KER_SPDIFRX		227
+#define CK_KER_I2C1		228
+#define CK_KER_I2C2		229
+#define CK_KER_I3C1		230
+#define CK_KER_I3C2		231
+#define CK_KER_I2C3		232
+#define CK_KER_I3C3		233
+#define CK_KER_SPI1		234
+#define CK_KER_SPI4		235
+#define CK_KER_SPI5		236
+#define CK_KER_SPI6		237
+#define CK_KER_USART1		238
+#define CK_KER_USART6		239
+#define CK_KER_UART7		240
+#define CK_KER_MDF1		241
+#define CK_KER_SAI1		242
+#define CK_KER_SAI2		243
+#define CK_KER_SAI3		244
+#define CK_KER_SAI4		245
+#define CK_KER_FDCAN		246
+#define CK_KER_CSI		247
+#define CK_KER_CSITXESC		248
+#define CK_KER_CSIPHY		249
+#define CK_KER_STGEN		250
+#define CK_KER_USB2PHY2EN	251
+#define CK_KER_LPUART1		252
+#define CK_KER_LPTIM3		253
+#define CK_KER_LPTIM4		254
+#define CK_KER_LPTIM5		255
+#define CK_KER_TSDBG		256
+#define CK_KER_TPIU		257
+#define CK_BUS_ETR		258
+#define CK_BUS_SYSATB		259
+#define CK_KER_ADC1		260
+#define CK_KER_ADC2		261
+#define CK_KER_OSPI1		262
+#define CK_KER_FMC		263
+#define CK_KER_SDMMC1		264
+#define CK_KER_SDMMC2		265
+#define CK_KER_SDMMC3		266
+#define CK_KER_ETH1		267
+#define CK_KER_ETH2		268
+#define CK_KER_ETH1PTP		269
+#define CK_KER_ETH2PTP		270
+#define CK_KER_USB2PHY1		271
+#define CK_KER_USB2PHY2		272
+#define CK_MCO1			273
+#define CK_MCO2			274
+#define CK_KER_DTS		275
+#define CK_ETH1_RX		276
+#define CK_ETH1_TX		277
+#define CK_ETH1_MAC		278
+#define CK_ETH2_RX		279
+#define CK_ETH2_TX		280
+#define CK_ETH2_MAC		281
+#define CK_ETH1_STP		282
+#define CK_ETH2_STP		283
+#define CK_KER_LTDC		284
+#define HSE_DIV2_CK		285
+#define CK_DBGMCU		286
+#define CK_DAP			287
+#define CK_KER_ETR		288
+#define CK_KER_STM		289
+
+#define STM32MP21_LAST_CLK	290
+
+#define CK_SCMI_ICN_HS_MCU	0
+#define CK_SCMI_ICN_SDMMC	1
+#define CK_SCMI_ICN_DDR		2
+#define CK_SCMI_ICN_DISPLAY	3
+#define CK_SCMI_ICN_HSL		4
+#define CK_SCMI_ICN_NIC		5
+#define CK_SCMI_ICN_VID		6
+#define CK_SCMI_FLEXGEN_07	7
+#define CK_SCMI_FLEXGEN_08	8
+#define CK_SCMI_FLEXGEN_09	9
+#define CK_SCMI_FLEXGEN_10	10
+#define CK_SCMI_FLEXGEN_11	11
+#define CK_SCMI_FLEXGEN_12	12
+#define CK_SCMI_FLEXGEN_13	13
+#define CK_SCMI_FLEXGEN_14	14
+#define CK_SCMI_FLEXGEN_15	15
+#define CK_SCMI_FLEXGEN_16	16
+#define CK_SCMI_FLEXGEN_17	17
+#define CK_SCMI_FLEXGEN_18	18
+#define CK_SCMI_FLEXGEN_19	19
+#define CK_SCMI_FLEXGEN_20	20
+#define CK_SCMI_FLEXGEN_21	21
+#define CK_SCMI_FLEXGEN_22	22
+#define CK_SCMI_FLEXGEN_23	23
+#define CK_SCMI_FLEXGEN_24	24
+#define CK_SCMI_FLEXGEN_25	25
+#define CK_SCMI_FLEXGEN_26	26
+#define CK_SCMI_FLEXGEN_27	27
+#define CK_SCMI_FLEXGEN_28	28
+#define CK_SCMI_FLEXGEN_29	29
+#define CK_SCMI_FLEXGEN_30	30
+#define CK_SCMI_FLEXGEN_31	31
+#define CK_SCMI_FLEXGEN_32	32
+#define CK_SCMI_FLEXGEN_33	33
+#define CK_SCMI_FLEXGEN_34	34
+#define CK_SCMI_FLEXGEN_35	35
+#define CK_SCMI_FLEXGEN_36	36
+#define CK_SCMI_FLEXGEN_37	37
+#define CK_SCMI_FLEXGEN_38	38
+#define CK_SCMI_FLEXGEN_39	39
+#define CK_SCMI_FLEXGEN_40	40
+#define CK_SCMI_FLEXGEN_41	41
+#define CK_SCMI_FLEXGEN_42	42
+#define CK_SCMI_FLEXGEN_43	43
+#define CK_SCMI_FLEXGEN_44	44
+#define CK_SCMI_FLEXGEN_45	45
+#define CK_SCMI_FLEXGEN_46	46
+#define CK_SCMI_FLEXGEN_47	47
+#define CK_SCMI_FLEXGEN_48	48
+#define CK_SCMI_FLEXGEN_49	49
+#define CK_SCMI_FLEXGEN_50	50
+#define CK_SCMI_FLEXGEN_51	51
+#define CK_SCMI_FLEXGEN_52	52
+#define CK_SCMI_FLEXGEN_53	53
+#define CK_SCMI_FLEXGEN_54	54
+#define CK_SCMI_FLEXGEN_55	55
+#define CK_SCMI_FLEXGEN_56	56
+#define CK_SCMI_FLEXGEN_57	57
+#define CK_SCMI_FLEXGEN_58	58
+#define CK_SCMI_FLEXGEN_59	59
+#define CK_SCMI_FLEXGEN_60	60
+#define CK_SCMI_FLEXGEN_61	61
+#define CK_SCMI_FLEXGEN_62	62
+#define CK_SCMI_FLEXGEN_63	63
+#define CK_SCMI_ICN_LS_MCU	64
+#define CK_SCMI_HSE		65
+#define CK_SCMI_LSE		66
+#define CK_SCMI_HSI		67
+#define CK_SCMI_LSI		68
+#define CK_SCMI_MSI		69
+#define CK_SCMI_HSE_DIV2	70
+#define CK_SCMI_CPU1		71
+#define CK_SCMI_SYSCPU1		72
+#define CK_SCMI_PLL2		73
+#define CK_SCMI_RTC		74
+#define CK_SCMI_RTCCK		75
+#define CK_SCMI_ICN_APB1	76
+#define CK_SCMI_ICN_APB2	77
+#define CK_SCMI_ICN_APB3	78
+#define CK_SCMI_ICN_APB4	79
+#define CK_SCMI_ICN_APB5	80
+#define CK_SCMI_ICN_APBDBG	81
+#define CK_SCMI_TIMG1		82
+#define CK_SCMI_TIMG2		83
+#define CK_SCMI_BKPSRAM		84
+#define CK_SCMI_BSEC		85
+#define CK_SCMI_BUS_ETR		86
+#define CK_SCMI_FMC		87
+#define CK_SCMI_GPIOA		88
+#define CK_SCMI_GPIOB		89
+#define CK_SCMI_GPIOC		90
+#define CK_SCMI_GPIOD		91
+#define CK_SCMI_GPIOE		92
+#define CK_SCMI_GPIOF		93
+#define CK_SCMI_GPIOG		94
+#define CK_SCMI_GPIOH		95
+#define CK_SCMI_GPIOI		96
+#define CK_SCMI_GPIOZ		97
+#define CK_SCMI_HPDMA1		98
+#define CK_SCMI_HPDMA2		99
+#define CK_SCMI_HPDMA3		100
+#define CK_SCMI_IPCC1		101
+#define CK_SCMI_RETRAM		102
+#define CK_SCMI_SRAM1		103
+#define CK_SCMI_SYSRAM		104
+#define CK_SCMI_OSPI1		105
+#define CK_SCMI_TPIU		106
+#define CK_SCMI_SYSDBG		107
+#define CK_SCMI_SYSATB		108
+#define CK_SCMI_TSDBG		109
+#define CK_SCMI_BUS_STM		110
+#define CK_SCMI_KER_STM		111
+#define CK_SCMI_KER_ETR		112
+
+#endif /* _DT_BINDINGS_STM32MP21_CLKS_H_ */
diff --git a/include/dt-bindings/clock/st,stm32mp25-rcc.h b/include/dt-bindings/clock/st,stm32mp25-rcc.h
new file mode 100644
index 0000000000..04b7fd605a
--- /dev/null
+++ b/include/dt-bindings/clock/st,stm32mp25-rcc.h
@@ -0,0 +1,532 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_CLKS_H_
+#define _DT_BINDINGS_STM32MP25_CLKS_H_
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL3_CK			10
+#define PLL4_CK			11
+#define PLL5_CK			12
+#define PLL6_CK			13
+#define PLL7_CK			14
+#define PLL8_CK			15
+
+#define CK_CPU1			16
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		17
+#define CK_ICN_APB2		18
+#define CK_ICN_APB3		19
+#define CK_ICN_APB4		20
+#define CK_ICN_APBDBG		21
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		22
+#define TIMG2_CK		23
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		24
+#define CK_ICN_SDMMC		25
+#define CK_ICN_DDR		26
+#define CK_ICN_DISPLAY		27
+#define CK_ICN_HSL		28
+#define CK_ICN_NIC		29
+#define CK_ICN_VID		30
+#define CK_FLEXGEN_07		31
+#define CK_FLEXGEN_08		32
+#define CK_FLEXGEN_09		33
+#define CK_FLEXGEN_10		34
+#define CK_FLEXGEN_11		35
+#define CK_FLEXGEN_12		36
+#define CK_FLEXGEN_13		37
+#define CK_FLEXGEN_14		38
+#define CK_FLEXGEN_15		39
+#define CK_FLEXGEN_16		40
+#define CK_FLEXGEN_17		41
+#define CK_FLEXGEN_18		42
+#define CK_FLEXGEN_19		43
+#define CK_FLEXGEN_20		44
+#define CK_FLEXGEN_21		45
+#define CK_FLEXGEN_22		46
+#define CK_FLEXGEN_23		47
+#define CK_FLEXGEN_24		48
+#define CK_FLEXGEN_25		49
+#define CK_FLEXGEN_26		50
+#define CK_FLEXGEN_27		51
+#define CK_FLEXGEN_28		52
+#define CK_FLEXGEN_29		53
+#define CK_FLEXGEN_30		54
+#define CK_FLEXGEN_31		55
+#define CK_FLEXGEN_32		56
+#define CK_FLEXGEN_33		57
+#define CK_FLEXGEN_34		58
+#define CK_FLEXGEN_35		59
+#define CK_FLEXGEN_36		60
+#define CK_FLEXGEN_37		61
+#define CK_FLEXGEN_38		62
+#define CK_FLEXGEN_39		63
+#define CK_FLEXGEN_40		64
+#define CK_FLEXGEN_41		65
+#define CK_FLEXGEN_42		66
+#define CK_FLEXGEN_43		67
+#define CK_FLEXGEN_44		68
+#define CK_FLEXGEN_45		69
+#define CK_FLEXGEN_46		70
+#define CK_FLEXGEN_47		71
+#define CK_FLEXGEN_48		72
+#define CK_FLEXGEN_49		73
+#define CK_FLEXGEN_50		74
+#define CK_FLEXGEN_51		75
+#define CK_FLEXGEN_52		76
+#define CK_FLEXGEN_53		77
+#define CK_FLEXGEN_54		78
+#define CK_FLEXGEN_55		79
+#define CK_FLEXGEN_56		80
+#define CK_FLEXGEN_57		81
+#define CK_FLEXGEN_58		82
+#define CK_FLEXGEN_59		83
+#define CK_FLEXGEN_60		84
+#define CK_FLEXGEN_61		85
+#define CK_FLEXGEN_62		86
+#define CK_FLEXGEN_63		87
+
+/* LOW SPEED MCU CLOCK */
+#define CK_ICN_LS_MCU		88
+
+#define CK_BUS_STM		89
+#define CK_BUS_FMC		90
+#define CK_BUS_GPU		91
+#define CK_BUS_ETH1		92
+#define CK_BUS_ETH2		93
+#define CK_BUS_PCIE		94
+#define CK_BUS_DDRPHYC		95
+#define CK_BUS_SYSCPU1		96
+#define CK_BUS_ETHSW		97
+#define CK_BUS_HPDMA1		98
+#define CK_BUS_HPDMA2		99
+#define CK_BUS_HPDMA3		100
+#define CK_BUS_ADC12		101
+#define CK_BUS_ADC3		102
+#define CK_BUS_IPCC1		103
+#define CK_BUS_CCI		104
+#define CK_BUS_CRC		105
+#define CK_BUS_MDF1		106
+#define CK_BUS_OSPIIOM		107
+#define CK_BUS_BKPSRAM		108
+#define CK_BUS_HASH		109
+#define CK_BUS_RNG		110
+#define CK_BUS_CRYP1		111
+#define CK_BUS_CRYP2		112
+#define CK_BUS_SAES		113
+#define CK_BUS_PKA		114
+#define CK_BUS_GPIOA		115
+#define CK_BUS_GPIOB		116
+#define CK_BUS_GPIOC		117
+#define CK_BUS_GPIOD		118
+#define CK_BUS_GPIOE		119
+#define CK_BUS_GPIOF		120
+#define CK_BUS_GPIOG		121
+#define CK_BUS_GPIOH		122
+#define CK_BUS_GPIOI		123
+#define CK_BUS_GPIOJ		124
+#define CK_BUS_GPIOK		125
+#define CK_BUS_LPSRAM1		126
+#define CK_BUS_LPSRAM2		127
+#define CK_BUS_LPSRAM3		128
+#define CK_BUS_GPIOZ		129
+#define CK_BUS_LPDMA		130
+#define CK_BUS_HSEM		131
+#define CK_BUS_IPCC2		132
+#define CK_BUS_RTC		133
+#define CK_BUS_SPI8		134
+#define CK_BUS_LPUART1		135
+#define CK_BUS_I2C8		136
+#define CK_BUS_LPTIM3		137
+#define CK_BUS_LPTIM4		138
+#define CK_BUS_LPTIM5		139
+#define CK_BUS_IWDG5		140
+#define CK_BUS_WWDG2		141
+#define CK_BUS_I3C4		142
+#define CK_BUS_TIM2		143
+#define CK_BUS_TIM3		144
+#define CK_BUS_TIM4		145
+#define CK_BUS_TIM5		146
+#define CK_BUS_TIM6		147
+#define CK_BUS_TIM7		148
+#define CK_BUS_TIM10		149
+#define CK_BUS_TIM11		150
+#define CK_BUS_TIM12		151
+#define CK_BUS_TIM13		152
+#define CK_BUS_TIM14		153
+#define CK_BUS_LPTIM1		154
+#define CK_BUS_LPTIM2		155
+#define CK_BUS_SPI2		156
+#define CK_BUS_SPI3		157
+#define CK_BUS_SPDIFRX		158
+#define CK_BUS_USART2		159
+#define CK_BUS_USART3		160
+#define CK_BUS_UART4		161
+#define CK_BUS_UART5		162
+#define CK_BUS_I2C1		163
+#define CK_BUS_I2C2		164
+#define CK_BUS_I2C3		165
+#define CK_BUS_I2C4		166
+#define CK_BUS_I2C5		167
+#define CK_BUS_I2C6		168
+#define CK_BUS_I2C7		169
+#define CK_BUS_I3C1		170
+#define CK_BUS_I3C2		171
+#define CK_BUS_I3C3		172
+#define CK_BUS_TIM1		173
+#define CK_BUS_TIM8		174
+#define CK_BUS_TIM15		175
+#define CK_BUS_TIM16		176
+#define CK_BUS_TIM17		177
+#define CK_BUS_TIM20		178
+#define CK_BUS_SAI1		179
+#define CK_BUS_SAI2		180
+#define CK_BUS_SAI3		181
+#define CK_BUS_SAI4		182
+#define CK_BUS_USART1		183
+#define CK_BUS_USART6		184
+#define CK_BUS_UART7		185
+#define CK_BUS_UART8		186
+#define CK_BUS_UART9		187
+#define CK_BUS_FDCAN		188
+#define CK_BUS_SPI1		189
+#define CK_BUS_SPI4		190
+#define CK_BUS_SPI5		191
+#define CK_BUS_SPI6		192
+#define CK_BUS_SPI7		193
+#define CK_BUS_BSEC		194
+#define CK_BUS_IWDG1		195
+#define CK_BUS_IWDG2		196
+#define CK_BUS_IWDG3		197
+#define CK_BUS_IWDG4		198
+#define CK_BUS_WWDG1		199
+#define CK_BUS_VREF		200
+#define CK_BUS_DTS		201
+#define CK_BUS_SERC		202
+#define CK_BUS_HDP		203
+#define CK_BUS_IS2M		204
+#define CK_BUS_DSI		205
+#define CK_BUS_LTDC		206
+#define CK_BUS_CSI		207
+#define CK_BUS_DCMIPP		208
+#define CK_BUS_DDRC		209
+#define CK_BUS_DDRCFG		210
+#define CK_BUS_GICV2M		211
+#define CK_BUS_USBTC		212
+#define CK_BUS_USB3PCIEPHY	214
+#define CK_BUS_STGEN		215
+#define CK_BUS_VDEC		216
+#define CK_BUS_VENC		217
+#define CK_SYSDBG		218
+#define CK_KER_TIM2		219
+#define CK_KER_TIM3		220
+#define CK_KER_TIM4		221
+#define CK_KER_TIM5		222
+#define CK_KER_TIM6		223
+#define CK_KER_TIM7		224
+#define CK_KER_TIM10		225
+#define CK_KER_TIM11		226
+#define CK_KER_TIM12		227
+#define CK_KER_TIM13		228
+#define CK_KER_TIM14		229
+#define CK_KER_TIM1		230
+#define CK_KER_TIM8		231
+#define CK_KER_TIM15		232
+#define CK_KER_TIM16		233
+#define CK_KER_TIM17		234
+#define CK_KER_TIM20		235
+#define CK_BUS_SYSRAM		236
+#define CK_BUS_VDERAM		237
+#define CK_BUS_RETRAM		238
+#define CK_BUS_OSPI1		239
+#define CK_BUS_OSPI2		240
+#define CK_BUS_OTFD1		241
+#define CK_BUS_OTFD2		242
+#define CK_BUS_SRAM1		243
+#define CK_BUS_SRAM2		244
+#define CK_BUS_SDMMC1		245
+#define CK_BUS_SDMMC2		246
+#define CK_BUS_SDMMC3		247
+#define CK_BUS_DDR		248
+#define CK_BUS_RISAF4		249
+#define CK_BUS_USB2OHCI		250
+#define CK_BUS_USB2EHCI		251
+#define CK_BUS_USB3DR		252
+#define CK_KER_LPTIM1		253
+#define CK_KER_LPTIM2		254
+#define CK_KER_USART2		255
+#define CK_KER_UART4		256
+#define CK_KER_USART3		257
+#define CK_KER_UART5		258
+#define CK_KER_SPI2		259
+#define CK_KER_SPI3		260
+#define CK_KER_SPDIFRX		261
+#define CK_KER_I2C1		262
+#define CK_KER_I2C2		263
+#define CK_KER_I3C1		264
+#define CK_KER_I3C2		265
+#define CK_KER_I2C3		266
+#define CK_KER_I2C5		267
+#define CK_KER_I3C3		268
+#define CK_KER_I2C4		269
+#define CK_KER_I2C6		270
+#define CK_KER_I2C7		271
+#define CK_KER_SPI1		272
+#define CK_KER_SPI4		273
+#define CK_KER_SPI5		274
+#define CK_KER_SPI6		275
+#define CK_KER_SPI7		276
+#define CK_KER_USART1		277
+#define CK_KER_USART6		278
+#define CK_KER_UART7		279
+#define CK_KER_UART8		280
+#define CK_KER_UART9		281
+#define CK_KER_MDF1		282
+#define CK_KER_SAI1		283
+#define CK_KER_SAI2		284
+#define CK_KER_SAI3		285
+#define CK_KER_SAI4		286
+#define CK_KER_FDCAN		287
+#define CK_KER_DSIBLANE		288
+#define CK_KER_DSIPHY		289
+#define CK_KER_CSI		290
+#define CK_KER_CSITXESC		291
+#define CK_KER_CSIPHY		292
+#define CK_KER_LVDSPHY		293
+#define CK_KER_STGEN		294
+#define CK_KER_USB3PCIEPHY	295
+#define CK_KER_USB2PHY2EN	296
+#define CK_KER_I3C4		297
+#define CK_KER_SPI8		298
+#define CK_KER_I2C8		299
+#define CK_KER_LPUART1		300
+#define CK_KER_LPTIM3		301
+#define CK_KER_LPTIM4		302
+#define CK_KER_LPTIM5		303
+#define CK_KER_TSDBG		304
+#define CK_KER_TPIU		305
+#define CK_BUS_ETR		306
+#define CK_BUS_SYSATB		307
+#define CK_KER_ADC12		308
+#define CK_KER_ADC3		309
+#define CK_KER_OSPI1		310
+#define CK_KER_OSPI2		311
+#define CK_KER_FMC		312
+#define CK_KER_SDMMC1		313
+#define CK_KER_SDMMC2		314
+#define CK_KER_SDMMC3		315
+#define CK_KER_ETH1		316
+#define CK_KER_ETH2		317
+#define CK_KER_ETH1PTP		318
+#define CK_KER_ETH2PTP		319
+#define CK_KER_USB2PHY1		320
+#define CK_KER_USB2PHY2		321
+#define CK_KER_ETHSW		322
+#define CK_KER_ETHSWREF		323
+#define CK_MCO1			324
+#define CK_MCO2			325
+#define CK_KER_DTS		326
+#define CK_ETH1_RX		327
+#define CK_ETH1_TX		328
+#define CK_ETH1_MAC		329
+#define CK_ETH2_RX		330
+#define CK_ETH2_TX		331
+#define CK_ETH2_MAC		332
+#define CK_ETH1_STP		333
+#define CK_ETH2_STP		334
+#define CK_KER_USBTC		335
+#define CK_BUS_ADF1		336
+#define CK_KER_ADF1		337
+#define CK_BUS_LVDS		338
+#define CK_KER_LTDC		339
+#define CK_KER_GPU		340
+#define CK_BUS_ETHSWACMCFG	341
+#define CK_BUS_ETHSWACMMSG	342
+#define HSE_DIV2_CK		343
+#define CK_KER_ETR		344
+#define CK_KER_STM		345
+#define HSI_KER_CK		346
+#define HSE_KER_CK		347
+#define MSI_KER_CK		348
+#define CK_CPU3			349
+#define CK_ADF1_C3		350
+#define CK_GPIOZ_C3		351
+#define CK_I2C8_C3		352
+#define CK_I3C4_C3		353
+#define CK_LPDMA_C3		354
+#define CK_LPTIM3_C3		355
+#define CK_LPTIM4_C3		356
+#define CK_LPTIM5_C3		357
+#define CK_LPUART1_C3		358
+#define CK_RTC_C3		359
+#define CK_SPI8_C3		360
+#define CK_ADF1_AM		361
+#define CK_CPU3_AM		362
+#define CK_GPIOZ_AM		363
+#define CK_I2C8_AM		364
+#define CK_I3C4_AM		365
+#define CK_IPCC2_AM		366
+#define CK_LPDMA_AM		367
+#define CK_LPTIM3_AM		368
+#define CK_LPTIM4_AM		369
+#define CK_LPTIM5_AM		370
+#define CK_LPUART1_AM		371
+#define CK_RTC_AM		372
+#define CK_SPI8_AM		373
+
+#define STM32MP25_LAST_CLK	374
+
+
+#define CK_SCMI_ICN_HS_MCU	0
+#define CK_SCMI_ICN_SDMMC	1
+#define CK_SCMI_ICN_DDR		2
+#define CK_SCMI_ICN_DISPLAY	3
+#define CK_SCMI_ICN_HSL		4
+#define CK_SCMI_ICN_NIC		5
+#define CK_SCMI_ICN_VID		6
+#define CK_SCMI_FLEXGEN_07	7
+#define CK_SCMI_FLEXGEN_08	8
+#define CK_SCMI_FLEXGEN_09	9
+#define CK_SCMI_FLEXGEN_10	10
+#define CK_SCMI_FLEXGEN_11	11
+#define CK_SCMI_FLEXGEN_12	12
+#define CK_SCMI_FLEXGEN_13	13
+#define CK_SCMI_FLEXGEN_14	14
+#define CK_SCMI_FLEXGEN_15	15
+#define CK_SCMI_FLEXGEN_16	16
+#define CK_SCMI_FLEXGEN_17	17
+#define CK_SCMI_FLEXGEN_18	18
+#define CK_SCMI_FLEXGEN_19	19
+#define CK_SCMI_FLEXGEN_20	20
+#define CK_SCMI_FLEXGEN_21	21
+#define CK_SCMI_FLEXGEN_22	22
+#define CK_SCMI_FLEXGEN_23	23
+#define CK_SCMI_FLEXGEN_24	24
+#define CK_SCMI_FLEXGEN_25	25
+#define CK_SCMI_FLEXGEN_26	26
+#define CK_SCMI_FLEXGEN_27	27
+#define CK_SCMI_FLEXGEN_28	28
+#define CK_SCMI_FLEXGEN_29	29
+#define CK_SCMI_FLEXGEN_30	30
+#define CK_SCMI_FLEXGEN_31	31
+#define CK_SCMI_FLEXGEN_32	32
+#define CK_SCMI_FLEXGEN_33	33
+#define CK_SCMI_FLEXGEN_34	34
+#define CK_SCMI_FLEXGEN_35	35
+#define CK_SCMI_FLEXGEN_36	36
+#define CK_SCMI_FLEXGEN_37	37
+#define CK_SCMI_FLEXGEN_38	38
+#define CK_SCMI_FLEXGEN_39	39
+#define CK_SCMI_FLEXGEN_40	40
+#define CK_SCMI_FLEXGEN_41	41
+#define CK_SCMI_FLEXGEN_42	42
+#define CK_SCMI_FLEXGEN_43	43
+#define CK_SCMI_FLEXGEN_44	44
+#define CK_SCMI_FLEXGEN_45	45
+#define CK_SCMI_FLEXGEN_46	46
+#define CK_SCMI_FLEXGEN_47	47
+#define CK_SCMI_FLEXGEN_48	48
+#define CK_SCMI_FLEXGEN_49	49
+#define CK_SCMI_FLEXGEN_50	50
+#define CK_SCMI_FLEXGEN_51	51
+#define CK_SCMI_FLEXGEN_52	52
+#define CK_SCMI_FLEXGEN_53	53
+#define CK_SCMI_FLEXGEN_54	54
+#define CK_SCMI_FLEXGEN_55	55
+#define CK_SCMI_FLEXGEN_56	56
+#define CK_SCMI_FLEXGEN_57	57
+#define CK_SCMI_FLEXGEN_58	58
+#define CK_SCMI_FLEXGEN_59	59
+#define CK_SCMI_FLEXGEN_60	60
+#define CK_SCMI_FLEXGEN_61	61
+#define CK_SCMI_FLEXGEN_62	62
+#define CK_SCMI_FLEXGEN_63	63
+#define CK_SCMI_ICN_LS_MCU	64
+#define CK_SCMI_HSE		65
+#define CK_SCMI_LSE		66
+#define CK_SCMI_HSI		67
+#define CK_SCMI_LSI		68
+#define CK_SCMI_MSI		69
+#define CK_SCMI_HSE_DIV2	70
+#define CK_SCMI_CPU1		71
+#define CK_SCMI_SYSCPU1		72
+#define CK_SCMI_PLL2		73
+#define CK_SCMI_PLL3		74
+#define CK_SCMI_RTC		75
+#define CK_SCMI_RTCCK		76
+#define CK_SCMI_ICN_APB1	77
+#define CK_SCMI_ICN_APB2	78
+#define CK_SCMI_ICN_APB3	79
+#define CK_SCMI_ICN_APB4	80
+#define CK_SCMI_ICN_APBDBG	81
+#define CK_SCMI_TIMG1		82
+#define CK_SCMI_TIMG2		83
+#define CK_SCMI_BKPSRAM		84
+#define CK_SCMI_BSEC		85
+#define CK_SCMI_BUS_ETR		87
+#define CK_SCMI_FMC		88
+#define CK_SCMI_GPIOA		89
+#define CK_SCMI_GPIOB		90
+#define CK_SCMI_GPIOC		91
+#define CK_SCMI_GPIOD		92
+#define CK_SCMI_GPIOE		93
+#define CK_SCMI_GPIOF		94
+#define CK_SCMI_GPIOG		95
+#define CK_SCMI_GPIOH		96
+#define CK_SCMI_GPIOI		97
+#define CK_SCMI_GPIOJ		98
+#define CK_SCMI_GPIOK		99
+#define CK_SCMI_GPIOZ		100
+#define CK_SCMI_HPDMA1		101
+#define CK_SCMI_HPDMA2		102
+#define CK_SCMI_HPDMA3		103
+#define CK_SCMI_HSEM		104
+#define CK_SCMI_IPCC1		105
+#define CK_SCMI_IPCC2		106
+#define CK_SCMI_LPDMA		107
+#define CK_SCMI_RETRAM		108
+#define CK_SCMI_SRAM1		109
+#define CK_SCMI_SRAM2		110
+#define CK_SCMI_LPSRAM1		111
+#define CK_SCMI_LPSRAM2		112
+#define CK_SCMI_LPSRAM3		113
+#define CK_SCMI_VDERAM		114
+#define CK_SCMI_SYSRAM		115
+#define CK_SCMI_OSPI1		116
+#define CK_SCMI_OSPI2		117
+#define CK_SCMI_TPIU		118
+#define CK_SCMI_SYSDBG		119
+#define CK_SCMI_SYSATB		120
+#define CK_SCMI_TSDBG		121
+#define CK_SCMI_BUS_STM		122
+#define CK_SCMI_KER_STM		123
+#define CK_SCMI_KER_ETR		124
+#define CK_SCMI_HSI_KER_CK	125
+#define CK_SCMI_HSE_KER_CK	126
+#define CK_SCMI_MSI_KER_CK	127
+#define CK_SCMI_GPIOZ_AM	128
+#define CK_SCMI_IPCC2_AM	129
+#define CK_SCMI_LPDMA_AM	130
+#define CK_SCMI_RTC_AM		131
+
+#endif /* _DT_BINDINGS_STM32MP25_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp1-clks.h b/include/dt-bindings/clock/stm32mp1-clks.h
index 25e8cfd434..ff3a40ac5b 100644
--- a/include/dt-bindings/clock/stm32mp1-clks.h
+++ b/include/dt-bindings/clock/stm32mp1-clks.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
 /*
  * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
  * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
@@ -179,6 +179,12 @@
 #define DAC12_K		168
 #define ETHPTP_K	169
 
+#define PCLK1		170
+#define PCLK2		171
+#define PCLK3		172
+#define PCLK4		173
+#define PCLK5		174
+
 /* PLL */
 #define PLL1		176
 #define PLL2		177
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
index da4cb75674..151111e5d0 100644
--- a/include/dt-bindings/clock/stm32mp13-clks.h
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later or BSD-3-Clause */
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
 /*
  * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
  * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
@@ -193,7 +193,13 @@
 #define SAI1		160
 #define SAI2		161
 
-#define STM32MP1_LAST_CLK 162
+#define SPI1		162
+#define SPI2		163
+#define SPI3		164
+#define SPI4		165
+#define SPI5		166
+
+#define STM32MP1_LAST_CLK 167
 
 /* SCMI clock identifiers */
 #define CK_SCMI_HSE		0
diff --git a/include/dt-bindings/clock/stm32mp2-clksrc.h b/include/dt-bindings/clock/stm32mp2-clksrc.h
new file mode 100644
index 0000000000..971f01a458
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp2-clksrc.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2017-2019, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_
+#define _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_
+
+/* PLLs source clocks */
+#define PLL_SRC_HSI		0x0
+#define PLL_SRC_HSE		0x1
+#define PLL_SRC_CSI		0x2
+#define PLL_SRC_DISABLED	0x3
+
+/*
+ * Configure a PLL with its clock source
+ * pll_nb: PLL number from 1 to 8
+ * pll_src: one of the 3 previous PLLs source clocks defines
+ */
+#define PLL_CFG(pll_nb, pll_src) \
+	(((pll_nb) - 1) | (pll_src << 4))
+
+/* XBAR source clocks */
+#define XBAR_SRC_PLL4		0x0
+#define XBAR_SRC_PLL5		0x1
+#define XBAR_SRC_PLL6		0x2
+#define XBAR_SRC_PLL7		0x3
+#define XBAR_SRC_PLL8		0x4
+#define XBAR_SRC_HSI		0x5
+#define XBAR_SRC_HSE		0x6
+#define XBAR_SRC_CSI		0x7
+#define XBAR_SRC_HSI_KER	0x8
+#define XBAR_SRC_HSE_KER	0x9
+#define XBAR_SRC_CSI_KER	0xA
+#define XBAR_SRC_SPDIF_SYMB	0xB
+#define XBAR_SRC_I2S		0xC
+#define XBAR_SRC_LSI		0xD
+#define XBAR_SRC_LSE		0xE
+#define XBAR_SRC_DISABLED	0xF
+
+/*
+ * Configure a XBAR channel with its clock source
+ * channel_nb: XBAR channel number from 0 to 63
+ * channel_src: one of the 15 previous XBAR source clocks defines
+ * channel_prediv: value of the PREDIV in channel RCC_PREDIVxCFGR register
+ *		   can be either 1, 2, 4 or 1024
+ * channel_findiv: value of the FINDIV in channel RCC_FINDIVxCFGR register
+ *		   from 1 to 64
+ */
+#define XBAR_CFG(channel_nb, channel_src, channel_prediv, channel_findiv) \
+	((channel_nb) | ((channel_src) << 6) |\
+	 ((channel_prediv) << 10) | (((channel_findiv) - 1) << 20))
+
+/* st,clksrc: mandatory clock source */
+
+#define CLK_CA35SS_EXT2F	0x0
+#define CLK_CA35SS_PLL1		0x1
+
+#define CLK_RTC_DISABLED	0x0
+#define CLK_RTC_LSE		0x1
+#define CLK_RTC_LSI		0x2
+#define CLK_RTC_HSE		0x3
+
+#define CLK_MCO1_HSI		0x00008000
+#define CLK_MCO1_HSE		0x00008001
+#define CLK_MCO1_CSI		0x00008002
+#define CLK_MCO1_LSI		0x00008003
+#define CLK_MCO1_LSE		0x00008004
+#define CLK_MCO1_DISABLED	0x0000800F
+
+#define CLK_MCO2_MPU		0x00008040
+#define CLK_MCO2_AXI		0x00008041
+#define CLK_MCO2_MCU		0x00008042
+#define CLK_MCO2_PLL4P		0x00008043
+#define CLK_MCO2_HSE		0x00008044
+#define CLK_MCO2_HSI		0x00008045
+#define CLK_MCO2_DISABLED	0x0000804F
+
+/* define for st,pll /csg */
+#define SSCG_MODE_CENTER_SPREAD	0
+#define SSCG_MODE_DOWN_SPREAD	1
+
+/* define for st,drive */
+#define LSEDRV_LOWEST		0
+#define LSEDRV_MEDIUM_LOW	1
+#define LSEDRV_MEDIUM_HIGH	2
+#define LSEDRV_HIGHEST		3
+
+#endif /* _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_ */
diff --git a/include/dt-bindings/gpio/gpio.h b/include/dt-bindings/gpio/gpio.h
index c029467e82..5566e58196 100644
--- a/include/dt-bindings/gpio/gpio.h
+++ b/include/dt-bindings/gpio/gpio.h
@@ -39,4 +39,7 @@
 /* Bit 5 express pull down */
 #define GPIO_PULL_DOWN 32
 
+/* Bit 6 express pull disable */
+#define GPIO_PULL_DISABLE 64
+
 #endif
diff --git a/include/dt-bindings/mfd/stm32f7-rcc.h b/include/dt-bindings/mfd/stm32f7-rcc.h
index ba5cb7456e..a4e4f92713 100644
--- a/include/dt-bindings/mfd/stm32f7-rcc.h
+++ b/include/dt-bindings/mfd/stm32f7-rcc.h
@@ -64,6 +64,7 @@
 #define STM32F7_RCC_APB1_TIM14		8
 #define STM32F7_RCC_APB1_LPTIM1		9
 #define STM32F7_RCC_APB1_WWDG		11
+#define STM32F7_RCC_APB1_CAN3		13
 #define STM32F7_RCC_APB1_SPI2		14
 #define STM32F7_RCC_APB1_SPI3		15
 #define STM32F7_RCC_APB1_SPDIFRX	16
diff --git a/include/dt-bindings/pinctrl/stm32-pinfunc.h b/include/dt-bindings/pinctrl/stm32-pinfunc.h
index e6fb8ada3f..01bc8be78e 100644
--- a/include/dt-bindings/pinctrl/stm32-pinfunc.h
+++ b/include/dt-bindings/pinctrl/stm32-pinfunc.h
@@ -26,6 +26,7 @@
 #define AF14	0xf
 #define AF15	0x10
 #define ANALOG	0x11
+#define RSVD	0x12
 
 /* define Pins number*/
 #define PIN_NO(port, line)	(((port) - 'A') * 0x10 + (line))
@@ -37,6 +38,12 @@
 #define STM32MP_PKG_AB	0x2
 #define STM32MP_PKG_AC	0x4
 #define STM32MP_PKG_AD	0x8
+#define STM32MP_PKG_AI	0x100
+#define STM32MP_PKG_AK	0x400
+#define STM32MP_PKG_AL	0x800
+#define STM32MP_PKG_AM	0x1000
+#define STM32MP_PKG_AN	0x2000
+#define STM32MP_PKG_AO	0x4000
 
 #endif /* _DT_BINDINGS_STM32_PINFUNC_H */
 
diff --git a/include/dt-bindings/pinctrl/stm32mp15-hdp.h b/include/dt-bindings/pinctrl/stm32mp15-hdp.h
new file mode 100644
index 0000000000..b761cd66b0
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp15-hdp.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clément Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP15_HDP_H
+#define _DT_BINDINGS_STM32MP15_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			 "0"
+#define HDP0_CM4_SLEEPDEEP			 "1"
+#define HDP0_PWR_STDBY_WKUP			 "2"
+#define HDP0_PWR_ENCOMP_VDDCORE			 "3"
+#define HDP0_BSEC_OUT_SEC_NIDEN			 "4"
+#define HDP0_RCC_CM4_SLEEPDEEP			 "6"
+#define HDP0_GPU_DBG7				 "7"
+#define HDP0_DDRCTRL_LP_REQ			 "8"
+#define HDP0_PWR_DDR_RET_ENABLE_N		 "9"
+#define HDP0_DTS_CLK_PTAT			 "10"
+#define HDP0_GPOVAL_0				 "15"
+
+#define HDP1_PWR_PWRWAKE_MCU			 "0"
+#define HDP1_CM4_HALTED				 "1"
+#define HDP1_CA7_NAXIERRIRQ			 "2"
+#define HDP1_PWR_OKIN_MR			 "3"
+#define HDP1_BSEC_OUT_SEC_DBGEN			 "4"
+#define HDP1_EXTI_SYS_WAKEUP			 "5"
+#define HDP1_RCC_PWRDS_MPU			 "6"
+#define HDP1_GPU_DBG6				 "7"
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		 "8"
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		 "9"
+#define HDP1_GPOVAL_1				 "15"
+
+#define HDP2_PWR_PWRWAKE_MPU			 "0"
+#define HDP2_CM4_RXEV				 "1"
+#define HDP2_CA7_NPMUIRQ1			 "2"
+#define HDP2_CA7_NFIQOUT1			 "3"
+#define HDP2_BSEC_IN_RSTCORE_N			 "4"
+#define HDP2_EXTI_C2_WAKEUP			 "5"
+#define HDP2_RCC_PWRDS_MCU			 "6"
+#define HDP2_GPU_DBG5				 "7"
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		 "8"
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		 "9"
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		 "10"
+#define HDP2_GPOVAL_2				 "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCORE		 "0"
+#define HDP3_CM4_TXEV				 "1"
+#define HDP3_CA7_NPMUIRQ0			 "2"
+#define HDP3_CA7_NFIQOUT0			 "3"
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		 "4"
+#define HDP3_EXTI_C1_WAKEUP			 "5"
+#define HDP3_RCC_PWRDS_SYS			 "6"
+#define HDP3_GPU_DBG4				 "7"
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE0 "8"
+#define HDP3_DDRCTRL_CACTIVE_1			 "9"
+#define HDP3_DTS_VALOBUS1_0			 "10"
+#define HDP3_DTS_VALOBUS2_0			 "11"
+#define HDP3_GPOVAL_3				 "15"
+
+#define HDP4_PWR_PDDS_NOT_CSTBYDIS		 "0"
+#define HDP4_CM4_SLEEPING			 "1"
+#define HDP4_CA7_NRESET1			 "2"
+#define HDP4_CA7_NIRQOUT1			 "3"
+#define HDP4_BSEC_OUT_SEC_DFTEN			 "4"
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		 "5"
+#define HDP4_ETH_OUT_PMT_INTR_O			 "6"
+#define HDP4_GPU_DBG3				 "7"
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE1 "8"
+#define HDP4_DDRCTRL_CACTIVE_0			 "9"
+#define HDP4_DTS_VALOBUS1_1			 "10"
+#define HDP4_DTS_VALOBUS2_1			 "11"
+#define HDP4_GPOVAL_4				 "15"
+
+#define HDP5_CA7_STANDBYWFIL2			 "0"
+#define HDP5_PWR_VTH_VDDCORE_ACK		 "1"
+#define HDP5_CA7_NRESET0			 "2"
+#define HDP5_CA7_NIRQOUT0			 "3"
+#define HDP5_BSEC_IN_PWROK			 "4"
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		 "5"
+#define HDP5_ETH_OUT_LPI_INTR_O			 "6"
+#define HDP5_GPU_DBG2				 "7"
+#define HDP5_DDRCTRL_CACTIVE_DDRC		 "8"
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		 "9"
+#define HDP5_DTS_VALOBUS1_2			 "10"
+#define HDP5_DTS_VALOBUS2_2			 "11"
+#define HDP5_GPOVAL_5				 "15"
+
+#define HDP6_CA7_STANDBYWFI1			 "0"
+#define HDP6_CA7_STANDBYWFE1			 "1"
+#define HDP6_CA7_EVENTO				 "2"
+#define HDP6_CA7_DBGACK1			 "3"
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		 "5"
+#define HDP6_ETH_OUT_MAC_SPEED_O1		 "6"
+#define HDP6_GPU_DBG1				 "7"
+#define HDP6_DDRCTRL_CSYSACK_DDRC		 "8"
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		 "9"
+#define HDP6_DTS_VALOBUS1_3			 "10"
+#define HDP6_DTS_VALOBUS2_3			 "11"
+#define HDP6_GPOVAL_6				 "15"
+
+#define HDP7_CA7_STANDBYWFI0			 "0"
+#define HDP7_CA7_STANDBYWFE0			 "1"
+#define HDP7_CA7_DBGACK0			 "3"
+#define HDP7_BSEC_OUT_FUSE_OK			 "4"
+#define HDP7_BSEC_OUT_SEC_SPIDEN		 "5"
+#define HDP7_ETH_OUT_MAC_SPEED_O0		 "6"
+#define HDP7_GPU_DBG0				 "7"
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		 "8"
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		 "9"
+#define HDP7_DTS_VALOBUS1_4			 "10"
+#define HDP7_DTS_VALOBUS2_4			 "11"
+#define HDP7_GPOVAL_7				 "15"
+
+#endif /* _DT_BINDINGS_STM32MP15_HDP_H */
diff --git a/include/dt-bindings/power/st,stm32mp25-power.h b/include/dt-bindings/power/st,stm32mp25-power.h
new file mode 100644
index 0000000000..fe5d9f40ca
--- /dev/null
+++ b/include/dt-bindings/power/st,stm32mp25-power.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_
+#define _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_
+
+#define PD_SCMI_GPU             0
+
+#endif /* _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_ */
diff --git a/include/dt-bindings/regulator/st,stm32mp13-regulator.h b/include/dt-bindings/regulator/st,stm32mp13-regulator.h
new file mode 100644
index 0000000000..b3a974dfc5
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp13-regulator.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_REG11		0
+#define VOLTD_SCMI_REG18		1
+#define VOLTD_SCMI_USB33		2
+#define VOLTD_SCMI_SDMMC1_IO		3
+#define VOLTD_SCMI_SDMMC2_IO		4
+#define VOLTD_SCMI_VREFBUF		5
+
+/* STPMIC1 regulators */
+#define VOLTD_SCMI_STPMIC1_BUCK1	6
+#define VOLTD_SCMI_STPMIC1_BUCK2	7
+#define VOLTD_SCMI_STPMIC1_BUCK3	8
+#define VOLTD_SCMI_STPMIC1_BUCK4	9
+#define VOLTD_SCMI_STPMIC1_LDO1	        10
+#define VOLTD_SCMI_STPMIC1_LDO2	        11
+#define VOLTD_SCMI_STPMIC1_LDO3	        12
+#define VOLTD_SCMI_STPMIC1_LDO4	        13
+#define VOLTD_SCMI_STPMIC1_LDO5	        14
+#define VOLTD_SCMI_STPMIC1_LDO6	        15
+#define VOLTD_SCMI_STPMIC1_VREFDDR	16
+#define VOLTD_SCMI_STPMIC1_BOOST	17
+#define VOLTD_SCMI_STPMIC1_PWR_SW1	18
+#define VOLTD_SCMI_STPMIC1_PWR_SW2	19
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		20
+#define VOLTD_SCMI_REGU1		21
+#define VOLTD_SCMI_REGU2		22
+#define VOLTD_SCMI_REGU3		23
+#define VOLTD_SCMI_REGU4		24
+
+#endif /*__DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H */
diff --git a/include/dt-bindings/regulator/st,stm32mp21-regulator.h b/include/dt-bindings/regulator/st,stm32mp21-regulator.h
new file mode 100644
index 0000000000..aac6426363
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp21-regulator.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_STM32MP21_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_STM32MP21_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_VDDIO1		0
+#define VOLTD_SCMI_VDDIO2		1
+#define VOLTD_SCMI_VDDIO3		2
+#define VOLTD_SCMI_ADC			3
+#define VOLTD_SCMI_VREFBUF		4
+
+/* STPMIC regulators (STPMIC25/STM32MP2L/STPMIC1L) */
+#define VOLTD_SCMI_STPMIC_BUCK1		5
+#define VOLTD_SCMI_STPMIC_BUCK2		6
+#define VOLTD_SCMI_STPMIC_BUCK3		7
+#define VOLTD_SCMI_STPMIC_BUCK4		8
+#define VOLTD_SCMI_STPMIC_BUCK5		9
+#define VOLTD_SCMI_STPMIC_BUCK6		10
+#define VOLTD_SCMI_STPMIC_BUCK7		11
+#define VOLTD_SCMI_STPMIC_LDO1		12
+#define VOLTD_SCMI_STPMIC_LDO2		13
+#define VOLTD_SCMI_STPMIC_LDO3		14
+#define VOLTD_SCMI_STPMIC_LDO4		15
+#define VOLTD_SCMI_STPMIC_LDO5		16
+#define VOLTD_SCMI_STPMIC_LDO6		17
+#define VOLTD_SCMI_STPMIC_LDO7		18
+#define VOLTD_SCMI_STPMIC_LDO8		19
+#define VOLTD_SCMI_STPMIC_REFDDR	20
+#define VOLTD_SCMI_STPMIC_GPO1		21
+#define VOLTD_SCMI_STPMIC_GPO2		22
+#define VOLTD_SCMI_STPMIC_GPO3		23
+#define VOLTD_SCMI_STPMIC_GPO4		24
+#define VOLTD_SCMI_STPMIC_GPO5		25
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		26
+#define VOLTD_SCMI_REGU1		27
+#define VOLTD_SCMI_REGU2		28
+#define VOLTD_SCMI_REGU3		29
+#define VOLTD_SCMI_REGU4		30
+
+#endif /*__DT_BINDINGS_REGULATOR_STM32MP21_REGULATOR_H */
diff --git a/include/dt-bindings/regulator/st,stm32mp25-regulator.h b/include/dt-bindings/regulator/st,stm32mp25-regulator.h
new file mode 100644
index 0000000000..10a8938920
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp25-regulator.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_VDDIO1		0
+#define VOLTD_SCMI_VDDIO2		1
+#define VOLTD_SCMI_VDDIO3		2
+#define VOLTD_SCMI_VDDIO4		3
+#define VOLTD_SCMI_VDDIO		4
+#define VOLTD_SCMI_UCPD			5
+#define VOLTD_SCMI_USB33		6
+#define VOLTD_SCMI_ADC			7
+#define VOLTD_SCMI_GPU			8
+#define VOLTD_SCMI_VREFBUF		9
+
+/* STPMIC2 regulators */
+#define VOLTD_SCMI_STPMIC2_BUCK1	10
+#define VOLTD_SCMI_STPMIC2_BUCK2	11
+#define VOLTD_SCMI_STPMIC2_BUCK3	12
+#define VOLTD_SCMI_STPMIC2_BUCK4	13
+#define VOLTD_SCMI_STPMIC2_BUCK5	14
+#define VOLTD_SCMI_STPMIC2_BUCK6	15
+#define VOLTD_SCMI_STPMIC2_BUCK7	16
+#define VOLTD_SCMI_STPMIC2_LDO1		17
+#define VOLTD_SCMI_STPMIC2_LDO2		18
+#define VOLTD_SCMI_STPMIC2_LDO3		19
+#define VOLTD_SCMI_STPMIC2_LDO4		20
+#define VOLTD_SCMI_STPMIC2_LDO5		21
+#define VOLTD_SCMI_STPMIC2_LDO6		22
+#define VOLTD_SCMI_STPMIC2_LDO7		23
+#define VOLTD_SCMI_STPMIC2_LDO8		24
+#define VOLTD_SCMI_STPMIC2_REFDDR	25
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		26
+#define VOLTD_SCMI_REGU1		27
+#define VOLTD_SCMI_REGU2		28
+#define VOLTD_SCMI_REGU3		29
+#define VOLTD_SCMI_REGU4		30
+
+#endif /*__DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H */
diff --git a/include/dt-bindings/reset/st,stm32mp21-rcc.h b/include/dt-bindings/reset/st,stm32mp21-rcc.h
new file mode 100644
index 0000000000..bb9d3cef01
--- /dev/null
+++ b/include/dt-bindings/reset/st,stm32mp21-rcc.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP21_RESET_H_
+#define _DT_BINDINGS_STM32MP21_RESET_H_
+
+#define TIM1_R		0
+#define TIM2_R		1
+#define TIM3_R		2
+#define TIM4_R		3
+#define TIM5_R		4
+#define TIM6_R		5
+#define TIM7_R		6
+#define TIM8_R		7
+#define TIM10_R		8
+#define TIM11_R		9
+#define TIM12_R		10
+#define TIM13_R		11
+#define TIM14_R		12
+#define TIM15_R		13
+#define TIM16_R		14
+#define TIM17_R		15
+#define LPTIM1_R	16
+#define LPTIM2_R	17
+#define LPTIM3_R	18
+#define LPTIM4_R	19
+#define LPTIM5_R	20
+#define SPI1_R		21
+#define SPI2_R		22
+#define SPI3_R		23
+#define SPI4_R		24
+#define SPI5_R		25
+#define SPI6_R		26
+#define SPDIFRX_R	27
+#define USART1_R	28
+#define USART2_R	29
+#define USART3_R	30
+#define UART4_R		31
+#define UART5_R		32
+#define USART6_R	33
+#define UART7_R		34
+#define LPUART1_R	35
+#define I2C1_R		36
+#define I2C2_R		37
+#define I2C3_R		38
+#define SAI1_R		39
+#define SAI2_R		40
+#define SAI3_R		41
+#define SAI4_R		42
+#define MDF1_R		43
+#define FDCAN_R		44
+#define HDP_R		45
+#define ADC1_R		46
+#define ADC2_R		47
+#define ETH1_R		48
+#define ETH2_R		49
+#define USBH_R		50
+#define USB2PHY1_R	51
+#define USB2PHY2_R	52
+#define SDMMC1_R	53
+#define SDMMC1DLL_R	54
+#define SDMMC2_R	55
+#define SDMMC2DLL_R	56
+#define SDMMC3_R	57
+#define SDMMC3DLL_R	58
+#define LTDC_R		59
+#define CSI_R		60
+#define DCMIPP_R	61
+#define DCMIPSSI_R	62
+#define WWDG1_R		63
+#define VREF_R		64
+#define DTS_R		65
+#define CRC_R		66
+#define SERC_R		67
+#define I3C1_R		68
+#define I3C2_R		69
+#define I3C3_R		70
+#define IWDG2_KER_R	71
+#define IWDG4_KER_R	72
+#define RNG1_R		73
+#define RNG2_R		74
+#define PKA_R		75
+#define SAES_R		76
+#define HASH1_R		77
+#define HASH2_R		78
+#define CRYP1_R		79
+#define CRYP2_R		80
+#define OSPI1_R		81
+#define OSPI1DLL_R	82
+#define OTG_R		83
+#define FMC_R		84
+#define DBG_R		85
+#define GPIOA_R		86
+#define GPIOB_R		87
+#define GPIOC_R		88
+#define GPIOD_R		89
+#define GPIOE_R		90
+#define GPIOF_R		91
+#define GPIOG_R		92
+#define GPIOH_R		93
+#define GPIOI_R		94
+#define GPIOZ_R		95
+#define HPDMA1_R	96
+#define HPDMA2_R	97
+#define HPDMA3_R	98
+#define IPCC1_R		99
+#define C2_HOLDBOOT_R	100
+#define C1_HOLDBOOT_R	101
+#define C1_R		102
+#define C1P1POR_R	103
+#define C1P1_R		104
+#define C2_R		105
+#define SYS_R		106
+#define VSW_R		107
+#define C1MS_R		108
+#define DDRCP_R		109
+#define DDRCAPB_R	110
+#define DDRPHYCAPB_R	111
+#define DDRCFG_R	112
+#define DDR_R		113
+#define DDRPERFM_R	114
+#define CCB_R		115
+#define IWDG1_SYS_R	116
+#define IWDG2_SYS_R	117
+#define IWDG3_SYS_R	118
+#define IWDG4_SYS_R	119
+
+#define STM32MP21_LAST_RESET	120
+
+#define RST_SCMI_C1_R		0
+#define RST_SCMI_C2_R		1
+#define RST_SCMI_C1_HOLDBOOT_R	2
+#define RST_SCMI_C2_HOLDBOOT_R	3
+#define RST_SCMI_FMC		4
+#define RST_SCMI_OSPI1		5
+#define RST_SCMI_OSPI1DLL	6
+
+#endif /* _DT_BINDINGS_STM32MP2_RESET_H_ */
diff --git a/include/dt-bindings/reset/st,stm32mp25-rcc.h b/include/dt-bindings/reset/st,stm32mp25-rcc.h
new file mode 100644
index 0000000000..d5615930bc
--- /dev/null
+++ b/include/dt-bindings/reset/st,stm32mp25-rcc.h
@@ -0,0 +1,167 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RESET_H_
+#define _DT_BINDINGS_STM32MP25_RESET_H_
+
+#define TIM1_R		0
+#define TIM2_R		1
+#define TIM3_R		2
+#define TIM4_R		3
+#define TIM5_R		4
+#define TIM6_R		5
+#define TIM7_R		6
+#define TIM8_R		7
+#define TIM10_R		8
+#define TIM11_R		9
+#define TIM12_R		10
+#define TIM13_R		11
+#define TIM14_R		12
+#define TIM15_R		13
+#define TIM16_R		14
+#define TIM17_R		15
+#define TIM20_R		16
+#define LPTIM1_R	17
+#define LPTIM2_R	18
+#define LPTIM3_R	19
+#define LPTIM4_R	20
+#define LPTIM5_R	21
+#define SPI1_R		22
+#define SPI2_R		23
+#define SPI3_R		24
+#define SPI4_R		25
+#define SPI5_R		26
+#define SPI6_R		27
+#define SPI7_R		28
+#define SPI8_R		29
+#define SPDIFRX_R	30
+#define USART1_R	31
+#define USART2_R	32
+#define USART3_R	33
+#define UART4_R		34
+#define UART5_R		35
+#define USART6_R	36
+#define UART7_R		37
+#define UART8_R		38
+#define UART9_R		39
+#define LPUART1_R	40
+#define IS2M_R		41
+#define I2C1_R		42
+#define I2C2_R		43
+#define I2C3_R		44
+#define I2C4_R		45
+#define I2C5_R		46
+#define I2C6_R		47
+#define I2C7_R		48
+#define I2C8_R		49
+#define SAI1_R		50
+#define SAI2_R		51
+#define SAI3_R		52
+#define SAI4_R		53
+#define MDF1_R		54
+#define MDF2_R		55
+#define FDCAN_R		56
+#define HDP_R		57
+#define ADC12_R		58
+#define ADC3_R		59
+#define ETH1_R		60
+#define ETH2_R		61
+#define USB2_R		62
+#define USB2PHY1_R	63
+#define USB2PHY2_R	64
+#define USB3DR_R	65
+#define USB3PCIEPHY_R	66
+#define USBTC_R		67
+#define ETHSW_R		68
+#define SDMMC1_R	69
+#define SDMMC1DLL_R	70
+#define SDMMC2_R	71
+#define SDMMC2DLL_R	72
+#define SDMMC3_R	73
+#define SDMMC3DLL_R	74
+#define GPU_R		75
+#define LTDC_R		76
+#define DSI_R		77
+#define LVDS_R		78
+#define CSI_R		79
+#define DCMIPP_R	80
+#define CCI_R		81
+#define VDEC_R		82
+#define VENC_R		83
+#define WWDG1_R		84
+#define WWDG2_R		85
+#define VREF_R		86
+#define DTS_R		87
+#define CRC_R		88
+#define SERC_R		89
+#define OSPIIOM_R	90
+#define I3C1_R		91
+#define I3C2_R		92
+#define I3C3_R		93
+#define I3C4_R		94
+#define IWDG2_KER_R	95
+#define IWDG4_KER_R	96
+#define RNG_R		97
+#define PKA_R		98
+#define SAES_R		99
+#define HASH_R		100
+#define CRYP1_R		101
+#define CRYP2_R		102
+#define PCIE_R		103
+#define OSPI1_R		104
+#define OSPI1DLL_R	105
+#define OSPI2_R		106
+#define OSPI2DLL_R	107
+#define FMC_R		108
+#define DBG_R		109
+#define GPIOA_R		110
+#define GPIOB_R		111
+#define GPIOC_R		112
+#define GPIOD_R		113
+#define GPIOE_R		114
+#define GPIOF_R		115
+#define GPIOG_R		116
+#define GPIOH_R		117
+#define GPIOI_R		118
+#define GPIOJ_R		119
+#define GPIOK_R		120
+#define GPIOZ_R		121
+#define HPDMA1_R	122
+#define HPDMA2_R	123
+#define HPDMA3_R	124
+#define LPDMA_R		125
+#define HSEM_R		126
+#define IPCC1_R		127
+#define IPCC2_R		128
+#define C2_HOLDBOOT_R	129
+#define C1_HOLDBOOT_R	130
+#define C1_R		131
+#define C1P1POR_R	132
+#define C1P1_R		133
+#define C2_R		134
+#define C3_R		135
+#define SYS_R		136
+#define VSW_R		137
+#define C1MS_R		138
+#define DDRCP_R		139
+#define DDRCAPB_R	140
+#define DDRPHYCAPB_R	141
+#define DDRCFG_R	142
+#define DDR_R		143
+
+#define STM32MP25_LAST_RESET	144
+
+#define RST_SCMI_C1_R		0
+#define RST_SCMI_C2_R		1
+#define RST_SCMI_C1_HOLDBOOT_R	2
+#define RST_SCMI_C2_HOLDBOOT_R	3
+#define RST_SCMI_FMC		4
+#define RST_SCMI_OSPI1		5
+#define RST_SCMI_OSPI1DLL	6
+#define RST_SCMI_OSPI2		7
+#define RST_SCMI_OSPI2DLL	8
+
+#endif /* _DT_BINDINGS_STM32MP25_RESET_H_ */
diff --git a/include/dt-bindings/reset/stm32mp1-resets.h b/include/dt-bindings/reset/stm32mp1-resets.h
index 4ffa7c3612..9071f13964 100644
--- a/include/dt-bindings/reset/stm32mp1-resets.h
+++ b/include/dt-bindings/reset/stm32mp1-resets.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
 /*
  * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
  * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
diff --git a/include/dt-bindings/reset/stm32mp13-resets.h b/include/dt-bindings/reset/stm32mp13-resets.h
index 1b83a01de8..ecb37c7ddd 100644
--- a/include/dt-bindings/reset/stm32mp13-resets.h
+++ b/include/dt-bindings/reset/stm32mp13-resets.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later or BSD-3-Clause */
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
 /*
  * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
  * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
diff --git a/include/dt-bindings/rtc/rtc-stm32.h b/include/dt-bindings/rtc/rtc-stm32.h
new file mode 100644
index 0000000000..f0e70af1ca
--- /dev/null
+++ b/include/dt-bindings/rtc/rtc-stm32.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * This header provides constants for STM32_RTC bindings.
+ */
+
+#ifndef _DT_BINDINGS_RTC_RTC_STM32_H
+#define _DT_BINDINGS_RTC_RTC_STM32_H
+
+#define RTC_NO_OUT	0
+#define RTC_OUT1	1
+#define RTC_OUT2	2
+#define RTC_OUT2_RMP	3
+
+#endif
diff --git a/include/dt-bindings/soc/stm32-hdp.h b/include/dt-bindings/soc/stm32-hdp.h
new file mode 100644
index 0000000000..d986653272
--- /dev/null
+++ b/include/dt-bindings/soc/stm32-hdp.h
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_CM4_SLEEPDEEP			1
+#define HDP0_PWR_STDBY_WKUP			2
+#define HDP0_PWR_ENCOMP_VDDCORE			3
+#define HDP0_BSEC_OUT_SEC_NIDEN			4
+#define HDP0_RCC_CM4_SLEEPDEEP			6
+#define HDP0_GPU_DBG7				7
+#define HDP0_DDRCTRL_LP_REQ			8
+#define HDP0_PWR_DDR_RET_ENABLE_N		9
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_PWRWAKE_MCU			0
+#define HDP1_CM4_HALTED				1
+#define HDP1_CA7_NAXIERRIRQ			2
+#define HDP1_PWR_OKIN_MR			3
+#define HDP1_BSEC_OUT_SEC_DBGEN			4
+#define HDP1_EXTI_SYS_WAKEUP			5
+#define HDP1_RCC_PWRDS_MPU			6
+#define HDP1_GPU_DBG6				7
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		8
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		9
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_MPU			0
+#define HDP2_CM4_RXEV				1
+#define HDP2_CA7_NPMUIRQ1			2
+#define HDP2_CA7_NFIQOUT1			3
+#define HDP2_BSEC_IN_RSTCORE_N			4
+#define HDP2_EXTI_C2_WAKEUP			5
+#define HDP2_RCC_PWRDS_MCU			6
+#define HDP2_GPU_DBG5				7
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		8
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		9
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		10
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CORE		0
+#define HDP3_CM4_TXEV				1
+#define HDP3_CA7_NPMUIRQ0			2
+#define HDP3_CA7_NFIQOUT0			3
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		4
+#define HDP3_EXTI_C1_WAKEUP			5
+#define HDP3_RCC_PWRDS_SYS			6
+#define HDP3_GPU_DBG4				7
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE0	8
+#define HDP3_DDRCTRL_CACTIVE_1			9
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_PDDS				0
+#define HDP4_CM4_SLEEPING			1
+#define HDP4_CA7_NRESET1			2
+#define HDP4_CA7_NIRQOUT1			3
+#define HDP4_BSEC_OUT_SEC_DFTEN			4
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		5
+#define HDP4_ETH_OUT_PMT_INTR_O			6
+#define HDP4_GPU_DBG3				7
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE1	8
+#define HDP4_DDRCTRL_CACTIVE_0			9
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CA7_STANDBYWFIL2			0
+#define HDP5_PWR_VTH_VDDCORE_ACK		1
+#define HDP5_CA7_NRESET0			2
+#define HDP5_CA7_NIRQOUT0			3
+#define HDP5_BSEC_IN_PWROK			4
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		5
+#define HDP5_ETH_OUT_LPI_INTR_O			6
+#define HDP5_GPU_DBG2				7
+#define HDP5_DDRCTRL_CACTIVE_DDRC		8
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		9
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CA7_STANDBYWFI1			0
+#define HDP6_CA7_STANDBYWFE1			1
+#define HDP6_CA7_EVENT0				2
+#define HDP6_CA7_DBGACK1			3
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		5
+#define HDP6_ETH_OUT_MAC_SPEED_O1		6
+#define HDP6_GPU_DBG1				7
+#define HDP6_DDRCTRL_CSYSACK_DDRC		8
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		9
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CA7_STANDBYWFI0			0
+#define HDP7_CA7_STANDBYWFE0			1
+#define HDP7_CA7_DBGACK0			3
+#define HDP7_BSEC_OUT_FUSE_OK			4
+#define HDP7_BSEC_OUT_SEC_SPIDEN		5
+#define HDP7_ETH_OUT_MAC_SPEED_O0		6
+#define HDP7_GPU_DBG0				7
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		8
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		9
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/dt-bindings/soc/stm32mp13-hdp.h b/include/dt-bindings/soc/stm32mp13-hdp.h
new file mode 100644
index 0000000000..091c1c8358
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp13-hdp.h
@@ -0,0 +1,133 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_PWR_STOP_FORBIDDEN			1
+#define HDP0_PWR_STDBY_WKUP			2
+#define HDP0_PWR_ENCOMP_VDDCORE			3
+#define HDP0_BSEC_OUT_SEC_NIDEN			4
+#define HDP0_AIEC_SYS_WAKEUP			5
+#define HDP0_DDRCTRL_LP_REQ			8
+#define HDP0_PWR_DDR_RET_ENABLE_N		9
+#define HDP0_DTS_CLK_PTAT			10
+#define HDP0_SRAM3CTRL_TAMP_ERASE_ACT		12
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_SEL_VTH_VDDCPU			0
+#define HDP1_PWR_MPU_RAM_LOWSPEED		1
+#define HDP1_CA7_NAXIERRIRQ			2
+#define HDP1_PWR_OKIN_MR			3
+#define HDP1_BSEC_OUT_SEC_DBGEN			4
+#define HDP1_AIEC_C1_WAKEUP			5
+#define HDP1_RCC_PWRDS_MPU			6
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		8
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		9
+#define HDP1_SRAM3CTRL_HW_ERASE_ACT		12
+#define HDP1_NIC400_S0_BREADY			13
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_MPU			0
+#define HDP2_PWR_MPU_CLOCK_DISABLE_ACK		1
+#define HDP2_CA7_NDGBRESET_I			2
+#define HDP2_BSEC_IN_RSTCORE_N			4
+#define HDP2_BSEC_OUT_SEC_BSC_DIS		5
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		8
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		9
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		10
+#define HDP2_SRAM3CTRL_SW_ERASE_ACT		12
+#define HDP2_NIC400_S0_BVALID			13
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CORE		0
+#define HDP3_PWR_MPU_CLOCK_DISABLE_REQ		1
+#define HDP3_CA7_NPMUIRQ0			2
+#define HDP3_CA7_NFIQOUT0			3
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		4
+#define HDP3_BSEC_OUT_SEC_JTAG_DIS		5
+#define HDP3_RCC_PWRDS_SYS			6
+#define HDP3_SRAM3CTRL_TAMP_ERASE_REQ		7
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE0	8
+#define HDP3_DTS_VALOBUS1_0			10
+#define HDP3_DTS_VALOBUS2_0			11
+#define HDP3_TAMP_POTENTIAL_TAMP_ERFCFG		12
+#define HDP3_NIC400_S0_WREADY			13
+#define HDP3_NIC400_S0_RREADY			14
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_STOP2_ACTIVE			1
+#define HDP4_CA7_NL2RESET1			2
+#define HDP4_CA7_NPORESET_VARM_I		3
+#define HDP4_BSEC_OUT_SEC_DFTEN			4
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		5
+#define HDP4_ETH1_OUT_PMT_INTR_O		6
+#define HDP4_ETH2_OUT_PMT_INTR_O		7
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE1	8
+#define HDP4_DDRCTRL_CACTIVE_0			9
+#define HDP4_DTS_VALOBUS1_1			10
+#define HDP4_DTS_VALOBUS2_1			11
+#define HDP4_TAMP_NRESET_SRAM_ERCFG		12
+#define HDP4_NIC400_S0_WLAST			13
+#define HDP4_NIC400_S0_RLAST			14
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CA7_STANDBYWFIL2			0
+#define HDP5_PWR_VTH_VDDCORE_ACK		1
+#define HDP5_CA7_NCORERESET_I			2
+#define HDP5_CA7_NIRQOUT0			3
+#define HDP5_BSEC_IN_PWROK			4
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		5
+#define HDP5_ETH1_OUT_LPI_INTR_O		6
+#define HDP5_ETH2_OUT_LPI_INTR_O		7
+#define HDP5_DDRCTRL_CACTIVE_DDRC		8
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		9
+#define HDP5_DTS_VALOBUS1_2			10
+#define HDP5_DTS_VALOBUS2_2			11
+#define HDP5_PKA_PKA_ITAMP_OUT			12
+#define HDP5_NIC400_S0_WVALID			13
+#define HDP5_NIC400_S0_RVALID			14
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CA7_STANDBYWFE0			0
+#define HDP6_PWR_VTH_VDDCPU_ACK			1
+#define HDP6_CA7_EVENT0				2
+#define HDP6_BSEC_IN_TAMPER_DET			4
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		5
+#define HDP6_ETH1_OUT_MAC_SPEED_O1		6
+#define HDP6_ETH2_OUT_MAC_SPEED_O1		7
+#define HDP6_DDRCTRL_CSYSACK_DDRC		8
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		9
+#define HDP6_DTS_VALOBUS1_3			10
+#define HDP6_DTS_VALOBUS2_3			11
+#define HDP6_SAES_TAMPER_OUT			12
+#define HDP6_NIC400_S0_AWREADY			13
+#define HDP6_NIC400_S0_ARREADY			14
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CA7_STANDBYWFI0			0
+#define HDP7_PWR_RCC_VCPU_RDY			1
+#define HDP7_CA7_EVENTI				2
+#define HDP7_CA7_DBGACK0			3
+#define HDP7_BSEC_OUT_FUSE_OK			4
+#define HDP7_BSEC_OUT_SEC_SPIDEN		5
+#define HDP7_ETH1_OUT_MAC_SPEED_O0		6
+#define HDP7_ETH2_OUT_MAC_SPEED_O0		7
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		8
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		9
+#define HDP7_DTS_VALOBUS1_4			10
+#define HDP7_DTS_VALOBUS2_4			11
+#define HDP7_RNG_TAMPER_OUT			12
+#define HDP7_NIC400_S0_AWVALID			13
+#define HDP7_NIC400_S0_ARVALID			14
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/flash.h b/include/flash.h
index 3710a2731b..8cb0e7a6e6 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -90,6 +90,7 @@ int flash_sect_roundb(ulong *addr);
 unsigned long flash_sector_size(flash_info_t *info, flash_sect_t sect);
 void flash_cmd_reset(flash_info_t *info);
 void flash_set_verbose(uint v);
+int is_flash_available(void);
 
 /* common/flash.c */
 void flash_protect(int flag, ulong from, ulong to, flash_info_t *info);
@@ -167,6 +168,7 @@ void flash_perror(int err);
 #define AMIC_MANUFACT	0x00370037	/* AMIC    manuf. ID in D23..D16, D7..D0 */
 #define WINB_MANUFACT	0x00DA00DA	/* Winbond manuf. ID in D23..D16, D7..D0 */
 #define EON_ALT_MANU	0x001C001C	/* EON     manuf. ID in D23..D16, D7..D0 */
+#define CY_MANUFACT	0x00340034	/* Cypress manuf. IF in D23..D16, D7..D0 */
 
 /* Manufacturers inside bank 1 have ids like 0x01xx01xx */
 #define EON_MANUFACT	0x011C011C	/* EON     manuf. ID in D23..D16, D7..D0 */
diff --git a/include/fwu.h b/include/fwu.h
index ac5c5de870..77ec65e618 100644
--- a/include/fwu.h
+++ b/include/fwu.h
@@ -8,6 +8,7 @@
 
 #include <blk.h>
 #include <efi.h>
+#include <fwu_mdata.h>
 #include <mtd.h>
 #include <uuid.h>
 
@@ -26,31 +27,70 @@ struct fwu_mtd_image_info {
 	char uuidbuf[UUID_STR_LEN + 1];
 };
 
+struct fwu_mdata_mtd_priv {
+	struct mtd_info *mtd;
+	char pri_label[50];
+	char sec_label[50];
+	u32 pri_offset;
+	u32 sec_offset;
+	struct fwu_mtd_image_info *fwu_mtd_images;
+};
+
+struct fwu_data {
+	uint32_t crc32;
+	uint32_t version;
+	uint32_t active_index;
+	uint32_t previous_active_index;
+	uint32_t metadata_size;
+	uint32_t boot_index;
+	uint32_t num_banks;
+	uint32_t num_images;
+	uint8_t  bank_state[4];
+	bool     trial_state;
+
+	struct fwu_mdata *fwu_mdata;
+
+	struct fwu_image_entry fwu_images[CONFIG_FWU_NUM_IMAGES_PER_BANK];
+};
+
 struct fwu_mdata_ops {
 	/**
 	 * read_mdata() - Populate the asked FWU metadata copy
 	 * @dev: FWU metadata device
 	 * @mdata: Output FWU mdata read
 	 * @primary: If primary or secondary copy of metadata is to be read
+	 * @size: Size in bytes of the metadata to be read
 	 *
 	 * Return: 0 if OK, -ve on error
 	 */
-	int (*read_mdata)(struct udevice *dev, struct fwu_mdata *mdata, bool primary);
+	int (*read_mdata)(struct udevice *dev, struct fwu_mdata *mdata,
+			  bool primary, uint32_t size);
 
 	/**
 	 * write_mdata() - Write the given FWU metadata copy
 	 * @dev: FWU metadata device
 	 * @mdata: Copy of the FWU metadata to write
 	 * @primary: If primary or secondary copy of metadata is to be written
+	 * @size: Size in bytes of the metadata to be written
 	 *
 	 * Return: 0 if OK, -ve on error
 	 */
-	int (*write_mdata)(struct udevice *dev, struct fwu_mdata *mdata, bool primary);
+	int (*write_mdata)(struct udevice *dev, struct fwu_mdata *mdata,
+			   bool primary, uint32_t size);
 };
 
-#define FWU_MDATA_VERSION	0x1
 #define FWU_IMAGE_ACCEPTED	0x1
 
+#define FWU_BANK_INVALID	(uint8_t)0xFF
+#define FWU_BANK_VALID		(uint8_t)0xFE
+#define FWU_BANK_ACCEPTED	(uint8_t)0xFC
+
+enum {
+	PRIMARY_PART = 1,
+	SECONDARY_PART,
+	BOTH_PARTS,
+};
+
 /*
 * GUID value defined in the FWU specification for identification
 * of the FWU metadata partition.
@@ -80,12 +120,14 @@ struct fwu_mdata_ops {
 /**
  * fwu_read_mdata() - Wrapper around fwu_mdata_ops.read_mdata()
  */
-int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary);
+int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+		   bool primary, uint32_t size);
 
 /**
  * fwu_write_mdata() - Wrapper around fwu_mdata_ops.write_mdata()
  */
-int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary);
+int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+		    bool primary, uint32_t size);
 
 /**
  * fwu_get_mdata() - Read, verify and return the FWU metadata
@@ -122,21 +164,18 @@ int fwu_get_active_index(uint *active_idxp);
 int fwu_set_active_index(uint active_idx);
 
 /**
- * fwu_get_image_index() - Get the Image Index to be used for capsule update
- * @image_index: The Image Index for the image
- *
- * The FWU multi bank update feature computes the value of image_index at
- * runtime, based on the bank to which the image needs to be written to.
- * Derive the image_index value for the image.
+ * fwu_get_dfu_alt_num() - Get the dfu_alt_num to be used for capsule update
+ * @image_index:	The Image Index for the image
+ * @alt_num:		pointer to store dfu_alt_num
  *
  * Currently, the capsule update driver uses the DFU framework for
  * the updates. This function gets the DFU alt number which is to
- * be used as the Image Index
+ * be used for capsule update.
  *
  * Return: 0 if OK, -ve on error
  *
  */
-int fwu_get_image_index(u8 *image_index);
+int fwu_get_dfu_alt_num(u8 image_index, u8 *alt_num);
 
 /**
  * fwu_revert_boot_index() - Revert the active index in the FWU metadata
@@ -283,4 +322,99 @@ int fwu_gen_alt_info_from_mtd(char *buf, size_t len, struct mtd_info *mtd);
  */
 int fwu_mtd_get_alt_num(efi_guid_t *image_guid, u8 *alt_num, const char *mtd_dev);
 
+/**
+ * fwu_mdata_copies_allocate() - Allocate memory for metadata
+ * @mdata_size: Size of the metadata structure
+ *
+ * Allocate memory for storing both the copies of the FWU metadata. The
+ * copies are then used as a cache for storing FWU metadata contents.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_mdata_copies_allocate(u32 mdata_size);
+
+/**
+ * fwu_get_dev() - Return the FWU metadata device
+ *
+ * Return the pointer to the FWU metadata device.
+ *
+ * Return: Pointer to the FWU metadata dev
+ */
+struct udevice *fwu_get_dev(void);
+
+/**
+ * fwu_get_data() - Return the version agnostic FWU structure
+ *
+ * Return the pointer to the version agnostic FWU structure.
+ *
+ * Return: Pointer to the FWU data structure
+ */
+struct fwu_data *fwu_get_data(void);
+
+/**
+ * fwu_sync_mdata() - Update given meta-data partition(s) with the copy provided
+ * @data: FWU Data structure
+ * @part: Bitmask of FWU metadata partitions to be written to
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_sync_mdata(struct fwu_mdata *mdata, int part);
+
+/**
+ * fwu_populate_mdata_image_info() - Populate the image information
+ * of the metadata
+ * @data: Version agnostic FWU metadata information
+ *
+ * Populate the image information in the FWU metadata by copying it
+ * from the version agnostic structure. This is done before the
+ * metadata gets written to the storage media.
+ *
+ * Return: None
+ */
+void fwu_populate_mdata_image_info(struct fwu_data *data);
+
+/**
+ * fwu_get_mdata_size() - Get the FWU metadata size
+ * @mdata_size: Size of the metadata structure
+ *
+ * Get the size of the FWU metadata from the structure. This is later used
+ * to allocate memory for the structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata_size(uint32_t *mdata_size);
+
+/**
+ * fwu_state_machine_updates() - Update FWU state of the platform
+ * @trial_state: Is platform transitioning into Trial State
+ * @update_index: Bank number to which images have been updated
+ *
+ * On successful completion of updates, transition the platform to
+ * either Trial State or Regular State.
+ *
+ * To transition the platform to Trial State, start the
+ * TrialStateCtr counter, followed by setting the value of bank_state
+ * field of the metadata to Valid state(applicable only in version 2
+ * of metadata).
+ *
+ * In case, the platform is to transition directly to Regular State,
+ * update the bank_state field of the metadata to Accepted
+ * state(applicable only in version 2 of metadata).
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_state_machine_updates(bool trial_state, uint32_t update_index);
+
+/**
+ * fwu_init() - FWU specific initialisations
+ *
+ * Carry out some FWU specific initialisations including allocation
+ * of memory for the metadata copies, and reading the FWU metadata
+ * copies into the allocated memory. The metadata fields are then
+ * copied into a version agnostic structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_init(void);
+
 #endif /* _FWU_H_ */
diff --git a/include/fwu_mdata.h b/include/fwu_mdata.h
index 56189e2f40..d2521f39b4 100644
--- a/include/fwu_mdata.h
+++ b/include/fwu_mdata.h
@@ -11,7 +11,7 @@
 
 /**
  * struct fwu_image_bank_info - firmware image information
- * @image_uuid: Guid value of the image in this bank
+ * @image_guid: Guid value of the image in this bank
  * @accepted: Acceptance status of the image
  * @reserved: Reserved
  *
@@ -20,15 +20,15 @@
  * acceptance status
  */
 struct fwu_image_bank_info {
-	efi_guid_t  image_uuid;
+	efi_guid_t  image_guid;
 	uint32_t accepted;
 	uint32_t reserved;
 } __packed;
 
 /**
  * struct fwu_image_entry - information for a particular type of image
- * @image_type_uuid: Guid value for identifying the image type
- * @location_uuid: Guid of the storage volume where the image is located
+ * @image_type_guid: Guid value for identifying the image type
+ * @location_guid: Guid of the storage volume where the image is located
  * @img_bank_info: Array containing properties of images
  *
  * This structure contains information on various types of updatable
@@ -36,11 +36,35 @@ struct fwu_image_bank_info {
  * information per bank.
  */
 struct fwu_image_entry {
-	efi_guid_t image_type_uuid;
-	efi_guid_t location_uuid;
+	efi_guid_t image_type_guid;
+	efi_guid_t location_guid;
 	struct fwu_image_bank_info img_bank_info[CONFIG_FWU_NUM_BANKS];
 } __packed;
 
+/**
+ * struct fwu_fw_store_desc - FWU updatable image information
+ * @num_banks: Number of firmware banks
+ * @num_images: Number of images per bank
+ * @img_entry_size: The size of the img_entry array
+ * @bank_info_entry_size: The size of the img_bank_info array
+ * @img_entry: Array of image entries each giving information on a image
+ *
+ * This image descriptor structure contains information on the number of
+ * updatable banks and images per bank. It also gives the total sizes of
+ * the fwu_image_entry and fwu_image_bank_info arrays. This structure is
+ * only present in version 2 of the metadata structure.
+ */
+struct fwu_fw_store_desc {
+	uint8_t  num_banks;
+	uint8_t  reserved;
+	uint16_t num_images;
+	uint16_t img_entry_size;
+	uint16_t bank_info_entry_size;
+
+	struct fwu_image_entry img_entry[CONFIG_FWU_NUM_IMAGES_PER_BANK];
+} __packed;
+
+#if defined(CONFIG_FWU_MDATA_V1)
 /**
  * struct fwu_mdata - FWU metadata structure for multi-bank updates
  * @crc32: crc32 value for the FWU metadata
@@ -65,4 +89,39 @@ struct fwu_mdata {
 	struct fwu_image_entry img_entry[CONFIG_FWU_NUM_IMAGES_PER_BANK];
 } __packed;
 
+#else /* CONFIG_FWU_MDATA_V1 */
+/**
+ * struct fwu_mdata - FWU metadata structure for multi-bank updates
+ * @crc32: crc32 value for the FWU metadata
+ * @version: FWU metadata version
+ * @active_index: Index of the bank currently used for booting images
+ * @previous_active_inde: Index of the bank used before the current bank
+ *                        being used for booting
+ * @metadata_size: Size of the entire metadata structure, including the
+ *                 image descriptors
+ * @desc_offset: The offset from the start of this structure where the
+ *               image descriptor structure starts. 0 if absent
+ * @bank_state: State of each bank, valid, invalid or accepted
+ * @fw_desc: The structure describing the FWU updatable images
+ *
+ * This is the top level structure used to store all information for performing
+ * multi bank updates on the platform. This contains info on the bank being
+ * used to boot along with the information on state of individual banks.
+ */
+struct fwu_mdata {
+	uint32_t crc32;
+	uint32_t version;
+	uint32_t active_index;
+	uint32_t previous_active_index;
+	uint32_t metadata_size;
+	uint16_t desc_offset;
+	uint16_t reserved1;
+	uint8_t  bank_state[4];
+	uint32_t reserved2;
+
+	// struct fwu_fw_store_desc fw_desc;
+} __packed;
+
+#endif /* CONFIG_FWU_MDATA_V1 */
+
 #endif /* _FWU_MDATA_H_ */
diff --git a/include/generic-phy.h b/include/generic-phy.h
index bee4de8a0b..a9d974224a 100644
--- a/include/generic-phy.h
+++ b/include/generic-phy.h
@@ -429,6 +429,17 @@ int generic_setup_phy(struct udevice *dev, struct phy *phy, int index);
  */
 int generic_shutdown_phy(struct phy *phy);
 
+/**
+ * generic_phy_set_mode_bulk() - Set Mode on all phys in a phy bulk struct.
+ *
+ * @bulk:	A phy bulk struct that was previously successfully requested
+ *		by generic_phy_get_bulk().
+ * @mode:	PHY mode, enum phy_mode
+ * @submode:	submode, underlying data is specific to the PHY function
+ * Return 0 if OK, or negative error code.
+ */
+int generic_phy_set_mode_bulk(struct phy_bulk *bulk, enum phy_mode mode, int submode);
+
 #else /* CONFIG_PHY */
 
 static inline int generic_phy_init(struct phy *phy)
@@ -519,6 +530,11 @@ static inline int generic_shutdown_phy(struct phy *phy)
 	return 0;
 }
 
+static inline int generic_phy_set_mode_bulk(struct phy_bulk *bulk, enum phy_mode mode, int submode)
+{
+	return 0;
+}
+
 #endif /* CONFIG_PHY */
 
 /**
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index b8acacd49e..6cb7060bdb 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -15,10 +15,17 @@
 
 struct udevice;
 
+/* update clock ID for the dev = clock provider, compatible with CLK_AUTO_ID */
+static inline void dev_clk_dm(const struct udevice *dev, ulong id, struct clk *clk)
+{
+	if (!IS_ERR(clk))
+		clk->id = CLK_ID(dev, id);
+}
+
 static inline void clk_dm(ulong id, struct clk *clk)
 {
 	if (!IS_ERR(clk))
-		clk->id = id;
+		clk->id = CLK_ID(clk->dev, id);
 }
 
 /*
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index 85288c3729..c12a7f70ad 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -135,6 +135,22 @@ static inline unsigned long resource_type(const struct resource *res)
 	return res->flags & IORESOURCE_TYPE_BITS;
 }
 
+/* True iff r1 completely contains r2 */
+static inline bool resource_contains(struct resource *r1, struct resource *r2)
+{
+	if (resource_type(r1) != resource_type(r2))
+		return false;
+	if (r1->flags & IORESOURCE_UNSET || r2->flags & IORESOURCE_UNSET)
+		return false;
+	return r1->start <= r2->start && r1->end >= r2->end;
+}
+
+/* True if any part of r1 overlaps r2 */
+static inline bool resource_overlaps(struct resource *r1, struct resource *r2)
+{
+	return r1->start <= r2->end && r1->end >= r2->start;
+}
+
 /* Convenience shorthand with allocation */
 #define request_region(start,n,name)	__request_region(&ioport_resource, (start), (n), (name), 0)
 #define __request_mem_region(start,n,name, excl) __request_region(&iomem_resource, (start), (n), (name), excl)
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 2861b73edb..b8be917697 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -298,6 +298,7 @@ enum spi_nor_option_flags {
 	SNOR_F_BROKEN_RESET	= BIT(6),
 	SNOR_F_SOFT_RESET	= BIT(7),
 	SNOR_F_IO_MODE_EN_VOLATILE = BIT(8),
+	SNOR_F_DTR_SWAB16       = BIT(9),
 };
 
 struct spi_nor;
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 5d0dac950e..af6350170a 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -18,6 +18,12 @@ enum usb_dr_mode {
 	USB_DR_MODE_OTG,
 };
 
+enum usb_role {
+	USB_ROLE_NONE,
+	USB_ROLE_HOST,
+	USB_ROLE_DEVICE,
+};
+
 /**
  * usb_get_dr_mode() - Get dual role mode for given device
  * @node: ofnode of the given device
diff --git a/include/mtd/cfi_flash.h b/include/mtd/cfi_flash.h
index 52cd1c4dbc..62ac86b871 100644
--- a/include/mtd/cfi_flash.h
+++ b/include/mtd/cfi_flash.h
@@ -20,6 +20,7 @@
 #define FLASH_CMD_PROTECT_CLEAR		0xD0
 #define FLASH_CMD_CLEAR_STATUS		0x50
 #define FLASH_CMD_READ_STATUS		0x70
+#define FLASH_CMD_CLEAR_ERROR_STATUS	0x71
 #define FLASH_CMD_WRITE_TO_BUFFER	0xE8
 #define FLASH_CMD_WRITE_BUFFER_PROG	0xE9
 #define FLASH_CMD_WRITE_BUFFER_CONFIRM	0xD0
diff --git a/include/mtd/sfdp_flash.h b/include/mtd/sfdp_flash.h
new file mode 100644
index 0000000000..a91b6bb8e1
--- /dev/null
+++ b/include/mtd/sfdp_flash.h
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * (C) Copyright 2024
+ */
+
+#ifndef __SFDP_FLASH_H__
+#define __SFDP_FLASH_H__
+
+int sfdp_flash_scan(flash_info_t *info, const void *sfdp);
+
+#endif /* __SFDP_FLASH_H__ */
diff --git a/include/netdev.h b/include/netdev.h
index 2a7f40e504..ec3506622c 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -25,7 +25,7 @@ struct udevice;
 
 int board_eth_init(struct bd_info *bis);
 int board_interface_eth_init(struct udevice *dev,
-			     phy_interface_t interface_type);
+			     phy_interface_t interface_type, ulong rate);
 int cpu_eth_init(struct bd_info *bis);
 
 /* Driver initialization prototypes */
diff --git a/include/reset.h b/include/reset.h
index 036a786d2a..252eb1a1ff 100644
--- a/include/reset.h
+++ b/include/reset.h
@@ -330,10 +330,10 @@ int reset_deassert_bulk(struct reset_ctl_bulk *bulk);
 int reset_status(struct reset_ctl *reset_ctl);
 
 /**
- * reset_release_all - Assert/Free an array of previously requested resets.
+ * reset_release_all - Free an array of previously requested resets.
  *
  * For each reset contained in the reset array, this function will check if
- * reset has been previously requested and then will assert and free it.
+ * reset has been previously requested and then free it.
  *
  * @reset_ctl:	A reset struct array that was previously successfully
  *		requested by reset_get_by_*().
@@ -343,12 +343,11 @@ int reset_status(struct reset_ctl *reset_ctl);
 int reset_release_all(struct reset_ctl *reset_ctl, int count);
 
 /**
- * reset_release_bulk - Assert/Free an array of previously requested reset
+ * reset_release_bulk - Free an array of previously requested reset
  * signals in a reset control bulk struct.
  *
  * For each reset contained in the reset control bulk struct, this function
- * will check if reset has been previously requested and then will assert
- * and free it.
+ * will check if reset has been previously requested and then will free it.
  *
  * @bulk:	A reset control bulk struct that was previously successfully
  *		requested by reset_get_bulk().
diff --git a/include/rproc_optee.h b/include/rproc_optee.h
new file mode 100644
index 0000000000..9718239afc
--- /dev/null
+++ b/include/rproc_optee.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+#ifndef _RPROC_OPTEE_H_
+#define _RPROC_OPTEE_H_
+
+/**
+ * struct rproc_optee - TEE remoteproc structure
+ * @tee:	TEE device
+ * @proc_id:	Identifier of the target processor
+ * @session:	TEE session identifier
+ */
+struct rproc_optee {
+	struct udevice *tee;
+	u32 proc_id;
+	u32 session;
+};
+
+#if IS_ENABLED(CONFIG_REMOTEPROC_OPTEE)
+
+/**
+ * rproc_optee_open() - open a rproc tee session
+ *
+ * Open a session towards the trusted application in charge of the remote
+ * processor.
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 if the session is opened, or an appropriate error value.
+ */
+int rproc_optee_open(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_close() - close a rproc tee session
+ *
+ * Close the trusted application session in charge of the remote processor.
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_close(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_start() - Request OP-TEE to start a remote processor
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_start(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_stop() - Request OP-TEE to stop a remote processor
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_stop(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_get_rsc_table() - Request OP-TEE the resource table
+ *
+ * Get the address and the size of the resource table. If no resource table is
+ * found, the size and address are null.
+ *
+ * @trproc: OPTEE remoteproc context structure
+ * @rsc_addr:  out the physical address of the resource table returned
+ * @rsc_size:  out the size of the resource table
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_get_rsc_table(struct rproc_optee *trproc, phys_addr_t *rsc_addr,
+			      phys_size_t *rsc_size);
+
+/**
+ * rproc_optee_load() - load an signed ELF image
+ *
+ * @trproc: OPTEE remoteproc context structure
+ * @addr:	valid ELF image address
+ * @size:	size of the image
+ *
+ * @return 0 if the image is successfully loaded, else appropriate error value.
+ */
+int rproc_optee_load(struct rproc_optee *trproc, ulong addr, ulong size);
+
+#else
+
+static inline int  rproc_optee_open(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_close(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_start(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_stop(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_get_rsc_table(struct rproc_optee *trproc,
+					     phys_addr_t *rsc_addr,
+					     phys_size_t *rsc_size)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_load(struct rproc_optee *trproc, ulong addr,
+				    ulong size)
+{
+	return -ENOSYS;
+}
+
+#endif
+
+#endif	/* _RPROC_OPTEE_H_ */
diff --git a/include/spi-mem.h b/include/spi-mem.h
index b07cf2ed83..c7ce761f4a 100644
--- a/include/spi-mem.h
+++ b/include/spi-mem.h
@@ -89,6 +89,8 @@ enum spi_mem_data_dir {
  * @dummy.dtr: whether the dummy bytes should be sent in DTR mode or not
  * @data.buswidth: number of IO lanes used to send/receive the data
  * @data.dtr: whether the data should be sent in DTR mode or not
+ * @data.dtr_swab16: whether the byte order of 16-bit words is swapped when read
+ *		     or written in Octal DTR mode compared to STR mode.
  * @data.dir: direction of the transfer
  * @data.buf.in: input buffer
  * @data.buf.out: output buffer
@@ -117,6 +119,7 @@ struct spi_mem_op {
 	struct {
 		u8 buswidth;
 		u8 dtr : 1;
+		u8 dtr_swab16 : 1;
 		enum spi_mem_data_dir dir;
 		unsigned int nbytes;
 		/* buf.{in,out} must be DMA-able. */
diff --git a/include/st_logo_data.h b/include/st_logo_data.h
deleted file mode 100644
index b53fa1c38b..0000000000
--- a/include/st_logo_data.h
+++ /dev/null
@@ -1,3265 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2018 STMicroelectronics - All Rights Reserved
- * Author(s): Yannick Fertre <yannick.fertre@st.com> for STMicroelectronics.
- *	      Philippe Cornu <philippe.cornu@st.com> for STMicroelectronics.
- */
-
-/*
- * file generated from picture
- * tools/logos/stmicroelectronics_uboot_logo_8bit_rle.bmp
- */
-
-unsigned char stmicroelectronics_uboot_logo_8bit_rle[] = {
-0x42, 0x4d, 0x5c, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0x04,
-0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x00, 0x00, 0x60, 0x01,
-0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe2, 0x93,
-0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x01,
-0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x42, 0x47, 0x52, 0x73, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xae, 0x82, 0x3a, 0x00, 0xa5, 0x7b,
-0x37, 0x00, 0xfe, 0xfe, 0xfe, 0x00, 0xac, 0x80, 0x39, 0x00, 0x4e, 0x1b,
-0x02, 0x00, 0xb7, 0x88, 0x3b, 0x00, 0x4f, 0x1c, 0x02, 0x00, 0xb3, 0x85,
-0x3a, 0x00, 0xe1, 0xaa, 0x35, 0x00, 0x86, 0x62, 0x1f, 0x00, 0x65, 0x4a,
-0x13, 0x00, 0xa9, 0x7e, 0x38, 0x00, 0xff, 0xfe, 0xff, 0x00, 0x77, 0x55,
-0x13, 0x00, 0xbe, 0x91, 0x47, 0x00, 0xbc, 0x8d, 0x3d, 0x00, 0xfe, 0xfd,
-0xfd, 0x00, 0xa3, 0x7a, 0x38, 0x00, 0xbd, 0x8e, 0x42, 0x00, 0xa7, 0x7d,
-0x39, 0x00, 0x72, 0x52, 0x14, 0x00, 0xbc, 0x8d, 0x40, 0x00, 0x84, 0x60,
-0x1e, 0x00, 0xba, 0x8a, 0x3c, 0x00, 0x75, 0x53, 0x13, 0x00, 0x87, 0x62,
-0x11, 0x00, 0x85, 0x60, 0x10, 0x00, 0x7e, 0x5b, 0x12, 0x00, 0xb4, 0x86,
-0x3a, 0x00, 0x8c, 0x6a, 0x35, 0x00, 0xb1, 0x84, 0x3b, 0x00, 0xaa, 0x7f,
-0x3a, 0x00, 0xbc, 0x8c, 0x3c, 0x00, 0x85, 0x64, 0x34, 0x00, 0xb9, 0x89,
-0x3b, 0x00, 0x93, 0x69, 0x0e, 0x00, 0x8d, 0x65, 0x0e, 0x00, 0xfd, 0xfd,
-0xfc, 0x00, 0xa0, 0x78, 0x37, 0x00, 0x81, 0x5d, 0x12, 0x00, 0x9e, 0x76,
-0x36, 0x00, 0xbe, 0x90, 0x45, 0x00, 0x94, 0x6a, 0x0b, 0x00, 0x8b, 0x64,
-0x10, 0x00, 0x68, 0x4c, 0x14, 0x00, 0x8b, 0x69, 0x35, 0x00, 0x82, 0x5e,
-0x11, 0x00, 0x90, 0x6c, 0x35, 0x00, 0x89, 0x63, 0x0f, 0x00, 0xaf, 0x83,
-0x39, 0x00, 0xa2, 0x75, 0x06, 0x00, 0x96, 0x6b, 0x0d, 0x00, 0x7b, 0x59,
-0x12, 0x00, 0x9c, 0x70, 0x08, 0x00, 0x99, 0x73, 0x37, 0x00, 0xb0, 0x83,
-0x39, 0x00, 0x84, 0x60, 0x11, 0x00, 0x80, 0x5c, 0x14, 0x00, 0x91, 0x68,
-0x0c, 0x00, 0x6a, 0x4d, 0x14, 0x00, 0xc3, 0x99, 0x54, 0x00, 0x92, 0x6e,
-0x36, 0x00, 0x9a, 0x6e, 0x0b, 0x00, 0x8a, 0x68, 0x34, 0x00, 0xc0, 0x94,
-0x4b, 0x00, 0x98, 0x6c, 0x09, 0x00, 0x8f, 0x67, 0x0f, 0x00, 0x82, 0x62,
-0x34, 0x00, 0x7d, 0x5a, 0x15, 0x00, 0xc5, 0x9f, 0x5f, 0x00, 0xbb, 0x8b,
-0x3b, 0x00, 0xc8, 0xa7, 0x6a, 0x00, 0xc0, 0x95, 0x4e, 0x00, 0x87, 0x66,
-0x34, 0x00, 0x9f, 0x72, 0x06, 0x00, 0xbf, 0x93, 0x49, 0x00, 0xfd, 0xfb,
-0xfc, 0x00, 0xc7, 0xa4, 0x66, 0x00, 0x7a, 0x57, 0x13, 0x00, 0xc4, 0x9d,
-0x5a, 0x00, 0x83, 0x5f, 0x13, 0x00, 0x9c, 0x75, 0x36, 0x00, 0x7f, 0x60,
-0x32, 0x00, 0xb5, 0x87, 0x3c, 0x00, 0xc3, 0x9b, 0x57, 0x00, 0xc8, 0xa5,
-0x69, 0x00, 0x72, 0x55, 0x25, 0x00, 0xb9, 0x8a, 0x3a, 0x00, 0x94, 0x70,
-0x36, 0x00, 0xa2, 0x79, 0x36, 0x00, 0x7f, 0x5c, 0x12, 0x00, 0x97, 0x72,
-0x37, 0x00, 0x6c, 0x4e, 0x14, 0x00, 0xc5, 0x9e, 0x5d, 0x00, 0xca, 0xa9,
-0x6c, 0x00, 0xc5, 0xa3, 0x64, 0x00, 0x9e, 0x72, 0x0b, 0x00, 0xad, 0x81,
-0x3a, 0x00, 0x8e, 0x6b, 0x36, 0x00, 0xc6, 0xa1, 0x62, 0x00, 0x7c, 0x5f,
-0x31, 0x00, 0x6f, 0x50, 0x14, 0x00, 0xc1, 0x96, 0x50, 0x00, 0xd9, 0xc4,
-0x9f, 0x00, 0xcd, 0xbe, 0xa9, 0x00, 0xaa, 0x98, 0x7f, 0x00, 0xf6, 0xf3,
-0xf1, 0x00, 0xb9, 0x9b, 0x62, 0x00, 0x6a, 0x4c, 0x19, 0x00, 0x76, 0x59,
-0x29, 0x00, 0x79, 0x57, 0x15, 0x00, 0x6e, 0x4f, 0x13, 0x00, 0xfb, 0xf9,
-0xf9, 0x00, 0xae, 0x8d, 0x53, 0x00, 0x78, 0x5c, 0x2e, 0x00, 0xb2, 0x91,
-0x55, 0x00, 0xe8, 0xe1, 0xdc, 0x00, 0x8b, 0x69, 0x2e, 0x00, 0xc0, 0x9f,
-0x62, 0x00, 0xc1, 0x97, 0x52, 0x00, 0x52, 0x20, 0x06, 0x00, 0xbe, 0x9c,
-0x60, 0x00, 0xa1, 0x79, 0x38, 0x00, 0xed, 0xe8, 0xe5, 0x00, 0xdc, 0xc8,
-0xa6, 0x00, 0xd6, 0xca, 0xb9, 0x00, 0x80, 0x5e, 0x1d, 0x00, 0xb6, 0x95,
-0x58, 0x00, 0xb5, 0x97, 0x60, 0x00, 0x92, 0x75, 0x41, 0x00, 0x6f, 0x51,
-0x1d, 0x00, 0xc9, 0xba, 0xb2, 0x00, 0xa2, 0x88, 0x7b, 0x00, 0x82, 0x5e,
-0x1a, 0x00, 0x89, 0x67, 0x56, 0x00, 0xb0, 0x93, 0x5d, 0x00, 0x67, 0x4a,
-0x00, 0x00, 0xad, 0x9c, 0x81, 0x00, 0xd1, 0xbc, 0x9a, 0x00, 0x84, 0x64,
-0x2c, 0x00, 0x6e, 0x53, 0x25, 0x00, 0xf2, 0xee, 0xeb, 0x00, 0xbe, 0xa0,
-0x69, 0x00, 0xd5, 0xbf, 0x9b, 0x00, 0xba, 0x99, 0x5c, 0x00, 0x5a, 0x2a,
-0x12, 0x00, 0x7d, 0x5e, 0x29, 0x00, 0xbc, 0xa9, 0x9f, 0x00, 0x56, 0x24,
-0x0b, 0x00, 0xd0, 0xc2, 0xba, 0x00, 0x64, 0x37, 0x21, 0x00, 0x6a, 0x3f,
-0x29, 0x00, 0xd6, 0xcb, 0xc4, 0x00, 0xe4, 0xdc, 0xd7, 0x00, 0x6f, 0x45,
-0x30, 0x00, 0x6d, 0x4e, 0x03, 0x00, 0xca, 0xab, 0x72, 0x00, 0x64, 0x49,
-0x13, 0x00, 0xa5, 0x8c, 0x7f, 0x00, 0xed, 0xcc, 0x86, 0x00, 0xf8, 0xea,
-0xcd, 0x00, 0xfc, 0xf7, 0xec, 0x00, 0xfc, 0xf9, 0xf3, 0x00, 0x77, 0x4f,
-0x3b, 0x00, 0x8e, 0x71, 0x3c, 0x00, 0x92, 0x73, 0x3b, 0x00, 0xc6, 0xa8,
-0x6f, 0x00, 0xa8, 0x8a, 0x53, 0x00, 0x97, 0x79, 0x6a, 0x00, 0xa9, 0x80,
-0x3e, 0x00, 0xb2, 0x7e, 0x04, 0x00, 0x7b, 0x56, 0x0d, 0x00, 0xee, 0xe7,
-0xde, 0x00, 0x74, 0x51, 0x02, 0x00, 0xa4, 0x84, 0x4a, 0x00, 0xf6, 0xe4,
-0xbf, 0x00, 0xdc, 0xd2, 0xc8, 0x00, 0xe0, 0xd7, 0xd0, 0x00, 0xe9, 0xbf,
-0x68, 0x00, 0x9d, 0x7d, 0x43, 0x00, 0x5f, 0x31, 0x19, 0x00, 0xb3, 0x9d,
-0x92, 0x00, 0xb8, 0x8a, 0x40, 0x00, 0x9e, 0x82, 0x4f, 0x00, 0x92, 0x6d,
-0x2e, 0x00, 0x65, 0x4a, 0x11, 0x00, 0x97, 0x7b, 0x48, 0x00, 0xbf, 0x93,
-0x41, 0x00, 0x7d, 0x57, 0x44, 0x00, 0x80, 0x5c, 0x02, 0x00, 0x83, 0x5f,
-0x4e, 0x00, 0x97, 0x71, 0x30, 0x00, 0xab, 0x89, 0x4d, 0x00, 0x9d, 0x81,
-0x73, 0x00, 0x87, 0x64, 0x24, 0x00, 0x90, 0x70, 0x61, 0x00, 0xc6, 0xb5,
-0xac, 0x00, 0xab, 0x7e, 0x2d, 0x00, 0xa7, 0x7b, 0x1b, 0x00, 0xb8, 0x89,
-0x26, 0x00, 0xe3, 0xb1, 0x45, 0x00, 0x9c, 0x74, 0x2e, 0x00, 0x7a, 0x57,
-0x01, 0x00, 0xc2, 0xa4, 0x6e, 0x00, 0x86, 0x60, 0x01, 0x00, 0x60, 0x41,
-0x00, 0x00, 0xba, 0xa5, 0x83, 0x00, 0xce, 0xb8, 0x93, 0x00, 0xb6, 0x84,
-0x17, 0x00, 0xf8, 0xf1, 0xe4, 0x00, 0x73, 0x53, 0x0c, 0x00, 0xa7, 0x91,
-0x6b, 0x00, 0xa9, 0x78, 0x04, 0x00, 0xc1, 0xaf, 0xa6, 0x00, 0xac, 0x93,
-0x87, 0x00, 0xf2, 0xda, 0xa8, 0x00, 0xe3, 0xd2, 0xb7, 0x00, 0xeb, 0xc5,
-0x75, 0x00, 0xb8, 0xa5, 0x96, 0x00, 0x93, 0x68, 0x01, 0x00, 0xbb, 0x8d,
-0x32, 0x00, 0xc5, 0x9c, 0x55, 0x00, 0x9c, 0x72, 0x22, 0x00, 0xa5, 0x78,
-0x29, 0x00, 0xb3, 0x83, 0x2d, 0x00, 0xe7, 0xbd, 0x61, 0x00, 0xf0, 0xd4,
-0x99, 0x00, 0x9a, 0x6d, 0x02, 0x00, 0x78, 0x58, 0x1f, 0x00, 0xf9, 0xef,
-0xd8, 0x00, 0xeb, 0xe0, 0xd1, 0x00, 0xf4, 0xdf, 0xb3, 0x00, 0xe2, 0xad,
-0x3d, 0x00, 0xc3, 0xae, 0x8c, 0x00, 0xcf, 0xb1, 0x7e, 0x00, 0xe8, 0xd9,
-0xc2, 0x00, 0x89, 0x6d, 0x3c, 0x00, 0x85, 0x69, 0x37, 0x00, 0x8d, 0x64,
-0x01, 0x00, 0x90, 0x69, 0x23, 0x00, 0xc4, 0xb3, 0x99, 0x00, 0xc2, 0x9c,
-0x50, 0x00, 0xb9, 0x8d, 0x44, 0x00, 0xa0, 0x87, 0x5e, 0x00, 0xa8, 0x8f,
-0x82, 0x00, 0xaf, 0x98, 0x8d, 0x00, 0xb1, 0x9a, 0x73, 0x00, 0xb3, 0x8a,
-0x48, 0x00, 0xe5, 0xb5, 0x4f, 0x00, 0xd6, 0xbb, 0x8e, 0x00, 0xbb, 0x92,
-0x4c, 0x00, 0x86, 0x62, 0x19, 0x00, 0xe1, 0xa9, 0x35, 0x00, 0xe6, 0xb9,
-0x59, 0x00, 0xdb, 0xb3, 0x61, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00,
-0xdb, 0x00, 0x01, 0x4d, 0x01, 0x4d, 0x0a, 0x00, 0x00, 0x03, 0x26, 0x4d,
-0x03, 0x00, 0xf6, 0x00, 0x00, 0x00, 0xd9, 0x00, 0x01, 0x03, 0x03, 0x00,
-0x00, 0x0a, 0x4d, 0x9a, 0x96, 0xc5, 0x94, 0xb6, 0xd6, 0x96, 0xb2, 0x8e,
-0x03, 0x00, 0x01, 0x26, 0xf5, 0x00, 0x00, 0x00, 0xdb, 0x00, 0x00, 0x0e,
-0x9a, 0xb6, 0x87, 0x9b, 0x79, 0x07, 0x07, 0x05, 0x05, 0x07, 0x97, 0xbd,
-0x85, 0x96, 0xf7, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x06, 0x03, 0x00,
-0x00, 0x8e, 0xc2, 0x98, 0x05, 0x07, 0x01, 0x05, 0x06, 0x07, 0x00, 0x03,
-0x95, 0x87, 0xb1, 0x00, 0xf5, 0x00, 0x00, 0x00, 0xd5, 0x00, 0x00, 0x05,
-0x03, 0x00, 0x00, 0x96, 0x9b, 0x00, 0x04, 0x05, 0x03, 0x07, 0x00, 0x03,
-0x05, 0x07, 0x07, 0x00, 0x04, 0x05, 0x00, 0x07, 0x07, 0x07, 0x92, 0xf6,
-0x00, 0x00, 0x03, 0x00, 0xf1, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x07,
-0x26, 0x00, 0x00, 0xb6, 0x79, 0x07, 0x05, 0x00, 0x03, 0x07, 0x00, 0x12,
-0x97, 0x87, 0xf5, 0xdb, 0x94, 0xb6, 0xa9, 0x9b, 0x95, 0x05, 0x05, 0x07,
-0x07, 0x05, 0xa9, 0x4d, 0x00, 0x4d, 0xf0, 0x00, 0x00, 0x00, 0xd6, 0x00,
-0x01, 0xdb, 0x05, 0x07, 0x00, 0x03, 0x9b, 0xb6, 0x8e, 0x00, 0x06, 0x00,
-0x00, 0x0c, 0x03, 0x99, 0xc4, 0x79, 0x07, 0x07, 0x05, 0x05, 0x9f, 0x00,
-0x00, 0x03, 0xef, 0x00, 0x00, 0x00, 0xd5, 0x00, 0x01, 0x99, 0x01, 0x95,
-0x03, 0x07, 0x00, 0x03, 0x05, 0xa9, 0x6b, 0x00, 0x0b, 0x00, 0x01, 0xc5,
-0x01, 0xb5, 0x03, 0x07, 0x01, 0x05, 0x01, 0x84, 0xf1, 0x00, 0x00, 0x00,
-0xd2, 0x00, 0x00, 0x04, 0x03, 0x00, 0x6b, 0xa4, 0x03, 0x07, 0x01, 0x05,
-0x01, 0xf5, 0x0e, 0x00, 0x01, 0x96, 0x01, 0x95, 0x03, 0x07, 0x01, 0xa4,
-0x01, 0x8e, 0xf0, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x09, 0xd6, 0x05,
-0x07, 0x05, 0x05, 0xc4, 0x00, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x01, 0xdb,
-0x04, 0x07, 0x01, 0xc5, 0xf0, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x01, 0x03,
-0x06, 0x00, 0x01, 0x03, 0x4e, 0x00, 0x00, 0x09, 0x26, 0x9b, 0x05, 0x07,
-0x05, 0x98, 0x7c, 0x00, 0x03, 0x00, 0x0e, 0x00, 0x00, 0x06, 0x6b, 0xa4,
-0x07, 0x07, 0x05, 0x87, 0x93, 0x00, 0x01, 0x03, 0x5c, 0x00, 0x00, 0x00,
-0x1f, 0x00, 0x01, 0x03, 0x0f, 0x00, 0x00, 0x03, 0x03, 0x00, 0x03, 0x00,
-0x0f, 0x00, 0x01, 0x03, 0x01, 0x03, 0x0f, 0x00, 0x01, 0x03, 0x0a, 0x00,
-0x01, 0x03, 0x01, 0x26, 0x03, 0x00, 0x01, 0x26, 0x04, 0xa2, 0x01, 0xa3,
-0x04, 0x00, 0x01, 0x26, 0x0f, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x00, 0xa2,
-0xd2, 0xd2, 0xa2, 0x00, 0x00, 0x03, 0x0f, 0x00, 0x01, 0x03, 0x01, 0x4d,
-0x03, 0x00, 0x00, 0x07, 0x03, 0x8e, 0x7c, 0xad, 0xad, 0x7c, 0x6b, 0x00,
-0x03, 0x00, 0x00, 0x04, 0x4d, 0x26, 0x00, 0x26, 0x06, 0x00, 0x01, 0x03,
-0x0a, 0x00, 0x01, 0x26, 0x01, 0x4d, 0x03, 0x00, 0x00, 0x06, 0x8e, 0x7c,
-0x75, 0x9a, 0x75, 0x8e, 0x03, 0x00, 0x01, 0x4d, 0x01, 0x26, 0x06, 0x00,
-0x01, 0x26, 0x03, 0x00, 0x00, 0x06, 0x99, 0x07, 0x07, 0x05, 0x05, 0x94,
-0x05, 0x00, 0x00, 0x07, 0x4d, 0x8e, 0x7c, 0xad, 0x7c, 0x8e, 0x71, 0x00,
-0x03, 0x00, 0x00, 0x09, 0x4d, 0x00, 0x00, 0xd6, 0x07, 0x07, 0x05, 0x92,
-0x6b, 0x00, 0x03, 0x00, 0x01, 0x03, 0x01, 0x03, 0x06, 0x00, 0x01, 0x03,
-0x0b, 0x00, 0x01, 0x26, 0x05, 0x00, 0x01, 0x26, 0x0c, 0x00, 0x01, 0x03,
-0x06, 0x00, 0x01, 0x03, 0x09, 0x00, 0x01, 0x26, 0x01, 0x4d, 0x03, 0x00,
-0x00, 0x07, 0x6b, 0x8e, 0xad, 0xad, 0x7c, 0x8e, 0x71, 0x00, 0x03, 0x00,
-0x01, 0x4d, 0x01, 0x03, 0x0a, 0x00, 0x01, 0x03, 0x06, 0x00, 0x01, 0x03,
-0x0d, 0x00, 0x01, 0x03, 0x06, 0x00, 0x01, 0x03, 0x06, 0x00, 0x01, 0x03,
-0x06, 0x00, 0x01, 0x03, 0x01, 0x03, 0x0d, 0x00, 0x01, 0x03, 0x01, 0x4d,
-0x03, 0x00, 0x00, 0x07, 0x4d, 0x8e, 0x7c, 0xad, 0xad, 0x7c, 0x6b, 0x00,
-0x03, 0x00, 0x01, 0x4d, 0x01, 0x03, 0x12, 0x00, 0x01, 0x4d, 0x04, 0x00,
-0x00, 0x06, 0x8e, 0x7c, 0xad, 0xad, 0x7c, 0x8e, 0x03, 0x00, 0x00, 0x04,
-0x26, 0x4d, 0x00, 0x03, 0x06, 0x00, 0x01, 0x03, 0x24, 0x00, 0x00, 0x00,
-0x20, 0x00, 0x01, 0x4d, 0x0d, 0xb0, 0x01, 0xa2, 0x03, 0x00, 0x01, 0x4d,
-0x01, 0xa1, 0x0c, 0xb0, 0x00, 0x05, 0xa2, 0x00, 0x00, 0x4d, 0xa1, 0x00,
-0x0b, 0xb0, 0x00, 0x04, 0xe8, 0xd2, 0x00, 0x03, 0x08, 0x00, 0x00, 0x0f,
-0x03, 0x00, 0x00, 0x71, 0xa1, 0xd8, 0xa0, 0xb3, 0xf9, 0xf9, 0xfe, 0xda,
-0xa0, 0xe8, 0xd2, 0x00, 0x03, 0x00, 0x01, 0x03, 0x0c, 0x00, 0x00, 0x0a,
-0x03, 0x00, 0x26, 0xd8, 0xe2, 0xe9, 0xe9, 0xe2, 0xd8, 0x71, 0x0f, 0x00,
-0x01, 0x03, 0x03, 0x00, 0x00, 0x11, 0xb2, 0x94, 0xc2, 0xbd, 0x9b, 0x98,
-0x97, 0x9b, 0x87, 0x9f, 0x84, 0x8e, 0x00, 0x00, 0x26, 0x00, 0x8e, 0x00,
-0x03, 0xc5, 0x01, 0x84, 0x01, 0x4d, 0x0a, 0x00, 0x00, 0x17, 0x26, 0x00,
-0x00, 0x7c, 0xc5, 0xc2, 0xbd, 0x98, 0xb5, 0x92, 0x97, 0xbd, 0xc2, 0x84,
-0x6b, 0x00, 0x00, 0x6b, 0x96, 0xc5, 0xc5, 0x84, 0x6b, 0x00, 0x04, 0x00,
-0x01, 0x99, 0x03, 0x85, 0x01, 0xf6, 0x01, 0x8e, 0x03, 0x00, 0x00, 0x0c,
-0xb2, 0x94, 0xa9, 0xa4, 0x98, 0x97, 0x98, 0xa4, 0xc4, 0xdb, 0xb1, 0x03,
-0x03, 0x00, 0x01, 0x9a, 0x01, 0x92, 0x03, 0x07, 0x01, 0xb1, 0x05, 0x00,
-0x01, 0x9a, 0x03, 0xc5, 0x01, 0xb2, 0x0c, 0x00, 0x00, 0x07, 0x03, 0x00,
-0x9a, 0xc5, 0x84, 0xd6, 0xb1, 0x00, 0x0e, 0x00, 0x01, 0xad, 0x03, 0xc5,
-0x01, 0x99, 0x01, 0x71, 0x09, 0x00, 0x00, 0x08, 0x26, 0x00, 0x00, 0x6b,
-0x99, 0xf6, 0x87, 0xa4, 0x03, 0x98, 0x00, 0x04, 0xa4, 0xc4, 0xb6, 0xb1,
-0x03, 0x00, 0x01, 0x03, 0x0a, 0x00, 0x00, 0x06, 0x7c, 0x84, 0xc5, 0xc5,
-0x99, 0x71, 0x0f, 0x00, 0x00, 0x08, 0x71, 0x96, 0xc5, 0xc5, 0x84, 0x8e,
-0x00, 0x03, 0x07, 0x00, 0x00, 0x05, 0x9a, 0xd6, 0xc5, 0xc5, 0xb1, 0x00,
-0x0e, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x0f, 0xb2, 0x94, 0xa9, 0xbd,
-0x98, 0x98, 0x97, 0xa4, 0x87, 0xf6, 0x99, 0x6b, 0x00, 0x00, 0x26, 0x00,
-0x0f, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x16, 0x9a, 0xd6, 0xc2, 0xbd,
-0x98, 0x97, 0x98, 0x98, 0xbd, 0x85, 0x84, 0x7c, 0x00, 0x00, 0x4d, 0x00,
-0x8e, 0x96, 0xc5, 0xc5, 0x96, 0x6b, 0x25, 0x00, 0x00, 0x00, 0x20, 0x00,
-0x01, 0xa2, 0x0d, 0x09, 0x01, 0xd8, 0x03, 0x00, 0x01, 0xa2, 0x01, 0xc9,
-0x03, 0x09, 0x01, 0xfd, 0x01, 0xfd, 0x07, 0x09, 0x00, 0x05, 0xe8, 0x00,
-0x00, 0xa2, 0xfe, 0x00, 0x0c, 0x09, 0x00, 0x03, 0xd8, 0x00, 0x26, 0x00,
-0x0a, 0x00, 0x00, 0x03, 0xb0, 0xda, 0xe9, 0x00, 0x09, 0x09, 0x00, 0x06,
-0xf9, 0xa0, 0xe6, 0x00, 0x00, 0x03, 0x0a, 0x00, 0x00, 0x04, 0x03, 0x00,
-0x26, 0xa0, 0x06, 0x09, 0x01, 0xda, 0x01, 0x26, 0x10, 0x00, 0x00, 0x09,
-0x99, 0xc4, 0xb5, 0x07, 0x07, 0x05, 0x05, 0x07, 0x07, 0x00, 0x04, 0x05,
-0x00, 0x0b, 0xa4, 0xb6, 0x6b, 0x00, 0x00, 0x96, 0x07, 0x05, 0x07, 0x07,
-0x6b, 0x00, 0x0b, 0x00, 0x00, 0x06, 0x71, 0xb6, 0x9b, 0x07, 0x07, 0x05,
-0x07, 0x07, 0x00, 0x05, 0xbd, 0x84, 0x00, 0x7c, 0x92, 0x00, 0x03, 0x07,
-0x01, 0x75, 0x03, 0x00, 0x01, 0x03, 0x07, 0x00, 0x00, 0x03, 0x84, 0xc4,
-0x92, 0x00, 0x03, 0x07, 0x01, 0x05, 0x01, 0x05, 0x04, 0x07, 0x00, 0x07,
-0x92, 0xc4, 0x84, 0x00, 0x00, 0x7c, 0xa4, 0x00, 0x03, 0x07, 0x01, 0xc5,
-0x05, 0x00, 0x00, 0x05, 0xc2, 0x05, 0x05, 0x07, 0xc4, 0x00, 0x0c, 0x00,
-0x00, 0x03, 0x4d, 0x00, 0x9f, 0x00, 0x03, 0x07, 0x01, 0xbd, 0x0e, 0x00,
-0x01, 0xdb, 0x03, 0x07, 0x01, 0xa4, 0x01, 0x8e, 0x0b, 0x00, 0x00, 0x06,
-0xd6, 0xbf, 0x79, 0x07, 0x07, 0x05, 0x03, 0x07, 0x03, 0x05, 0x00, 0x03,
-0x92, 0xc4, 0x96, 0x00, 0x0c, 0x00, 0x01, 0xc5, 0x03, 0x07, 0x01, 0x9b,
-0x01, 0x7c, 0x0d, 0x00, 0x00, 0x04, 0x03, 0x00, 0x7c, 0xb5, 0x03, 0x07,
-0x00, 0x03, 0x84, 0x00, 0x4d, 0x00, 0x07, 0x00, 0x00, 0x05, 0xc2, 0x05,
-0x07, 0x07, 0xbd, 0x00, 0x10, 0x00, 0x00, 0x09, 0x96, 0xc4, 0x92, 0x07,
-0x07, 0x05, 0x07, 0x07, 0x05, 0x00, 0x03, 0x07, 0x00, 0x07, 0x79, 0xbf,
-0x94, 0x71, 0x00, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x00, 0x04, 0x99, 0xa9,
-0x97, 0x05, 0x03, 0x07, 0x00, 0x11, 0x05, 0x05, 0x07, 0x05, 0x07, 0x07,
-0x9b, 0xd7, 0x7c, 0x00, 0x00, 0x99, 0x95, 0x05, 0x05, 0x95, 0x9a, 0x00,
-0x25, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0xa2, 0x01, 0xe9, 0x0c, 0x09,
-0x01, 0xe8, 0x03, 0x00, 0x01, 0xa2, 0x01, 0xf9, 0x0c, 0x09, 0x00, 0x05,
-0xb0, 0x00, 0x00, 0xa2, 0xe2, 0x00, 0x0c, 0x09, 0x00, 0x03, 0xd8, 0x00,
-0x26, 0x00, 0x05, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0xd2, 0xda, 0x00,
-0x0e, 0x09, 0x00, 0x06, 0xc9, 0xe3, 0x4d, 0x00, 0x00, 0x03, 0x0a, 0x00,
-0x01, 0xe8, 0x08, 0x09, 0x01, 0xd8, 0x0b, 0x00, 0x00, 0x06, 0x03, 0x00,
-0x00, 0x7c, 0xa9, 0x92, 0x04, 0x07, 0x00, 0x0e, 0x05, 0x07, 0x07, 0x05,
-0x07, 0x07, 0x05, 0x07, 0x07, 0x05, 0xa4, 0x99, 0x00, 0x99, 0x03, 0x07,
-0x01, 0x95, 0x01, 0x6b, 0x0a, 0x00, 0x00, 0x07, 0x75, 0xbf, 0x05, 0x07,
-0x07, 0x05, 0x05, 0x00, 0x04, 0x07, 0x01, 0x05, 0x01, 0x05, 0x03, 0x07,
-0x00, 0x07, 0xd6, 0x6b, 0x98, 0x05, 0x07, 0x05, 0x75, 0x00, 0x09, 0x00,
-0x00, 0x06, 0x8e, 0xa9, 0x79, 0x07, 0x07, 0x05, 0x04, 0x07, 0x01, 0x05,
-0x06, 0x07, 0x00, 0x04, 0xc2, 0x26, 0x00, 0x87, 0x03, 0x05, 0x01, 0xdb,
-0x05, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x07, 0xa9, 0x00, 0x0c, 0x00,
-0x00, 0x07, 0x4d, 0x00, 0xd7, 0x07, 0x07, 0x05, 0x87, 0x00, 0x0e, 0x00,
-0x01, 0x94, 0x03, 0x07, 0x01, 0xbf, 0x01, 0x6b, 0x06, 0x00, 0x00, 0x05,
-0x03, 0x00, 0x00, 0x9a, 0x87, 0x00, 0x04, 0x07, 0x01, 0x05, 0x01, 0x05,
-0x03, 0x07, 0x01, 0x05, 0x01, 0x05, 0x03, 0x07, 0x00, 0x06, 0x95, 0xa9,
-0x8e, 0x00, 0x00, 0x03, 0x07, 0x00, 0x01, 0x84, 0x03, 0x07, 0x01, 0xa4,
-0x01, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x98, 0x07, 0x07,
-0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x01, 0x85, 0x03, 0x07, 0x01, 0x87,
-0x0b, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0x6b, 0x85, 0x95, 0x07, 0x05,
-0x08, 0x07, 0x01, 0x05, 0x03, 0x07, 0x00, 0x05, 0xbf, 0xb1, 0x00, 0x00,
-0x03, 0x00, 0x09, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x71, 0x9f, 0x92,
-0x04, 0x07, 0x01, 0x05, 0x04, 0x07, 0x01, 0x05, 0x01, 0x05, 0x03, 0x07,
-0x00, 0x09, 0x9b, 0x84, 0x00, 0xb2, 0xb5, 0x07, 0x07, 0x97, 0x9a, 0x00,
-0x25, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0xa2, 0x01, 0xe9, 0x0c, 0x09,
-0x01, 0xe8, 0x03, 0x00, 0x01, 0xa2, 0x01, 0xf9, 0x03, 0x09, 0x01, 0xfd,
-0x08, 0x09, 0x00, 0x05, 0xb0, 0x00, 0x00, 0xa2, 0xe2, 0x00, 0x0c, 0x09,
-0x00, 0x03, 0xd8, 0x00, 0x26, 0x00, 0x04, 0x00, 0x00, 0x05, 0x03, 0x00,
-0x00, 0xa1, 0xf9, 0x00, 0x04, 0x09, 0x00, 0x03, 0xfd, 0x09, 0xfe, 0x00,
-0x03, 0xb3, 0x01, 0xf9, 0x06, 0x09, 0x01, 0xda, 0x01, 0xa2, 0x0b, 0x00,
-0x01, 0xa3, 0x01, 0xb3, 0x03, 0x09, 0x01, 0xfd, 0x04, 0x09, 0x01, 0xfe,
-0x01, 0x4d, 0x09, 0x00, 0x00, 0x10, 0x03, 0x00, 0x00, 0xb1, 0x9b, 0x05,
-0x07, 0x05, 0x05, 0x07, 0x07, 0x79, 0x98, 0x9b, 0x9b, 0x97, 0x06, 0x07,
-0x00, 0x03, 0x92, 0x99, 0xb2, 0x00, 0x03, 0x07, 0x01, 0x95, 0x01, 0x6b,
-0x09, 0x00, 0x01, 0x9a, 0x01, 0x98, 0x03, 0x07, 0x00, 0x09, 0x05, 0x07,
-0x07, 0x98, 0xbd, 0xbf, 0x9b, 0x95, 0x05, 0x00, 0x03, 0x07, 0x00, 0x03,
-0x92, 0x85, 0x9b, 0x00, 0x03, 0x07, 0x01, 0x75, 0x05, 0x00, 0x00, 0x05,
-0x03, 0x00, 0x00, 0x99, 0x9b, 0x00, 0x05, 0x07, 0x00, 0x07, 0x05, 0x95,
-0x98, 0x9b, 0x9b, 0x92, 0x05, 0x00, 0x05, 0x07, 0x00, 0x07, 0x87, 0x8e,
-0xa9, 0x05, 0x07, 0x05, 0xf6, 0x00, 0x05, 0x00, 0x00, 0x05, 0x85, 0x05,
-0x07, 0x07, 0xa9, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x07,
-0x07, 0x05, 0x87, 0x00, 0x0e, 0x00, 0x01, 0x94, 0x03, 0x07, 0x01, 0xbf,
-0x01, 0x6b, 0x05, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x84, 0x97, 0x00,
-0x04, 0x07, 0x00, 0x09, 0x05, 0x07, 0x92, 0x9b, 0x9b, 0x98, 0x95, 0x05,
-0x05, 0x00, 0x04, 0x07, 0x01, 0x9b, 0x01, 0x9a, 0x09, 0x00, 0x00, 0x06,
-0x84, 0x79, 0x07, 0x05, 0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x7c, 0x9b, 0x07, 0x07, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x01, 0x85,
-0x03, 0x07, 0x01, 0x87, 0x0a, 0x00, 0x00, 0x07, 0x03, 0x00, 0x00, 0x75,
-0xbd, 0x07, 0x05, 0x00, 0x04, 0x07, 0x00, 0x05, 0x95, 0x98, 0x9b, 0x9b,
-0x92, 0x00, 0x03, 0x07, 0x00, 0x08, 0x05, 0x07, 0x07, 0xb5, 0x84, 0x00,
-0x00, 0x03, 0x07, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x75, 0xbd, 0x00,
-0x05, 0x07, 0x00, 0x14, 0x05, 0x79, 0x97, 0xbd, 0xbd, 0x98, 0x95, 0x07,
-0x07, 0x05, 0x07, 0x07, 0x79, 0xd6, 0x9a, 0x97, 0x07, 0x07, 0x97, 0x75,
-0x25, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x0b, 0xa3, 0xe8, 0xd8, 0xd8,
-0xe8, 0xa0, 0xe9, 0x09, 0x09, 0xf9, 0xe3, 0x00, 0x03, 0xd8, 0x01, 0xd2,
-0x03, 0x00, 0x00, 0x06, 0x71, 0xe8, 0xd8, 0xd8, 0xe8, 0xa0, 0x03, 0x09,
-0x00, 0x0e, 0xe2, 0xd8, 0xe8, 0xd8, 0xd8, 0xd2, 0x00, 0x00, 0x71, 0xb0,
-0xd8, 0xd8, 0xe8, 0xe3, 0x03, 0x09, 0x00, 0x08, 0xfe, 0xd8, 0xe8, 0xd8,
-0xe3, 0xe6, 0x00, 0x03, 0x03, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0xb0,
-0xe9, 0x00, 0x04, 0x09, 0x00, 0x04, 0xfe, 0xd8, 0xd2, 0xa2, 0x03, 0xa3,
-0x00, 0x04, 0xa2, 0xe6, 0xe3, 0xc9, 0x04, 0x09, 0x01, 0xe2, 0x01, 0xa2,
-0x0a, 0x00, 0x01, 0xd2, 0x01, 0xf9, 0x08, 0x09, 0x01, 0xe9, 0x01, 0xa2,
-0x08, 0x00, 0x00, 0x0d, 0x03, 0x00, 0x00, 0x99, 0x97, 0x07, 0x79, 0x07,
-0x07, 0x95, 0x87, 0xd6, 0x9a, 0x00, 0x04, 0x8e, 0x00, 0x09, 0xb2, 0xb6,
-0x9b, 0x07, 0x07, 0x05, 0x05, 0x98, 0x85, 0x00, 0x03, 0x07, 0x01, 0x95,
-0x01, 0x6b, 0x06, 0x00, 0x00, 0x04, 0x03, 0x00, 0x6b, 0xa4, 0x04, 0x07,
-0x00, 0x13, 0x92, 0x85, 0x9a, 0x8e, 0x6b, 0x6b, 0x8e, 0x75, 0x94, 0x9b,
-0x05, 0x07, 0x07, 0x79, 0x95, 0x07, 0x07, 0x05, 0x75, 0x00, 0x04, 0x00,
-0x00, 0x06, 0x03, 0x00, 0x00, 0x96, 0xb5, 0x05, 0x03, 0x07, 0x00, 0x04,
-0x95, 0x87, 0xc5, 0x7c, 0x03, 0x8e, 0x00, 0x05, 0x7c, 0x96, 0xa9, 0xb5,
-0x05, 0x00, 0x03, 0x07, 0x01, 0x87, 0x01, 0x87, 0x03, 0x07, 0x01, 0xb6,
-0x05, 0x00, 0x01, 0x85, 0x03, 0x07, 0x01, 0xa9, 0x0c, 0x00, 0x00, 0x03,
-0x4d, 0x00, 0xd7, 0x00, 0x03, 0x07, 0x01, 0x87, 0x0e, 0x00, 0x01, 0x94,
-0x03, 0x07, 0x01, 0xbf, 0x01, 0x6b, 0x04, 0x00, 0x00, 0x0d, 0x03, 0x00,
-0x00, 0xc5, 0x95, 0x07, 0x79, 0x05, 0x07, 0x92, 0xc4, 0x84, 0xad, 0x00,
-0x03, 0x8e, 0x00, 0x0a, 0x75, 0x84, 0xc4, 0x95, 0x07, 0x07, 0x05, 0x05,
-0x97, 0xb1, 0x08, 0x00, 0x00, 0x06, 0x84, 0x07, 0x05, 0x07, 0xa4, 0x7c,
-0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x98, 0x07, 0x05, 0x92, 0x96,
-0x00, 0x4d, 0x07, 0x00, 0x00, 0x05, 0x85, 0x07, 0x07, 0x05, 0x87, 0x00,
-0x09, 0x00, 0x00, 0x0d, 0x03, 0x00, 0x00, 0x9a, 0x9b, 0x07, 0x07, 0x05,
-0x07, 0x07, 0xbd, 0x94, 0x9a, 0x00, 0x03, 0x8e, 0x00, 0x0d, 0x7c, 0x96,
-0xa9, 0xb5, 0x07, 0x07, 0x79, 0x07, 0x92, 0xc5, 0x00, 0x00, 0x03, 0x00,
-0x05, 0x00, 0x00, 0x06, 0x03, 0x03, 0x00, 0xb2, 0x98, 0x05, 0x04, 0x07,
-0x00, 0x0a, 0xbd, 0x94, 0x75, 0x8e, 0x8e, 0x6b, 0x8e, 0x75, 0x94, 0xbd,
-0x04, 0x07, 0x00, 0x07, 0x92, 0xc4, 0x98, 0x05, 0x07, 0x97, 0x75, 0x00,
-0x25, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x01, 0x03, 0x05, 0x00, 0x00, 0x06,
-0xe6, 0xc9, 0x09, 0x09, 0xb3, 0xa3, 0x04, 0x00, 0x00, 0x03, 0x03, 0x00,
-0x03, 0x00, 0x05, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x05, 0x00,
-0x01, 0x03, 0x01, 0x03, 0x05, 0x00, 0x01, 0xd2, 0x03, 0x09, 0x01, 0xda,
-0x01, 0x11, 0x04, 0x00, 0x01, 0x03, 0x06, 0x00, 0x01, 0xa1, 0x01, 0xe9,
-0x03, 0x09, 0x00, 0x03, 0xc9, 0xd8, 0x03, 0x00, 0x09, 0x00, 0x01, 0xa2,
-0x01, 0xa0, 0x04, 0x09, 0x00, 0x04, 0xb3, 0xa3, 0x00, 0x03, 0x07, 0x00,
-0x00, 0x05, 0xd2, 0xf9, 0x09, 0x09, 0xfd, 0x00, 0x05, 0x09, 0x01, 0xe9,
-0x01, 0xa2, 0x0a, 0x00, 0x00, 0x08, 0xb1, 0x92, 0x05, 0x07, 0x05, 0x07,
-0xbf, 0xb2, 0x09, 0x00, 0x00, 0x03, 0x4d, 0x94, 0x97, 0x00, 0x07, 0x07,
-0x01, 0x95, 0x01, 0x6b, 0x08, 0x00, 0x01, 0xc2, 0x03, 0x05, 0x00, 0x03,
-0x07, 0xbf, 0x7c, 0x00, 0x08, 0x00, 0x00, 0x0a, 0x71, 0x85, 0x07, 0x07,
-0x05, 0x07, 0x07, 0x05, 0x05, 0x75, 0x06, 0x00, 0x00, 0x08, 0x99, 0x92,
-0x07, 0x05, 0x07, 0x05, 0xbf, 0xb1, 0x09, 0x00, 0x01, 0x7c, 0x01, 0xc4,
-0x03, 0x07, 0x00, 0x06, 0x05, 0x79, 0x05, 0x07, 0x07, 0xb6, 0x05, 0x00,
-0x01, 0x85, 0x03, 0x07, 0x01, 0xa9, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00,
-0xd7, 0x05, 0x07, 0x07, 0x87, 0x00, 0x0e, 0x00, 0x01, 0x94, 0x03, 0x07,
-0x01, 0xbf, 0x01, 0x6b, 0x06, 0x00, 0x01, 0x96, 0x01, 0x79, 0x04, 0x07,
-0x01, 0x87, 0x01, 0x9a, 0x09, 0x00, 0x00, 0x03, 0xb2, 0x87, 0x07, 0x00,
-0x03, 0x05, 0x00, 0x04, 0x98, 0x75, 0x00, 0x26, 0x05, 0x00, 0x00, 0x06,
-0x84, 0x07, 0x05, 0x07, 0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x7c, 0x98, 0x05, 0x07, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05,
-0x85, 0x07, 0x07, 0x05, 0x87, 0x00, 0x0b, 0x00, 0x00, 0x08, 0x75, 0x9b,
-0x07, 0x05, 0x05, 0x07, 0xa4, 0x96, 0x09, 0x00, 0x00, 0x03, 0x8e, 0x85,
-0x95, 0x00, 0x03, 0x07, 0x00, 0x04, 0x79, 0x84, 0x00, 0x26, 0x07, 0x00,
-0x00, 0x08, 0x75, 0x9b, 0x05, 0x05, 0x07, 0x07, 0xbd, 0x99, 0x0a, 0x00,
-0x01, 0x96, 0x01, 0xa4, 0x04, 0x07, 0x00, 0x05, 0x79, 0x05, 0x07, 0x97,
-0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x06, 0xe6, 0xc9,
-0x09, 0x09, 0xb3, 0xa3, 0x0c, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0,
-0x01, 0x03, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0x71,
-0x0a, 0x00, 0x01, 0xa3, 0x01, 0xfe, 0x03, 0x09, 0x01, 0xf9, 0x01, 0xa1,
-0x0d, 0x00, 0x01, 0xd8, 0x04, 0x09, 0x01, 0xe3, 0x09, 0x00, 0x01, 0xa3,
-0x01, 0xda, 0x08, 0x09, 0x01, 0xfe, 0x01, 0x26, 0x09, 0x00, 0x00, 0x03,
-0x6b, 0xa4, 0x05, 0x00, 0x03, 0x07, 0x01, 0xf5, 0x0d, 0x00, 0x01, 0x75,
-0x01, 0xbd, 0x06, 0x07, 0x01, 0x95, 0x01, 0x6b, 0x05, 0x00, 0x00, 0x09,
-0x26, 0x00, 0xb2, 0xb5, 0x05, 0x79, 0x05, 0xbd, 0x6b, 0x00, 0x0b, 0x00,
-0x01, 0x9f, 0x04, 0x07, 0x00, 0x03, 0x05, 0x05, 0x75, 0x00, 0x05, 0x00,
-0x00, 0x07, 0x7c, 0x9b, 0x07, 0x07, 0x05, 0x07, 0x85, 0x00, 0x0d, 0x00,
-0x01, 0xb6, 0x03, 0x07, 0x00, 0x05, 0x05, 0x05, 0x07, 0x07, 0xb6, 0x00,
-0x05, 0x00, 0x01, 0x85, 0x03, 0x07, 0x01, 0xa9, 0x0c, 0x00, 0x00, 0x07,
-0x4d, 0x00, 0xd7, 0x05, 0x07, 0x05, 0x87, 0x00, 0x0e, 0x00, 0x00, 0x06,
-0x94, 0x07, 0x07, 0x05, 0xbf, 0x6b, 0x05, 0x00, 0x00, 0x07, 0x8e, 0x98,
-0x07, 0x05, 0x07, 0x05, 0xd7, 0x00, 0x0d, 0x00, 0x01, 0xf6, 0x04, 0x07,
-0x00, 0x04, 0xbf, 0x71, 0x00, 0x26, 0x04, 0x00, 0x01, 0x84, 0x03, 0x07,
-0x01, 0xa4, 0x01, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x98,
-0x05, 0x07, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x01, 0x85, 0x03, 0x07,
-0x01, 0x87, 0x0b, 0x00, 0x01, 0x87, 0x04, 0x05, 0x01, 0xc4, 0x01, 0x6b,
-0x0c, 0x00, 0x00, 0x09, 0x84, 0x92, 0x05, 0x07, 0x07, 0x97, 0x9a, 0x00,
-0x03, 0x00, 0x05, 0x00, 0x00, 0x08, 0x4d, 0x87, 0x07, 0x07, 0x05, 0x07,
-0xc2, 0x4d, 0x0c, 0x00, 0x00, 0x04, 0x6b, 0xc4, 0x07, 0x05, 0x03, 0x07,
-0x00, 0x03, 0x05, 0x97, 0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00,
-0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00,
-0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6,
-0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x0a, 0x00, 0x01, 0xe3, 0x03, 0x09,
-0x01, 0xc9, 0x01, 0xa1, 0x0c, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0xe3,
-0x04, 0x09, 0x00, 0x03, 0xa1, 0x00, 0x11, 0x00, 0x07, 0x00, 0x01, 0xe8,
-0x08, 0x09, 0x01, 0xe8, 0x0a, 0x00, 0x00, 0x06, 0xf5, 0x07, 0x05, 0x05,
-0x07, 0xd7, 0x0f, 0x00, 0x00, 0x09, 0x8e, 0xa4, 0x07, 0x07, 0x05, 0x05,
-0x07, 0x95, 0x6b, 0x00, 0x05, 0x00, 0x00, 0x03, 0x4d, 0x00, 0xd7, 0x00,
-0x03, 0x07, 0x00, 0x04, 0xb5, 0xb1, 0x00, 0x26, 0x0b, 0x00, 0x00, 0x07,
-0xbf, 0x05, 0x07, 0x07, 0x05, 0x07, 0x75, 0x00, 0x05, 0x00, 0x00, 0x06,
-0xc2, 0x07, 0x05, 0x05, 0x07, 0xc2, 0x0f, 0x00, 0x00, 0x04, 0xb6, 0x05,
-0x05, 0x07, 0x03, 0x05, 0x01, 0xb6, 0x05, 0x00, 0x00, 0x05, 0x85, 0x05,
-0x07, 0x07, 0xa9, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x05,
-0x07, 0x07, 0x87, 0x00, 0x0e, 0x00, 0x00, 0x06, 0x94, 0x07, 0x07, 0x05,
-0xbf, 0x6b, 0x05, 0x00, 0x00, 0x06, 0xc2, 0x07, 0x05, 0x07, 0x07, 0xf6,
-0x0f, 0x00, 0x01, 0xd7, 0x04, 0x07, 0x00, 0x03, 0xdb, 0x00, 0x4d, 0x00,
-0x04, 0x00, 0x00, 0x06, 0x84, 0x79, 0x07, 0x07, 0xa4, 0x7c, 0x0d, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0x7c, 0x9b, 0x07, 0x07, 0x92, 0x96, 0x00, 0x4d,
-0x07, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x05, 0x87, 0x00, 0x0a, 0x00,
-0x01, 0xc5, 0x01, 0x05, 0x03, 0x07, 0x01, 0xc4, 0x0f, 0x00, 0x01, 0x84,
-0x01, 0x95, 0x03, 0x05, 0x01, 0xa9, 0x07, 0x00, 0x01, 0x94, 0x04, 0x07,
-0x01, 0xc2, 0x10, 0x00, 0x01, 0x87, 0x05, 0x07, 0x01, 0x97, 0x01, 0x75,
-0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09,
-0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0,
-0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3,
-0x09, 0x00, 0x01, 0xd2, 0x01, 0xf9, 0x03, 0x09, 0x00, 0x04, 0xd8, 0x00,
-0x03, 0x03, 0x0b, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0xda, 0x09, 0xe9,
-0xfd, 0xa0, 0x07, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0xe3, 0x06, 0x09,
-0x01, 0xa0, 0x01, 0x03, 0x09, 0x00, 0x01, 0xad, 0x01, 0x97, 0x03, 0x07,
-0x00, 0x04, 0xc4, 0x00, 0x00, 0x03, 0x0e, 0x00, 0x00, 0x08, 0xb2, 0x92,
-0x07, 0x07, 0x05, 0x05, 0x95, 0x6b, 0x06, 0x00, 0x01, 0x26, 0x01, 0x87,
-0x03, 0x07, 0x01, 0xc4, 0x0e, 0x00, 0x00, 0x07, 0xb2, 0x07, 0x07, 0x05,
-0x07, 0x07, 0x75, 0x00, 0x04, 0x00, 0x00, 0x07, 0x75, 0x92, 0x05, 0x05,
-0x07, 0xbf, 0x71, 0x00, 0x10, 0x00, 0x00, 0x07, 0xc4, 0x05, 0x07, 0x05,
-0x05, 0x07, 0xb6, 0x00, 0x05, 0x00, 0x00, 0x05, 0x85, 0x05, 0x07, 0x07,
-0xa9, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x07, 0x07, 0x05,
-0x87, 0x00, 0x0e, 0x00, 0x00, 0x06, 0x94, 0x07, 0x05, 0x05, 0xbf, 0x6b,
-0x04, 0x00, 0x00, 0x09, 0xb2, 0x92, 0x05, 0x05, 0x07, 0xa9, 0x00, 0x00,
-0x03, 0x00, 0x0b, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x87, 0x03, 0x07,
-0x01, 0x98, 0x01, 0xad, 0x05, 0x00, 0x00, 0x06, 0x84, 0x79, 0x07, 0x07,
-0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x9b, 0x07, 0x05,
-0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05, 0x85, 0x05, 0x07, 0x05,
-0x87, 0x00, 0x09, 0x00, 0x01, 0x4d, 0x01, 0xa4, 0x03, 0x07, 0x01, 0xa4,
-0x01, 0x8e, 0x10, 0x00, 0x00, 0x06, 0xf6, 0x07, 0x05, 0x07, 0x07, 0x99,
-0x05, 0x00, 0x00, 0x07, 0x71, 0x9b, 0x07, 0x05, 0x07, 0xbd, 0x6b, 0x00,
-0x10, 0x00, 0x01, 0x7c, 0x01, 0x9b, 0x04, 0x07, 0x01, 0x97, 0x01, 0x75,
-0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09,
-0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0,
-0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3,
-0x07, 0x00, 0x00, 0x03, 0x03, 0x00, 0xe3, 0x00, 0x03, 0x09, 0x00, 0x04,
-0xb3, 0x11, 0x00, 0x03, 0x0d, 0x00, 0x00, 0x03, 0x03, 0x00, 0xa3, 0x00,
-0x03, 0xe6, 0x01, 0xd2, 0x01, 0x26, 0x07, 0x00, 0x00, 0x0c, 0x03, 0x00,
-0x00, 0xb0, 0xb3, 0xc9, 0xc9, 0xb3, 0xe8, 0x03, 0x00, 0x03, 0x08, 0x00,
-0x00, 0x08, 0xf5, 0x07, 0x05, 0x05, 0x97, 0x9a, 0x00, 0x71, 0x10, 0x00,
-0x01, 0xf5, 0x03, 0x07, 0x00, 0x03, 0x05, 0x95, 0x6b, 0x00, 0x06, 0x00,
-0x00, 0x06, 0x9a, 0x9b, 0x07, 0x07, 0x79, 0x94, 0x0f, 0x00, 0x01, 0xbd,
-0x04, 0x07, 0x01, 0x75, 0x04, 0x00, 0x00, 0x06, 0x9f, 0x05, 0x05, 0x07,
-0x95, 0x99, 0x11, 0x00, 0x01, 0x9a, 0x01, 0x92, 0x03, 0x07, 0x01, 0x05,
-0x01, 0xb6, 0x05, 0x00, 0x00, 0x05, 0x85, 0x05, 0x07, 0x07, 0xa9, 0x00,
-0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x07, 0x07, 0x05, 0x87, 0x00,
-0x0e, 0x00, 0x00, 0x06, 0x94, 0x05, 0x05, 0x07, 0xbf, 0x6b, 0x04, 0x00,
-0x00, 0x08, 0xc2, 0x05, 0x07, 0x07, 0x98, 0x75, 0x00, 0x26, 0x0f, 0x00,
-0x00, 0x06, 0xb2, 0x79, 0x05, 0x07, 0x07, 0x94, 0x05, 0x00, 0x00, 0x06,
-0x84, 0x07, 0x07, 0x05, 0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x7c, 0x9b, 0x07, 0x07, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x01, 0x85,
-0x03, 0x05, 0x01, 0x87, 0x09, 0x00, 0x00, 0x06, 0x84, 0x79, 0x05, 0x07,
-0x07, 0x84, 0x11, 0x00, 0x00, 0x06, 0x6b, 0x9b, 0x07, 0x07, 0x05, 0xc4,
-0x05, 0x00, 0x00, 0x06, 0xd6, 0x07, 0x05, 0x07, 0x79, 0x99, 0x12, 0x00,
-0x01, 0xc5, 0x01, 0x05, 0x03, 0x07, 0x01, 0x97, 0x01, 0x75, 0x25, 0x00,
-0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2,
-0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d,
-0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x06, 0x00,
-0x00, 0x04, 0x03, 0x00, 0x03, 0xb3, 0x03, 0x09, 0x00, 0x03, 0xe8, 0x00,
-0x11, 0x00, 0x0f, 0x00, 0x01, 0x03, 0x0e, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x00, 0x11, 0xa3, 0xa3, 0x26, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x0a,
-0x03, 0x00, 0x71, 0xa4, 0x05, 0x79, 0x05, 0x9f, 0x00, 0x26, 0x11, 0x00,
-0x00, 0x07, 0x8e, 0x97, 0x05, 0x07, 0x05, 0x95, 0x6b, 0x00, 0x06, 0x00,
-0x00, 0x06, 0x99, 0x92, 0x07, 0x07, 0xb5, 0xb2, 0x0f, 0x00, 0x01, 0xf6,
-0x04, 0x07, 0x01, 0x75, 0x03, 0x00, 0x00, 0x09, 0x4d, 0x9b, 0x05, 0x07,
-0x05, 0xc2, 0x00, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x00, 0x09, 0x03, 0x00,
-0x00, 0x9f, 0x05, 0x05, 0x07, 0x05, 0xb6, 0x00, 0x05, 0x00, 0x01, 0x85,
-0x03, 0x07, 0x01, 0xa9, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x05,
-0x07, 0x07, 0x87, 0x00, 0x0e, 0x00, 0x00, 0x11, 0x94, 0x07, 0x05, 0x07,
-0xbf, 0x6b, 0x00, 0x03, 0x00, 0x8e, 0x9b, 0x05, 0x07, 0x07, 0xf6, 0x00,
-0x4d, 0x00, 0x11, 0x00, 0x00, 0x06, 0xd6, 0xd7, 0xf6, 0xf5, 0x96, 0x03,
-0x04, 0x00, 0x01, 0x84, 0x03, 0x07, 0x01, 0xa4, 0x01, 0x7c, 0x0d, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0x7c, 0x9b, 0x07, 0x05, 0x92, 0x96, 0x00, 0x4d,
-0x07, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x05, 0x87, 0x00, 0x09, 0x00,
-0x00, 0x08, 0x87, 0x05, 0x05, 0x07, 0x87, 0x00, 0x00, 0x03, 0x10, 0x00,
-0x00, 0x06, 0x96, 0xa9, 0xc2, 0xa9, 0xd7, 0x71, 0x04, 0x00, 0x01, 0xbf,
-0x03, 0x07, 0x00, 0x04, 0xa9, 0x00, 0x00, 0x03, 0x0e, 0x00, 0x00, 0x04,
-0x03, 0x00, 0x71, 0xbf, 0x03, 0x07, 0x01, 0x97, 0x01, 0x75, 0x25, 0x00,
-0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2,
-0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d,
-0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x06, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0xe6, 0xf9, 0x09, 0x09, 0xfe, 0xa2, 0x00, 0x11,
-0x16, 0x03, 0x09, 0x00, 0x01, 0x03, 0x0e, 0x00, 0x00, 0x0a, 0x26, 0x00,
-0x99, 0xb5, 0x07, 0x05, 0xb5, 0x99, 0x00, 0x26, 0x12, 0x00, 0x00, 0x06,
-0xc2, 0x05, 0x07, 0x05, 0x95, 0x6b, 0x06, 0x00, 0x00, 0x06, 0x84, 0x07,
-0x05, 0x07, 0x98, 0x6b, 0x0f, 0x00, 0x01, 0x84, 0x03, 0x07, 0x01, 0x05,
-0x01, 0x75, 0x03, 0x00, 0x01, 0xb1, 0x01, 0x92, 0x03, 0x07, 0x00, 0x03,
-0x96, 0x00, 0x71, 0x00, 0x11, 0x00, 0x00, 0x06, 0xb1, 0x79, 0x05, 0x07,
-0x07, 0xb6, 0x05, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x07, 0xa9, 0x00,
-0x0c, 0x00, 0x00, 0x03, 0x4d, 0x00, 0xd7, 0x00, 0x03, 0x07, 0x01, 0x87,
-0x0e, 0x00, 0x00, 0x11, 0x94, 0x07, 0x05, 0x05, 0xbf, 0x6b, 0x00, 0x26,
-0x00, 0x84, 0x92, 0x05, 0x05, 0x97, 0xb2, 0x00, 0x71, 0x00, 0x0f, 0x26,
-0x01, 0x4d, 0x06, 0x00, 0x01, 0x26, 0x04, 0x00, 0x00, 0x06, 0x84, 0x07,
-0x05, 0x07, 0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x9b,
-0x05, 0x05, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05, 0x85, 0x07,
-0x05, 0x05, 0x87, 0x00, 0x08, 0x00, 0x00, 0x08, 0x8e, 0x98, 0x07, 0x07,
-0x05, 0x94, 0x00, 0x71, 0x0f, 0x26, 0x01, 0x4d, 0x01, 0x03, 0x05, 0x00,
-0x01, 0x26, 0x03, 0x00, 0x01, 0x8e, 0x01, 0x97, 0x03, 0x07, 0x00, 0x03,
-0xc5, 0x00, 0x71, 0x00, 0x10, 0x00, 0x00, 0x03, 0x4d, 0x00, 0xdb, 0x00,
-0x03, 0x07, 0x01, 0x97, 0x01, 0x75, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00,
-0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00,
-0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6,
-0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x06, 0x00, 0x00, 0x07, 0x11, 0x00,
-0xb0, 0xe9, 0x09, 0x09, 0xda, 0x00, 0x1a, 0x00, 0x01, 0x03, 0x16, 0x00,
-0x00, 0x0a, 0x4d, 0x00, 0xdb, 0x07, 0x07, 0x05, 0xa4, 0x71, 0x00, 0x03,
-0x12, 0x00, 0x00, 0x06, 0x84, 0x05, 0x07, 0x05, 0x95, 0x6b, 0x06, 0x00,
-0x01, 0xc5, 0x03, 0x07, 0x01, 0x98, 0x10, 0x00, 0x01, 0xb1, 0x03, 0x07,
-0x01, 0x05, 0x01, 0x75, 0x03, 0x00, 0x00, 0x08, 0xdb, 0x79, 0x07, 0x07,
-0xa4, 0x7c, 0x00, 0x4d, 0x11, 0x00, 0x00, 0x06, 0x8e, 0xbd, 0x05, 0x07,
-0x07, 0xb6, 0x05, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x07, 0xa9, 0x00,
-0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x07, 0x07, 0x05, 0x87, 0x00,
-0x0e, 0x00, 0x00, 0x0e, 0x94, 0x07, 0x07, 0x05, 0xbf, 0x6b, 0x00, 0x26,
-0x00, 0xf6, 0x07, 0x07, 0x05, 0xbf, 0x1a, 0x00, 0x01, 0x03, 0x03, 0x00,
-0x00, 0x06, 0x84, 0x79, 0x07, 0x05, 0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a,
-0x03, 0x00, 0x7c, 0x9b, 0x07, 0x07, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00,
-0x01, 0x85, 0x03, 0x07, 0x01, 0x87, 0x06, 0x00, 0x00, 0x08, 0x03, 0x00,
-0x99, 0xb5, 0x07, 0x07, 0x98, 0xad, 0x19, 0x00, 0x00, 0x0b, 0x03, 0x00,
-0x00, 0x96, 0x92, 0x07, 0x07, 0x98, 0xb2, 0x00, 0x4d, 0x00, 0x10, 0x00,
-0x00, 0x08, 0x4d, 0x00, 0x99, 0x92, 0x07, 0x07, 0x97, 0x75, 0x25, 0x00,
-0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2,
-0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d,
-0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x06, 0x00,
-0x00, 0x03, 0x26, 0x00, 0xd8, 0x00, 0x03, 0x09, 0x01, 0xf9, 0x18, 0xa0,
-0x01, 0xe3, 0x01, 0xa2, 0x17, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xf5, 0x07,
-0x07, 0x05, 0x87, 0x00, 0x15, 0x00, 0x00, 0x06, 0xb2, 0x95, 0x05, 0x07,
-0x95, 0x6b, 0x06, 0x00, 0x01, 0xc5, 0x03, 0x07, 0x01, 0x98, 0x10, 0x00,
-0x01, 0xb2, 0x04, 0x07, 0x01, 0x75, 0x03, 0x00, 0x00, 0x08, 0xf5, 0x07,
-0x07, 0x05, 0x87, 0x26, 0x00, 0x03, 0x12, 0x00, 0x00, 0x05, 0xc2, 0x07,
-0x05, 0x07, 0xb6, 0x00, 0x05, 0x00, 0x00, 0x05, 0x85, 0x05, 0x07, 0x07,
-0xa9, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x05, 0x07, 0x07,
-0x87, 0x00, 0x0e, 0x00, 0x01, 0x94, 0x03, 0x07, 0x00, 0x0b, 0xbf, 0x6b,
-0x00, 0x4d, 0x00, 0xc2, 0x07, 0x79, 0x07, 0x98, 0xd7, 0x00, 0x16, 0x9f,
-0x00, 0x03, 0x85, 0x85, 0x99, 0x00, 0x04, 0x00, 0x00, 0x06, 0x84, 0x79,
-0x07, 0x07, 0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x9b,
-0x07, 0x07, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05, 0x85, 0x07,
-0x05, 0x05, 0x87, 0x00, 0x06, 0x00, 0x00, 0x09, 0x03, 0x00, 0xd6, 0x95,
-0x05, 0x07, 0xb5, 0xc2, 0xf5, 0x00, 0x15, 0x9f, 0x00, 0x03, 0x85, 0xc2,
-0xd6, 0x00, 0x03, 0x00, 0x00, 0x08, 0x94, 0x79, 0x07, 0x07, 0xbd, 0x8e,
-0x00, 0x26, 0x10, 0x00, 0x00, 0x08, 0x4d, 0x00, 0x75, 0x9b, 0x05, 0x05,
-0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9,
-0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09,
-0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda,
-0x01, 0xa3, 0x06, 0x00, 0x00, 0x03, 0x26, 0x00, 0xd8, 0x00, 0x1c, 0x09,
-0x01, 0xe9, 0x01, 0xd2, 0x17, 0x00, 0x00, 0x07, 0x4d, 0x00, 0x85, 0x07,
-0x07, 0x05, 0xc4, 0x00, 0x15, 0x00, 0x00, 0x06, 0xb2, 0xb5, 0x07, 0x07,
-0x95, 0x6b, 0x06, 0x00, 0x00, 0x05, 0x84, 0x07, 0x07, 0x05, 0x98, 0x00,
-0x10, 0x00, 0x01, 0x9a, 0x01, 0x95, 0x03, 0x07, 0x01, 0x75, 0x03, 0x00,
-0x01, 0xc2, 0x03, 0x07, 0x00, 0x04, 0xc4, 0x00, 0x00, 0x03, 0x10, 0x00,
-0x00, 0x07, 0x26, 0x00, 0xf5, 0x05, 0x05, 0x07, 0xb6, 0x00, 0x05, 0x00,
-0x00, 0x05, 0x85, 0x07, 0x07, 0x05, 0xa9, 0x00, 0x0c, 0x00, 0x00, 0x03,
-0x4d, 0x00, 0xd7, 0x00, 0x03, 0x07, 0x01, 0x87, 0x0e, 0x00, 0x00, 0x0c,
-0x94, 0x05, 0x05, 0x07, 0xbf, 0x6b, 0x00, 0x4d, 0x00, 0xa9, 0x07, 0x79,
-0x07, 0x07, 0x01, 0x05, 0x08, 0x07, 0x00, 0x05, 0x05, 0x07, 0x05, 0x07,
-0x07, 0x00, 0x03, 0x05, 0x03, 0x07, 0x01, 0xd7, 0x04, 0x00, 0x01, 0x84,
-0x03, 0x07, 0x01, 0xa4, 0x01, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x7c, 0x9b, 0x07, 0x05, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05,
-0x85, 0x05, 0x05, 0x07, 0x87, 0x00, 0x06, 0x00, 0x00, 0x03, 0x03, 0x00,
-0xdb, 0x00, 0x04, 0x07, 0x00, 0x04, 0x05, 0x05, 0x07, 0x05, 0x09, 0x07,
-0x00, 0x05, 0x05, 0x07, 0x05, 0x07, 0x07, 0x00, 0x04, 0x05, 0x00, 0x04,
-0x07, 0x05, 0x05, 0xbf, 0x03, 0x00, 0x00, 0x08, 0xb6, 0x79, 0x05, 0x07,
-0x87, 0x71, 0x00, 0x03, 0x10, 0x00, 0x00, 0x08, 0x26, 0x00, 0x7c, 0xa4,
-0x07, 0x07, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08,
-0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1,
-0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09,
-0x01, 0xda, 0x01, 0xa3, 0x06, 0x00, 0x00, 0x03, 0x26, 0x00, 0xd8, 0x00,
-0x1a, 0x09, 0x00, 0x04, 0xe9, 0x09, 0xf9, 0xd2, 0x17, 0x00, 0x00, 0x07,
-0x4d, 0x00, 0x85, 0x07, 0x07, 0x05, 0xa9, 0x00, 0x15, 0x00, 0x00, 0x06,
-0x9a, 0x97, 0x07, 0x07, 0x95, 0x6b, 0x06, 0x00, 0x01, 0x84, 0x03, 0x07,
-0x01, 0x98, 0x10, 0x00, 0x00, 0x06, 0x9a, 0x92, 0x05, 0x05, 0x07, 0x75,
-0x03, 0x00, 0x00, 0x08, 0xc2, 0x07, 0x05, 0x05, 0xc4, 0x00, 0x00, 0x03,
-0x10, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x05, 0x07, 0x07, 0xb6, 0x00,
-0x05, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x07, 0xa9, 0x00, 0x0c, 0x00,
-0x00, 0x07, 0x4d, 0x00, 0xd7, 0x05, 0x07, 0x07, 0x87, 0x00, 0x0e, 0x00,
-0x00, 0x0c, 0x94, 0x05, 0x07, 0x07, 0xbf, 0x6b, 0x00, 0x4d, 0x00, 0xa9,
-0x07, 0x79, 0x04, 0x07, 0x01, 0x05, 0x12, 0x07, 0x00, 0x05, 0x05, 0x79,
-0x07, 0x07, 0xf6, 0x00, 0x04, 0x00, 0x00, 0x06, 0x84, 0x07, 0x07, 0x05,
-0xa4, 0x7c, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x7c, 0x98, 0x07, 0x05,
-0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x05,
-0x87, 0x00, 0x06, 0x00, 0x00, 0x05, 0x03, 0x00, 0xb6, 0x07, 0x05, 0x00,
-0x04, 0x07, 0x01, 0x05, 0x03, 0x07, 0x01, 0x05, 0x08, 0x07, 0x00, 0x04,
-0x05, 0x07, 0x07, 0x05, 0x03, 0x07, 0x00, 0x04, 0x79, 0x07, 0x07, 0x87,
-0x03, 0x00, 0x00, 0x08, 0xb6, 0x07, 0x05, 0x07, 0x87, 0x71, 0x00, 0x03,
-0x10, 0x00, 0x00, 0x08, 0x26, 0x00, 0x8e, 0xbd, 0x05, 0x07, 0x97, 0x75,
-0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09,
-0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0,
-0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3,
-0x06, 0x00, 0x00, 0x03, 0x11, 0x00, 0xe8, 0x00, 0x03, 0x09, 0x01, 0xc9,
-0x01, 0xb3, 0x12, 0xe2, 0x00, 0x07, 0xb3, 0xe2, 0xe9, 0x09, 0x09, 0xe2,
-0xa2, 0x00, 0x17, 0x00, 0x00, 0x07, 0x4d, 0x00, 0x85, 0x05, 0x07, 0x05,
-0x87, 0x00, 0x15, 0x00, 0x00, 0x06, 0xb2, 0x92, 0x07, 0x05, 0x95, 0x6b,
-0x06, 0x00, 0x00, 0x05, 0x84, 0x05, 0x05, 0x07, 0x98, 0x00, 0x10, 0x00,
-0x00, 0x06, 0x9a, 0x92, 0x05, 0x07, 0x07, 0x75, 0x03, 0x00, 0x01, 0xf5,
-0x03, 0x05, 0x00, 0x04, 0x87, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0x05,
-0x85, 0x07, 0x07, 0x05, 0xb6, 0x00, 0x05, 0x00, 0x00, 0x05, 0x85, 0x07,
-0x05, 0x07, 0xa9, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xd7, 0x05,
-0x07, 0x07, 0x87, 0x00, 0x0e, 0x00, 0x00, 0x0d, 0x94, 0x07, 0x07, 0x05,
-0xbf, 0x6b, 0x00, 0x4d, 0x00, 0xc2, 0x07, 0x79, 0x07, 0x00, 0x17, 0x79,
-0x03, 0x07, 0x01, 0xdb, 0x04, 0x00, 0x01, 0x84, 0x03, 0x07, 0x01, 0xa4,
-0x01, 0x7c, 0x0f, 0x00, 0x00, 0x08, 0x7c, 0x9b, 0x07, 0x05, 0x92, 0x96,
-0x00, 0x4d, 0x07, 0x00, 0x01, 0x85, 0x03, 0x07, 0x01, 0x87, 0x06, 0x00,
-0x00, 0x07, 0x03, 0x00, 0xd6, 0x95, 0x05, 0x05, 0x07, 0x00, 0x16, 0x79,
-0x03, 0x07, 0x01, 0xc4, 0x03, 0x00, 0x00, 0x08, 0xdb, 0x79, 0x07, 0x05,
-0xbd, 0x8e, 0x00, 0x26, 0x10, 0x00, 0x00, 0x08, 0x26, 0x00, 0x75, 0xa4,
-0x07, 0x07, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08,
-0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1,
-0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09,
-0x01, 0xda, 0x01, 0xa3, 0x06, 0x00, 0x00, 0x07, 0x11, 0x00, 0xa1, 0xc9,
-0x09, 0x09, 0xb3, 0x00, 0x14, 0x00, 0x00, 0x06, 0xa3, 0xe9, 0x09, 0x09,
-0xda, 0xa3, 0x17, 0x00, 0x00, 0x07, 0x4d, 0x00, 0xb6, 0x05, 0x07, 0x07,
-0xbd, 0x00, 0x15, 0x00, 0x01, 0x96, 0x03, 0x07, 0x01, 0x95, 0x01, 0x6b,
-0x06, 0x00, 0x00, 0x05, 0x84, 0x05, 0x07, 0x07, 0x98, 0x00, 0x10, 0x00,
-0x01, 0x9a, 0x01, 0x92, 0x03, 0x07, 0x01, 0x75, 0x03, 0x00, 0x00, 0x08,
-0xdb, 0x79, 0x05, 0x05, 0xa4, 0x7c, 0x00, 0x26, 0x11, 0x00, 0x01, 0x6b,
-0x01, 0x87, 0x03, 0x07, 0x01, 0xb6, 0x05, 0x00, 0x01, 0x85, 0x03, 0x07,
-0x01, 0xa9, 0x0c, 0x00, 0x00, 0x03, 0x4d, 0x00, 0xd7, 0x00, 0x03, 0x07,
-0x01, 0x87, 0x0e, 0x00, 0x00, 0x0a, 0x94, 0x05, 0x07, 0x07, 0xbf, 0x6b,
-0x00, 0x26, 0x00, 0xd7, 0x03, 0x07, 0x01, 0x9b, 0x13, 0x94, 0x00, 0x03,
-0xc5, 0xb6, 0xb5, 0x00, 0x03, 0x07, 0x01, 0x96, 0x04, 0x00, 0x00, 0x06,
-0x84, 0x79, 0x07, 0x07, 0x9b, 0x75, 0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x7c, 0x98, 0x07, 0x05, 0x92, 0x96, 0x00, 0x4d, 0x07, 0x00, 0x00, 0x05,
-0x85, 0x05, 0x07, 0x07, 0x87, 0x00, 0x06, 0x00, 0x00, 0x09, 0x03, 0x00,
-0x96, 0xb5, 0x07, 0x07, 0xb5, 0xf5, 0xd6, 0x00, 0x11, 0x94, 0x00, 0x07,
-0xd6, 0xdb, 0xa4, 0x05, 0x07, 0x05, 0xf5, 0x00, 0x03, 0x00, 0x00, 0x08,
-0x84, 0x92, 0x05, 0x07, 0x9b, 0x9a, 0x00, 0x4d, 0x10, 0x00, 0x00, 0x08,
-0x4d, 0x00, 0x99, 0xb5, 0x05, 0x05, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00,
-0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03,
-0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00,
-0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x06, 0x00, 0x00, 0x08,
-0x03, 0x00, 0xa2, 0xe2, 0x09, 0x09, 0xf9, 0xe6, 0x13, 0x00, 0x00, 0x05,
-0xb0, 0x09, 0x09, 0xfd, 0xe3, 0x00, 0x18, 0x00, 0x00, 0x0a, 0x26, 0x00,
-0x84, 0x92, 0x07, 0x05, 0x98, 0x9a, 0x00, 0x26, 0x12, 0x00, 0x00, 0x06,
-0xf5, 0x07, 0x07, 0x05, 0x95, 0x6b, 0x06, 0x00, 0x01, 0x84, 0x03, 0x07,
-0x01, 0x98, 0x10, 0x00, 0x01, 0x9a, 0x01, 0x95, 0x03, 0x07, 0x01, 0x75,
-0x03, 0x00, 0x00, 0x08, 0x99, 0x92, 0x05, 0x05, 0x92, 0x99, 0x00, 0x71,
-0x0f, 0x00, 0x00, 0x04, 0x03, 0x00, 0x75, 0x97, 0x03, 0x07, 0x01, 0xb6,
-0x05, 0x00, 0x01, 0x85, 0x03, 0x05, 0x01, 0xc4, 0x0c, 0x00, 0x00, 0x07,
-0x4d, 0x00, 0x9f, 0x07, 0x79, 0x07, 0x87, 0x00, 0x0e, 0x00, 0x00, 0x0f,
-0xb6, 0x05, 0x07, 0x07, 0x87, 0x6b, 0x00, 0x26, 0x00, 0xc5, 0x95, 0x07,
-0x07, 0x9b, 0x6b, 0x00, 0x13, 0x00, 0x00, 0x06, 0xad, 0x95, 0x07, 0x05,
-0x79, 0x75, 0x04, 0x00, 0x00, 0x06, 0x84, 0x79, 0x07, 0x07, 0x97, 0x9a,
-0x0d, 0x00, 0x00, 0x0a, 0x03, 0x00, 0xb1, 0x97, 0x07, 0x05, 0xb5, 0x99,
-0x00, 0x4d, 0x07, 0x00, 0x01, 0x85, 0x03, 0x05, 0x01, 0x87, 0x08, 0x00,
-0x00, 0x06, 0x7c, 0x98, 0x07, 0x07, 0x95, 0x99, 0x13, 0x00, 0x00, 0x06,
-0x4d, 0xa4, 0x05, 0x07, 0x05, 0x84, 0x03, 0x00, 0x00, 0x08, 0x7c, 0x97,
-0x05, 0x07, 0x07, 0x84, 0x00, 0x71, 0x10, 0x00, 0x00, 0x08, 0x71, 0x00,
-0x94, 0x05, 0x05, 0x07, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00,
-0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00,
-0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6,
-0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x09, 0x00, 0x01, 0xa0, 0x03, 0x09,
-0x00, 0x04, 0xe3, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x05, 0xb3, 0x09,
-0x09, 0xfd, 0xa1, 0x00, 0x18, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x8e, 0x9b,
-0x05, 0x05, 0x07, 0xdb, 0x00, 0x4d, 0x11, 0x00, 0x00, 0x07, 0x6b, 0x9b,
-0x07, 0x07, 0x05, 0x95, 0x6b, 0x00, 0x06, 0x00, 0x00, 0x05, 0x84, 0x05,
-0x07, 0x07, 0x98, 0x00, 0x10, 0x00, 0x01, 0x9a, 0x01, 0x92, 0x03, 0x07,
-0x01, 0x75, 0x03, 0x00, 0x01, 0x71, 0x01, 0x98, 0x03, 0x07, 0x00, 0x03,
-0xd7, 0x00, 0x26, 0x00, 0x11, 0x00, 0x01, 0xd6, 0x04, 0x07, 0x01, 0xb6,
-0x05, 0x00, 0x00, 0x06, 0x85, 0x05, 0x05, 0x07, 0xbf, 0x26, 0x0b, 0x00,
-0x00, 0x0a, 0x26, 0x00, 0xa9, 0x07, 0x79, 0x07, 0xbd, 0x00, 0x00, 0x03,
-0x0b, 0x00, 0x01, 0x9f, 0x03, 0x05, 0x00, 0x07, 0xc4, 0x71, 0x00, 0x03,
-0x00, 0x7c, 0x98, 0x00, 0x03, 0x07, 0x00, 0x04, 0x94, 0x00, 0x4d, 0x03,
-0x0d, 0x00, 0x00, 0x09, 0x03, 0x00, 0x00, 0xd7, 0x07, 0x07, 0x05, 0xbd,
-0x6b, 0x00, 0x04, 0x00, 0x00, 0x08, 0x84, 0x79, 0x07, 0x07, 0x05, 0x99,
-0x00, 0x03, 0x0b, 0x00, 0x00, 0x0a, 0x26, 0x00, 0xc5, 0x95, 0x05, 0x07,
-0x9b, 0x9a, 0x00, 0x26, 0x07, 0x00, 0x00, 0x05, 0x85, 0x07, 0x05, 0x05,
-0x87, 0x00, 0x09, 0x00, 0x01, 0xbf, 0x03, 0x07, 0x00, 0x04, 0x85, 0x00,
-0x03, 0x03, 0x0d, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x99, 0x03, 0x07,
-0x01, 0x79, 0x01, 0x7c, 0x04, 0x00, 0x00, 0x05, 0xbd, 0x05, 0x07, 0x05,
-0x85, 0x00, 0x11, 0x00, 0x00, 0x09, 0x03, 0x00, 0x26, 0x87, 0x05, 0x07,
-0x07, 0x97, 0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08,
-0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1,
-0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09,
-0x01, 0xda, 0x01, 0xa3, 0x07, 0x00, 0x00, 0x0a, 0x03, 0x00, 0xb0, 0xe9,
-0x09, 0x09, 0xf9, 0xe6, 0x00, 0x11, 0x0f, 0x00, 0x01, 0xb0, 0x03, 0x09,
-0x01, 0xb3, 0x01, 0xa2, 0x1b, 0x00, 0x00, 0x08, 0xa9, 0x07, 0x05, 0x07,
-0xbd, 0x71, 0x00, 0x4d, 0x10, 0x00, 0x01, 0xd6, 0x03, 0x07, 0x00, 0x03,
-0x05, 0x95, 0x6b, 0x00, 0x06, 0x00, 0x01, 0x84, 0x03, 0x07, 0x01, 0x98,
-0x10, 0x00, 0x01, 0x9a, 0x01, 0x92, 0x03, 0x07, 0x01, 0x75, 0x04, 0x00,
-0x00, 0x08, 0xa9, 0x05, 0x07, 0x07, 0x98, 0x7c, 0x00, 0x03, 0x0d, 0x00,
-0x00, 0x04, 0x03, 0x00, 0x71, 0xa4, 0x04, 0x07, 0x01, 0xb6, 0x05, 0x00,
-0x00, 0x06, 0x85, 0x07, 0x05, 0x07, 0x98, 0x71, 0x0a, 0x00, 0x00, 0x0b,
-0x03, 0x00, 0x03, 0x87, 0x07, 0x79, 0x07, 0x9b, 0x7c, 0x00, 0x03, 0x00,
-0x0b, 0x00, 0x00, 0x05, 0x87, 0x07, 0x05, 0x07, 0x85, 0x00, 0x05, 0x00,
-0x01, 0xc4, 0x03, 0x07, 0x00, 0x04, 0xbf, 0x26, 0x00, 0x03, 0x0f, 0x00,
-0x01, 0x6b, 0x01, 0x98, 0x03, 0x05, 0x01, 0xf6, 0x05, 0x00, 0x01, 0x84,
-0x04, 0x07, 0x01, 0xdb, 0x0d, 0x00, 0x00, 0x0a, 0x26, 0x00, 0x85, 0x07,
-0x07, 0x05, 0xbd, 0x71, 0x00, 0x03, 0x07, 0x00, 0x01, 0x85, 0x03, 0x07,
-0x01, 0x87, 0x09, 0x00, 0x01, 0xdb, 0x03, 0x07, 0x00, 0x04, 0x98, 0x75,
-0x00, 0x03, 0x0d, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0xc4, 0x05, 0x07,
-0x07, 0xbf, 0x05, 0x00, 0x00, 0x08, 0xf6, 0x07, 0x05, 0x07, 0x98, 0xad,
-0x00, 0x03, 0x10, 0x00, 0x01, 0x96, 0x03, 0x07, 0x00, 0x03, 0x05, 0x97,
-0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9,
-0x09, 0xfd, 0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09,
-0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda,
-0x01, 0xa3, 0x0a, 0x00, 0x01, 0xb3, 0x03, 0x09, 0x00, 0x04, 0xda, 0x71,
-0x00, 0x03, 0x0a, 0x00, 0x00, 0x05, 0x03, 0x11, 0x00, 0xd2, 0xf9, 0x00,
-0x03, 0x09, 0x00, 0x03, 0xe8, 0x00, 0x26, 0x00, 0x1a, 0x00, 0x01, 0x99,
-0x01, 0x92, 0x03, 0x07, 0x00, 0x04, 0xf6, 0x00, 0x26, 0x03, 0x0c, 0x00,
-0x00, 0x04, 0x26, 0x00, 0x7c, 0x97, 0x04, 0x07, 0x01, 0x95, 0x01, 0x6b,
-0x06, 0x00, 0x00, 0x05, 0x84, 0x07, 0x07, 0x05, 0x98, 0x00, 0x10, 0x00,
-0x00, 0x06, 0x9a, 0x92, 0x05, 0x07, 0x07, 0x75, 0x04, 0x00, 0x00, 0x09,
-0xb2, 0x95, 0x07, 0x05, 0x05, 0xc2, 0x00, 0x00, 0x03, 0x00, 0x0b, 0x00,
-0x00, 0x06, 0x03, 0x00, 0x00, 0xf6, 0x07, 0x07, 0x03, 0x05, 0x01, 0xb6,
-0x05, 0x00, 0x01, 0x85, 0x04, 0x07, 0x01, 0x99, 0x0a, 0x00, 0x00, 0x04,
-0x4d, 0x00, 0xb2, 0x97, 0x03, 0x07, 0x00, 0x04, 0x79, 0xc5, 0x00, 0x4d,
-0x0a, 0x00, 0x01, 0x6b, 0x01, 0x97, 0x03, 0x07, 0x01, 0xd6, 0x05, 0x00,
-0x01, 0x99, 0x01, 0x92, 0x03, 0x05, 0x00, 0x04, 0xdb, 0x00, 0x00, 0x03,
-0x0b, 0x00, 0x00, 0x0b, 0x03, 0x00, 0x00, 0x9f, 0x05, 0x07, 0x05, 0x97,
-0x75, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x84, 0x03, 0x07, 0x00, 0x05,
-0x05, 0xbd, 0x6b, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x04, 0x4d, 0x00,
-0x8e, 0xa4, 0x03, 0x07, 0x00, 0x03, 0xc2, 0x00, 0x03, 0x00, 0x08, 0x00,
-0x00, 0x05, 0x85, 0x05, 0x07, 0x05, 0x87, 0x00, 0x09, 0x00, 0x01, 0x6b,
-0x01, 0x98, 0x03, 0x07, 0x00, 0x04, 0xa9, 0x00, 0x00, 0x03, 0x0e, 0x00,
-0x00, 0x06, 0x96, 0x07, 0x05, 0x07, 0x07, 0x96, 0x05, 0x00, 0x01, 0x8e,
-0x01, 0xb5, 0x03, 0x07, 0x00, 0x04, 0xa9, 0x00, 0x00, 0x03, 0x0c, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0x6b, 0xa4, 0x05, 0x07, 0x05, 0x05, 0x97, 0x75,
-0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09,
-0xb3, 0xa2, 0x00, 0x03, 0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0,
-0x01, 0x4d, 0x0b, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3,
-0x0a, 0x00, 0x01, 0xa1, 0x04, 0x09, 0x00, 0x05, 0xa0, 0x26, 0x00, 0x03,
-0x03, 0x00, 0x07, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0xa2, 0xb3, 0x00,
-0x03, 0x09, 0x00, 0x04, 0xb3, 0x71, 0x00, 0x03, 0x1b, 0x00, 0x01, 0xc4,
-0x03, 0x07, 0x00, 0x05, 0x92, 0x96, 0x00, 0x00, 0x03, 0x00, 0x0a, 0x00,
-0x00, 0x04, 0x4d, 0x00, 0x00, 0x87, 0x04, 0x07, 0x00, 0x03, 0x05, 0x95,
-0x6b, 0x00, 0x06, 0x00, 0x00, 0x05, 0x84, 0x05, 0x07, 0x07, 0x98, 0x00,
-0x10, 0x00, 0x00, 0x06, 0x9a, 0x95, 0x07, 0x05, 0x07, 0x75, 0x05, 0x00,
-0x00, 0x09, 0xc4, 0x07, 0x05, 0x07, 0x07, 0xd6, 0x00, 0x00, 0x03, 0x00,
-0x09, 0x00, 0x00, 0x0b, 0x03, 0x00, 0x00, 0x99, 0x95, 0x07, 0x05, 0x05,
-0x07, 0x07, 0xb6, 0x00, 0x05, 0x00, 0x01, 0x85, 0x04, 0x07, 0x01, 0xa9,
-0x0a, 0x00, 0x00, 0x0c, 0x26, 0x00, 0xf6, 0x05, 0x05, 0x07, 0x79, 0x07,
-0xc4, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x06, 0xdb, 0x05, 0x07, 0x07,
-0xb5, 0xb1, 0x06, 0x00, 0x01, 0xc4, 0x03, 0x05, 0x00, 0x05, 0xb5, 0x99,
-0x00, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x0b, 0x03, 0x00, 0x00, 0x84,
-0x79, 0x05, 0x05, 0x07, 0xd7, 0x00, 0x03, 0x00, 0x04, 0x00, 0x01, 0x84,
-0x01, 0x79, 0x03, 0x07, 0x01, 0x05, 0x01, 0xc5, 0x0a, 0x00, 0x00, 0x0b,
-0x03, 0x26, 0x00, 0xb6, 0x07, 0x07, 0x05, 0x95, 0x84, 0x00, 0x03, 0x00,
-0x08, 0x00, 0x00, 0x05, 0x85, 0x05, 0x05, 0x07, 0x87, 0x00, 0x0a, 0x00,
-0x01, 0xdb, 0x04, 0x07, 0x00, 0x04, 0xdb, 0x00, 0x00, 0x03, 0x0a, 0x00,
-0x00, 0x04, 0x03, 0x00, 0x75, 0x98, 0x03, 0x07, 0x00, 0x04, 0x87, 0x4d,
-0x00, 0x03, 0x04, 0x00, 0x01, 0x9f, 0x03, 0x07, 0x00, 0x05, 0x05, 0x94,
-0x00, 0x00, 0x03, 0x00, 0x0a, 0x00, 0x00, 0x0b, 0x26, 0x00, 0x00, 0xa9,
-0x07, 0x07, 0x05, 0x07, 0x07, 0x97, 0x75, 0x00, 0x25, 0x00, 0x00, 0x00,
-0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03,
-0x0a, 0x00, 0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x0b, 0x00,
-0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x01, 0xa3, 0x0b, 0x00, 0x01, 0xa0,
-0x04, 0x09, 0x01, 0xda, 0x01, 0xa2, 0x0b, 0x00, 0x01, 0xa1, 0x01, 0xe2,
-0x03, 0x09, 0x00, 0x04, 0xe9, 0xa1, 0x00, 0x03, 0x1c, 0x00, 0x00, 0x07,
-0x9a, 0x92, 0x05, 0x05, 0x07, 0xb5, 0x96, 0x00, 0x0d, 0x00, 0x00, 0x0a,
-0x71, 0xa9, 0x07, 0x07, 0x05, 0x07, 0x07, 0x05, 0x95, 0x6b, 0x06, 0x00,
-0x00, 0x05, 0x84, 0x07, 0x05, 0x07, 0x98, 0x00, 0x10, 0x00, 0x00, 0x06,
-0x9a, 0x95, 0x07, 0x07, 0x05, 0x75, 0x05, 0x00, 0x01, 0x9a, 0x01, 0xb5,
-0x03, 0x07, 0x01, 0x79, 0x01, 0x84, 0x0d, 0x00, 0x00, 0x09, 0x99, 0x97,
-0x05, 0x07, 0x07, 0x05, 0x07, 0x07, 0xb6, 0x00, 0x05, 0x00, 0x00, 0x07,
-0x85, 0x07, 0x05, 0x07, 0x07, 0x95, 0x99, 0x00, 0x0a, 0x00, 0x00, 0x04,
-0x9a, 0x97, 0x05, 0x05, 0x03, 0x07, 0x01, 0x79, 0x01, 0x84, 0x08, 0x00,
-0x00, 0x09, 0x03, 0x00, 0x7c, 0x98, 0x05, 0x79, 0x07, 0x87, 0x03, 0x00,
-0x06, 0x00, 0x01, 0x75, 0x01, 0xb5, 0x03, 0x07, 0x01, 0x97, 0x01, 0xb1,
-0x0d, 0x00, 0x01, 0x84, 0x01, 0x92, 0x03, 0x07, 0x00, 0x04, 0xa4, 0x6b,
-0x00, 0x4d, 0x04, 0x00, 0x01, 0x84, 0x01, 0x79, 0x03, 0x07, 0x00, 0x03,
-0x05, 0x98, 0x75, 0x00, 0x0b, 0x00, 0x00, 0x07, 0x99, 0xb5, 0x07, 0x07,
-0x05, 0xa4, 0x4d, 0x00, 0x0a, 0x00, 0x01, 0x85, 0x03, 0x07, 0x01, 0x87,
-0x0a, 0x00, 0x01, 0x26, 0x01, 0xbd, 0x03, 0x05, 0x01, 0x79, 0x01, 0xd6,
-0x0d, 0x00, 0x00, 0x07, 0x75, 0xa4, 0x05, 0x07, 0x07, 0x92, 0xb1, 0x00,
-0x07, 0x00, 0x00, 0x07, 0x8e, 0x9b, 0x07, 0x05, 0x05, 0x79, 0xc5, 0x00,
-0x0e, 0x00, 0x01, 0xf5, 0x03, 0x07, 0x00, 0x05, 0x05, 0x05, 0x07, 0x97,
-0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9,
-0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x04, 0x00, 0x01, 0x03, 0x05, 0x00,
-0x01, 0xa1, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d, 0x05, 0x00, 0x01, 0x03,
-0x05, 0x00, 0x01, 0xd2, 0x03, 0x09, 0x01, 0xda, 0x01, 0x03, 0x04, 0x00,
-0x01, 0x03, 0x06, 0x00, 0x01, 0x4d, 0x01, 0xda, 0x04, 0x09, 0x00, 0x03,
-0xfe, 0xe8, 0x4d, 0x00, 0x07, 0x00, 0x00, 0x03, 0xd2, 0xe3, 0xe9, 0x00,
-0x04, 0x09, 0x01, 0xe8, 0x20, 0x00, 0x00, 0x07, 0x94, 0x07, 0x07, 0x05,
-0x07, 0x92, 0xb6, 0x00, 0x0b, 0x00, 0x00, 0x0b, 0xb2, 0xbd, 0x05, 0x07,
-0x07, 0x05, 0x05, 0x07, 0x05, 0x95, 0x6b, 0x00, 0x06, 0x00, 0x00, 0x05,
-0x84, 0x07, 0x05, 0x07, 0x98, 0x00, 0x10, 0x00, 0x00, 0x06, 0x9a, 0x92,
-0x07, 0x07, 0x05, 0x75, 0x06, 0x00, 0x00, 0x08, 0xd6, 0x05, 0x07, 0x07,
-0x05, 0x95, 0xf6, 0x4d, 0x0a, 0x00, 0x00, 0x04, 0xdb, 0xb5, 0x07, 0x07,
-0x03, 0x05, 0x00, 0x03, 0x07, 0x07, 0xb6, 0x00, 0x05, 0x00, 0x00, 0x08,
-0x85, 0x07, 0x05, 0x07, 0x07, 0x05, 0x98, 0xb2, 0x08, 0x00, 0x00, 0x04,
-0x7c, 0xbd, 0x07, 0x07, 0x03, 0x05, 0x00, 0x04, 0x07, 0x07, 0x97, 0x99,
-0x08, 0x00, 0x00, 0x09, 0x8e, 0xbd, 0x05, 0x07, 0x07, 0x79, 0x84, 0x00,
-0x4d, 0x00, 0x06, 0x00, 0x01, 0x94, 0x04, 0x07, 0x01, 0x97, 0x01, 0x94,
-0x0a, 0x00, 0x00, 0x0a, 0x71, 0xd7, 0x95, 0x05, 0x07, 0x07, 0x92, 0x99,
-0x00, 0x26, 0x05, 0x00, 0x00, 0x09, 0x84, 0x79, 0x07, 0x07, 0x05, 0x07,
-0x07, 0xa4, 0xb2, 0x00, 0x09, 0x00, 0x01, 0x96, 0x01, 0x97, 0x03, 0x07,
-0x01, 0x05, 0x01, 0xd6, 0x0b, 0x00, 0x00, 0x05, 0xf5, 0x05, 0x05, 0x07,
-0x87, 0x00, 0x07, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x08, 0xb2, 0xb5,
-0x07, 0x05, 0x07, 0x79, 0x9f, 0x6b, 0x0a, 0x00, 0x01, 0xc5, 0x01, 0x98,
-0x04, 0x07, 0x01, 0xb6, 0x09, 0x00, 0x00, 0x08, 0x96, 0x95, 0x07, 0x05,
-0x07, 0x79, 0x85, 0x8e, 0x0a, 0x00, 0x00, 0x0b, 0x75, 0x87, 0x07, 0x07,
-0x05, 0x07, 0x07, 0x05, 0x05, 0x97, 0x75, 0x00, 0x25, 0x00, 0x00, 0x00,
-0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03,
-0x05, 0x00, 0x01, 0x26, 0x01, 0xe6, 0x03, 0xa1, 0x01, 0xd8, 0x03, 0x09,
-0x01, 0xa0, 0x01, 0x4d, 0x06, 0x00, 0x00, 0x06, 0x4d, 0xa1, 0xe8, 0xe8,
-0xb0, 0xe3, 0x03, 0x09, 0x00, 0x08, 0xe2, 0xe8, 0xb0, 0xe8, 0xe8, 0xd2,
-0x00, 0x03, 0x06, 0x00, 0x01, 0xa2, 0x01, 0xb3, 0x05, 0x09, 0x00, 0x09,
-0xe2, 0xa0, 0xe8, 0xa1, 0xa1, 0xb0, 0xd8, 0xda, 0xf9, 0x00, 0x05, 0x09,
-0x01, 0xd8, 0x1f, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x85, 0x05, 0x07,
-0x05, 0x07, 0x07, 0xbd, 0xdb, 0x7c, 0x06, 0x00, 0x00, 0x03, 0xb2, 0xc2,
-0xb5, 0x00, 0x03, 0x07, 0x00, 0x07, 0x95, 0xbd, 0x07, 0x07, 0x05, 0x95,
-0x6b, 0x00, 0x06, 0x00, 0x00, 0x05, 0x84, 0x05, 0x07, 0x07, 0x98, 0x00,
-0x10, 0x00, 0x00, 0x06, 0x9a, 0x92, 0x07, 0x05, 0x05, 0x75, 0x04, 0x00,
-0x00, 0x05, 0x03, 0x00, 0x00, 0xd7, 0x05, 0x00, 0x04, 0x07, 0x00, 0x03,
-0xbd, 0x94, 0x8e, 0x00, 0x05, 0x00, 0x00, 0x0d, 0x71, 0xd6, 0xbf, 0x05,
-0x05, 0x07, 0x07, 0x9b, 0xbd, 0x07, 0x07, 0x05, 0xb6, 0x00, 0x05, 0x00,
-0x01, 0x85, 0x05, 0x07, 0x00, 0x04, 0x05, 0xb5, 0xb6, 0x6b, 0x04, 0x00,
-0x00, 0x0f, 0x71, 0xd6, 0x98, 0x05, 0x07, 0x07, 0x05, 0xa9, 0x92, 0x05,
-0x07, 0x07, 0x92, 0xf6, 0x6b, 0x00, 0x04, 0x00, 0x00, 0x0b, 0x71, 0xd6,
-0x9b, 0x05, 0x05, 0x07, 0x07, 0xa9, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00,
-0x00, 0x04, 0x03, 0x00, 0x00, 0xf5, 0x05, 0x07, 0x00, 0x03, 0xbf, 0xd6,
-0x6b, 0x00, 0x05, 0x00, 0x00, 0x03, 0x8e, 0xdb, 0xa4, 0x00, 0x04, 0x07,
-0x01, 0x79, 0x01, 0xd6, 0x08, 0x00, 0x00, 0x03, 0x84, 0x79, 0x05, 0x00,
-0x05, 0x07, 0x00, 0x03, 0xb5, 0x85, 0x75, 0x00, 0x05, 0x00, 0x00, 0x03,
-0x9a, 0xc2, 0x92, 0x00, 0x03, 0x07, 0x01, 0x05, 0x01, 0x87, 0x06, 0x00,
-0x01, 0x9a, 0x01, 0x94, 0x04, 0xd6, 0x01, 0xbf, 0x03, 0x07, 0x00, 0x03,
-0xa4, 0xd6, 0xc5, 0x00, 0x04, 0xd6, 0x01, 0xb2, 0x05, 0x00, 0x00, 0x09,
-0x84, 0x92, 0x07, 0x05, 0x07, 0x07, 0xa4, 0xb6, 0x7c, 0x00, 0x05, 0x00,
-0x00, 0x05, 0x26, 0x84, 0x87, 0x79, 0x05, 0x00, 0x03, 0x07, 0x00, 0x04,
-0xc2, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x94,
-0x05, 0x07, 0x00, 0x03, 0x9b, 0xf5, 0x9a, 0x00, 0x06, 0x00, 0x00, 0x03,
-0xb2, 0x85, 0x97, 0x00, 0x03, 0x07, 0x00, 0x07, 0x05, 0x9b, 0x97, 0x07,
-0x05, 0x97, 0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08,
-0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x05, 0x00, 0x00, 0x03,
-0xa3, 0xda, 0x09, 0x00, 0x03, 0xe9, 0x03, 0x09, 0x01, 0xa0, 0x01, 0x4d,
-0x06, 0x00, 0x00, 0x03, 0xa2, 0xb3, 0x09, 0x00, 0x03, 0xe9, 0x00, 0x04,
-0x09, 0xfd, 0x09, 0x09, 0x03, 0xe9, 0x00, 0x04, 0x09, 0xd8, 0x00, 0x26,
-0x05, 0x00, 0x00, 0x04, 0x03, 0x00, 0xa3, 0xa0, 0x06, 0x09, 0x00, 0x04,
-0xe9, 0xc9, 0xc9, 0xe9, 0x06, 0x09, 0x00, 0x05, 0xc9, 0xe8, 0x00, 0x00,
-0x03, 0x00, 0x1e, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x9f, 0x07, 0x05,
-0x04, 0x07, 0x00, 0x08, 0xb5, 0xbd, 0xa9, 0x85, 0x85, 0xc4, 0xa4, 0xb5,
-0x04, 0x07, 0x00, 0x08, 0x05, 0xd7, 0x99, 0x07, 0x07, 0x05, 0x95, 0x6b,
-0x06, 0x00, 0x01, 0x84, 0x03, 0x07, 0x01, 0x98, 0x10, 0x00, 0x01, 0x9a,
-0x01, 0x92, 0x03, 0x07, 0x01, 0x75, 0x05, 0x00, 0x00, 0x05, 0x26, 0x00,
-0x00, 0xb6, 0x95, 0x00, 0x03, 0x07, 0x00, 0x0a, 0x05, 0x07, 0x97, 0xbf,
-0xc2, 0xf5, 0xc2, 0x87, 0x98, 0x79, 0x03, 0x07, 0x00, 0x08, 0x05, 0x9b,
-0xb1, 0xa9, 0x07, 0x07, 0x05, 0xb6, 0x05, 0x00, 0x01, 0x85, 0x05, 0x07,
-0x00, 0x09, 0x05, 0x07, 0x05, 0x97, 0xbf, 0xc2, 0xc2, 0x87, 0x98, 0x00,
-0x05, 0x07, 0x00, 0x03, 0xa9, 0x00, 0xb6, 0x00, 0x05, 0x07, 0x00, 0x0f,
-0x97, 0xbf, 0xc2, 0xc2, 0x87, 0x98, 0x79, 0x07, 0x05, 0x07, 0x07, 0xbd,
-0x8e, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0xf6,
-0x79, 0x00, 0x03, 0x07, 0x00, 0x09, 0x05, 0x79, 0x97, 0xbf, 0xc2, 0xc2,
-0xa9, 0xbd, 0x97, 0x00, 0x05, 0x07, 0x01, 0x95, 0x01, 0xd6, 0x09, 0x00,
-0x00, 0x06, 0x84, 0x79, 0x07, 0x07, 0x98, 0xb5, 0x04, 0x07, 0x00, 0x0e,
-0xb5, 0xa4, 0xa9, 0xc2, 0xc4, 0xa4, 0xb5, 0x07, 0x05, 0x79, 0x07, 0x05,
-0xbd, 0x8e, 0x06, 0x00, 0x00, 0x03, 0xf6, 0x07, 0x79, 0x00, 0x03, 0x95,
-0x01, 0x79, 0x04, 0x07, 0x04, 0x95, 0x00, 0x03, 0x79, 0x79, 0xf5, 0x00,
-0x03, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x96, 0x97, 0x00, 0x03, 0x07,
-0x00, 0x13, 0x05, 0x05, 0xb5, 0xbd, 0xa9, 0x85, 0xc2, 0x87, 0x98, 0x95,
-0x07, 0x07, 0x05, 0x05, 0x07, 0x85, 0x00, 0x00, 0x26, 0x00, 0x07, 0x00,
-0x00, 0x05, 0x26, 0x00, 0x00, 0xd6, 0x92, 0x00, 0x05, 0x07, 0x00, 0x08,
-0xb5, 0xa4, 0xc4, 0xc2, 0xc2, 0xc4, 0xa4, 0x92, 0x03, 0x05, 0x00, 0x09,
-0x07, 0x07, 0xa9, 0x96, 0x98, 0x07, 0x07, 0x97, 0x75, 0x00, 0x25, 0x00,
-0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0xfd, 0xb3, 0xa2,
-0x00, 0x03, 0x05, 0x00, 0x01, 0xa3, 0x01, 0xe2, 0x05, 0x09, 0x00, 0x04,
-0xe9, 0x09, 0xa0, 0x4d, 0x06, 0x00, 0x01, 0xa2, 0x01, 0xe2, 0x04, 0x09,
-0x01, 0xfd, 0x07, 0x09, 0x00, 0x03, 0xd8, 0x00, 0x26, 0x00, 0x09, 0x00,
-0x01, 0xb0, 0x01, 0xe2, 0x0c, 0x09, 0x00, 0x06, 0xc9, 0xa0, 0xd2, 0x00,
-0x00, 0x03, 0x20, 0x00, 0x00, 0x0b, 0x03, 0x00, 0x00, 0xc5, 0x98, 0x07,
-0x07, 0x05, 0x05, 0x07, 0x07, 0x00, 0x03, 0x05, 0x06, 0x07, 0x00, 0x09,
-0x95, 0xd7, 0x00, 0xb2, 0x07, 0x07, 0x05, 0x92, 0x6b, 0x00, 0x06, 0x00,
-0x00, 0x05, 0x84, 0x07, 0x07, 0x05, 0x9b, 0x00, 0x10, 0x00, 0x00, 0x06,
-0x9a, 0x92, 0x05, 0x05, 0x79, 0x75, 0x06, 0x00, 0x00, 0x05, 0x03, 0x00,
-0x00, 0x96, 0xa4, 0x00, 0x03, 0x07, 0x01, 0x05, 0x03, 0x07, 0x00, 0x05,
-0x05, 0x07, 0x07, 0x05, 0x05, 0x00, 0x03, 0x07, 0x00, 0x08, 0xbf, 0x8e,
-0x00, 0xc4, 0x05, 0x07, 0x07, 0xb6, 0x05, 0x00, 0x01, 0x9f, 0x03, 0x07,
-0x01, 0xc4, 0x01, 0xbd, 0x03, 0x07, 0x01, 0x05, 0x01, 0x05, 0x05, 0x07,
-0x00, 0x0b, 0x05, 0x05, 0x07, 0xa9, 0x71, 0x00, 0x00, 0xf6, 0x79, 0x07,
-0x05, 0x00, 0x03, 0x07, 0x00, 0x04, 0x05, 0x07, 0x07, 0x05, 0x04, 0x07,
-0x01, 0xbf, 0x01, 0x8e, 0x0a, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x96,
-0x9b, 0x05, 0x08, 0x07, 0x01, 0x05, 0x04, 0x07, 0x00, 0x06, 0x05, 0xa4,
-0x99, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x09, 0x84, 0x79, 0x07, 0x07,
-0xbf, 0x96, 0xa4, 0x07, 0x05, 0x00, 0x03, 0x07, 0x00, 0x04, 0x05, 0x07,
-0x07, 0x05, 0x03, 0x07, 0x00, 0x07, 0x05, 0x07, 0xc4, 0x6b, 0x00, 0x00,
-0x03, 0x00, 0x04, 0x00, 0x01, 0xf5, 0x03, 0x07, 0x01, 0x05, 0x05, 0x07,
-0x00, 0x04, 0x05, 0x07, 0x07, 0x05, 0x03, 0x07, 0x01, 0x9f, 0x04, 0x00,
-0x00, 0x05, 0x03, 0x00, 0x00, 0x75, 0x87, 0x00, 0x06, 0x07, 0x00, 0x0e,
-0x05, 0x07, 0x05, 0x05, 0x07, 0x07, 0x05, 0x05, 0x07, 0x97, 0x94, 0x00,
-0x00, 0x03, 0x09, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0xb1, 0xbd, 0x00,
-0x0a, 0x07, 0x01, 0x05, 0x04, 0x07, 0x00, 0x09, 0x79, 0x9f, 0x00, 0x9a,
-0xb5, 0x07, 0x07, 0x97, 0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00,
-0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x05, 0x00,
-0x01, 0xa3, 0x01, 0xfe, 0x07, 0x09, 0x01, 0xda, 0x01, 0x4d, 0x06, 0x00,
-0x01, 0xa2, 0x01, 0xf9, 0x0c, 0x09, 0x00, 0x03, 0xd8, 0x00, 0x26, 0x00,
-0x0a, 0x00, 0x00, 0x04, 0x4d, 0xd8, 0xb3, 0xf9, 0x06, 0x09, 0x00, 0x04,
-0xc9, 0xe2, 0xa0, 0xe6, 0x29, 0x00, 0x00, 0x03, 0x7c, 0x85, 0x97, 0x00,
-0x07, 0x07, 0x01, 0x05, 0x03, 0x07, 0x00, 0x07, 0x95, 0xbf, 0x99, 0x00,
-0x00, 0x96, 0x05, 0x00, 0x03, 0x07, 0x01, 0x6b, 0x06, 0x00, 0x00, 0x05,
-0xd6, 0x05, 0x05, 0x07, 0x92, 0x00, 0x10, 0x00, 0x01, 0xb2, 0x01, 0x05,
-0x03, 0x07, 0x01, 0x75, 0x07, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x6b,
-0x9f, 0x98, 0x05, 0x07, 0x00, 0x10, 0x05, 0x07, 0x05, 0x05, 0x07, 0x07,
-0x98, 0xd7, 0x71, 0x00, 0x71, 0xbf, 0x05, 0x07, 0x07, 0xd7, 0x05, 0x00,
-0x00, 0x08, 0xa9, 0x07, 0x07, 0x05, 0xa9, 0x6b, 0xc2, 0x95, 0x04, 0x07,
-0x01, 0x05, 0x03, 0x07, 0x00, 0x0f, 0x05, 0x9b, 0x94, 0x00, 0x00, 0x03,
-0x00, 0x00, 0x96, 0xbd, 0x05, 0x07, 0x07, 0x05, 0x05, 0x00, 0x04, 0x07,
-0x00, 0x04, 0x05, 0x97, 0xd7, 0x71, 0x0c, 0x00, 0x00, 0x06, 0x03, 0x00,
-0x00, 0x6b, 0x85, 0x97, 0x03, 0x07, 0x07, 0x05, 0x00, 0x07, 0x07, 0x9b,
-0xf6, 0x71, 0x00, 0x00, 0x03, 0x00, 0x08, 0x00, 0x01, 0xc5, 0x03, 0x07,
-0x00, 0x05, 0x98, 0x71, 0x6b, 0xc4, 0x79, 0x00, 0x03, 0x07, 0x03, 0x05,
-0x00, 0x06, 0x07, 0x07, 0x05, 0x07, 0x98, 0xb6, 0x03, 0x00, 0x01, 0x03,
-0x05, 0x00, 0x00, 0x03, 0x85, 0x07, 0x05, 0x00, 0x07, 0x07, 0x01, 0x05,
-0x05, 0x07, 0x01, 0x05, 0x01, 0xc2, 0x05, 0x00, 0x01, 0x03, 0x03, 0x00,
-0x01, 0xdb, 0x01, 0xa4, 0x05, 0x07, 0x00, 0x09, 0x05, 0x07, 0x05, 0x07,
-0x05, 0x07, 0x97, 0xa9, 0x75, 0x00, 0x0e, 0x00, 0x00, 0x0b, 0x03, 0x00,
-0x00, 0x71, 0xd7, 0x9b, 0x05, 0x07, 0x07, 0x05, 0x05, 0x00, 0x06, 0x07,
-0x00, 0x0b, 0x95, 0xbf, 0x96, 0x00, 0x00, 0x99, 0xb5, 0x07, 0x05, 0x97,
-0x75, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9,
-0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x05, 0x00, 0x01, 0x71, 0x01, 0xe8,
-0x07, 0xe3, 0x01, 0xb0, 0x01, 0x26, 0x06, 0x00, 0x01, 0xa3, 0x01, 0xe8,
-0x03, 0xe3, 0x01, 0xda, 0x03, 0x09, 0x01, 0xfe, 0x03, 0xe3, 0x00, 0x04,
-0xa0, 0xe6, 0x00, 0x11, 0x0d, 0x00, 0x00, 0x03, 0xe6, 0xe8, 0xd8, 0x00,
-0x03, 0xe3, 0x00, 0x03, 0xe8, 0xa1, 0xa2, 0x00, 0x2d, 0x00, 0x00, 0x05,
-0x9a, 0xf6, 0x87, 0x9b, 0x92, 0x00, 0x04, 0x07, 0x00, 0x04, 0xb5, 0xa4,
-0xc2, 0x96, 0x04, 0x00, 0x00, 0x06, 0x75, 0x85, 0x9f, 0x85, 0xd7, 0x71,
-0x06, 0x00, 0x00, 0x05, 0x9a, 0x9f, 0x9f, 0xc2, 0xb6, 0x00, 0x10, 0x00,
-0x00, 0x06, 0x8e, 0xd7, 0x85, 0x85, 0x9f, 0x6b, 0x0c, 0x00, 0x00, 0x0d,
-0xad, 0xb6, 0xc4, 0x9b, 0x95, 0x07, 0x07, 0x05, 0x95, 0x98, 0x87, 0xb6,
-0x7c, 0x00, 0x03, 0x00, 0x00, 0x06, 0x71, 0xc5, 0x85, 0x85, 0x9f, 0x99,
-0x05, 0x00, 0x01, 0x96, 0x03, 0x85, 0x00, 0x0e, 0x84, 0x00, 0x00, 0x96,
-0xa9, 0xa4, 0x92, 0x07, 0x05, 0x95, 0x98, 0x87, 0xdb, 0x7c, 0x07, 0x00,
-0x00, 0x0c, 0x71, 0xd6, 0xc4, 0x9b, 0x92, 0x05, 0x07, 0x95, 0x98, 0x87,
-0xf6, 0x75, 0x13, 0x00, 0x00, 0x0d, 0x75, 0xb6, 0xc4, 0x9b, 0x92, 0x05,
-0x07, 0x07, 0x92, 0x9b, 0xc4, 0xdb, 0x8e, 0x00, 0x0d, 0x00, 0x00, 0x14,
-0x9a, 0x9f, 0x85, 0x85, 0x94, 0x6b, 0x00, 0x00, 0x96, 0xc2, 0xa4, 0xb5,
-0x07, 0x07, 0x05, 0x92, 0x98, 0xbf, 0xb6, 0x7c, 0x0a, 0x00, 0x00, 0x0d,
-0x99, 0x85, 0x9f, 0x9f, 0xf5, 0xf5, 0xa4, 0x05, 0x07, 0x05, 0x98, 0xf5,
-0xf5, 0x00, 0x03, 0x9f, 0x01, 0x85, 0x01, 0x96, 0x0a, 0x00, 0x00, 0x05,
-0x6b, 0x94, 0xa9, 0xa4, 0xb5, 0x00, 0x03, 0x07, 0x00, 0x05, 0x95, 0x98,
-0x87, 0xd7, 0xb2, 0x00, 0x15, 0x00, 0x00, 0x0d, 0x8e, 0x94, 0xa9, 0xa4,
-0xb5, 0x79, 0x07, 0x07, 0x79, 0x97, 0xbd, 0xc2, 0x84, 0x00, 0x04, 0x00,
-0x00, 0x06, 0x99, 0xb5, 0x07, 0x05, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00,
-0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03,
-0x04, 0x00, 0x01, 0x03, 0x0b, 0x00, 0x01, 0x03, 0x04, 0x00, 0x01, 0x03,
-0x05, 0x00, 0x01, 0xe6, 0x03, 0x09, 0x01, 0xda, 0x05, 0x00, 0x01, 0x11,
-0x0c, 0x00, 0x01, 0x03, 0x0b, 0x00, 0x01, 0x03, 0x29, 0x00, 0x01, 0x03,
-0x04, 0x00, 0x01, 0x75, 0x01, 0x99, 0x03, 0x84, 0x00, 0x03, 0x96, 0xb1,
-0x8e, 0x00, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x26, 0x00, 0x06, 0x00,
-0x01, 0x26, 0x04, 0x00, 0x01, 0x26, 0x06, 0x00, 0x01, 0x03, 0x0d, 0x00,
-0x01, 0x26, 0x06, 0x00, 0x01, 0x26, 0x09, 0x00, 0x01, 0x03, 0x04, 0x00,
-0x01, 0x75, 0x01, 0x96, 0x03, 0x84, 0x00, 0x03, 0x96, 0x9a, 0x26, 0x00,
-0x0b, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x05, 0x00,
-0x01, 0x03, 0x03, 0x00, 0x00, 0x0a, 0x7c, 0x99, 0x84, 0x84, 0x96, 0x9a,
-0x4d, 0x00, 0x00, 0x03, 0x05, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x07,
-0x75, 0x99, 0x84, 0x84, 0x96, 0x9a, 0x71, 0x00, 0x13, 0x00, 0x01, 0x03,
-0x04, 0x00, 0x01, 0x75, 0x01, 0x99, 0x03, 0x84, 0x01, 0x99, 0x01, 0x75,
-0x03, 0x00, 0x01, 0x03, 0x0b, 0x00, 0x01, 0x03, 0x06, 0x00, 0x01, 0x26,
-0x03, 0x00, 0x01, 0x7c, 0x01, 0x99, 0x03, 0x84, 0x00, 0x06, 0x99, 0x9a,
-0x71, 0x00, 0x00, 0x03, 0x07, 0x00, 0x01, 0x03, 0x01, 0x03, 0x06, 0x00,
-0x01, 0xd7, 0x03, 0x07, 0x01, 0xc4, 0x07, 0x00, 0x01, 0x26, 0x08, 0x00,
-0x01, 0x03, 0x03, 0x00, 0x01, 0x7c, 0x01, 0x99, 0x03, 0x84, 0x00, 0x03,
-0x96, 0xb2, 0x71, 0x00, 0x03, 0x00, 0x01, 0x03, 0x16, 0x00, 0x00, 0x08,
-0x7c, 0xb1, 0x96, 0x84, 0x84, 0x96, 0xb1, 0x8e, 0x03, 0x00, 0x00, 0x09,
-0x03, 0x4d, 0x00, 0x99, 0xb5, 0x07, 0x05, 0x97, 0x75, 0x00, 0x25, 0x00,
-0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2,
-0x00, 0x03, 0x06, 0x00, 0x01, 0x11, 0x07, 0x26, 0x01, 0x11, 0x08, 0x00,
-0x00, 0x05, 0x11, 0x26, 0x11, 0x00, 0xe6, 0x00, 0x03, 0x09, 0x00, 0x06,
-0xb3, 0xa2, 0x00, 0x26, 0x26, 0x03, 0x0e, 0x00, 0x00, 0x03, 0x03, 0x03,
-0x11, 0x00, 0x05, 0x26, 0x01, 0x11, 0x01, 0x03, 0x2d, 0x00, 0x01, 0x26,
-0x01, 0x4d, 0x09, 0x00, 0x00, 0x03, 0x26, 0x4d, 0x03, 0x00, 0x03, 0x00,
-0x00, 0x05, 0x03, 0x71, 0x4d, 0x71, 0x4d, 0x00, 0x07, 0x00, 0x00, 0x05,
-0x03, 0x71, 0x4d, 0x71, 0x4d, 0x00, 0x10, 0x00, 0x00, 0x06, 0x03, 0x4d,
-0x71, 0x71, 0x4d, 0x03, 0x0c, 0x00, 0x01, 0x26, 0x01, 0x4d, 0x09, 0x00,
-0x01, 0x4d, 0x01, 0x26, 0x04, 0x00, 0x01, 0x4d, 0x03, 0x71, 0x01, 0x26,
-0x05, 0x00, 0x01, 0x26, 0x03, 0x71, 0x00, 0x04, 0x4d, 0x00, 0x00, 0x4d,
-0x08, 0x00, 0x01, 0x4d, 0x01, 0x26, 0x07, 0x00, 0x01, 0x03, 0x01, 0x4d,
-0x08, 0x00, 0x01, 0x4d, 0x01, 0x26, 0x13, 0x00, 0x01, 0x26, 0x01, 0x4d,
-0x09, 0x00, 0x01, 0x4d, 0x01, 0x26, 0x0d, 0x00, 0x00, 0x05, 0x03, 0x4d,
-0x71, 0x71, 0x4d, 0x00, 0x03, 0x00, 0x01, 0x4d, 0x01, 0x03, 0x08, 0x00,
-0x01, 0x4d, 0x01, 0x26, 0x0a, 0x00, 0x00, 0x07, 0x26, 0x71, 0x4d, 0x4d,
-0x00, 0x00, 0x85, 0x00, 0x03, 0x07, 0x00, 0x08, 0x87, 0x00, 0x00, 0x4d,
-0x4d, 0x71, 0x71, 0x26, 0x0a, 0x00, 0x01, 0x03, 0x01, 0x4d, 0x09, 0x00,
-0x01, 0x4d, 0x01, 0x26, 0x15, 0x00, 0x01, 0x03, 0x01, 0x4d, 0x09, 0x00,
-0x00, 0x0c, 0x26, 0x4d, 0x03, 0x00, 0x4d, 0x00, 0x99, 0xb5, 0x07, 0x07,
-0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x08, 0xa1, 0xc9,
-0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03, 0x09, 0x00, 0x01, 0x03, 0x04, 0x26,
-0x0d, 0x00, 0x01, 0xa2, 0x03, 0x09, 0x00, 0x04, 0xf9, 0xa2, 0x00, 0x03,
-0xff, 0x00, 0x1d, 0x00, 0x01, 0x85, 0x03, 0x07, 0x01, 0x87, 0x42, 0x00,
-0x00, 0x08, 0x4d, 0x00, 0x99, 0xb5, 0x07, 0x07, 0x97, 0x75, 0x25, 0x00,
-0x00, 0x00, 0x21, 0x00, 0x03, 0x03, 0x00, 0x09, 0x00, 0xa1, 0xc9, 0x09,
-0x09, 0xb3, 0xa2, 0x00, 0x03, 0x00, 0x08, 0x00, 0x01, 0x03, 0x06, 0x00,
-0x01, 0x03, 0x0b, 0x00, 0x01, 0xa3, 0x01, 0xf9, 0x03, 0x09, 0x00, 0x04,
-0xb0, 0x00, 0x00, 0x03, 0xff, 0x00, 0x1c, 0x00, 0x00, 0x05, 0x85, 0x05,
-0x07, 0x05, 0x87, 0x00, 0x42, 0x00, 0x00, 0x08, 0x4d, 0x00, 0x99, 0xb5,
-0x07, 0x05, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x01, 0x03,
-0x05, 0x00, 0x00, 0x08, 0xe6, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x00, 0x03,
-0x09, 0x00, 0x00, 0x06, 0xa2, 0xe8, 0xd8, 0xd8, 0xb0, 0x4d, 0x0d, 0x00,
-0x01, 0xa0, 0x03, 0x09, 0x01, 0xe2, 0x01, 0xa2, 0xff, 0x00, 0x1e, 0x00,
-0x00, 0x05, 0x85, 0x07, 0x07, 0x05, 0x87, 0x00, 0x42, 0x00, 0x00, 0x08,
-0x4d, 0x00, 0x99, 0xb5, 0x07, 0x07, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00,
-0x21, 0x00, 0x00, 0x0c, 0xa1, 0xe8, 0xb0, 0xb0, 0xe3, 0xe9, 0x09, 0x09,
-0xb3, 0xa2, 0x00, 0x03, 0x09, 0x00, 0x01, 0xb0, 0x03, 0x09, 0x01, 0xfe,
-0x01, 0xa2, 0x0d, 0x00, 0x01, 0xb0, 0x04, 0x09, 0x01, 0xe2, 0x01, 0xb0,
-0x03, 0x00, 0x01, 0x03, 0xff, 0x00, 0x19, 0x00, 0x00, 0x05, 0x85, 0x07,
-0x07, 0x05, 0x87, 0x00, 0x42, 0x00, 0x00, 0x08, 0x4d, 0x00, 0x99, 0xb5,
-0x07, 0x05, 0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x21, 0x00, 0x01, 0xda,
-0x01, 0x09, 0x03, 0xe9, 0x03, 0x09, 0x00, 0x04, 0xb3, 0xa2, 0x00, 0x03,
-0x09, 0x00, 0x00, 0x06, 0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x0b, 0x00,
-0x00, 0x04, 0x03, 0x00, 0x00, 0xa0, 0x04, 0x09, 0x00, 0x04, 0xe9, 0xb3,
-0xda, 0xa1, 0xff, 0x00, 0x1a, 0x00, 0x00, 0x05, 0x85, 0x05, 0x07, 0x05,
-0x87, 0x00, 0x42, 0x00, 0x00, 0x08, 0x4d, 0x00, 0x99, 0xb5, 0x05, 0x07,
-0x97, 0x75, 0x25, 0x00, 0x00, 0x00, 0x21, 0x00, 0x01, 0xb3, 0x06, 0x09,
-0x00, 0x05, 0xfd, 0xe2, 0xa2, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x06,
-0xa1, 0xc9, 0xfd, 0x09, 0xb3, 0xa2, 0x0c, 0x00, 0x00, 0x04, 0x03, 0x00,
-0xa3, 0xda, 0x06, 0x09, 0x01, 0xe3, 0xff, 0x00, 0x1a, 0x00, 0x01, 0x85,
-0x03, 0x07, 0x01, 0x87, 0x42, 0x00, 0x00, 0x08, 0x4d, 0x00, 0x99, 0xb5,
-0x07, 0x07, 0x97, 0x9a, 0x25, 0x00, 0x00, 0x00, 0x21, 0x00, 0x01, 0xb3,
-0x07, 0x09, 0x00, 0x04, 0xe2, 0xa2, 0x00, 0x03, 0x09, 0x00, 0x00, 0x06,
-0xa1, 0xc9, 0x09, 0x09, 0xb3, 0xa2, 0x0d, 0x00, 0x00, 0x05, 0x03, 0x00,
-0x00, 0xd8, 0xf9, 0x00, 0x04, 0x09, 0x01, 0xe3, 0xff, 0x00, 0x1a, 0x00,
-0x00, 0x05, 0xc2, 0x07, 0x05, 0x05, 0xbf, 0x00, 0x42, 0x00, 0x00, 0x08,
-0x4d, 0x00, 0x99, 0x92, 0x07, 0x07, 0x92, 0x9a, 0x25, 0x00, 0x00, 0x00,
-0x21, 0x00, 0x01, 0xd8, 0x07, 0xa0, 0x00, 0x04, 0xd8, 0xa3, 0x00, 0x03,
-0x09, 0x00, 0x01, 0xb0, 0x03, 0x09, 0x01, 0xfe, 0x01, 0xa2, 0x11, 0x00,
-0x00, 0x06, 0xd2, 0xe3, 0xda, 0xe2, 0xf9, 0xe8, 0xff, 0x00, 0x1a, 0x00,
-0x00, 0x05, 0x84, 0xc4, 0xa9, 0xa9, 0x94, 0x00, 0x42, 0x00, 0x00, 0x08,
-0x26, 0x00, 0x75, 0x9f, 0xa9, 0xc4, 0x9f, 0x8e, 0x25, 0x00, 0x00, 0x00,
-0x1f, 0x00, 0x01, 0x03, 0x0b, 0x00, 0x01, 0x03, 0x0a, 0x00, 0x00, 0x06,
-0xd2, 0xe3, 0xe3, 0xa0, 0xe8, 0x71, 0x14, 0x00, 0x00, 0x03, 0xa3, 0xe6,
-0xa2, 0x00, 0xff, 0x00, 0x20, 0x00, 0x01, 0x03, 0x41, 0x00, 0x01, 0x03,
-0x06, 0x00, 0x01, 0x03, 0x24, 0x00, 0x00, 0x00, 0x35, 0x00, 0x01, 0x03,
-0x06, 0x00, 0x01, 0x03, 0xff, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x36, 0x00,
-0x01, 0x03, 0x03, 0x26, 0x01, 0x11, 0x15, 0x00, 0x03, 0x03, 0xff, 0x00,
-0x8e, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0x2d, 0x00, 0x01, 0x0d, 0xb3, 0x00,
-0x00, 0x00, 0xc9, 0x00, 0x00, 0x04, 0x03, 0x00, 0x75, 0x69, 0x34, 0x7e,
-0x01, 0xad, 0x03, 0x00, 0x01, 0x0d, 0x28, 0x00, 0x01, 0x8e, 0x15, 0x7e,
-0x00, 0x05, 0xb1, 0x9a, 0x7c, 0xa3, 0x4d, 0x00, 0x97, 0x00, 0x00, 0x00,
-0xc9, 0x00, 0x00, 0x07, 0x03, 0x00, 0xf1, 0xac, 0x45, 0x0a, 0xc3, 0x00,
-0x30, 0x0a, 0x00, 0x07, 0x17, 0xc3, 0xf4, 0x7e, 0x00, 0x00, 0x03, 0x00,
-0x26, 0x00, 0x00, 0x03, 0x99, 0x30, 0x86, 0x00, 0x14, 0x0a, 0x00, 0x0b,
-0xc3, 0xc3, 0x76, 0x76, 0xbb, 0xd4, 0xea, 0x96, 0x9a, 0x8e, 0x71, 0x00,
-0x03, 0x00, 0x01, 0x26, 0x01, 0x26, 0x8c, 0x00, 0x00, 0x00, 0xc9, 0x00,
-0x00, 0x07, 0x03, 0x00, 0x8e, 0xea, 0x82, 0xac, 0xac, 0x00, 0x31, 0x3a,
-0x00, 0x05, 0x45, 0xac, 0x86, 0xcf, 0x11, 0x00, 0x26, 0x00, 0x00, 0x04,
-0x71, 0xbb, 0xae, 0x5b, 0x15, 0x3a, 0x00, 0x0d, 0x1c, 0x1c, 0x35, 0x1c,
-0x1c, 0x3a, 0x3a, 0x17, 0x82, 0xf7, 0x69, 0x9a, 0x6b, 0x00, 0x03, 0x00,
-0x01, 0x03, 0x8a, 0x00, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x05, 0x6b, 0xf1,
-0x3e, 0xac, 0x86, 0x00, 0x30, 0x0a, 0x00, 0x04, 0x17, 0x3a, 0xac, 0xcf,
-0x26, 0x00, 0x00, 0x03, 0x7c, 0xc3, 0xac, 0x00, 0x1a, 0x0a, 0x00, 0x0b,
-0x17, 0x86, 0x86, 0x3a, 0x3a, 0x35, 0xac, 0x76, 0xd4, 0xf1, 0xb2, 0x00,
-0x8c, 0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 0x05, 0x75, 0xf7, 0x17, 0x35,
-0x17, 0x00, 0x03, 0x0a, 0x01, 0x7f, 0x0b, 0x6f, 0x1d, 0x45, 0x00, 0x07,
-0x7f, 0x17, 0x0a, 0x0a, 0x1c, 0x0a, 0xb2, 0x00, 0x25, 0x00, 0x00, 0x05,
-0x71, 0xa6, 0xac, 0x0a, 0x0a, 0x00, 0x16, 0x86, 0x01, 0x17, 0x01, 0x17,
-0x06, 0x0a, 0x00, 0x08, 0x17, 0x86, 0xac, 0xac, 0x30, 0xf7, 0x7e, 0x71,
-0x89, 0x00, 0x00, 0x00, 0xcd, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x0a,
-0x7e, 0x82, 0xac, 0x3a, 0x0a, 0x0a, 0x17, 0x6f, 0x66, 0x70, 0x04, 0x66,
-0x0a, 0x15, 0x01, 0x19, 0x03, 0x15, 0x0d, 0x19, 0x07, 0x0e, 0x00, 0x06,
-0x45, 0x17, 0x0a, 0x17, 0xac, 0xf7, 0x26, 0x00, 0x00, 0x05, 0xcf, 0x35,
-0x86, 0x0a, 0x86, 0x00, 0x06, 0x35, 0x01, 0x45, 0x01, 0x45, 0x06, 0x35,
-0x00, 0x05, 0x45, 0x35, 0x45, 0x35, 0x35, 0x00, 0x05, 0x45, 0x00, 0x04,
-0x3a, 0x86, 0x17, 0x17, 0x03, 0x0a, 0x00, 0x08, 0xc3, 0x0a, 0x3a, 0xac,
-0xc3, 0xb8, 0x69, 0x6b, 0x87, 0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 0x07,
-0x4d, 0x00, 0x00, 0x8e, 0xf7, 0x35, 0x35, 0x00, 0x03, 0x0a, 0x01, 0x7f,
-0x03, 0x15, 0x01, 0x19, 0x01, 0x15, 0x0d, 0x19, 0x11, 0x0e, 0x01, 0x4f,
-0x03, 0x6f, 0x00, 0x07, 0x0e, 0x7f, 0x0a, 0x0a, 0x35, 0x3e, 0xad, 0x00,
-0x25, 0x00, 0x00, 0x09, 0x9a, 0xc3, 0x3a, 0x0a, 0x0a, 0x3a, 0x45, 0x45,
-0x1c, 0x00, 0x18, 0x45, 0x00, 0x0d, 0x3a, 0x86, 0x17, 0x0a, 0x0a, 0xc3,
-0xc3, 0x86, 0x35, 0x86, 0xbb, 0x69, 0x71, 0x00, 0x85, 0x00, 0x00, 0x00,
-0xd4, 0x00, 0x00, 0x03, 0xf1, 0xc3, 0x1c, 0x00, 0x03, 0x0a, 0x00, 0x04,
-0x7f, 0x19, 0x15, 0x15, 0x0d, 0x19, 0x00, 0x04, 0x0e, 0x0e, 0x19, 0x19,
-0x0b, 0x0e, 0x07, 0x6f, 0x00, 0x07, 0x4f, 0x45, 0x17, 0x0a, 0x86, 0x3a,
-0xcf, 0x00, 0x25, 0x00, 0x00, 0x06, 0x03, 0xf7, 0x35, 0x17, 0x0a, 0x86,
-0x04, 0x1c, 0x01, 0x45, 0x08, 0x1c, 0x01, 0x45, 0x01, 0x1c, 0x04, 0x45,
-0x04, 0x1c, 0x00, 0x04, 0x45, 0x45, 0x35, 0x35, 0x03, 0x45, 0x00, 0x03,
-0x3a, 0x86, 0x17, 0x00, 0x03, 0x0a, 0x00, 0x09, 0x3a, 0xac, 0x35, 0xb8,
-0x7e, 0x0d, 0x00, 0x03, 0x03, 0x00, 0x80, 0x00, 0x00, 0x00, 0xd5, 0x00,
-0x00, 0x03, 0x7e, 0x30, 0x35, 0x00, 0x03, 0x0a, 0x00, 0x03, 0x7f, 0x19,
-0x15, 0x00, 0x0b, 0x19, 0x0e, 0x0e, 0x01, 0x4f, 0x07, 0x6f, 0x00, 0x0a,
-0x4f, 0x35, 0x4f, 0x4f, 0x86, 0x0a, 0x0a, 0xac, 0xbb, 0x6b, 0x25, 0x00,
-0x00, 0x06, 0x7e, 0x3a, 0x86, 0x0a, 0x0a, 0x3a, 0x0c, 0x1c, 0x01, 0x5b,
-0x0c, 0x1c, 0x04, 0x45, 0x00, 0x05, 0x35, 0x45, 0x45, 0x86, 0x17, 0x00,
-0x03, 0x0a, 0x00, 0x08, 0x86, 0x35, 0x86, 0xd4, 0x9a, 0x00, 0x00, 0x03,
-0x7f, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x03, 0xb2, 0x82, 0xac, 0x00,
-0x03, 0x0a, 0x00, 0x03, 0x7f, 0x19, 0x15, 0x00, 0x08, 0x19, 0x0e, 0x0e,
-0x01, 0x4f, 0x04, 0x6f, 0x07, 0x4f, 0x00, 0x0a, 0x35, 0x4f, 0x45, 0x0a,
-0x0a, 0x17, 0x17, 0x69, 0x00, 0x11, 0x23, 0x00, 0x00, 0x08, 0x8e, 0xb8,
-0x1c, 0x0a, 0x0a, 0x86, 0x1c, 0x1c, 0x06, 0x5b, 0x01, 0x1c, 0x01, 0x1c,
-0x03, 0x5b, 0x03, 0x1c, 0x01, 0x5b, 0x0a, 0x1c, 0x00, 0x09, 0x45, 0x1c,
-0x45, 0x1c, 0x45, 0x45, 0x1c, 0x86, 0x17, 0x00, 0x03, 0x0a, 0x00, 0x05,
-0x86, 0xac, 0x30, 0xf1, 0x0d, 0x00, 0x80, 0x00, 0x00, 0x00, 0xd7, 0x00,
-0x00, 0x07, 0x75, 0xbb, 0xac, 0x86, 0x0a, 0x0a, 0x7f, 0x00, 0x06, 0x19,
-0x0d, 0x0e, 0x01, 0x4f, 0x06, 0x6f, 0x07, 0x4f, 0x05, 0x35, 0x00, 0x08,
-0x86, 0x0a, 0xc3, 0xac, 0xd4, 0x0d, 0x00, 0x03, 0x21, 0x00, 0x00, 0x07,
-0x11, 0x00, 0xf1, 0xac, 0x0a, 0x0a, 0x17, 0x00, 0x0c, 0x5b, 0x01, 0x1c,
-0x09, 0x5b, 0x00, 0x06, 0x1c, 0x1c, 0x5b, 0x1c, 0x1c, 0x5b, 0x08, 0x1c,
-0x01, 0x86, 0x01, 0x17, 0x03, 0x0a, 0x00, 0x04, 0x1c, 0x45, 0xd4, 0x8e,
-0x7f, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x07, 0x7c, 0xbb, 0xac, 0x17,
-0x0a, 0x0a, 0x45, 0x00, 0x03, 0x19, 0x01, 0x0e, 0x01, 0x19, 0x0a, 0x0e,
-0x01, 0x4f, 0x05, 0x6f, 0x05, 0x4f, 0x01, 0x6f, 0x01, 0x4f, 0x09, 0x35,
-0x00, 0x08, 0x86, 0x0a, 0x0a, 0x86, 0x76, 0xb1, 0x00, 0x4d, 0x21, 0x00,
-0x00, 0x0b, 0x26, 0x00, 0x9a, 0xa6, 0x3a, 0xc3, 0x0a, 0x86, 0x3a, 0x3a,
-0x5b, 0x00, 0x08, 0x3a, 0x01, 0x5b, 0x05, 0x3a, 0x01, 0x5b, 0x01, 0x3a,
-0x08, 0x5b, 0x00, 0x03, 0x1c, 0x1c, 0x5b, 0x00, 0x05, 0x1c, 0x00, 0x03,
-0x45, 0x3a, 0x86, 0x00, 0x03, 0x0a, 0x00, 0x07, 0x86, 0xd3, 0x82, 0xb1,
-0x00, 0x00, 0x0d, 0x00, 0x7b, 0x00, 0x00, 0x00, 0xd9, 0x00, 0x00, 0x03,
-0x7c, 0xbb, 0xac, 0x00, 0x03, 0x0a, 0x01, 0x45, 0x01, 0x19, 0x0b, 0x0e,
-0x01, 0x4f, 0x01, 0x4f, 0x04, 0x6f, 0x04, 0x4f, 0x01, 0x35, 0x01, 0x4f,
-0x09, 0x35, 0x04, 0x45, 0x00, 0x05, 0x17, 0x0a, 0xc3, 0xac, 0xcf, 0x00,
-0x26, 0x00, 0x00, 0x08, 0xcf, 0xac, 0xc3, 0x0a, 0x17, 0x3a, 0x3a, 0x28,
-0x17, 0x3a, 0x08, 0x5b, 0x04, 0x1c, 0x00, 0x0b, 0x3a, 0x17, 0x7f, 0x7f,
-0x45, 0xae, 0x7f, 0xf1, 0x00, 0x00, 0x03, 0x00, 0x7a, 0x00, 0x00, 0x00,
-0xda, 0x00, 0x00, 0x08, 0x9a, 0xa6, 0x35, 0x0a, 0x0a, 0x17, 0x6f, 0x19,
-0x03, 0x0e, 0x01, 0x6f, 0x04, 0x0e, 0x01, 0x4f, 0x01, 0x4f, 0x04, 0x6f,
-0x06, 0x4f, 0x05, 0x35, 0x00, 0x03, 0x45, 0x35, 0x35, 0x00, 0x07, 0x45,
-0x00, 0x06, 0x86, 0x0a, 0x0a, 0x3a, 0xa6, 0xad, 0x23, 0x00, 0x00, 0x08,
-0x11, 0x00, 0xb1, 0x76, 0x86, 0x0a, 0x0a, 0x51, 0x0b, 0x28, 0x03, 0x3a,
-0x01, 0x28, 0x01, 0x28, 0x0e, 0x3a, 0x07, 0x5b, 0x00, 0x0a, 0x1c, 0x1c,
-0x3a, 0x7f, 0x7f, 0x45, 0xd3, 0xd3, 0x8a, 0x4d, 0x7b, 0x00, 0x00, 0x00,
-0xdb, 0x00, 0x00, 0x06, 0xb1, 0x76, 0x1c, 0x0a, 0x0a, 0x86, 0x08, 0x0e,
-0x01, 0x4f, 0x04, 0x6f, 0x06, 0x4f, 0x06, 0x35, 0x03, 0x45, 0x01, 0x35,
-0x03, 0x45, 0x01, 0x1c, 0x03, 0x45, 0x00, 0x06, 0x3a, 0x0a, 0x0a, 0x17,
-0xac, 0x69, 0x26, 0x00, 0x00, 0x05, 0xf4, 0xac, 0x0a, 0x0a, 0x86, 0x00,
-0x17, 0x28, 0x00, 0x03, 0x3a, 0x28, 0x28, 0x00, 0x0a, 0x3a, 0x04, 0x5b,
-0x00, 0x08, 0x1c, 0x45, 0x6f, 0x6f, 0xd3, 0x89, 0xd4, 0x11, 0x7a, 0x00,
-0x00, 0x00, 0xdc, 0x00, 0x00, 0x06, 0x69, 0x17, 0x86, 0x0a, 0x0a, 0x7f,
-0x03, 0x0e, 0x01, 0x4f, 0x05, 0x6f, 0x05, 0x4f, 0x08, 0x35, 0x05, 0x45,
-0x00, 0x03, 0x35, 0x1c, 0x45, 0x00, 0x06, 0x1c, 0x00, 0x06, 0x17, 0x0a,
-0x0a, 0x1c, 0xb8, 0x6b, 0x25, 0x00, 0x00, 0x08, 0x69, 0x17, 0x3a, 0x0a,
-0x17, 0x2f, 0x2f, 0x28, 0x07, 0x2f, 0x00, 0x06, 0x28, 0x28, 0x2f, 0x2f,
-0x28, 0x2f, 0x04, 0x28, 0x01, 0x2f, 0x01, 0x2f, 0x08, 0x28, 0x01, 0x3a,
-0x01, 0x28, 0x09, 0x3a, 0x00, 0x08, 0x45, 0x6f, 0x0e, 0x19, 0x9c, 0xce,
-0xd4, 0x0d, 0x79, 0x00, 0x00, 0x00, 0xda, 0x00, 0x00, 0x0b, 0x03, 0x00,
-0x00, 0xcf, 0x35, 0x86, 0x0a, 0x0a, 0x45, 0x0e, 0x4f, 0x00, 0x04, 0x6f,
-0x06, 0x4f, 0x06, 0x35, 0x07, 0x45, 0x07, 0x1c, 0x00, 0x09, 0x5b, 0x5b,
-0x1c, 0x3a, 0x0a, 0x0a, 0x86, 0x86, 0xb1, 0x00, 0x25, 0x00, 0x00, 0x06,
-0x6b, 0x82, 0xac, 0x0a, 0x0a, 0x51, 0x19, 0x2f, 0x09, 0x28, 0x07, 0x3a,
-0x00, 0x0a, 0x45, 0x0e, 0xd3, 0xd3, 0x9c, 0x89, 0xd4, 0x03, 0x00, 0x03,
-0x76, 0x00, 0x00, 0x00, 0xdb, 0x00, 0x00, 0x11, 0x03, 0x00, 0x71, 0xb8,
-0xac, 0x17, 0x0a, 0x17, 0x6f, 0x0e, 0x6f, 0x6f, 0x4f, 0x4f, 0x6f, 0x4f,
-0x4f, 0x00, 0x05, 0x35, 0x03, 0x45, 0x00, 0x03, 0x35, 0x45, 0x35, 0x00,
-0x04, 0x45, 0x06, 0x1c, 0x00, 0x0b, 0x5b, 0x5b, 0x1c, 0x5b, 0x5b, 0x3a,
-0x17, 0x0a, 0x17, 0x1c, 0xf7, 0x00, 0x26, 0x00, 0x00, 0x05, 0xcf, 0x35,
-0x86, 0x0a, 0x17, 0x00, 0x08, 0x51, 0x01, 0x2f, 0x05, 0x51, 0x0a, 0x2f,
-0x01, 0x28, 0x01, 0x28, 0x06, 0x2f, 0x05, 0x28, 0x01, 0x3a, 0x04, 0x28,
-0x01, 0x1c, 0x01, 0xd3, 0x03, 0x9c, 0x00, 0x05, 0xce, 0xd4, 0x00, 0x00,
-0x11, 0x00, 0x75, 0x00, 0x00, 0x00, 0xde, 0x00, 0x00, 0x07, 0x9a, 0x76,
-0x1c, 0x0a, 0x0a, 0x86, 0x6f, 0x00, 0x04, 0x4f, 0x07, 0x35, 0x08, 0x45,
-0x07, 0x1c, 0x08, 0x5b, 0x00, 0x06, 0x86, 0x0a, 0x0a, 0x1c, 0x76, 0xad,
-0x25, 0x00, 0x00, 0x05, 0x75, 0xc3, 0x1c, 0x0a, 0x0a, 0x00, 0x12, 0x51,
-0x01, 0x2f, 0x03, 0x51, 0x0b, 0x2f, 0x00, 0x03, 0x28, 0x28, 0x2f, 0x00,
-0x07, 0x28, 0x00, 0x0a, 0x1c, 0xd3, 0x9c, 0x9c, 0x89, 0xce, 0x8a, 0x00,
-0x00, 0x03, 0x74, 0x00, 0x00, 0x00, 0xdf, 0x00, 0x00, 0x06, 0xf1, 0x45,
-0x86, 0x0a, 0x0a, 0x45, 0x04, 0x4f, 0x04, 0x35, 0x09, 0x45, 0x04, 0x1c,
-0x06, 0x5b, 0x06, 0x3a, 0x00, 0x07, 0x5b, 0x51, 0x0a, 0x0a, 0x86, 0x45,
-0xea, 0x00, 0x26, 0x00, 0x00, 0x05, 0xd4, 0x1c, 0x17, 0x0a, 0xfc, 0x00,
-0x06, 0x39, 0x05, 0x51, 0x01, 0x39, 0x0f, 0x51, 0x0c, 0x2f, 0x03, 0x28,
-0x00, 0x08, 0x51, 0x1c, 0x9c, 0x89, 0x89, 0xce, 0xce, 0xf1, 0x76, 0x00,
-0x00, 0x00, 0xdf, 0x00, 0x00, 0x06, 0x71, 0xf4, 0xac, 0x0a, 0x0a, 0x17,
-0x08, 0x35, 0x06, 0x45, 0x06, 0x1c, 0x06, 0x5b, 0x03, 0x3a, 0x00, 0x03,
-0x28, 0x28, 0x3a, 0x00, 0x03, 0x28, 0x00, 0x06, 0x86, 0x0a, 0x0a, 0xac,
-0xbb, 0x71, 0x25, 0x00, 0x00, 0x05, 0x7e, 0x45, 0x86, 0x0a, 0x0a, 0x00,
-0x12, 0x39, 0x00, 0x06, 0x51, 0x51, 0x39, 0x39, 0x51, 0x39, 0x09, 0x51,
-0x00, 0x03, 0x2f, 0x2f, 0x51, 0x00, 0x05, 0x2f, 0x00, 0x04, 0x28, 0x2f,
-0x51, 0x35, 0x03, 0x89, 0x00, 0x03, 0xce, 0x66, 0x99, 0x00, 0x75, 0x00,
-0x00, 0x00, 0xe0, 0x00, 0x00, 0x06, 0xb1, 0xc3, 0x3a, 0x0a, 0x0a, 0x3a,
-0x04, 0x35, 0x05, 0x45, 0x06, 0x1c, 0x06, 0x5b, 0x05, 0x3a, 0x06, 0x28,
-0x00, 0x08, 0x2f, 0x28, 0x51, 0x0a, 0x0a, 0x3a, 0xc3, 0x96, 0x25, 0x00,
-0x00, 0x06, 0x8e, 0xbb, 0x1c, 0x0a, 0x0a, 0xfc, 0x0c, 0x1b, 0x03, 0x39,
-0x01, 0x1b, 0x06, 0x39, 0x01, 0x51, 0x03, 0x39, 0x01, 0x51, 0x01, 0x39,
-0x0a, 0x51, 0x04, 0x2f, 0x00, 0x03, 0x51, 0x39, 0xac, 0x00, 0x03, 0x89,
-0x00, 0x03, 0xce, 0xee, 0x6b, 0x00, 0x74, 0x00, 0x00, 0x00, 0xe1, 0x00,
-0x00, 0x05, 0xcf, 0xac, 0x0a, 0x0a, 0x17, 0x00, 0x07, 0x45, 0x01, 0x1c,
-0x01, 0x45, 0x04, 0x1c, 0x06, 0x5b, 0x03, 0x3a, 0x00, 0x03, 0x28, 0x3a,
-0x3a, 0x00, 0x05, 0x28, 0x05, 0x2f, 0x00, 0x05, 0x17, 0x0a, 0x0a, 0xac,
-0xd4, 0x00, 0x26, 0x00, 0x00, 0x05, 0xf1, 0xac, 0x0a, 0x0a, 0xfc, 0x00,
-0x13, 0x1b, 0x01, 0x39, 0x01, 0x39, 0x03, 0x1b, 0x06, 0x39, 0x00, 0x03,
-0x51, 0x39, 0x39, 0x00, 0x09, 0x51, 0x00, 0x04, 0x2f, 0x51, 0x51, 0xcb,
-0x03, 0x9c, 0x01, 0xce, 0x01, 0xf7, 0x74, 0x00, 0x00, 0x00, 0xdf, 0x00,
-0x00, 0x08, 0x4d, 0x00, 0xad, 0xa6, 0x3a, 0xc3, 0x0a, 0x86, 0x04, 0x45,
-0x05, 0x1c, 0x00, 0x03, 0x5b, 0x5b, 0x1c, 0x00, 0x03, 0x5b, 0x05, 0x3a,
-0x00, 0x07, 0x28, 0x3a, 0x3a, 0x28, 0x28, 0x2f, 0x28, 0x00, 0x07, 0x2f,
-0x00, 0x08, 0xfc, 0x0a, 0x0a, 0x3a, 0x76, 0xb1, 0x00, 0x11, 0x23, 0x00,
-0x00, 0x06, 0x75, 0x3e, 0x3a, 0x0a, 0x0a, 0x39, 0x04, 0x1b, 0x00, 0x05,
-0x1a, 0x1b, 0x1b, 0x1a, 0x1a, 0x00, 0x0f, 0x1b, 0x00, 0x04, 0x39, 0x39,
-0x1b, 0x1b, 0x07, 0x39, 0x08, 0x51, 0x00, 0x0a, 0x39, 0x39, 0xcb, 0x9c,
-0xae, 0x9c, 0xae, 0x69, 0x00, 0x03, 0x71, 0x00, 0x00, 0x00, 0xe2, 0x00,
-0x00, 0x07, 0xea, 0x1c, 0x0a, 0x0a, 0x17, 0x1c, 0x45, 0x00, 0x05, 0x1c,
-0x05, 0x5b, 0x05, 0x3a, 0x05, 0x28, 0x03, 0x2f, 0x01, 0x28, 0x04, 0x2f,
-0x05, 0x51, 0x00, 0x07, 0x17, 0x0a, 0xc3, 0xac, 0xcf, 0x00, 0x03, 0x00,
-0x24, 0x00, 0x00, 0x05, 0xf7, 0xac, 0xc3, 0x0a, 0xfc, 0x00, 0x0c, 0x1a,
-0x01, 0x1b, 0x03, 0x1a, 0x04, 0x1b, 0x01, 0x1a, 0x07, 0x1b, 0x00, 0x03,
-0x39, 0x1b, 0x1b, 0x00, 0x08, 0x39, 0x06, 0x51, 0x00, 0x09, 0x28, 0xcb,
-0xae, 0xcb, 0x9c, 0xb9, 0x7c, 0x00, 0x11, 0x00, 0x70, 0x00, 0x00, 0x00,
-0xe0, 0x00, 0x00, 0x08, 0x03, 0x00, 0x7c, 0x82, 0x1c, 0x0a, 0x0a, 0x86,
-0x05, 0x1c, 0x04, 0x5b, 0x05, 0x3a, 0x05, 0x28, 0x08, 0x2f, 0x04, 0x51,
-0x00, 0x09, 0x39, 0x51, 0x39, 0xfc, 0x0a, 0xc3, 0x1c, 0xbb, 0xad, 0x00,
-0x23, 0x00, 0x00, 0x07, 0x4d, 0x00, 0x7e, 0xc3, 0x86, 0x0a, 0x0a, 0x00,
-0x15, 0x1a, 0x04, 0x1b, 0x01, 0x1a, 0x07, 0x1b, 0x01, 0x39, 0x01, 0x1b,
-0x08, 0x39, 0x03, 0x51, 0x00, 0x06, 0x5b, 0xcb, 0xcb, 0xbe, 0xae, 0xf7,
-0x72, 0x00, 0x00, 0x00, 0xe3, 0x00, 0x00, 0x07, 0xcf, 0x45, 0x86, 0x0a,
-0x86, 0x1c, 0x1c, 0x00, 0x05, 0x5b, 0x03, 0x3a, 0x06, 0x28, 0x01, 0x2f,
-0x01, 0x28, 0x03, 0x2f, 0x09, 0x51, 0x04, 0x39, 0x01, 0x51, 0x03, 0x0a,
-0x01, 0x35, 0x01, 0x69, 0x23, 0x00, 0x00, 0x08, 0x03, 0x00, 0x71, 0xf4,
-0xac, 0xc3, 0x0a, 0xfc, 0x1a, 0x1a, 0x00, 0x03, 0x39, 0x1a, 0x1a, 0x00,
-0x0b, 0x1b, 0x04, 0x39, 0x01, 0x51, 0x01, 0x51, 0x03, 0xbe, 0x00, 0x03,
-0xcb, 0x31, 0xb1, 0x00, 0x71, 0x00, 0x00, 0x00, 0xe3, 0x00, 0x00, 0x07,
-0x9a, 0x76, 0x35, 0x0a, 0x0a, 0x3a, 0x1c, 0x00, 0x03, 0x5b, 0x03, 0x3a,
-0x05, 0x28, 0x00, 0x03, 0x2f, 0x28, 0x28, 0x00, 0x03, 0x2f, 0x07, 0x51,
-0x07, 0x39, 0x00, 0x08, 0x1b, 0x1b, 0xfc, 0x0a, 0x0a, 0x35, 0xf4, 0x71,
-0x23, 0x00, 0x00, 0x0c, 0x03, 0x00, 0xf1, 0x86, 0x0a, 0x0a, 0xfc, 0x1a,
-0x31, 0x1a, 0x1a, 0x31, 0x06, 0x1a, 0x01, 0x31, 0x15, 0x1a, 0x09, 0x1b,
-0x04, 0x39, 0x00, 0x07, 0x2f, 0xbe, 0xcd, 0xcd, 0xcb, 0x88, 0x11, 0x00,
-0x70, 0x00, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x06, 0xd4, 0xac, 0x17, 0x0a,
-0x86, 0x5b, 0x06, 0x3a, 0x04, 0x28, 0x06, 0x2f, 0x06, 0x51, 0x06, 0x39,
-0x05, 0x1b, 0x00, 0x06, 0x39, 0x0a, 0x0a, 0x86, 0x7f, 0xb1, 0x25, 0x00,
-0x00, 0x06, 0x7c, 0x82, 0x1c, 0x0a, 0x0a, 0x1a, 0x07, 0x31, 0x01, 0x1a,
-0x01, 0x1a, 0x05, 0x31, 0x00, 0x03, 0x1a, 0x1a, 0x31, 0x00, 0x13, 0x1a,
-0x06, 0x1b, 0x04, 0x39, 0x01, 0x1b, 0x03, 0xcd, 0x01, 0xef, 0x01, 0xb1,
-0x70, 0x00, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x0a, 0x99, 0x17, 0x3a, 0x0a,
-0x17, 0x3a, 0x3a, 0x28, 0x28, 0x3a, 0x03, 0x28, 0x06, 0x2f, 0x06, 0x51,
-0x04, 0x39, 0x01, 0x1b, 0x01, 0x39, 0x05, 0x1b, 0x00, 0x09, 0x1a, 0x1a,
-0x1b, 0x1a, 0x0a, 0x0a, 0x17, 0xac, 0xf7, 0x00, 0x26, 0x00, 0x00, 0x06,
-0xcf, 0x3a, 0x86, 0x0a, 0xfc, 0x2c, 0x10, 0x31, 0x00, 0x06, 0x1a, 0x1a,
-0x31, 0x1a, 0x31, 0x31, 0x11, 0x1a, 0x05, 0x1b, 0x00, 0x08, 0x39, 0x1b,
-0xcd, 0xef, 0xef, 0xcd, 0x74, 0x0d, 0x6f, 0x00, 0x00, 0x00, 0xe4, 0x00,
-0x00, 0x06, 0x71, 0x82, 0x1c, 0x0a, 0x0a, 0x86, 0x08, 0x28, 0x01, 0x2f,
-0x07, 0x51, 0x04, 0x39, 0x08, 0x1b, 0x01, 0x1a, 0x01, 0x1b, 0x04, 0x1a,
-0x00, 0x06, 0xfc, 0x0a, 0x0a, 0x3a, 0x76, 0x7c, 0x25, 0x00, 0x00, 0x06,
-0x9a, 0x76, 0x1c, 0x0a, 0x17, 0x1a, 0x07, 0x2c, 0x10, 0x31, 0x04, 0x1a,
-0x01, 0x31, 0x01, 0x31, 0x0d, 0x1a, 0x03, 0x1b, 0x00, 0x07, 0x39, 0x31,
-0xdc, 0xdc, 0xef, 0xdc, 0xe7, 0x00, 0x6f, 0x00, 0x00, 0x00, 0xe5, 0x00,
-0x00, 0x05, 0xcf, 0x1c, 0x17, 0x0a, 0x86, 0x00, 0x05, 0x28, 0x01, 0x2f,
-0x08, 0x51, 0x05, 0x39, 0x07, 0x1b, 0x09, 0x1a, 0x00, 0x05, 0x0a, 0x0a,
-0x86, 0x1c, 0xf1, 0x00, 0x26, 0x00, 0x00, 0x05, 0xf4, 0xac, 0x86, 0x7f,
-0xfc, 0x00, 0x0c, 0x2c, 0x00, 0x05, 0x31, 0x2c, 0x31, 0x2c, 0x2c, 0x00,
-0x0d, 0x31, 0x00, 0x03, 0x1a, 0x1a, 0x31, 0x00, 0x0c, 0x1a, 0x01, 0x39,
-0x01, 0x1a, 0x04, 0xdc, 0x01, 0x77, 0x6f, 0x00, 0x00, 0x00, 0xe5, 0x00,
-0x00, 0x05, 0xb1, 0x3a, 0x86, 0x0a, 0x17, 0x00, 0x05, 0x2f, 0x06, 0x51,
-0x03, 0x39, 0x01, 0x1b, 0x03, 0x39, 0x05, 0x1b, 0x0a, 0x1a, 0x00, 0x08,
-0x31, 0x1a, 0xfc, 0x0a, 0x17, 0xac, 0xbb, 0x4d, 0x25, 0x00, 0x00, 0x07,
-0x7e, 0x4f, 0x35, 0x7f, 0x3a, 0x2c, 0x25, 0x00, 0x15, 0x2c, 0x08, 0x31,
-0x00, 0x06, 0x1a, 0x31, 0x31, 0x1a, 0x31, 0x31, 0x0a, 0x1a, 0x00, 0x06,
-0x25, 0xe4, 0xe4, 0xdc, 0xc7, 0xe7, 0x6e, 0x00, 0x00, 0x00, 0xe5, 0x00,
-0x00, 0x06, 0x7c, 0xa6, 0x3a, 0x0a, 0x0a, 0x51, 0x03, 0x2f, 0x05, 0x51,
-0x05, 0x39, 0x06, 0x1b, 0x0c, 0x1a, 0x00, 0x09, 0x31, 0x1a, 0x31, 0x1a,
-0x0a, 0x0a, 0x3a, 0xc3, 0x7e, 0x00, 0x25, 0x00, 0x00, 0x0a, 0x6b, 0x63,
-0xd3, 0x45, 0x6f, 0x39, 0x25, 0x2c, 0x2c, 0x25, 0x18, 0x2c, 0x0a, 0x31,
-0x01, 0x1a, 0x01, 0x31, 0x06, 0x1a, 0x01, 0x2c, 0x01, 0xe4, 0x03, 0x4b,
-0x01, 0xeb, 0x6e, 0x00, 0x00, 0x00, 0xe5, 0x00, 0x00, 0x06, 0x4d, 0xf7,
-0x35, 0x0a, 0x0a, 0xfc, 0x06, 0x51, 0x04, 0x39, 0x07, 0x1b, 0x0a, 0x1a,
-0x00, 0x03, 0x31, 0x1a, 0x1a, 0x00, 0x05, 0x31, 0x00, 0x05, 0xfc, 0x0a,
-0x17, 0xac, 0xd4, 0x00, 0x26, 0x00, 0x00, 0x05, 0xea, 0xd3, 0x6f, 0x0e,
-0x35, 0x00, 0x09, 0x25, 0x01, 0x2c, 0x01, 0x25, 0x15, 0x2c, 0x08, 0x31,
-0x06, 0x1a, 0x00, 0x07, 0x1b, 0x2b, 0x33, 0x33, 0x4b, 0xc8, 0x8e, 0x00,
-0x6d, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x01, 0x03, 0x7f, 0x11, 0x01, 0x03,
-0x01, 0x03, 0x2a, 0x00, 0x00, 0x05, 0x69, 0xac, 0x0a, 0x0a, 0x17, 0x00,
-0x04, 0x51, 0x00, 0x05, 0x39, 0x39, 0x1b, 0x39, 0x39, 0x00, 0x04, 0x1b,
-0x0b, 0x1a, 0x0a, 0x31, 0x00, 0x09, 0x2c, 0xfc, 0x7f, 0x7f, 0x35, 0x76,
-0xb2, 0x00, 0x0d, 0x00, 0x23, 0x00, 0x00, 0x06, 0x9a, 0x7f, 0xd3, 0x19,
-0x19, 0x31, 0x0e, 0x25, 0x08, 0x2c, 0x01, 0x25, 0x0a, 0x2c, 0x09, 0x31,
-0x00, 0x06, 0x1a, 0x31, 0x1a, 0x1a, 0x3b, 0x33, 0x03, 0xd5, 0x00, 0x03,
-0x68, 0x00, 0x03, 0x00, 0x6b, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x06,
-0xb1, 0xc3, 0x86, 0x17, 0x17, 0x51, 0x04, 0x39, 0x07, 0x1b, 0x09, 0x1a,
-0x00, 0x03, 0x31, 0x31, 0x1a, 0x00, 0x07, 0x31, 0x04, 0x2c, 0x00, 0x06,
-0x31, 0x3a, 0x45, 0x7f, 0xd3, 0xcf, 0x25, 0x00, 0x00, 0x07, 0x0d, 0xd4,
-0x89, 0x19, 0xd3, 0x1c, 0x43, 0x00, 0x04, 0x25, 0x01, 0x43, 0x10, 0x25,
-0x03, 0x2c, 0x01, 0x25, 0x0a, 0x2c, 0x01, 0x31, 0x01, 0x2c, 0x07, 0x31,
-0x00, 0x0a, 0x1a, 0x1a, 0x4b, 0xab, 0xab, 0xd5, 0xf2, 0x4d, 0x00, 0x0d,
-0x6a, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x04, 0x0d, 0x00, 0x00, 0x75,
-0x7f, 0x69, 0x00, 0x03, 0x7e, 0x9a, 0x0d, 0x00, 0x29, 0x00, 0x00, 0x06,
-0xad, 0xbb, 0x4f, 0x7f, 0x86, 0x51, 0x03, 0x39, 0x05, 0x1b, 0x0a, 0x1a,
-0x08, 0x31, 0x08, 0x2c, 0x00, 0x09, 0x25, 0x28, 0x6f, 0x7f, 0xae, 0x82,
-0x8e, 0x00, 0x11, 0x00, 0x23, 0x00, 0x01, 0x96, 0x01, 0x9c, 0x03, 0xd3,
-0x01, 0x2c, 0x0a, 0x43, 0x00, 0x03, 0x25, 0x25, 0x43, 0x00, 0x0c, 0x25,
-0x01, 0x2c, 0x01, 0x25, 0x0d, 0x2c, 0x05, 0x31, 0x01, 0x1a, 0x01, 0x42,
-0x03, 0xab, 0x00, 0x04, 0xd1, 0xec, 0x00, 0x26, 0x6a, 0x00, 0x00, 0x00,
-0x39, 0x00, 0x01, 0x7e, 0x01, 0xa6, 0x7f, 0x17, 0x00, 0x08, 0xc3, 0xa6,
-0xb8, 0xf1, 0x6b, 0x00, 0x00, 0x03, 0x24, 0x00, 0x00, 0x06, 0x71, 0xd4,
-0xae, 0x7f, 0x45, 0x28, 0x06, 0x1b, 0x08, 0x1a, 0x01, 0x31, 0x03, 0x1a,
-0x06, 0x31, 0x0a, 0x2c, 0x00, 0x09, 0x25, 0x1a, 0x4f, 0x0e, 0x0e, 0xd3,
-0x69, 0x00, 0x4d, 0x00, 0x23, 0x00, 0x00, 0x07, 0x8e, 0x82, 0x89, 0xd3,
-0x9c, 0xbe, 0x24, 0x00, 0x0d, 0x43, 0x00, 0x04, 0x25, 0x43, 0x25, 0x43,
-0x0c, 0x25, 0x0e, 0x2c, 0x00, 0x08, 0x31, 0x1a, 0x2c, 0xd5, 0xab, 0xab,
-0xd5, 0xeb, 0x6c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x8e, 0xbb,
-0xac, 0x17, 0x0a, 0x17, 0x0a, 0x00, 0x7b, 0x17, 0x00, 0x09, 0x86, 0x3a,
-0xac, 0x45, 0xb8, 0xb1, 0x00, 0x00, 0x03, 0x00, 0x22, 0x00, 0x00, 0x07,
-0x03, 0x00, 0xcf, 0x9c, 0x45, 0x6f, 0x1c, 0x00, 0x04, 0x1b, 0x09, 0x1a,
-0x08, 0x31, 0x0c, 0x2c, 0x03, 0x25, 0x00, 0x06, 0x35, 0xd3, 0x19, 0x89,
-0xf4, 0x71, 0x23, 0x00, 0x00, 0x07, 0x26, 0x00, 0xdb, 0xce, 0x9c, 0x89,
-0xae, 0x00, 0x16, 0x43, 0x0c, 0x25, 0x00, 0x03, 0x2c, 0x2c, 0x25, 0x00,
-0x08, 0x2c, 0x00, 0x08, 0x31, 0x1a, 0x61, 0xd1, 0xd1, 0xab, 0xdd, 0xad,
-0x6b, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x03, 0x75, 0xc3, 0x3a, 0x00,
-0x82, 0x0a, 0x00, 0x06, 0x3a, 0xac, 0xc3, 0x96, 0x00, 0x03, 0x22, 0x00,
-0x00, 0x0a, 0x4d, 0x00, 0xf1, 0x9c, 0x0e, 0x19, 0x35, 0x1a, 0x1b, 0x1b,
-0x08, 0x1a, 0x07, 0x31, 0x0a, 0x2c, 0x07, 0x25, 0x01, 0x43, 0x01, 0x2f,
-0x04, 0x9c, 0x01, 0x7e, 0x23, 0x00, 0x00, 0x09, 0x11, 0x00, 0x75, 0x8c,
-0xce, 0x89, 0x89, 0xbe, 0x24, 0x00, 0x04, 0x43, 0x00, 0x06, 0x3b, 0x43,
-0x43, 0x3b, 0x43, 0x3b, 0x0f, 0x43, 0x0b, 0x25, 0x01, 0x2c, 0x01, 0x25,
-0x06, 0x2c, 0x01, 0x1a, 0x01, 0x43, 0x03, 0xd1, 0x01, 0xab, 0x01, 0x68,
-0x6b, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x06, 0x7c, 0x82, 0x3a, 0x0a,
-0x0a, 0x17, 0x45, 0x7f, 0x09, 0x17, 0x01, 0x7f, 0x2d, 0x17, 0x05, 0x0a,
-0x00, 0x03, 0xac, 0x30, 0x9a, 0x00, 0x23, 0x00, 0x00, 0x08, 0x4d, 0x00,
-0x96, 0x19, 0xd3, 0xd3, 0x0e, 0x1b, 0x06, 0x1a, 0x00, 0x03, 0x31, 0x31,
-0x1a, 0x00, 0x05, 0x31, 0x0a, 0x2c, 0x0a, 0x25, 0x00, 0x08, 0x43, 0x25,
-0xae, 0x9c, 0x9c, 0xce, 0xd4, 0x0d, 0x25, 0x00, 0x00, 0x0f, 0xd4, 0xce,
-0x89, 0x89, 0xae, 0x24, 0x3b, 0x3b, 0x43, 0x43, 0x3b, 0x3b, 0x43, 0x3b,
-0x3b, 0x00, 0x04, 0x43, 0x01, 0x3b, 0x0e, 0x43, 0x0a, 0x25, 0x07, 0x2c,
-0x00, 0x07, 0x31, 0xc7, 0xc8, 0xc8, 0xd1, 0xde, 0x6b, 0x00, 0x6a, 0x00,
-0x00, 0x00, 0x39, 0x00, 0x00, 0x07, 0xea, 0xac, 0x0a, 0x0a, 0x7f, 0x3c,
-0x2d, 0x00, 0x22, 0x3c, 0x08, 0x5d, 0x09, 0x66, 0x08, 0x15, 0x00, 0x03,
-0x19, 0x15, 0x15, 0x00, 0x05, 0x19, 0x01, 0x0e, 0x01, 0x19, 0x07, 0x0e,
-0x08, 0x6f, 0x00, 0x07, 0x4f, 0x6f, 0x45, 0x6f, 0x45, 0x45, 0x35, 0x00,
-0x09, 0x45, 0x01, 0x1c, 0x08, 0x3a, 0x00, 0x06, 0x28, 0x51, 0x28, 0x51,
-0x51, 0x2f, 0x06, 0x51, 0x00, 0x04, 0x39, 0x51, 0xfc, 0x17, 0x03, 0x0a,
-0x01, 0xac, 0x01, 0xcf, 0x23, 0x00, 0x00, 0x08, 0x26, 0x00, 0xb1, 0x7f,
-0x9c, 0x9c, 0xd3, 0x1b, 0x04, 0x1a, 0x08, 0x31, 0x06, 0x2c, 0x01, 0x25,
-0x03, 0x2c, 0x09, 0x25, 0x04, 0x43, 0x00, 0x07, 0x3b, 0xcb, 0x89, 0x89,
-0xce, 0x15, 0x75, 0x00, 0x25, 0x00, 0x00, 0x07, 0x99, 0x70, 0xce, 0x89,
-0x9c, 0x31, 0x2b, 0x00, 0x0c, 0x3b, 0x04, 0x43, 0x01, 0x3b, 0x0e, 0x43,
-0x08, 0x25, 0x01, 0x2c, 0x01, 0x25, 0x03, 0x2c, 0x01, 0x31, 0x01, 0x3f,
-0x04, 0xc8, 0x01, 0xec, 0x6a, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x06,
-0xb2, 0xc3, 0x86, 0xc3, 0x17, 0x5d, 0x20, 0x9e, 0x04, 0x0b, 0x00, 0x03,
-0xba, 0x0b, 0xba, 0x00, 0x07, 0x2d, 0x04, 0x3c, 0x04, 0x5d, 0x04, 0x70,
-0x05, 0x66, 0x09, 0x15, 0x05, 0x19, 0x00, 0x04, 0x0e, 0x0e, 0x19, 0x19,
-0x05, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x04, 0x35, 0x04, 0x45, 0x03, 0x1c,
-0x00, 0x03, 0x5b, 0x1c, 0x5b, 0x00, 0x04, 0x3a, 0x03, 0x28, 0x04, 0x2f,
-0x03, 0x51, 0x05, 0x39, 0x00, 0x07, 0x1b, 0xfc, 0x0a, 0x0a, 0x3a, 0x3e,
-0xad, 0x00, 0x22, 0x00, 0x00, 0x08, 0x11, 0x00, 0xb2, 0x17, 0x89, 0x9c,
-0x9c, 0x2f, 0x03, 0x1a, 0x06, 0x31, 0x09, 0x2c, 0x0b, 0x25, 0x06, 0x43,
-0x01, 0x24, 0x01, 0x31, 0x03, 0x89, 0x01, 0xce, 0x01, 0xdb, 0x26, 0x00,
-0x00, 0x06, 0x82, 0xce, 0x89, 0x89, 0xbe, 0x24, 0x11, 0x3b, 0x01, 0x43,
-0x01, 0x3b, 0x10, 0x43, 0x09, 0x25, 0x00, 0x07, 0x31, 0x43, 0xe1, 0xdd,
-0xc8, 0xc8, 0x9d, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x07,
-0x4d, 0xd4, 0xac, 0xc3, 0x0a, 0xe5, 0x9e, 0x00, 0x0a, 0x0b, 0x01, 0xba,
-0x15, 0x0b, 0x07, 0x2d, 0x05, 0x3c, 0x06, 0x5d, 0x04, 0x70, 0x04, 0x66,
-0x0a, 0x15, 0x06, 0x19, 0x09, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x05, 0x35,
-0x03, 0x45, 0x05, 0x1c, 0x01, 0x5b, 0x01, 0x5b, 0x03, 0x3a, 0x03, 0x28,
-0x04, 0x2f, 0x04, 0x51, 0x04, 0x39, 0x03, 0x1b, 0x00, 0x06, 0x1a, 0x0a,
-0x0a, 0x86, 0x3a, 0xb2, 0x22, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x75, 0xee,
-0xce, 0x89, 0x9c, 0x2f, 0x31, 0x1a, 0x05, 0x31, 0x08, 0x2c, 0x01, 0x25,
-0x01, 0x2c, 0x08, 0x25, 0x0a, 0x43, 0x00, 0x08, 0x3b, 0x25, 0xae, 0x89,
-0x89, 0xce, 0xee, 0x4d, 0x25, 0x00, 0x00, 0x06, 0xf1, 0x89, 0x89, 0x9c,
-0xae, 0x25, 0x07, 0x24, 0x00, 0x04, 0x3b, 0x3b, 0x24, 0x24, 0x0b, 0x3b,
-0x04, 0x43, 0x01, 0x3b, 0x09, 0x43, 0x01, 0x25, 0x01, 0x43, 0x07, 0x25,
-0x00, 0x07, 0x31, 0xdf, 0xdd, 0xdd, 0xc8, 0xbc, 0xd2, 0x00, 0x69, 0x00,
-0x00, 0x00, 0x38, 0x00, 0x00, 0x0b, 0x4d, 0x00, 0x7e, 0x17, 0x17, 0x0a,
-0x7f, 0x3c, 0x9e, 0x0b, 0xba, 0x00, 0x0a, 0x0b, 0x03, 0xba, 0x00, 0x05,
-0x0b, 0xba, 0x0b, 0x0b, 0xba, 0x00, 0x0b, 0x0b, 0x07, 0x2d, 0x06, 0x3c,
-0x05, 0x5d, 0x03, 0x70, 0x04, 0x66, 0x01, 0x15, 0x01, 0x66, 0x08, 0x15,
-0x07, 0x19, 0x04, 0x0e, 0x01, 0x6f, 0x03, 0x0e, 0x03, 0x6f, 0x04, 0x4f,
-0x03, 0x35, 0x04, 0x45, 0x05, 0x1c, 0x00, 0x06, 0x5b, 0x5b, 0x3a, 0x3a,
-0x28, 0x3a, 0x05, 0x28, 0x01, 0x2f, 0x04, 0x51, 0x00, 0x04, 0x39, 0x39,
-0x1b, 0x39, 0x03, 0x1b, 0x00, 0x07, 0x1a, 0x1a, 0xfc, 0x0a, 0x86, 0x1c,
-0x7e, 0x00, 0x22, 0x00, 0x00, 0x09, 0x03, 0x00, 0x7c, 0xee, 0xce, 0x89,
-0x89, 0x5b, 0x2c, 0x00, 0x05, 0x31, 0x06, 0x2c, 0x00, 0x03, 0x25, 0x2c,
-0x2c, 0x00, 0x08, 0x25, 0x0c, 0x43, 0x00, 0x08, 0x3b, 0x24, 0xcd, 0x9c,
-0x9c, 0x89, 0x89, 0x7e, 0x25, 0x00, 0x00, 0x07, 0x6b, 0x7f, 0x89, 0xae,
-0xae, 0x31, 0x34, 0x00, 0x0f, 0x24, 0x08, 0x3b, 0x00, 0x07, 0x43, 0x3b,
-0x3b, 0x43, 0x43, 0x3b, 0x3b, 0x00, 0x09, 0x43, 0x05, 0x25, 0x00, 0x07,
-0x2c, 0x24, 0xe1, 0xdd, 0xdd, 0xc8, 0x90, 0x00, 0x69, 0x00, 0x00, 0x00,
-0x38, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x6b, 0xb8, 0xac, 0x0a, 0x0a, 0x19,
-0x9e, 0x0b, 0xba, 0xba, 0x0a, 0x0b, 0x01, 0xba, 0x03, 0x0b, 0x00, 0x06,
-0xba, 0x0b, 0xba, 0x0b, 0x0b, 0xba, 0x07, 0x0b, 0x05, 0x2d, 0x00, 0x03,
-0x3c, 0x3c, 0x2d, 0x00, 0x05, 0x3c, 0x06, 0x5d, 0x03, 0x70, 0x03, 0x66,
-0x0a, 0x15, 0x07, 0x19, 0x07, 0x0e, 0x01, 0x4f, 0x03, 0x6f, 0x04, 0x4f,
-0x03, 0x35, 0x04, 0x45, 0x04, 0x1c, 0x05, 0x5b, 0x00, 0x04, 0x3a, 0x3a,
-0x28, 0x28, 0x04, 0x2f, 0x03, 0x51, 0x03, 0x39, 0x01, 0x1b, 0x01, 0x39,
-0x03, 0x1b, 0x03, 0x1a, 0x00, 0x05, 0x0a, 0x0a, 0x86, 0x45, 0xb1, 0x00,
-0x22, 0x00, 0x00, 0x09, 0x03, 0x00, 0x7c, 0xee, 0xce, 0x89, 0x9c, 0x2f,
-0x2c, 0x00, 0x03, 0x31, 0x06, 0x2c, 0x00, 0x03, 0x25, 0x2c, 0x2c, 0x00,
-0x07, 0x25, 0x08, 0x43, 0x03, 0x3b, 0x01, 0x43, 0x04, 0x3b, 0x00, 0x07,
-0x24, 0x3b, 0xcb, 0xae, 0xae, 0x89, 0xb8, 0x00, 0x26, 0x00, 0x00, 0x07,
-0x8a, 0x89, 0xae, 0xae, 0xbe, 0x3b, 0x2b, 0x00, 0x13, 0x24, 0x0a, 0x3b,
-0x00, 0x04, 0x43, 0x43, 0x3b, 0x3b, 0x09, 0x43, 0x03, 0x25, 0x00, 0x06,
-0xe0, 0xbc, 0x10, 0xc8, 0x5e, 0xa3, 0x68, 0x00, 0x00, 0x00, 0x39, 0x00,
-0x00, 0x07, 0x03, 0x00, 0xf1, 0x3a, 0x86, 0x0a, 0x7f, 0x00, 0x09, 0x0b,
-0x01, 0xba, 0x01, 0xba, 0x0b, 0x0b, 0x01, 0xba, 0x08, 0x0b, 0x05, 0x2d,
-0x07, 0x3c, 0x06, 0x5d, 0x03, 0x70, 0x05, 0x66, 0x08, 0x15, 0x07, 0x19,
-0x08, 0x0e, 0x03, 0x6f, 0x00, 0x07, 0x4f, 0x4f, 0x6f, 0x4f, 0x45, 0x35,
-0x35, 0x00, 0x05, 0x45, 0x03, 0x1c, 0x01, 0x5b, 0x01, 0x5b, 0x05, 0x3a,
-0x01, 0x28, 0x01, 0x28, 0x04, 0x2f, 0x04, 0x51, 0x03, 0x39, 0x04, 0x1b,
-0x04, 0x1a, 0x00, 0x05, 0x17, 0x17, 0x45, 0x8c, 0x75, 0x00, 0x22, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0x7c, 0xed, 0x89, 0x9c, 0xae, 0x2f, 0x2c, 0x31,
-0x09, 0x2c, 0x05, 0x25, 0x0a, 0x43, 0x01, 0x3b, 0x01, 0x43, 0x09, 0x3b,
-0x00, 0x07, 0x24, 0xcd, 0xae, 0xcb, 0x9c, 0x51, 0x75, 0x00, 0x25, 0x00,
-0x00, 0x07, 0xb2, 0xcb, 0xae, 0xcb, 0xcb, 0xef, 0x34, 0x00, 0x03, 0x2b,
-0x14, 0x24, 0x0a, 0x3b, 0x01, 0x43, 0x01, 0x3b, 0x09, 0x43, 0x00, 0x07,
-0x31, 0xdf, 0x10, 0xbc, 0x10, 0xbc, 0xd9, 0x00, 0x68, 0x00, 0x00, 0x00,
-0x3b, 0x00, 0x00, 0x07, 0xad, 0xa6, 0xac, 0x0a, 0x0a, 0x66, 0x9e, 0x00,
-0x0d, 0x0b, 0x01, 0xba, 0x06, 0x0b, 0x01, 0xba, 0x06, 0x0b, 0x01, 0x2d,
-0x01, 0x0b, 0x06, 0x2d, 0x05, 0x3c, 0x06, 0x5d, 0x03, 0x70, 0x04, 0x66,
-0x09, 0x15, 0x07, 0x19, 0x08, 0x0e, 0x03, 0x6f, 0x04, 0x4f, 0x03, 0x35,
-0x00, 0x04, 0x45, 0x35, 0x45, 0x45, 0x05, 0x1c, 0x01, 0x5b, 0x04, 0x3a,
-0x03, 0x28, 0x03, 0x2f, 0x04, 0x51, 0x03, 0x39, 0x04, 0x1b, 0x05, 0x1a,
-0x00, 0x06, 0x51, 0x7f, 0x7f, 0xd3, 0xf4, 0x6b, 0x22, 0x00, 0x00, 0x08,
-0x03, 0x00, 0x7c, 0x63, 0x89, 0xae, 0xae, 0x1b, 0x09, 0x2c, 0x05, 0x25,
-0x0a, 0x43, 0x00, 0x03, 0x3b, 0x43, 0x43, 0x00, 0x07, 0x3b, 0x04, 0x24,
-0x00, 0x06, 0x25, 0xbe, 0xcb, 0xcb, 0xae, 0xcf, 0x25, 0x00, 0x00, 0x07,
-0x71, 0xa8, 0xae, 0xcb, 0xbe, 0xcd, 0x34, 0x00, 0x0c, 0x2b, 0x0e, 0x24,
-0x01, 0x3b, 0x01, 0x24, 0x09, 0x3b, 0x07, 0x43, 0x00, 0x07, 0x25, 0x43,
-0xe1, 0xbc, 0xbc, 0xdd, 0xeb, 0x00, 0x68, 0x00, 0x00, 0x00, 0x3c, 0x00,
-0x00, 0x05, 0xf7, 0xac, 0x17, 0x0a, 0xe5, 0x00, 0x07, 0x0b, 0x01, 0xba,
-0x01, 0xba, 0x05, 0x0b, 0x01, 0xba, 0x07, 0x0b, 0x01, 0xba, 0x05, 0x0b,
-0x08, 0x2d, 0x04, 0x3c, 0x05, 0x5d, 0x03, 0x70, 0x01, 0x66, 0x01, 0x70,
-0x04, 0x66, 0x09, 0x15, 0x06, 0x19, 0x09, 0x0e, 0x01, 0x6f, 0x01, 0x6f,
-0x04, 0x4f, 0x04, 0x35, 0x03, 0x45, 0x04, 0x1c, 0x01, 0x5b, 0x01, 0x5b,
-0x04, 0x3a, 0x01, 0x28, 0x01, 0x28, 0x04, 0x2f, 0x04, 0x51, 0x03, 0x39,
-0x04, 0x1b, 0x05, 0x1a, 0x00, 0x06, 0x39, 0x7f, 0x7f, 0x45, 0xd3, 0x69,
-0x23, 0x00, 0x00, 0x08, 0x03, 0x00, 0xe7, 0xf0, 0xae, 0xcb, 0xcb, 0x1a,
-0x04, 0x2c, 0x00, 0x03, 0x25, 0x25, 0x2c, 0x00, 0x05, 0x25, 0x09, 0x43,
-0x00, 0x03, 0x3b, 0x3b, 0x43, 0x00, 0x07, 0x3b, 0x08, 0x24, 0x00, 0x08,
-0xcd, 0xbe, 0xbe, 0xcb, 0x52, 0x6b, 0x00, 0x03, 0x23, 0x00, 0x00, 0x07,
-0x69, 0xae, 0xbe, 0xbe, 0xcd, 0x2b, 0x42, 0x00, 0x10, 0x2b, 0x01, 0x24,
-0x01, 0x2b, 0x0b, 0x24, 0x07, 0x3b, 0x04, 0x43, 0x01, 0x3b, 0x03, 0x43,
-0x00, 0x09, 0x31, 0xe0, 0x4c, 0xbc, 0xbc, 0xde, 0xe7, 0x00, 0x03, 0x00,
-0x65, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x0e, 0xb1, 0x17, 0x45, 0x0a,
-0x7f, 0x5d, 0x9e, 0x0b, 0x0b, 0xba, 0xba, 0x0b, 0x0b, 0xba, 0x05, 0x0b,
-0x01, 0xba, 0x01, 0xba, 0x03, 0x0b, 0x01, 0xba, 0x08, 0x0b, 0x07, 0x2d,
-0x03, 0x3c, 0x06, 0x5d, 0x05, 0x70, 0x03, 0x66, 0x0a, 0x15, 0x07, 0x19,
-0x07, 0x0e, 0x04, 0x6f, 0x03, 0x4f, 0x03, 0x35, 0x05, 0x45, 0x03, 0x1c,
-0x01, 0x5b, 0x01, 0x5b, 0x04, 0x3a, 0x01, 0x28, 0x01, 0x28, 0x04, 0x2f,
-0x04, 0x51, 0x03, 0x39, 0x04, 0x1b, 0x04, 0x1a, 0x00, 0x08, 0x31, 0x39,
-0x45, 0x45, 0x7f, 0x9c, 0xb8, 0x6b, 0x23, 0x00, 0x00, 0x0c, 0x11, 0x00,
-0xb1, 0xfc, 0xcb, 0xcb, 0xbe, 0x31, 0x2c, 0x25, 0x25, 0x2c, 0x05, 0x25,
-0x0b, 0x43, 0x08, 0x3b, 0x0b, 0x24, 0x01, 0x3b, 0x04, 0xcd, 0x00, 0x03,
-0x69, 0x00, 0x11, 0x00, 0x23, 0x00, 0x00, 0x06, 0x8e, 0x52, 0xcb, 0xcd,
-0xcd, 0x3b, 0x04, 0x34, 0x01, 0x2b, 0x01, 0x34, 0x0e, 0x2b, 0x0d, 0x24,
-0x06, 0x3b, 0x06, 0x43, 0x00, 0x07, 0x25, 0x34, 0xf3, 0xf2, 0xf2, 0xbc,
-0x68, 0x00, 0x67, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x0a, 0xb8, 0xac,
-0x7f, 0x17, 0x19, 0x9e, 0x9e, 0x0b, 0x0b, 0xba, 0x0c, 0x0b, 0x01, 0xba,
-0x01, 0xba, 0x07, 0x0b, 0x07, 0x2d, 0x04, 0x3c, 0x06, 0x5d, 0x04, 0x70,
-0x05, 0x66, 0x07, 0x15, 0x08, 0x19, 0x07, 0x0e, 0x00, 0x03, 0x4f, 0x6f,
-0x6f, 0x00, 0x04, 0x4f, 0x03, 0x35, 0x03, 0x45, 0x04, 0x1c, 0x04, 0x5b,
-0x01, 0x3a, 0x01, 0x3a, 0x03, 0x28, 0x04, 0x2f, 0x03, 0x51, 0x03, 0x39,
-0x06, 0x1b, 0x03, 0x1a, 0x00, 0x0a, 0x31, 0x51, 0x45, 0x6f, 0x45, 0xd3,
-0x8c, 0xb2, 0x00, 0x26, 0x22, 0x00, 0x00, 0x07, 0x26, 0x00, 0x7e, 0x1b,
-0xbe, 0xbe, 0xcd, 0x00, 0x04, 0x2c, 0x05, 0x25, 0x09, 0x43, 0x07, 0x3b,
-0x0c, 0x24, 0x04, 0x2b, 0x00, 0x08, 0xef, 0xef, 0x3b, 0xbe, 0x72, 0x4d,
-0x00, 0x03, 0x21, 0x00, 0x00, 0x04, 0x26, 0x00, 0xd0, 0xcb, 0x03, 0xef,
-0x0a, 0x34, 0x00, 0x06, 0x2b, 0x34, 0x2b, 0x34, 0x2b, 0x34, 0x04, 0x2b,
-0x01, 0x24, 0x05, 0x2b, 0x0a, 0x24, 0x04, 0x3b, 0x00, 0x03, 0x43, 0x3b,
-0x3b, 0x00, 0x03, 0x43, 0x00, 0x09, 0x31, 0xc6, 0xf2, 0xf2, 0x4c, 0x56,
-0xd2, 0x00, 0x03, 0x00, 0x64, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x07,
-0x69, 0x4f, 0x45, 0x7f, 0x45, 0x2d, 0x9e, 0x00, 0x16, 0x0b, 0x08, 0x2d,
-0x06, 0x3c, 0x05, 0x5d, 0x01, 0x70, 0x01, 0x70, 0x04, 0x66, 0x01, 0x15,
-0x01, 0x66, 0x07, 0x15, 0x07, 0x19, 0x09, 0x0e, 0x03, 0x6f, 0x03, 0x4f,
-0x04, 0x35, 0x03, 0x45, 0x04, 0x1c, 0x01, 0x5b, 0x01, 0x5b, 0x03, 0x3a,
-0x03, 0x28, 0x04, 0x2f, 0x03, 0x51, 0x03, 0x39, 0x04, 0x1b, 0x05, 0x1a,
-0x00, 0x08, 0x31, 0x2f, 0x6f, 0x0e, 0x6f, 0x9c, 0x6f, 0x69, 0x25, 0x00,
-0x00, 0x04, 0x4d, 0x00, 0x8b, 0xbe, 0x03, 0xcd, 0x01, 0x2c, 0x01, 0x2c,
-0x04, 0x25, 0x09, 0x43, 0x00, 0x03, 0x3b, 0x43, 0x43, 0x00, 0x05, 0x3b,
-0x0a, 0x24, 0x08, 0x2b, 0x03, 0xdc, 0x00, 0x05, 0xef, 0x34, 0xec, 0x00,
-0x4d, 0x00, 0x21, 0x00, 0x00, 0x08, 0x26, 0x00, 0xe7, 0xdf, 0xcd, 0xdc,
-0xdc, 0x2b, 0x0f, 0x34, 0x0b, 0x2b, 0x0b, 0x24, 0x06, 0x3b, 0x00, 0x0b,
-0x43, 0x43, 0x25, 0xdf, 0x41, 0xde, 0xf2, 0x4c, 0xd9, 0x00, 0x03, 0x00,
-0x64, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x07, 0x8e, 0x40, 0x0e, 0x45,
-0x7f, 0x66, 0x9e, 0x00, 0x0e, 0x0b, 0x01, 0xba, 0x05, 0x0b, 0x01, 0x2d,
-0x01, 0x0b, 0x08, 0x2d, 0x03, 0x3c, 0x07, 0x5d, 0x04, 0x70, 0x03, 0x66,
-0x01, 0x15, 0x01, 0x66, 0x07, 0x15, 0x07, 0x19, 0x07, 0x0e, 0x03, 0x6f,
-0x04, 0x4f, 0x03, 0x35, 0x04, 0x45, 0x04, 0x1c, 0x03, 0x5b, 0x03, 0x3a,
-0x03, 0x28, 0x03, 0x2f, 0x03, 0x51, 0x03, 0x39, 0x05, 0x1b, 0x04, 0x1a,
-0x00, 0x08, 0x2c, 0x2f, 0x0e, 0x19, 0x0e, 0x9c, 0x6f, 0x69, 0x26, 0x00,
-0x00, 0x04, 0x26, 0x00, 0xea, 0xbe, 0x03, 0xef, 0x01, 0x25, 0x01, 0x43,
-0x04, 0x25, 0x0a, 0x43, 0x05, 0x3b, 0x0b, 0x24, 0x03, 0x2b, 0x01, 0x24,
-0x05, 0x2b, 0x01, 0x34, 0x03, 0xe4, 0x01, 0xef, 0x01, 0x9d, 0x26, 0x00,
-0x00, 0x05, 0x8f, 0xcd, 0xdc, 0xdc, 0x42, 0x00, 0x05, 0x34, 0x01, 0x42,
-0x01, 0x42, 0x0c, 0x34, 0x0b, 0x2b, 0x0a, 0x24, 0x05, 0x3b, 0x00, 0x08,
-0x43, 0x25, 0x54, 0x50, 0x50, 0xf2, 0xeb, 0xa3, 0x65, 0x00, 0x00, 0x00,
-0x3e, 0x00, 0x00, 0x07, 0xcf, 0x9c, 0x45, 0x45, 0x0e, 0x0b, 0x9e, 0x00,
-0x06, 0x0b, 0x01, 0xba, 0x0d, 0x0b, 0x08, 0x2d, 0x04, 0x3c, 0x07, 0x5d,
-0x01, 0x66, 0x01, 0x70, 0x06, 0x66, 0x06, 0x15, 0x08, 0x19, 0x08, 0x0e,
-0x03, 0x6f, 0x03, 0x4f, 0x00, 0x03, 0x45, 0x35, 0x35, 0x00, 0x04, 0x45,
-0x00, 0x06, 0x1c, 0x1c, 0x5b, 0x1c, 0x1c, 0x5b, 0x03, 0x3a, 0x03, 0x28,
-0x04, 0x2f, 0x03, 0x51, 0x00, 0x04, 0x39, 0x39, 0x1b, 0x39, 0x03, 0x1b,
-0x05, 0x1a, 0x01, 0x31, 0x01, 0x5b, 0x03, 0xd3, 0x00, 0x03, 0x89, 0x6f,
-0x69, 0x00, 0x28, 0x00, 0x00, 0x06, 0x03, 0x6c, 0xcd, 0xdc, 0xdc, 0x3b,
-0x03, 0x25, 0x06, 0x43, 0x01, 0x3b, 0x01, 0x43, 0x07, 0x3b, 0x09, 0x24,
-0x0b, 0x2b, 0x04, 0x34, 0x00, 0x06, 0xe4, 0x4b, 0x4b, 0xe4, 0xc6, 0xad,
-0x23, 0x00, 0x00, 0x13, 0x03, 0x00, 0xd9, 0x34, 0xdc, 0xe4, 0xe4, 0x42,
-0x42, 0x34, 0x34, 0x42, 0x42, 0x34, 0x42, 0x34, 0x34, 0x42, 0x42, 0x00,
-0x0a, 0x34, 0x0b, 0x2b, 0x0a, 0x24, 0x03, 0x3b, 0x00, 0x07, 0xef, 0xe0,
-0x50, 0x5e, 0x55, 0xf2, 0xe7, 0x00, 0x65, 0x00, 0x00, 0x00, 0x3e, 0x00,
-0x00, 0x07, 0xb1, 0x6f, 0x0e, 0x45, 0x6f, 0x3c, 0x9e, 0x00, 0x05, 0x0b,
-0x01, 0xba, 0x0e, 0x0b, 0x07, 0x2d, 0x04, 0x3c, 0x06, 0x5d, 0x01, 0x70,
-0x01, 0x70, 0x05, 0x66, 0x01, 0x15, 0x01, 0x66, 0x07, 0x15, 0x07, 0x19,
-0x08, 0x0e, 0x03, 0x6f, 0x04, 0x4f, 0x03, 0x35, 0x04, 0x45, 0x03, 0x1c,
-0x03, 0x5b, 0x00, 0x06, 0x3a, 0x3a, 0x28, 0x3a, 0x28, 0x28, 0x03, 0x2f,
-0x03, 0x51, 0x03, 0x39, 0x04, 0x1b, 0x04, 0x1a, 0x00, 0x03, 0x31, 0x31,
-0x1c, 0x00, 0x03, 0xd3, 0x00, 0x06, 0x89, 0xe5, 0x7e, 0x00, 0x00, 0x03,
-0x26, 0x00, 0x00, 0x08, 0x8e, 0x1f, 0xdc, 0xe4, 0xe4, 0x3b, 0x25, 0x25,
-0x06, 0x43, 0x00, 0x03, 0x3b, 0x43, 0x43, 0x00, 0x05, 0x3b, 0x0b, 0x24,
-0x04, 0x2b, 0x00, 0x03, 0x34, 0x2b, 0x2b, 0x00, 0x08, 0x34, 0x01, 0x3f,
-0x03, 0x33, 0x01, 0xe4, 0x01, 0x68, 0x25, 0x00, 0x00, 0x06, 0x0d, 0xf8,
-0xef, 0xe4, 0x4b, 0x36, 0x0a, 0x42, 0x03, 0x34, 0x01, 0x42, 0x0c, 0x34,
-0x07, 0x2b, 0x00, 0x03, 0x24, 0x2b, 0x2b, 0x00, 0x08, 0x24, 0x00, 0x08,
-0x3b, 0xef, 0x24, 0xfb, 0x5e, 0xde, 0x4c, 0xfa, 0x65, 0x00, 0x00, 0x00,
-0x3e, 0x00, 0x00, 0x07, 0x71, 0xf4, 0x9c, 0x6f, 0x4f, 0x66, 0x9e, 0x00,
-0x14, 0x0b, 0x06, 0x2d, 0x04, 0x3c, 0x06, 0x5d, 0x05, 0x70, 0x00, 0x05,
-0x66, 0x66, 0x15, 0x66, 0x66, 0x00, 0x07, 0x15, 0x07, 0x19, 0x07, 0x0e,
-0x00, 0x03, 0x4f, 0x6f, 0x6f, 0x00, 0x03, 0x4f, 0x03, 0x35, 0x00, 0x0a,
-0x45, 0x45, 0x35, 0x35, 0x45, 0x1c, 0x1c, 0x5b, 0x1c, 0x5b, 0x03, 0x3a,
-0x03, 0x28, 0x04, 0x2f, 0x03, 0x51, 0x01, 0x39, 0x01, 0x39, 0x04, 0x1b,
-0x06, 0x1a, 0x00, 0x0b, 0x31, 0xac, 0x9c, 0xd3, 0xd3, 0xce, 0x93, 0x99,
-0x00, 0x00, 0x03, 0x00, 0x27, 0x00, 0x00, 0x07, 0xec, 0x61, 0xe4, 0x4b,
-0xe4, 0x3b, 0x25, 0x00, 0x07, 0x43, 0x05, 0x3b, 0x01, 0x24, 0x01, 0x3b,
-0x07, 0x24, 0x04, 0x2b, 0x00, 0x05, 0x34, 0x2b, 0x2b, 0x34, 0x2b, 0x00,
-0x09, 0x34, 0x00, 0x09, 0x42, 0x34, 0x34, 0x33, 0xd5, 0xd5, 0x33, 0xbc,
-0x71, 0x00, 0x25, 0x00, 0x00, 0x06, 0x90, 0xe4, 0xe4, 0x33, 0x4b, 0x3f,
-0x0e, 0x42, 0x01, 0x34, 0x04, 0x42, 0x09, 0x34, 0x01, 0x2b, 0x01, 0x34,
-0x06, 0x2b, 0x08, 0x24, 0x00, 0x08, 0x3b, 0x3b, 0xc6, 0x50, 0xf2, 0x4c,
-0x55, 0xd2, 0x64, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x09, 0x4d, 0x00,
-0x69, 0x9c, 0xd3, 0x0e, 0xd3, 0x2d, 0x9e, 0x00, 0x12, 0x0b, 0x07, 0x2d,
-0x03, 0x3c, 0x07, 0x5d, 0x00, 0x03, 0x70, 0x70, 0x5d, 0x00, 0x06, 0x66,
-0x06, 0x15, 0x08, 0x19, 0x01, 0x0e, 0x01, 0x19, 0x05, 0x0e, 0x00, 0x06,
-0x4f, 0x6f, 0x6f, 0x4f, 0x4f, 0x6f, 0x04, 0x35, 0x00, 0x04, 0x45, 0x45,
-0x35, 0x45, 0x03, 0x1c, 0x01, 0x5b, 0x01, 0x5b, 0x03, 0x3a, 0x01, 0x28,
-0x01, 0x28, 0x04, 0x2f, 0x04, 0x51, 0x03, 0x39, 0x04, 0x1b, 0x04, 0x1a,
-0x00, 0x03, 0x2c, 0x1a, 0xac, 0x00, 0x03, 0x9c, 0x00, 0x06, 0x89, 0xee,
-0xb2, 0x00, 0x00, 0x03, 0x28, 0x00, 0x00, 0x05, 0x68, 0xe4, 0x33, 0x33,
-0x4b, 0x00, 0x06, 0x43, 0x07, 0x3b, 0x06, 0x24, 0x00, 0x06, 0x2b, 0x24,
-0x2b, 0x2b, 0x24, 0x34, 0x04, 0x2b, 0x08, 0x34, 0x01, 0x42, 0x01, 0x34,
-0x04, 0x42, 0x00, 0x07, 0x34, 0x4b, 0xab, 0xab, 0xd5, 0xd5, 0xec, 0x00,
-0x25, 0x00, 0x00, 0x0b, 0x6b, 0xe1, 0xe4, 0x33, 0xd5, 0x4b, 0x42, 0x3f,
-0x3f, 0x42, 0x3f, 0x00, 0x0e, 0x42, 0x03, 0x34, 0x01, 0x42, 0x01, 0x42,
-0x07, 0x34, 0x09, 0x2b, 0x05, 0x24, 0x00, 0x07, 0x25, 0xdf, 0x49, 0xf2,
-0x4c, 0xbc, 0x7d, 0x00, 0x64, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x0a,
-0x26, 0x00, 0x8e, 0x82, 0x89, 0x0e, 0xd3, 0x5d, 0x9e, 0xba, 0x09, 0x0b,
-0x01, 0xba, 0x05, 0x0b, 0x09, 0x2d, 0x03, 0x3c, 0x06, 0x5d, 0x04, 0x70,
-0x05, 0x66, 0x07, 0x15, 0x07, 0x19, 0x08, 0x0e, 0x01, 0x6f, 0x01, 0x6f,
-0x03, 0x4f, 0x03, 0x35, 0x05, 0x45, 0x04, 0x1c, 0x01, 0x5b, 0x03, 0x3a,
-0x03, 0x28, 0x04, 0x2f, 0x04, 0x51, 0x03, 0x39, 0x03, 0x1b, 0x04, 0x1a,
-0x00, 0x09, 0x31, 0x1a, 0xd3, 0x89, 0x9c, 0x89, 0xce, 0xed, 0x75, 0x00,
-0x2b, 0x00, 0x00, 0x06, 0x4d, 0x4e, 0x4b, 0xd5, 0xd5, 0x4b, 0x06, 0x43,
-0x06, 0x3b, 0x05, 0x24, 0x0a, 0x2b, 0x0a, 0x34, 0x01, 0x42, 0x01, 0x34,
-0x05, 0x42, 0x01, 0x3f, 0x04, 0xab, 0x01, 0x48, 0x26, 0x00, 0x01, 0xeb,
-0x01, 0x4b, 0x03, 0xd5, 0x0b, 0x3f, 0x0c, 0x42, 0x0a, 0x34, 0x08, 0x2b,
-0x04, 0x24, 0x00, 0x08, 0x3b, 0x24, 0x38, 0xf2, 0x41, 0x10, 0x64, 0x71,
-0x63, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x07, 0x03, 0x00, 0xcf, 0x89,
-0xd3, 0xd3, 0x70, 0x00, 0x07, 0x0b, 0x01, 0xba, 0x0a, 0x0b, 0x07, 0x2d,
-0x04, 0x3c, 0x06, 0x5d, 0x01, 0x70, 0x01, 0x70, 0x04, 0x66, 0x01, 0x15,
-0x01, 0x66, 0x08, 0x15, 0x06, 0x19, 0x08, 0x0e, 0x03, 0x6f, 0x03, 0x4f,
-0x03, 0x35, 0x04, 0x45, 0x05, 0x1c, 0x00, 0x03, 0x5b, 0x3a, 0x3a, 0x00,
-0x03, 0x28, 0x04, 0x2f, 0x01, 0x51, 0x01, 0x51, 0x03, 0x39, 0x04, 0x1b,
-0x05, 0x1a, 0x00, 0x03, 0x2c, 0x1a, 0xd3, 0x00, 0x03, 0x89, 0x00, 0x03,
-0xce, 0xa5, 0x7c, 0x00, 0x2c, 0x00, 0x00, 0x0a, 0xd2, 0xc8, 0xd5, 0xab,
-0xab, 0x36, 0x43, 0x43, 0x3b, 0x43, 0x06, 0x3b, 0x06, 0x24, 0x08, 0x2b,
-0x06, 0x34, 0x01, 0x42, 0x05, 0x34, 0x09, 0x42, 0x00, 0x06, 0xd5, 0xd1,
-0xd1, 0xab, 0xc8, 0xd2, 0x25, 0x00, 0x00, 0x06, 0xad, 0xd5, 0xd5, 0xab,
-0xab, 0x4b, 0x0c, 0x3f, 0x00, 0x03, 0x42, 0x3f, 0x3f, 0x00, 0x09, 0x42,
-0x0a, 0x34, 0x0a, 0x2b, 0x00, 0x08, 0x24, 0x3b, 0xdf, 0x4c, 0x4c, 0x10,
-0xbc, 0xec, 0x63, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x09, 0x03, 0x00,
-0x9a, 0x93, 0x89, 0x9c, 0x9c, 0xba, 0x9e, 0x00, 0x0d, 0x0b, 0x00, 0x03,
-0x2d, 0x0b, 0x0b, 0x00, 0x06, 0x2d, 0x04, 0x3c, 0x06, 0x5d, 0x04, 0x70,
-0x05, 0x66, 0x07, 0x15, 0x06, 0x19, 0x08, 0x0e, 0x03, 0x6f, 0x00, 0x03,
-0x4f, 0x6f, 0x4f, 0x00, 0x03, 0x35, 0x04, 0x45, 0x04, 0x1c, 0x00, 0x08,
-0x5b, 0x28, 0x3a, 0x3a, 0x28, 0x3a, 0x28, 0x28, 0x03, 0x2f, 0x03, 0x51,
-0x01, 0x39, 0x01, 0x39, 0x05, 0x1b, 0x04, 0x1a, 0x00, 0x03, 0x2c, 0x1b,
-0xae, 0x00, 0x03, 0x89, 0x00, 0x03, 0xce, 0x82, 0x7c, 0x00, 0x2d, 0x00,
-0x01, 0xd9, 0x04, 0xab, 0x00, 0x04, 0x2b, 0x25, 0x3b, 0x43, 0x04, 0x3b,
-0x07, 0x24, 0x07, 0x2b, 0x09, 0x34, 0x0b, 0x42, 0x03, 0x3f, 0x01, 0x42,
-0x01, 0x61, 0x04, 0xd1, 0x01, 0x90, 0x25, 0x00, 0x00, 0x09, 0x0d, 0xf2,
-0xd5, 0xab, 0xab, 0xd5, 0x3f, 0x3f, 0x36, 0x00, 0x0f, 0x3f, 0x08, 0x42,
-0x03, 0x34, 0x01, 0x42, 0x08, 0x34, 0x07, 0x2b, 0x00, 0x07, 0x3b, 0x34,
-0x1d, 0x41, 0xbc, 0xc8, 0xeb, 0x00, 0x63, 0x00, 0x00, 0x00, 0x41, 0x00,
-0x00, 0x05, 0xf4, 0xce, 0x9c, 0x9c, 0x3c, 0x00, 0x10, 0x0b, 0x06, 0x2d,
-0x04, 0x3c, 0x07, 0x5d, 0x03, 0x70, 0x03, 0x66, 0x09, 0x15, 0x06, 0x19,
-0x08, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x00, 0x03, 0x45, 0x35, 0x35, 0x00,
-0x04, 0x45, 0x04, 0x1c, 0x03, 0x5b, 0x01, 0x3a, 0x04, 0x28, 0x03, 0x2f,
-0x03, 0x51, 0x03, 0x39, 0x03, 0x1b, 0x05, 0x1a, 0x00, 0x03, 0x2c, 0x1b,
-0x9c, 0x00, 0x03, 0x89, 0x00, 0x03, 0xce, 0xb8, 0x8e, 0x00, 0x2e, 0x00,
-0x00, 0x07, 0x5f, 0xab, 0xab, 0xd1, 0xab, 0x3b, 0x25, 0x00, 0x04, 0x3b,
-0x08, 0x24, 0x07, 0x2b, 0x06, 0x34, 0x01, 0x42, 0x01, 0x42, 0x03, 0x34,
-0x07, 0x42, 0x08, 0x3f, 0x00, 0x06, 0xc7, 0xc8, 0xc8, 0xab, 0xde, 0x4d,
-0x25, 0x00, 0x01, 0xd9, 0x04, 0xab, 0x01, 0x36, 0x01, 0x3f, 0x05, 0x36,
-0x01, 0x3f, 0x01, 0x36, 0x0c, 0x3f, 0x09, 0x42, 0x00, 0x03, 0x34, 0x42,
-0x42, 0x00, 0x06, 0x34, 0x06, 0x2b, 0x00, 0x0a, 0x34, 0x3b, 0xc7, 0xbc,
-0xbc, 0xc8, 0x41, 0xe7, 0x00, 0x0d, 0x60, 0x00, 0x00, 0x00, 0x41, 0x00,
-0x00, 0x06, 0x7e, 0xd3, 0xce, 0x9c, 0x89, 0xba, 0x0d, 0x0b, 0x08, 0x2d,
-0x03, 0x3c, 0x07, 0x5d, 0x03, 0x70, 0x03, 0x66, 0x01, 0x15, 0x01, 0x66,
-0x08, 0x15, 0x06, 0x19, 0x07, 0x0e, 0x00, 0x03, 0x4f, 0x6f, 0x6f, 0x00,
-0x03, 0x4f, 0x04, 0x35, 0x03, 0x45, 0x04, 0x1c, 0x01, 0x5b, 0x05, 0x3a,
-0x01, 0x28, 0x04, 0x2f, 0x03, 0x51, 0x01, 0x39, 0x05, 0x1b, 0x05, 0x1a,
-0x00, 0x03, 0x2c, 0x2f, 0x9c, 0x00, 0x03, 0x89, 0x00, 0x06, 0xce, 0xf4,
-0x71, 0x00, 0x00, 0x0d, 0x2b, 0x00, 0x00, 0x07, 0xd2, 0xc8, 0xab, 0xd1,
-0xd1, 0x61, 0x25, 0x00, 0x04, 0x3b, 0x07, 0x24, 0x00, 0x03, 0x2b, 0x2b,
-0x34, 0x00, 0x03, 0x2b, 0x09, 0x34, 0x08, 0x42, 0x0b, 0x3f, 0x01, 0x42,
-0x01, 0xc7, 0x04, 0xc8, 0x01, 0xd9, 0x25, 0x00, 0x00, 0x07, 0x6b, 0xbc,
-0xab, 0xd1, 0xd1, 0xd5, 0x3f, 0x00, 0x0a, 0x36, 0x01, 0x3f, 0x01, 0x36,
-0x0b, 0x3f, 0x0a, 0x42, 0x07, 0x34, 0x00, 0x0b, 0x2b, 0x34, 0x2b, 0x2b,
-0x3b, 0x3f, 0xdd, 0xbc, 0xdd, 0xc8, 0xfa, 0x00, 0x62, 0x00, 0x00, 0x00,
-0x42, 0x00, 0x00, 0x05, 0xa5, 0xce, 0x89, 0x89, 0xba, 0x00, 0x0d, 0x0b,
-0x07, 0x2d, 0x03, 0x3c, 0x00, 0x03, 0x5d, 0x5d, 0x3c, 0x00, 0x04, 0x5d,
-0x00, 0x03, 0x70, 0x66, 0x70, 0x00, 0x03, 0x66, 0x09, 0x15, 0x08, 0x19,
-0x06, 0x0e, 0x00, 0x03, 0x4f, 0x6f, 0x6f, 0x00, 0x03, 0x4f, 0x04, 0x35,
-0x04, 0x45, 0x03, 0x1c, 0x01, 0x5b, 0x03, 0x3a, 0x03, 0x28, 0x03, 0x2f,
-0x04, 0x51, 0x01, 0x39, 0x01, 0x39, 0x05, 0x1b, 0x04, 0x1a, 0x00, 0x03,
-0x2c, 0x2f, 0x9c, 0x00, 0x03, 0x89, 0x01, 0xce, 0x01, 0xd4, 0x30, 0x00,
-0x00, 0x08, 0x90, 0xd1, 0xd1, 0xc8, 0xd1, 0x34, 0x25, 0x3b, 0x08, 0x24,
-0x04, 0x2b, 0x08, 0x34, 0x00, 0x03, 0x42, 0x34, 0x34, 0x00, 0x08, 0x42,
-0x0b, 0x3f, 0x00, 0x09, 0x36, 0x3f, 0x3f, 0x36, 0xe1, 0xdd, 0xdd, 0xd1,
-0x9d, 0x00, 0x26, 0x00, 0x01, 0x68, 0x01, 0xab, 0x03, 0xd1, 0x10, 0x36,
-0x0b, 0x3f, 0x09, 0x42, 0x07, 0x34, 0x03, 0x2b, 0x00, 0x09, 0x3b, 0xc7,
-0xdd, 0xdd, 0xc8, 0xf2, 0xd2, 0x00, 0x03, 0x00, 0x5f, 0x00, 0x00, 0x00,
-0x42, 0x00, 0x00, 0x06, 0xf1, 0xce, 0xce, 0x89, 0x89, 0xba, 0x0c, 0x0b,
-0x04, 0x2d, 0x00, 0x03, 0x3c, 0x2d, 0x2d, 0x00, 0x03, 0x3c, 0x06, 0x5d,
-0x01, 0x70, 0x01, 0x70, 0x05, 0x66, 0x09, 0x15, 0x07, 0x19, 0x06, 0x0e,
-0x01, 0x4f, 0x03, 0x6f, 0x01, 0x4f, 0x01, 0x4f, 0x04, 0x35, 0x03, 0x45,
-0x05, 0x1c, 0x01, 0x5b, 0x03, 0x3a, 0x03, 0x28, 0x03, 0x2f, 0x03, 0x51,
-0x03, 0x39, 0x04, 0x1b, 0x04, 0x1a, 0x00, 0x08, 0x2c, 0x2f, 0x9c, 0x89,
-0x9c, 0x89, 0xce, 0xf7, 0x30, 0x00, 0x00, 0x08, 0x71, 0xf2, 0xd1, 0xc8,
-0xdd, 0xc7, 0x3b, 0x3b, 0x07, 0x24, 0x06, 0x2b, 0x07, 0x34, 0x09, 0x42,
-0x0a, 0x3f, 0x03, 0x36, 0x01, 0x3f, 0x03, 0x36, 0x01, 0xe4, 0x01, 0xc7,
-0x03, 0xdd, 0x00, 0x04, 0x4c, 0xe7, 0x00, 0x11, 0x23, 0x00, 0x00, 0x09,
-0xad, 0xdd, 0xd1, 0xc8, 0xc8, 0xc7, 0x3f, 0x61, 0x61, 0x00, 0x0b, 0x36,
-0x01, 0x3f, 0x04, 0x36, 0x09, 0x3f, 0x07, 0x42, 0x01, 0x34, 0x03, 0x42,
-0x05, 0x34, 0x00, 0x0a, 0x2b, 0x3b, 0x61, 0xc8, 0xdd, 0xc8, 0xd1, 0x7d,
-0x00, 0x11, 0x5f, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x06, 0x8e, 0x15,
-0xce, 0x89, 0x89, 0xba, 0x05, 0x0b, 0x01, 0xba, 0x01, 0xba, 0x03, 0x0b,
-0x08, 0x2d, 0x04, 0x3c, 0x06, 0x5d, 0x00, 0x03, 0x66, 0x70, 0x70, 0x00,
-0x03, 0x66, 0x0a, 0x15, 0x06, 0x19, 0x06, 0x0e, 0x01, 0x4f, 0x01, 0x4f,
-0x03, 0x6f, 0x01, 0x4f, 0x04, 0x35, 0x03, 0x45, 0x01, 0x1c, 0x01, 0x1c,
-0x04, 0x5b, 0x00, 0x03, 0x3a, 0x5b, 0x3a, 0x00, 0x03, 0x28, 0x03, 0x2f,
-0x03, 0x51, 0x00, 0x03, 0x39, 0x1b, 0x39, 0x00, 0x03, 0x1b, 0x05, 0x1a,
-0x00, 0x08, 0x2c, 0x2f, 0xae, 0x9c, 0x9c, 0x89, 0x89, 0x8a, 0x31, 0x00,
-0x00, 0x07, 0x7d, 0xdd, 0xc8, 0xdd, 0xdd, 0xdf, 0x25, 0x00, 0x06, 0x24,
-0x06, 0x2b, 0x06, 0x34, 0x00, 0x03, 0x42, 0x34, 0x34, 0x00, 0x06, 0x42,
-0x0a, 0x3f, 0x0b, 0x36, 0x00, 0x08, 0x61, 0xdd, 0xbc, 0xbc, 0xc8, 0x68,
-0x00, 0x0d, 0x24, 0x00, 0x00, 0x06, 0xeb, 0xab, 0xc8, 0xc8, 0xd1, 0x36,
-0x08, 0x61, 0x0c, 0x36, 0x0a, 0x3f, 0x09, 0x42, 0x05, 0x34, 0x00, 0x08,
-0x2b, 0x2b, 0xc6, 0xc8, 0xc8, 0xab, 0x64, 0xa3, 0x60, 0x00, 0x00, 0x00,
-0x43, 0x00, 0x01, 0xd4, 0x01, 0xce, 0x03, 0x89, 0x0a, 0x0b, 0x07, 0x2d,
-0x05, 0x3c, 0x05, 0x5d, 0x04, 0x70, 0x03, 0x66, 0x08, 0x15, 0x08, 0x19,
-0x06, 0x0e, 0x00, 0x03, 0x4f, 0x6f, 0x6f, 0x00, 0x03, 0x4f, 0x03, 0x35,
-0x04, 0x45, 0x01, 0x1c, 0x01, 0x1c, 0x03, 0x5b, 0x03, 0x3a, 0x01, 0x28,
-0x01, 0x28, 0x04, 0x2f, 0x03, 0x51, 0x03, 0x39, 0x01, 0x1b, 0x07, 0x1a,
-0x01, 0x31, 0x01, 0x2f, 0x03, 0xae, 0x00, 0x06, 0x89, 0x9c, 0xea, 0x00,
-0x00, 0x03, 0x2c, 0x00, 0x00, 0x0a, 0x0d, 0x00, 0x4d, 0x4e, 0xc8, 0xdd,
-0xdd, 0xe1, 0x24, 0x3b, 0x04, 0x24, 0x06, 0x2b, 0x05, 0x34, 0x00, 0x03,
-0x42, 0x34, 0x34, 0x00, 0x09, 0x42, 0x07, 0x3f, 0x0b, 0x36, 0x00, 0x0a,
-0x61, 0x61, 0x36, 0x36, 0xe1, 0xbc, 0xbc, 0xdd, 0x4e, 0xd2, 0x23, 0x00,
-0x00, 0x09, 0x11, 0x00, 0xd9, 0xc8, 0xc8, 0xdd, 0xc8, 0x33, 0x36, 0x00,
-0x0b, 0x61, 0x0c, 0x36, 0x09, 0x3f, 0x06, 0x42, 0x00, 0x03, 0x34, 0x42,
-0x42, 0x00, 0x03, 0x34, 0x00, 0x07, 0x24, 0x61, 0xc8, 0xc8, 0xd1, 0xd1,
-0xec, 0x00, 0x60, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x06, 0xb1, 0x89,
-0x89, 0x9c, 0x9c, 0xba, 0x09, 0x0b, 0x06, 0x2d, 0x04, 0x3c, 0x01, 0x5d,
-0x01, 0x3c, 0x04, 0x5d, 0x03, 0x70, 0x05, 0x66, 0x07, 0x15, 0x07, 0x19,
-0x07, 0x0e, 0x01, 0x4f, 0x03, 0x6f, 0x01, 0x4f, 0x04, 0x35, 0x04, 0x45,
-0x04, 0x1c, 0x01, 0x5b, 0x03, 0x3a, 0x03, 0x28, 0x03, 0x2f, 0x03, 0x51,
-0x04, 0x39, 0x01, 0x1b, 0x01, 0x1b, 0x05, 0x1a, 0x01, 0x31, 0x01, 0xbe,
-0x03, 0xae, 0x00, 0x06, 0x9c, 0xd3, 0xf1, 0x00, 0x00, 0x26, 0x2d, 0x00,
-0x00, 0x09, 0x03, 0x00, 0xd9, 0x47, 0xdd, 0x10, 0xbc, 0xc7, 0x43, 0x00,
-0x04, 0x24, 0x00, 0x05, 0x2b, 0x2b, 0x34, 0x2b, 0x2b, 0x00, 0x06, 0x34,
-0x09, 0x42, 0x08, 0x3f, 0x0c, 0x36, 0x04, 0x61, 0x00, 0x08, 0x36, 0x36,
-0xc7, 0xbc, 0x41, 0xbc, 0x10, 0xd9, 0x25, 0x00, 0x00, 0x0a, 0x71, 0x4e,
-0xd1, 0xdd, 0xdd, 0xc7, 0x36, 0x61, 0x4b, 0x4b, 0x05, 0x61, 0x01, 0x36,
-0x03, 0x61, 0x00, 0x03, 0x36, 0x61, 0x61, 0x00, 0x0b, 0x36, 0x08, 0x3f,
-0x08, 0x42, 0x00, 0x04, 0x34, 0x34, 0x2b, 0x34, 0x03, 0xd1, 0x01, 0xab,
-0x01, 0xeb, 0x60, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x03, 0x71, 0xb8,
-0xce, 0x00, 0x03, 0x9c, 0x08, 0x0b, 0x07, 0x2d, 0x03, 0x3c, 0x07, 0x5d,
-0x03, 0x70, 0x03, 0x66, 0x01, 0x15, 0x01, 0x66, 0x06, 0x15, 0x07, 0x19,
-0x07, 0x0e, 0x01, 0x4f, 0x03, 0x6f, 0x01, 0x4f, 0x01, 0x4f, 0x04, 0x35,
-0x03, 0x45, 0x04, 0x1c, 0x01, 0x5b, 0x03, 0x3a, 0x03, 0x28, 0x00, 0x03,
-0x2f, 0x28, 0x2f, 0x00, 0x03, 0x51, 0x03, 0x39, 0x03, 0x1b, 0x05, 0x1a,
-0x00, 0x0b, 0x31, 0xbe, 0xcb, 0xae, 0xcb, 0x9c, 0x3a, 0x69, 0x00, 0x00,
-0x03, 0x00, 0x2d, 0x00, 0x00, 0x0b, 0x11, 0x00, 0x6b, 0x64, 0xdd, 0xbc,
-0xbc, 0x1d, 0x24, 0x3b, 0x24, 0x00, 0x07, 0x2b, 0x06, 0x34, 0x08, 0x42,
-0x07, 0x3f, 0x00, 0x03, 0x36, 0x36, 0x3f, 0x00, 0x08, 0x36, 0x06, 0x61,
-0x00, 0x0b, 0x4b, 0x61, 0x61, 0x36, 0x36, 0x58, 0xf2, 0x49, 0xbc, 0xeb,
-0xa3, 0x00, 0x23, 0x00, 0x00, 0x08, 0x0d, 0x00, 0x7d, 0xdd, 0xdd, 0x10,
-0xdd, 0x33, 0x03, 0x4b, 0x01, 0x61, 0x03, 0x4b, 0x00, 0x05, 0x61, 0x4b,
-0x61, 0x61, 0x4b, 0x00, 0x03, 0x61, 0x01, 0x36, 0x01, 0x61, 0x0b, 0x36,
-0x08, 0x3f, 0x06, 0x42, 0x04, 0x34, 0x00, 0x06, 0x33, 0xd1, 0xab, 0xab,
-0xd1, 0xad, 0x5f, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x08, 0x69, 0x89,
-0x9c, 0xae, 0xae, 0xba, 0x9e, 0xba, 0x04, 0x0b, 0x07, 0x2d, 0x04, 0x3c,
-0x05, 0x5d, 0x00, 0x07, 0x70, 0x5d, 0x70, 0x66, 0x70, 0x66, 0x66, 0x00,
-0x09, 0x15, 0x07, 0x19, 0x07, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x03, 0x35,
-0x03, 0x45, 0x04, 0x1c, 0x03, 0x5b, 0x01, 0x3a, 0x03, 0x28, 0x03, 0x2f,
-0x04, 0x51, 0x01, 0x39, 0x01, 0x39, 0x04, 0x1b, 0x05, 0x1a, 0x01, 0xbe,
-0x03, 0xcb, 0x00, 0x03, 0x9c, 0x51, 0x7e, 0x00, 0x33, 0x00, 0x00, 0x09,
-0x7d, 0xdd, 0xbc, 0x41, 0x4c, 0xe0, 0x43, 0x24, 0x24, 0x00, 0x0d, 0x34,
-0x0b, 0x42, 0x00, 0x03, 0x3f, 0x3f, 0xe4, 0x00, 0x09, 0x36, 0x0c, 0x61,
-0x00, 0x08, 0x4b, 0x36, 0xc7, 0xf2, 0xf2, 0x49, 0x49, 0xe7, 0x25, 0x00,
-0x00, 0x07, 0x6b, 0xde, 0xc8, 0x10, 0xbc, 0xc7, 0x36, 0x00, 0x06, 0x4b,
-0x00, 0x05, 0x61, 0x4b, 0x61, 0x61, 0x4b, 0x00, 0x08, 0x61, 0x09, 0x36,
-0x09, 0x3f, 0x06, 0x42, 0x00, 0x03, 0x34, 0x2b, 0x3f, 0x00, 0x03, 0xab,
-0x01, 0xd5, 0x01, 0xfa, 0x5f, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x07,
-0x7c, 0x63, 0x9c, 0xcb, 0xae, 0x9c, 0x9e, 0x00, 0x04, 0x0b, 0x07, 0x2d,
-0x04, 0x3c, 0x07, 0x5d, 0x01, 0x70, 0x01, 0x70, 0x04, 0x66, 0x0a, 0x15,
-0x06, 0x19, 0x06, 0x0e, 0x00, 0x03, 0x4f, 0x6f, 0x6f, 0x00, 0x03, 0x4f,
-0x03, 0x35, 0x03, 0x45, 0x03, 0x1c, 0x03, 0x5b, 0x01, 0x3a, 0x01, 0x3a,
-0x03, 0x28, 0x03, 0x2f, 0x03, 0x51, 0x03, 0x39, 0x04, 0x1b, 0x05, 0x1a,
-0x00, 0x07, 0xbe, 0xcb, 0xcb, 0xbe, 0xae, 0xf0, 0x7e, 0x00, 0x33, 0x00,
-0x00, 0x08, 0xad, 0x4e, 0xf2, 0x50, 0x64, 0xfb, 0xca, 0xc0, 0x0e, 0xca,
-0x0e, 0xdf, 0x07, 0x61, 0x01, 0x36, 0x01, 0x61, 0x06, 0x36, 0x09, 0x4b,
-0x00, 0x06, 0x33, 0x41, 0x50, 0xf2, 0x41, 0x68, 0x26, 0x00, 0x00, 0x06,
-0xfa, 0xdd, 0x10, 0xbc, 0xe1, 0x33, 0x0c, 0x4b, 0x0a, 0x61, 0x07, 0x36,
-0x00, 0x03, 0x3f, 0x36, 0x36, 0x00, 0x06, 0x3f, 0x06, 0x42, 0x00, 0x08,
-0x34, 0x34, 0xd5, 0xab, 0xab, 0xd5, 0xdd, 0x71, 0x5e, 0x00, 0x00, 0x00,
-0x43, 0x00, 0x00, 0x07, 0x11, 0x00, 0xcf, 0x89, 0xcb, 0xcb, 0xae, 0x00,
-0x05, 0x0b, 0x08, 0x2d, 0x03, 0x3c, 0x06, 0x5d, 0x03, 0x70, 0x04, 0x66,
-0x08, 0x15, 0x06, 0x19, 0x07, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x04, 0x35,
-0x03, 0x45, 0x04, 0x1c, 0x01, 0x5b, 0x04, 0x3a, 0x01, 0x28, 0x04, 0x2f,
-0x03, 0x51, 0x03, 0x39, 0x01, 0x1b, 0x01, 0x1b, 0x05, 0x1a, 0x01, 0x31,
-0x01, 0xcd, 0x03, 0xbe, 0x00, 0x06, 0xae, 0xf0, 0xb2, 0x00, 0x00, 0x03,
-0x30, 0x00, 0x00, 0x0c, 0x0d, 0x90, 0x50, 0x56, 0x5f, 0x56, 0xaa, 0x52,
-0x29, 0x29, 0x27, 0x27, 0x08, 0x7b, 0x09, 0x12, 0x01, 0x14, 0x05, 0x12,
-0x03, 0x02, 0x06, 0x5a, 0x06, 0xe0, 0x01, 0xc7, 0x01, 0xc7, 0x04, 0x61,
-0x06, 0x4b, 0x00, 0x06, 0xe1, 0x46, 0x50, 0xf2, 0x4e, 0x6b, 0x25, 0x00,
-0x00, 0x07, 0xad, 0xbc, 0xdd, 0xbc, 0xbc, 0xc7, 0x4b, 0x00, 0x04, 0x33,
-0x0b, 0x4b, 0x03, 0x61, 0x01, 0x4b, 0x03, 0x61, 0x01, 0x36, 0x01, 0x61,
-0x07, 0x36, 0x00, 0x03, 0x3f, 0x3f, 0x36, 0x00, 0x06, 0x3f, 0x04, 0x42,
-0x00, 0x07, 0x2b, 0x4b, 0xab, 0xab, 0xd5, 0xd5, 0xd9, 0x00, 0x5e, 0x00,
-0x00, 0x00, 0x43, 0x00, 0x00, 0x0b, 0x26, 0x00, 0xb2, 0xfc, 0xae, 0xbe,
-0xcb, 0x5d, 0x9e, 0x0b, 0x0b, 0x00, 0x08, 0x2d, 0x04, 0x3c, 0x05, 0x5d,
-0x04, 0x70, 0x04, 0x66, 0x07, 0x15, 0x07, 0x19, 0x07, 0x0e, 0x01, 0x6f,
-0x01, 0x6f, 0x04, 0x4f, 0x01, 0x35, 0x01, 0x35, 0x04, 0x45, 0x03, 0x1c,
-0x01, 0x5b, 0x01, 0x5b, 0x03, 0x3a, 0x00, 0x05, 0x28, 0x3a, 0x28, 0x2f,
-0x2f, 0x00, 0x04, 0x51, 0x01, 0x39, 0x01, 0x39, 0x03, 0x1b, 0x05, 0x1a,
-0x01, 0x31, 0x03, 0xcd, 0x00, 0x07, 0xbe, 0xae, 0x52, 0x9a, 0x00, 0x03,
-0x03, 0x00, 0x31, 0x00, 0x00, 0x08, 0xec, 0x60, 0x4e, 0x56, 0x5f, 0x80,
-0x52, 0x52, 0x04, 0x29, 0x01, 0x27, 0x01, 0x7b, 0x04, 0x27, 0x01, 0x7b,
-0x06, 0x5a, 0x05, 0x12, 0x08, 0x02, 0x07, 0x14, 0x03, 0xaa, 0x01, 0x14,
-0x01, 0x14, 0x03, 0x0c, 0x03, 0x02, 0x01, 0xc6, 0x01, 0xc6, 0x03, 0xe0,
-0x00, 0x07, 0xc7, 0xc6, 0x50, 0x5e, 0xf2, 0xf2, 0xd9, 0x00, 0x26, 0x00,
-0x00, 0x07, 0x9d, 0xdd, 0xbc, 0xf2, 0xe1, 0x4b, 0x4b, 0x00, 0x06, 0x33,
-0x09, 0x4b, 0x01, 0x61, 0x01, 0x4b, 0x03, 0x61, 0x01, 0x36, 0x04, 0x61,
-0x05, 0x36, 0x00, 0x03, 0x3f, 0x36, 0x36, 0x00, 0x07, 0x3f, 0x04, 0x42,
-0x01, 0x3f, 0x03, 0xd5, 0x01, 0x4b, 0x01, 0x55, 0x5e, 0x00, 0x00, 0x00,
-0x46, 0x00, 0x00, 0x08, 0x88, 0xae, 0xbe, 0xbe, 0xd3, 0x9e, 0x0b, 0x0b,
-0x07, 0x2d, 0x03, 0x3c, 0x01, 0x5d, 0x01, 0x3c, 0x05, 0x5d, 0x03, 0x70,
-0x04, 0x66, 0x07, 0x15, 0x07, 0x19, 0x07, 0x0e, 0x03, 0x6f, 0x00, 0x03,
-0x4f, 0x35, 0x4f, 0x00, 0x03, 0x35, 0x04, 0x45, 0x00, 0x07, 0x1c, 0x5b,
-0x1c, 0x1c, 0x5b, 0x3a, 0x3a, 0x00, 0x03, 0x28, 0x03, 0x2f, 0x03, 0x51,
-0x00, 0x07, 0x39, 0x39, 0x1b, 0x39, 0x1b, 0x1b, 0x39, 0x00, 0x03, 0x1a,
-0x01, 0x31, 0x04, 0xcd, 0x00, 0x06, 0xbe, 0xaf, 0x7c, 0x00, 0x00, 0x0d,
-0x31, 0x00, 0x00, 0x0a, 0xd2, 0x9d, 0x60, 0x48, 0x9d, 0x60, 0x12, 0xca,
-0x29, 0x29, 0x05, 0x27, 0x01, 0x7b, 0x01, 0x27, 0x03, 0x7b, 0x00, 0x03,
-0x5a, 0x5a, 0x7b, 0x00, 0x06, 0x12, 0x09, 0x02, 0x0a, 0x14, 0x01, 0x0c,
-0x01, 0x0c, 0x06, 0x20, 0x06, 0xaa, 0x00, 0x08, 0x20, 0x04, 0x78, 0x48,
-0x4e, 0x50, 0xeb, 0x11, 0x25, 0x00, 0x00, 0x07, 0xec, 0xbc, 0xbc, 0xf2,
-0x4c, 0xc7, 0x4b, 0x00, 0x03, 0x33, 0x01, 0x61, 0x06, 0x33, 0x08, 0x4b,
-0x00, 0x03, 0x61, 0x4b, 0x4b, 0x00, 0x07, 0x61, 0x05, 0x36, 0x01, 0x3f,
-0x01, 0x36, 0x08, 0x3f, 0x00, 0x08, 0x42, 0x42, 0x4b, 0xd5, 0x33, 0xe4,
-0xc7, 0xe7, 0x5d, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x04, 0x03, 0x00,
-0x7e, 0x1b, 0x03, 0xbe, 0x01, 0x5d, 0x01, 0x9e, 0x08, 0x2d, 0x03, 0x3c,
-0x01, 0x5d, 0x01, 0x3c, 0x04, 0x5d, 0x03, 0x70, 0x04, 0x66, 0x08, 0x15,
-0x06, 0x19, 0x07, 0x0e, 0x01, 0x4f, 0x03, 0x6f, 0x01, 0x4f, 0x04, 0x35,
-0x04, 0x45, 0x01, 0x1c, 0x01, 0x1c, 0x03, 0x5b, 0x03, 0x3a, 0x01, 0x28,
-0x01, 0x28, 0x03, 0x2f, 0x04, 0x51, 0x01, 0x39, 0x05, 0x1b, 0x00, 0x0b,
-0x1a, 0x1a, 0xfc, 0xfc, 0x25, 0x25, 0x43, 0x43, 0x1a, 0x88, 0x6b, 0x00,
-0x34, 0x00, 0x00, 0x0a, 0x71, 0xfa, 0x64, 0x48, 0x5f, 0x9d, 0xc1, 0x52,
-0x52, 0x29, 0x04, 0x27, 0x01, 0x7b, 0x01, 0x27, 0x04, 0x7b, 0x01, 0x5a,
-0x01, 0x5a, 0x06, 0x12, 0x09, 0x02, 0x0a, 0x14, 0x05, 0x0c, 0x0a, 0x20,
-0x00, 0x09, 0x04, 0x20, 0x0c, 0xf8, 0x4e, 0x4e, 0x5e, 0x4e, 0xe7, 0x00,
-0x25, 0x00, 0x00, 0x07, 0xa3, 0x4e, 0xbc, 0xf2, 0xde, 0xe1, 0x4b, 0x00,
-0x0c, 0x33, 0x09, 0x4b, 0x09, 0x61, 0x07, 0x36, 0x07, 0x3f, 0x00, 0x07,
-0x42, 0x3f, 0x33, 0x33, 0x4b, 0xe4, 0xa7, 0x00, 0x5d, 0x00, 0x00, 0x00,
-0x46, 0x00, 0x00, 0x07, 0x03, 0xb4, 0xcb, 0xcd, 0xcd, 0xd3, 0x9e, 0x00,
-0x07, 0x2d, 0x04, 0x3c, 0x06, 0x5d, 0x01, 0x70, 0x01, 0x70, 0x04, 0x66,
-0x08, 0x15, 0x07, 0x19, 0x06, 0x0e, 0x01, 0x4f, 0x03, 0x6f, 0x03, 0x4f,
-0x01, 0x35, 0x01, 0x35, 0x04, 0x45, 0x01, 0x1c, 0x01, 0x1c, 0x03, 0x5b,
-0x01, 0x3a, 0x01, 0x3a, 0x04, 0x28, 0x03, 0x2f, 0x01, 0x51, 0x03, 0x2f,
-0x01, 0x39, 0x03, 0xfc, 0x00, 0x0c, 0xc3, 0xf0, 0xf0, 0x76, 0xb9, 0xc0,
-0xc0, 0x37, 0xc0, 0xf0, 0xf7, 0x71, 0x35, 0x00, 0x00, 0x09, 0x7d, 0x60,
-0x4e, 0x48, 0x5f, 0x80, 0x29, 0x52, 0x29, 0x00, 0x04, 0x27, 0x00, 0x03,
-0x7b, 0x7b, 0x27, 0x00, 0x03, 0x7b, 0x01, 0x5a, 0x06, 0x12, 0x0a, 0x02,
-0x09, 0x14, 0x07, 0x0c, 0x06, 0x20, 0x07, 0x04, 0x00, 0x06, 0x62, 0x78,
-0x64, 0x5e, 0x78, 0xfa, 0x26, 0x00, 0x00, 0x05, 0x7d, 0xbc, 0xf2, 0x50,
-0xbc, 0x00, 0x11, 0x33, 0x08, 0x4b, 0x04, 0x61, 0x01, 0x4b, 0x03, 0x61,
-0x06, 0x36, 0x01, 0x3f, 0x01, 0x36, 0x06, 0x3f, 0x00, 0x08, 0x36, 0x4b,
-0x4b, 0xdc, 0xc6, 0x8e, 0x00, 0x0d, 0x5a, 0x00, 0x00, 0x00, 0x47, 0x00,
-0x00, 0x07, 0xd0, 0xcd, 0xbe, 0xef, 0xbe, 0x3c, 0x0b, 0x00, 0x06, 0x2d,
-0x03, 0x3c, 0x06, 0x5d, 0x03, 0x70, 0x04, 0x66, 0x08, 0x15, 0x06, 0x19,
-0x07, 0x0e, 0x00, 0x03, 0x4f, 0x6f, 0x6f, 0x00, 0x03, 0x4f, 0x03, 0x35,
-0x04, 0x45, 0x00, 0x12, 0x1c, 0x1c, 0x5b, 0x5b, 0x3a, 0x3a, 0x28, 0x28,
-0x5b, 0x28, 0x28, 0x2f, 0x2f, 0x51, 0x17, 0x0a, 0xc3, 0xc3, 0x03, 0x76,
-0x01, 0x30, 0x03, 0x3e, 0x00, 0x08, 0x59, 0x37, 0x52, 0x52, 0xc0, 0xf0,
-0xcf, 0x71, 0x35, 0x00, 0x00, 0x08, 0xec, 0x60, 0x64, 0x4e, 0x5f, 0x77,
-0x12, 0x52, 0x04, 0x27, 0x04, 0x7b, 0x04, 0x5a, 0x05, 0x12, 0x09, 0x02,
-0x00, 0x04, 0x14, 0x14, 0x02, 0x02, 0x06, 0x14, 0x05, 0x0c, 0x07, 0x20,
-0x0a, 0x04, 0x00, 0x09, 0x0c, 0xf3, 0x5e, 0x50, 0x78, 0x56, 0xad, 0x00,
-0x0d, 0x00, 0x23, 0x00, 0x00, 0x06, 0xad, 0x50, 0xf2, 0x50, 0x50, 0xc7,
-0x13, 0x33, 0x09, 0x4b, 0x05, 0x61, 0x09, 0x36, 0x05, 0x3f, 0x00, 0x07,
-0x36, 0xe4, 0xe4, 0xdc, 0x90, 0x00, 0x11, 0x00, 0x5a, 0x00, 0x00, 0x00,
-0x47, 0x00, 0x00, 0x07, 0x8e, 0xdf, 0xbe, 0xef, 0xef, 0xd3, 0x9e, 0x00,
-0x05, 0x2d, 0x03, 0x3c, 0x07, 0x5d, 0x01, 0x70, 0x01, 0x70, 0x04, 0x66,
-0x09, 0x15, 0x06, 0x19, 0x06, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x03, 0x35,
-0x04, 0x45, 0x04, 0x1c, 0x00, 0x0f, 0x5b, 0x3a, 0x5b, 0x28, 0x28, 0x86,
-0x17, 0xc3, 0xc3, 0x76, 0x76, 0x1e, 0x63, 0x63, 0x30, 0x00, 0x05, 0x3e,
-0x00, 0x0b, 0x30, 0x59, 0x52, 0x29, 0x29, 0xca, 0xdf, 0xcf, 0x11, 0x00,
-0x03, 0x00, 0x33, 0x00, 0x00, 0x08, 0xe7, 0x4e, 0x5e, 0x60, 0x4e, 0x46,
-0xaa, 0x52, 0x04, 0x27, 0x00, 0x08, 0x7b, 0x7b, 0x27, 0x7b, 0x7b, 0x5a,
-0x7b, 0x7b, 0x05, 0x12, 0x08, 0x02, 0x08, 0x14, 0x06, 0x0c, 0x06, 0x20,
-0x09, 0x04, 0x00, 0x0e, 0x62, 0x62, 0x04, 0x62, 0x62, 0x04, 0x1f, 0x78,
-0x55, 0x55, 0x41, 0x7d, 0x00, 0x0d, 0x23, 0x00, 0x00, 0x06, 0x11, 0xfa,
-0x4c, 0x5e, 0x46, 0x58, 0x15, 0x33, 0x08, 0x4b, 0x03, 0x61, 0x01, 0x36,
-0x03, 0x61, 0x06, 0x36, 0x05, 0x3f, 0x03, 0xe4, 0x00, 0x05, 0xef, 0x74,
-0x4d, 0x00, 0x03, 0x00, 0x59, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0c,
-0xcc, 0xcd, 0xef, 0xdc, 0xbe, 0x2d, 0x0b, 0x2d, 0x2d, 0x3c, 0x3c, 0x2d,
-0x03, 0x3c, 0x05, 0x5d, 0x01, 0x70, 0x05, 0x66, 0x0a, 0x15, 0x06, 0x19,
-0x06, 0x0e, 0x01, 0x6f, 0x01, 0x6f, 0x03, 0x4f, 0x07, 0x35, 0x03, 0x1c,
-0x00, 0x0a, 0x5b, 0x3a, 0x86, 0x17, 0xc3, 0x8c, 0x40, 0x40, 0x1e, 0x1e,
-0x05, 0x63, 0x04, 0x30, 0x00, 0x0d, 0x3e, 0x3e, 0x30, 0x5c, 0x27, 0x5a,
-0x5a, 0xdf, 0xca, 0xd0, 0x00, 0x00, 0x11, 0x00, 0x33, 0x00, 0x00, 0x10,
-0xad, 0x56, 0x55, 0x46, 0x64, 0x46, 0xf8, 0x52, 0x27, 0x27, 0x7b, 0x27,
-0x7b, 0x27, 0x7b, 0x7b, 0x03, 0x5a, 0x06, 0x12, 0x07, 0x02, 0x08, 0x14,
-0x01, 0x0c, 0x01, 0x14, 0x04, 0x0c, 0x07, 0x20, 0x07, 0x04, 0x01, 0x62,
-0x03, 0x04, 0x04, 0x62, 0x00, 0x0a, 0x01, 0x04, 0xfb, 0x3d, 0x3d, 0x0f,
-0x9d, 0x6b, 0x00, 0x03, 0x21, 0x00, 0x00, 0x08, 0x11, 0x00, 0xec, 0xf2,
-0xf2, 0x50, 0x4c, 0xd5, 0x17, 0x33, 0x08, 0x4b, 0x06, 0x61, 0x07, 0x36,
-0x00, 0x03, 0x3f, 0x3f, 0x42, 0x00, 0x03, 0xdc, 0x00, 0x04, 0x2b, 0xd9,
-0x00, 0x4d, 0x59, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x07, 0xe7, 0xdc,
-0xef, 0xdc, 0xdc, 0xd3, 0x9e, 0x00, 0x03, 0x2d, 0x04, 0x3c, 0x06, 0x5d,
-0x01, 0x70, 0x01, 0x70, 0x04, 0x66, 0x01, 0x15, 0x01, 0x66, 0x06, 0x15,
-0x06, 0x19, 0x07, 0x0e, 0x03, 0x6f, 0x03, 0x4f, 0x04, 0x35, 0x00, 0x08,
-0x45, 0x45, 0x3a, 0x7f, 0x17, 0xc3, 0x8c, 0x40, 0x03, 0x2e, 0x01, 0x1e,
-0x06, 0x63, 0x01, 0x30, 0x01, 0x63, 0x04, 0x30, 0x00, 0x0a, 0x3e, 0x3e,
-0x30, 0x5c, 0x5a, 0x02, 0x02, 0xe0, 0x5a, 0x8b, 0x36, 0x00, 0x00, 0x0b,
-0xad, 0x4e, 0x49, 0x50, 0x50, 0x5e, 0xf8, 0x52, 0x29, 0x27, 0x27, 0x00,
-0x03, 0x7b, 0x00, 0x04, 0x27, 0x5a, 0x7b, 0x5a, 0x06, 0x12, 0x07, 0x02,
-0x09, 0x14, 0x05, 0x0c, 0x06, 0x20, 0x06, 0x04, 0x01, 0x62, 0x03, 0x04,
-0x04, 0x62, 0x05, 0x01, 0x00, 0x09, 0x62, 0x1f, 0x41, 0x67, 0x41, 0x13,
-0xd9, 0x00, 0x11, 0x00, 0x21, 0x00, 0x00, 0x08, 0x03, 0x00, 0xa3, 0xfa,
-0xf2, 0x5e, 0xde, 0xe1, 0x19, 0x33, 0x06, 0x4b, 0x07, 0x61, 0x07, 0x36,
-0x01, 0x3f, 0x01, 0x3f, 0x03, 0xdc, 0x01, 0xbe, 0x01, 0x8f, 0x5b, 0x00,
-0x00, 0x00, 0x48, 0x00, 0x00, 0x09, 0x0d, 0x74, 0xef, 0xdc, 0xe4, 0xbe,
-0x0b, 0x2d, 0x2d, 0x00, 0x05, 0x3c, 0x05, 0x5d, 0x03, 0x70, 0x05, 0x66,
-0x07, 0x15, 0x06, 0x19, 0x06, 0x0e, 0x04, 0x6f, 0x00, 0x0a, 0x4f, 0x4f,
-0x35, 0x45, 0x45, 0x7f, 0x7f, 0x8c, 0x8c, 0x4a, 0x08, 0x2e, 0x04, 0x1e,
-0x03, 0x63, 0x01, 0x30, 0x01, 0x63, 0x06, 0x30, 0x00, 0x07, 0x37, 0x02,
-0x0c, 0x02, 0xe0, 0x02, 0x68, 0x00, 0x36, 0x00, 0x00, 0x09, 0xe7, 0x64,
-0x4c, 0x3d, 0x55, 0x50, 0xfb, 0x29, 0x52, 0x00, 0x04, 0x27, 0x03, 0x7b,
-0x00, 0x03, 0x5a, 0x12, 0x5a, 0x00, 0x05, 0x12, 0x06, 0x02, 0x09, 0x14,
-0x05, 0x0c, 0x08, 0x20, 0x04, 0x04, 0x07, 0x62, 0x08, 0x01, 0x00, 0x08,
-0x62, 0x01, 0xf3, 0x4c, 0x4c, 0x58, 0xeb, 0x71, 0x23, 0x00, 0x00, 0x0b,
-0x03, 0x00, 0xd9, 0x60, 0x56, 0x4e, 0x78, 0xc6, 0xc7, 0xc7, 0xd5, 0x00,
-0x17, 0x33, 0x06, 0x4b, 0x08, 0x61, 0x06, 0x36, 0x00, 0x06, 0xdc, 0xef,
-0xef, 0xcd, 0x43, 0xe7, 0x5a, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x08,
-0x7d, 0xdc, 0xe4, 0xe4, 0xdc, 0x5d, 0x0b, 0x2d, 0x05, 0x3c, 0x04, 0x5d,
-0x04, 0x70, 0x03, 0x66, 0x08, 0x15, 0x07, 0x19, 0x06, 0x0e, 0x00, 0x0a,
-0x4f, 0x0e, 0x0e, 0x6f, 0x45, 0x7f, 0x17, 0x8c, 0x8c, 0x4a, 0x07, 0x40,
-0x05, 0x2e, 0x03, 0x1e, 0x04, 0x63, 0x04, 0x30, 0x00, 0x0a, 0x3e, 0x30,
-0x30, 0x37, 0x0c, 0x04, 0x04, 0xe0, 0x04, 0x7d, 0x36, 0x00, 0x00, 0x09,
-0xec, 0x5e, 0x4c, 0x78, 0x78, 0x3d, 0xfb, 0x12, 0x52, 0x00, 0x03, 0x27,
-0x03, 0x7b, 0x01, 0x5a, 0x01, 0x5a, 0x06, 0x12, 0x07, 0x02, 0x07, 0x14,
-0x05, 0x0c, 0x05, 0x20, 0x0b, 0x04, 0x00, 0x04, 0x62, 0x62, 0x01, 0x62,
-0x0c, 0x01, 0x00, 0x06, 0x54, 0x2a, 0x2a, 0x16, 0x2a, 0xe7, 0x23, 0x00,
-0x00, 0x0c, 0x0d, 0x00, 0x8e, 0xeb, 0x5e, 0x60, 0x64, 0xf8, 0x01, 0x01,
-0xc6, 0xc6, 0x03, 0xc7, 0x13, 0x33, 0x01, 0x61, 0x01, 0x33, 0x07, 0x4b,
-0x05, 0x61, 0x06, 0x36, 0x00, 0x06, 0x42, 0xef, 0xcd, 0xcd, 0xcb, 0xd0,
-0x5a, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x0c, 0xd2, 0xc6, 0xdc, 0x4b,
-0x4b, 0x35, 0x0b, 0x2d, 0x3c, 0x3c, 0x5d, 0x3c, 0x05, 0x5d, 0x03, 0x70,
-0x05, 0x66, 0x07, 0x15, 0x06, 0x19, 0x00, 0x03, 0x0e, 0x0e, 0x19, 0x00,
-0x03, 0x0e, 0x00, 0x07, 0x6f, 0x7f, 0x93, 0x93, 0x8c, 0x8c, 0x22, 0x00,
-0x05, 0x4a, 0x06, 0x40, 0x03, 0x2e, 0x05, 0x1e, 0x04, 0x63, 0x06, 0x30,
-0x00, 0x0a, 0x52, 0x04, 0x32, 0x62, 0xe0, 0x1f, 0xd9, 0x00, 0x00, 0x03,
-0x33, 0x00, 0x00, 0x09, 0xec, 0x78, 0x2a, 0x67, 0x49, 0x67, 0xf3, 0x12,
-0x29, 0x00, 0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a, 0x01, 0x5a, 0x05, 0x12,
-0x08, 0x02, 0x06, 0x14, 0x03, 0x0c, 0x00, 0x03, 0x20, 0x0c, 0x0c, 0x00,
-0x05, 0x20, 0x09, 0x04, 0x03, 0x62, 0x0b, 0x01, 0x00, 0x0b, 0x38, 0x32,
-0x32, 0x01, 0x32, 0x38, 0x10, 0x16, 0x10, 0xe1, 0x90, 0x00, 0x26, 0x00,
-0x00, 0x11, 0x68, 0x55, 0x5e, 0x64, 0x49, 0x32, 0x32, 0x01, 0x1f, 0x1f,
-0x01, 0x04, 0xc6, 0xc6, 0xc7, 0xc7, 0xd5, 0x00, 0x13, 0x33, 0x04, 0x4b,
-0x00, 0x05, 0x61, 0x4b, 0x61, 0x61, 0x36, 0x00, 0x03, 0x61, 0x04, 0x36,
-0x00, 0x06, 0xef, 0xcd, 0xcd, 0xcb, 0x37, 0x6b, 0x59, 0x00, 0x00, 0x00,
-0x4a, 0x00, 0x00, 0x09, 0xeb, 0xdc, 0x4b, 0x33, 0xdc, 0x2d, 0x2d, 0x3c,
-0x3c, 0x00, 0x06, 0x5d, 0x01, 0x70, 0x01, 0x70, 0x04, 0x66, 0x00, 0x03,
-0x15, 0x15, 0x66, 0x00, 0x06, 0x15, 0x07, 0x19, 0x00, 0x09, 0x0e, 0x0e,
-0x6f, 0xe5, 0x93, 0x93, 0x44, 0x44, 0x22, 0x00, 0x03, 0x4a, 0x01, 0x22,
-0x01, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x04, 0x2e, 0x06, 0x1e, 0x03, 0x63,
-0x04, 0x30, 0x00, 0x0c, 0x63, 0x30, 0x27, 0x38, 0x08, 0x38, 0xc6, 0xf8,
-0xec, 0x00, 0x00, 0x03, 0x33, 0x00, 0x00, 0x03, 0xd9, 0x4c, 0x13, 0x00,
-0x03, 0x41, 0x00, 0x05, 0xf3, 0x7b, 0x29, 0x27, 0x27, 0x00, 0x06, 0x7b,
-0x05, 0x12, 0x07, 0x02, 0x07, 0x14, 0x05, 0x0c, 0x05, 0x20, 0x08, 0x04,
-0x03, 0x62, 0x0a, 0x01, 0x03, 0x32, 0x07, 0x38, 0x00, 0x06, 0x06, 0x21,
-0x47, 0x06, 0x49, 0xd2, 0x25, 0x00, 0x00, 0x07, 0xad, 0x4e, 0x78, 0x5e,
-0x55, 0x54, 0x01, 0x00, 0x04, 0x32, 0x00, 0x09, 0x01, 0x1f, 0x1f, 0x01,
-0x04, 0x04, 0xc6, 0xc7, 0xc7, 0x00, 0x11, 0x33, 0x06, 0x4b, 0x06, 0x61,
-0x00, 0x09, 0x36, 0x36, 0x61, 0x2b, 0xcd, 0xbe, 0xcb, 0xcb, 0x7e, 0x00,
-0x59, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x09, 0xe7, 0xc7, 0x4b, 0xd5,
-0x33, 0x35, 0x2d, 0x3c, 0x3c, 0x00, 0x06, 0x5d, 0x03, 0x70, 0x03, 0x66,
-0x09, 0x15, 0x05, 0x19, 0x00, 0x06, 0x6f, 0xe5, 0xe5, 0x93, 0x53, 0x44,
-0x09, 0x22, 0x04, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x04, 0x1e, 0x04, 0x63,
-0x05, 0x30, 0x00, 0x0b, 0x3e, 0x12, 0x06, 0x06, 0x1d, 0xc6, 0x78, 0xe7,
-0x00, 0x00, 0x0d, 0x00, 0x30, 0x00, 0x00, 0x0e, 0x03, 0x00, 0x00, 0x68,
-0xb7, 0x23, 0x2a, 0x2a, 0x0f, 0x54, 0x7b, 0x52, 0x27, 0x27, 0x03, 0x7b,
-0x01, 0x5a, 0x01, 0x5a, 0x05, 0x12, 0x08, 0x02, 0x06, 0x14, 0x04, 0x0c,
-0x06, 0x20, 0x06, 0x04, 0x05, 0x62, 0x08, 0x01, 0x05, 0x32, 0x05, 0x38,
-0x04, 0x1f, 0x00, 0x06, 0x08, 0x23, 0x23, 0x1d, 0xe1, 0x7d, 0x26, 0x00,
-0x00, 0x05, 0xeb, 0x49, 0x55, 0x50, 0xf3, 0x00, 0x03, 0x38, 0x03, 0x32,
-0x00, 0x0c, 0x38, 0x32, 0x01, 0x01, 0x1f, 0x1f, 0x01, 0x01, 0x04, 0xc6,
-0xc7, 0xc7, 0x0f, 0x33, 0x06, 0x4b, 0x00, 0x03, 0x61, 0x61, 0x4b, 0x00,
-0x04, 0x61, 0x00, 0x06, 0xe4, 0xcd, 0xbe, 0xcb, 0xae, 0xb8, 0x59, 0x00,
-0x00, 0x00, 0x4b, 0x00, 0x00, 0x07, 0x48, 0xe4, 0xd5, 0xd5, 0x3b, 0x0b,
-0x3c, 0x00, 0x06, 0x5d, 0x00, 0x04, 0x70, 0x66, 0x5d, 0x70, 0x03, 0x66,
-0x09, 0x15, 0x00, 0x06, 0x19, 0x19, 0xe5, 0xe5, 0x93, 0x53, 0x03, 0x44,
-0x0a, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x04, 0x1e, 0x04, 0x63,
-0x03, 0x30, 0x00, 0x09, 0x63, 0x3e, 0x14, 0x58, 0x58, 0x23, 0xe1, 0x78,
-0xad, 0x00, 0x33, 0x00, 0x00, 0x06, 0x03, 0x00, 0x0d, 0x68, 0x58, 0x58,
-0x03, 0x13, 0x00, 0x05, 0x1f, 0x27, 0x52, 0x27, 0x27, 0x00, 0x03, 0x7b,
-0x01, 0x5a, 0x01, 0x5a, 0x05, 0x12, 0x07, 0x02, 0x07, 0x14, 0x04, 0x0c,
-0x05, 0x20, 0x09, 0x04, 0x01, 0x62, 0x01, 0x62, 0x09, 0x01, 0x04, 0x32,
-0x00, 0x05, 0x38, 0x38, 0x1f, 0x38, 0x38, 0x00, 0x06, 0x1f, 0x00, 0x07,
-0x08, 0x1d, 0x06, 0x06, 0xe1, 0x50, 0x4d, 0x00, 0x25, 0x00, 0x00, 0x0a,
-0xec, 0x78, 0x49, 0x3d, 0x49, 0x54, 0x38, 0x1f, 0x38, 0x38, 0x07, 0x32,
-0x00, 0x03, 0x01, 0x1f, 0x1f, 0x00, 0x03, 0x01, 0x00, 0x04, 0x04, 0xc6,
-0xc7, 0xc7, 0x0d, 0x33, 0x04, 0x4b, 0x00, 0x03, 0x61, 0x61, 0x4b, 0x00,
-0x05, 0x61, 0x00, 0x06, 0xdc, 0xcb, 0xcb, 0xae, 0x1c, 0x9a, 0x58, 0x00,
-0x00, 0x00, 0x49, 0x00, 0x00, 0x09, 0x11, 0x00, 0xd9, 0xd5, 0xd5, 0xab,
-0x33, 0x19, 0x2d, 0x00, 0x06, 0x5d, 0x03, 0x70, 0x03, 0x66, 0x01, 0x15,
-0x01, 0x66, 0x05, 0x15, 0x00, 0x06, 0x19, 0xe5, 0xe5, 0x93, 0x93, 0x53,
-0x09, 0x44, 0x05, 0x22, 0x01, 0x4a, 0x01, 0x22, 0x04, 0x4a, 0x05, 0x40,
-0x04, 0x2e, 0x04, 0x1e, 0x04, 0x63, 0x03, 0x30, 0x00, 0x09, 0x63, 0x3e,
-0x20, 0x21, 0x10, 0x47, 0xe1, 0x5e, 0xad, 0x00, 0x33, 0x00, 0x00, 0x0c,
-0x0d, 0x00, 0x4d, 0xfa, 0x06, 0x58, 0x47, 0x21, 0x10, 0x1f, 0x27, 0x29,
-0x04, 0x27, 0x00, 0x04, 0x7b, 0x7b, 0x5a, 0x5a, 0x04, 0x12, 0x07, 0x02,
-0x06, 0x14, 0x01, 0x0c, 0x01, 0x20, 0x03, 0x0c, 0x04, 0x20, 0x08, 0x04,
-0x04, 0x62, 0x03, 0x01, 0x00, 0x03, 0x62, 0x01, 0x01, 0x00, 0x03, 0x32,
-0x05, 0x38, 0x08, 0x1f, 0x07, 0x08, 0x00, 0x03, 0xc6, 0x38, 0xec, 0x00,
-0x25, 0x00, 0x00, 0x07, 0xa3, 0x56, 0x4c, 0x78, 0x78, 0xb7, 0x38, 0x00,
-0x04, 0x1f, 0x05, 0x38, 0x01, 0x32, 0x01, 0x32, 0x09, 0x01, 0x00, 0x04,
-0xc6, 0xe0, 0xc7, 0xd5, 0x0a, 0x33, 0x05, 0x4b, 0x06, 0x61, 0x00, 0x06,
-0x42, 0xbe, 0xcb, 0xae, 0x9c, 0xf7, 0x58, 0x00, 0x00, 0x00, 0x4b, 0x00,
-0x00, 0x07, 0x4d, 0xbc, 0xd5, 0xab, 0xab, 0x31, 0x9e, 0x00, 0x05, 0x5d,
-0x04, 0x70, 0x03, 0x66, 0x01, 0x15, 0x03, 0x66, 0x00, 0x09, 0x15, 0xe5,
-0x6e, 0x93, 0x53, 0x53, 0x44, 0x44, 0x53, 0x00, 0x07, 0x44, 0x07, 0x22,
-0x05, 0x4a, 0x05, 0x40, 0x04, 0x2e, 0x05, 0x1e, 0x03, 0x63, 0x03, 0x30,
-0x00, 0x09, 0x63, 0x3e, 0x62, 0x10, 0x10, 0x47, 0xe1, 0x56, 0xd2, 0x00,
-0x35, 0x00, 0x00, 0x12, 0x71, 0xeb, 0x1d, 0x58, 0x18, 0x47, 0x18, 0x62,
-0x27, 0x29, 0x27, 0x7b, 0x7b, 0x27, 0x7b, 0x7b, 0x5a, 0x5a, 0x04, 0x12,
-0x06, 0x02, 0x07, 0x14, 0x04, 0x0c, 0x05, 0x20, 0x04, 0x04, 0x00, 0x05,
-0x62, 0x04, 0x04, 0x62, 0x62, 0x00, 0x07, 0x01, 0x04, 0x32, 0x04, 0x38,
-0x01, 0x1f, 0x01, 0x38, 0x03, 0x1f, 0x0b, 0x08, 0x03, 0x38, 0x01, 0xc6,
-0x01, 0xeb, 0x26, 0x00, 0x00, 0x06, 0x7d, 0x2a, 0x41, 0x49, 0x2a, 0x08,
-0x08, 0x1f, 0x00, 0x03, 0x38, 0x38, 0x01, 0x00, 0x04, 0x32, 0x08, 0x01,
-0x00, 0x04, 0x04, 0xc6, 0xc7, 0xc7, 0x07, 0x33, 0x01, 0x61, 0x01, 0x33,
-0x06, 0x4b, 0x00, 0x0a, 0x61, 0x4b, 0x61, 0x61, 0xcd, 0xae, 0xae, 0x89,
-0x76, 0x6b, 0x57, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x01, 0xfa, 0x03, 0xab,
-0x00, 0x03, 0x33, 0x66, 0x2d, 0x00, 0x04, 0x5d, 0x00, 0x05, 0x66, 0x70,
-0x70, 0x66, 0x70, 0x00, 0x03, 0x66, 0x00, 0x07, 0x15, 0xe5, 0x6e, 0x73,
-0x65, 0x53, 0x44, 0x00, 0x05, 0x53, 0x07, 0x44, 0x08, 0x22, 0x04, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x04, 0x63, 0x03, 0x30, 0x00, 0x0b,
-0x1e, 0x59, 0x1f, 0x13, 0x13, 0x58, 0xe1, 0x5f, 0x6b, 0x00, 0x03, 0x00,
-0x33, 0x00, 0x00, 0x09, 0x6b, 0x9d, 0xe1, 0x1d, 0x06, 0x23, 0x06, 0x20,
-0x29, 0x00, 0x04, 0x27, 0x01, 0x7b, 0x03, 0x5a, 0x04, 0x12, 0x07, 0x02,
-0x06, 0x14, 0x00, 0x04, 0x0c, 0x14, 0x0c, 0x0c, 0x05, 0x20, 0x07, 0x04,
-0x01, 0x62, 0x01, 0x62, 0x06, 0x01, 0x03, 0x32, 0x01, 0x01, 0x01, 0x32,
-0x03, 0x38, 0x05, 0x1f, 0x0e, 0x08, 0x00, 0x06, 0x38, 0x62, 0x62, 0xe0,
-0xf8, 0xad, 0x25, 0x00, 0x00, 0x06, 0xad, 0x49, 0x2a, 0x41, 0x0f, 0x54,
-0x06, 0x08, 0x04, 0x1f, 0x03, 0x38, 0x04, 0x32, 0x08, 0x01, 0x00, 0x05,
-0x62, 0x04, 0xc6, 0xc6, 0xc7, 0x00, 0x03, 0x33, 0x00, 0x04, 0x4b, 0x4b,
-0x33, 0x33, 0x06, 0x4b, 0x00, 0x0b, 0x61, 0x61, 0x33, 0xdc, 0xae, 0xae,
-0x9c, 0x9c, 0xf1, 0x00, 0x03, 0x00, 0x55, 0x00, 0x00, 0x00, 0x4c, 0x00,
-0x00, 0x07, 0xd2, 0xc8, 0xd5, 0xab, 0xab, 0x2f, 0x0b, 0x00, 0x04, 0x5d,
-0x04, 0x70, 0x00, 0x06, 0x66, 0x83, 0xe5, 0x6e, 0x65, 0x65, 0x09, 0x53,
-0x07, 0x44, 0x08, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x04, 0x2e, 0x05, 0x1e,
-0x01, 0x63, 0x01, 0x63, 0x03, 0x30, 0x00, 0x0b, 0x1e, 0x59, 0x1f, 0x2a,
-0x13, 0x47, 0xe1, 0xeb, 0xa3, 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x09,
-0x6b, 0x56, 0xe1, 0x1d, 0x54, 0x06, 0x1d, 0x0c, 0x29, 0x00, 0x03, 0x27,
-0x01, 0x7b, 0x01, 0x7b, 0x03, 0x5a, 0x04, 0x12, 0x07, 0x02, 0x05, 0x14,
-0x05, 0x0c, 0x04, 0x20, 0x08, 0x04, 0x01, 0x62, 0x01, 0x62, 0x03, 0x01,
-0x00, 0x06, 0x62, 0x01, 0x32, 0x01, 0x32, 0x01, 0x03, 0x38, 0x06, 0x1f,
-0x0d, 0x08, 0x03, 0x1d, 0x00, 0x06, 0x1f, 0x04, 0x04, 0xc6, 0xc6, 0x90,
-0x25, 0x00, 0x00, 0x06, 0x71, 0xeb, 0x58, 0x0f, 0x0f, 0xb7, 0x08, 0x08,
-0x03, 0x1f, 0x01, 0x38, 0x01, 0x1f, 0x03, 0x38, 0x01, 0x32, 0x01, 0x32,
-0x07, 0x01, 0x04, 0x62, 0x00, 0x04, 0x04, 0x0c, 0xc6, 0xc7, 0x03, 0x33,
-0x00, 0x03, 0x4b, 0x4b, 0x33, 0x00, 0x06, 0x4b, 0x00, 0x0a, 0x61, 0x36,
-0xbe, 0x9c, 0xae, 0xce, 0xbb, 0x0d, 0x00, 0x0d, 0x54, 0x00, 0x00, 0x00,
-0x4d, 0x00, 0x00, 0x05, 0xeb, 0xab, 0xab, 0xd1, 0x3f, 0x00, 0x04, 0x5d,
-0x00, 0x06, 0x70, 0x70, 0x66, 0x83, 0x57, 0x73, 0x03, 0x65, 0x0b, 0x53,
-0x07, 0x44, 0x07, 0x22, 0x04, 0x4a, 0x05, 0x40, 0x05, 0x2e, 0x04, 0x1e,
-0x03, 0x63, 0x00, 0x0b, 0x30, 0x30, 0x1e, 0x5c, 0xb7, 0x4c, 0x0f, 0x16,
-0x23, 0xeb, 0x4d, 0x00, 0x35, 0x00, 0x00, 0x09, 0xd2, 0x7a, 0xe0, 0x38,
-0x08, 0x1d, 0x38, 0x02, 0x29, 0x00, 0x03, 0x27, 0x00, 0x04, 0x7b, 0x7b,
-0x5a, 0x5a, 0x05, 0x12, 0x06, 0x02, 0x03, 0x14, 0x00, 0x03, 0x02, 0x14,
-0x14, 0x00, 0x04, 0x0c, 0x05, 0x20, 0x06, 0x04, 0x03, 0x62, 0x06, 0x01,
-0x01, 0x32, 0x01, 0x32, 0x05, 0x38, 0x03, 0x1f, 0x0d, 0x08, 0x07, 0x1d,
-0x00, 0x09, 0x54, 0x01, 0x0c, 0x0c, 0xe0, 0x91, 0x6b, 0x00, 0x0d, 0x00,
-0x23, 0x00, 0x00, 0x06, 0xec, 0x16, 0x13, 0x13, 0x16, 0x1d, 0x09, 0x08,
-0x04, 0x1f, 0x04, 0x38, 0x03, 0x32, 0x06, 0x01, 0x06, 0x62, 0x00, 0x06,
-0x04, 0xc6, 0xc7, 0xc7, 0x33, 0x33, 0x07, 0x4b, 0x00, 0x09, 0x33, 0xef,
-0x9c, 0x9c, 0x89, 0x9c, 0x7e, 0x00, 0x26, 0x00, 0x54, 0x00, 0x00, 0x00,
-0x4d, 0x00, 0x00, 0x0c, 0xe7, 0xd1, 0xab, 0xd1, 0xd1, 0x45, 0xba, 0x5d,
-0x66, 0x83, 0x57, 0x73, 0x08, 0x65, 0x08, 0x53, 0x07, 0x44, 0x06, 0x22,
-0x06, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x04, 0x1e, 0x03, 0x63, 0x00, 0x0b,
-0x30, 0x30, 0x1e, 0x37, 0xf3, 0x41, 0x4c, 0x13, 0x16, 0xfa, 0x11, 0x00,
-0x35, 0x00, 0x00, 0x10, 0xad, 0x91, 0xc6, 0x04, 0x32, 0x38, 0x01, 0x02,
-0x29, 0x27, 0x7b, 0x7b, 0x27, 0x27, 0x5a, 0x5a, 0x04, 0x12, 0x07, 0x02,
-0x00, 0x03, 0x14, 0x14, 0x02, 0x00, 0x03, 0x14, 0x04, 0x0c, 0x05, 0x20,
-0x07, 0x04, 0x01, 0x62, 0x05, 0x01, 0x00, 0x05, 0x32, 0x01, 0x01, 0x32,
-0x32, 0x00, 0x04, 0x38, 0x03, 0x1f, 0x00, 0x03, 0x08, 0x08, 0x1f, 0x00,
-0x07, 0x08, 0x04, 0x1d, 0x07, 0x54, 0x01, 0x06, 0x01, 0x38, 0x03, 0x02,
-0x00, 0x04, 0x5a, 0x7d, 0x00, 0x11, 0x23, 0x00, 0x00, 0x06, 0x6b, 0x5f,
-0x06, 0x13, 0x21, 0x23, 0x09, 0x08, 0x00, 0x03, 0x1f, 0x08, 0x08, 0x00,
-0x04, 0x1f, 0x03, 0x38, 0x01, 0x01, 0x01, 0x32, 0x07, 0x01, 0x08, 0x62,
-0x00, 0x04, 0xc6, 0xe0, 0xc7, 0x33, 0x03, 0x4b, 0x00, 0x09, 0x61, 0x4b,
-0x4b, 0x36, 0xae, 0x89, 0x9c, 0xce, 0xd4, 0x00, 0x56, 0x00, 0x00, 0x00,
-0x4e, 0x00, 0x00, 0x08, 0xde, 0xab, 0xd1, 0xd1, 0xf0, 0x83, 0x57, 0x73,
-0x0a, 0x65, 0x09, 0x53, 0x06, 0x44, 0x08, 0x22, 0x05, 0x4a, 0x03, 0x40,
-0x05, 0x2e, 0x05, 0x1e, 0x03, 0x63, 0x00, 0x09, 0x30, 0x1e, 0x37, 0xf3,
-0x41, 0x4c, 0x13, 0x13, 0x90, 0x00, 0x36, 0x00, 0x00, 0x08, 0xe7, 0x74,
-0xe0, 0x62, 0x62, 0x32, 0x04, 0x12, 0x03, 0x27, 0x00, 0x06, 0x7b, 0x27,
-0x27, 0x7b, 0x5a, 0x5a, 0x03, 0x12, 0x07, 0x02, 0x06, 0x14, 0x04, 0x0c,
-0x03, 0x20, 0x07, 0x04, 0x03, 0x62, 0x05, 0x01, 0x04, 0x32, 0x01, 0x38,
-0x01, 0x38, 0x04, 0x1f, 0x09, 0x08, 0x01, 0x1d, 0x01, 0x08, 0x04, 0x1d,
-0x09, 0x54, 0x00, 0x08, 0x06, 0x54, 0x0c, 0x5a, 0x14, 0xdf, 0xcc, 0x0d,
-0x23, 0x00, 0x00, 0x07, 0x03, 0x00, 0x7d, 0xe1, 0x10, 0x18, 0x23, 0x00,
-0x05, 0x1d, 0x09, 0x08, 0x03, 0x1f, 0x03, 0x38, 0x04, 0x32, 0x06, 0x01,
-0x01, 0x62, 0x01, 0x62, 0x03, 0x04, 0x00, 0x08, 0x62, 0x62, 0xaa, 0x20,
-0xc6, 0xe0, 0xc7, 0x33, 0x03, 0x4b, 0x00, 0x09, 0x33, 0xbe, 0x89, 0x89,
-0xce, 0xe5, 0x9a, 0x00, 0x0d, 0x00, 0x53, 0x00, 0x00, 0x00, 0x4e, 0x00,
-0x00, 0x07, 0xd9, 0xd1, 0xc8, 0xdd, 0x1d, 0x53, 0x73, 0x00, 0x0b, 0x65,
-0x08, 0x53, 0x07, 0x44, 0x08, 0x22, 0x03, 0x4a, 0x04, 0x40, 0x05, 0x2e,
-0x04, 0x1e, 0x05, 0x63, 0x00, 0x0b, 0x1e, 0x52, 0xfb, 0x49, 0x41, 0x13,
-0x0f, 0x7d, 0x00, 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x03, 0xe7, 0xf8,
-0xe0, 0x00, 0x03, 0x04, 0x01, 0x0c, 0x01, 0x5a, 0x04, 0x27, 0x03, 0x7b,
-0x01, 0x5a, 0x01, 0x5a, 0x03, 0x12, 0x07, 0x02, 0x05, 0x14, 0x04, 0x0c,
-0x04, 0x20, 0x04, 0x04, 0x00, 0x05, 0x62, 0x62, 0x04, 0x04, 0x62, 0x00,
-0x05, 0x01, 0x03, 0x32, 0x03, 0x38, 0x05, 0x1f, 0x08, 0x08, 0x03, 0x1d,
-0x0a, 0x54, 0x05, 0x06, 0x00, 0x07, 0x23, 0x01, 0x5a, 0x5a, 0xca, 0x14,
-0xe7, 0x00, 0x23, 0x00, 0x00, 0x06, 0x11, 0x00, 0xad, 0x67, 0xe1, 0x23,
-0x05, 0x54, 0x03, 0x1d, 0x0a, 0x08, 0x04, 0x1f, 0x01, 0x38, 0x04, 0x32,
-0x05, 0x01, 0x03, 0x62, 0x05, 0x04, 0x00, 0x0e, 0x20, 0xaa, 0x20, 0xc6,
-0xe0, 0xc7, 0x4b, 0x33, 0xdc, 0x89, 0xce, 0x89, 0xce, 0xf1, 0x55, 0x00,
-0x00, 0x00, 0x4e, 0x00, 0x00, 0x08, 0x6b, 0x50, 0x10, 0x49, 0x49, 0xa6,
-0x73, 0x73, 0x0a, 0x65, 0x07, 0x53, 0x07, 0x44, 0x06, 0x22, 0x01, 0x4a,
-0x01, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x04, 0x2e, 0x05, 0x1e, 0x00, 0x0e,
-0x63, 0x30, 0x63, 0x40, 0x52, 0xfb, 0x78, 0x49, 0x13, 0x49, 0x7d, 0x00,
-0x00, 0x03, 0x33, 0x00, 0x00, 0x03, 0xd9, 0x1f, 0xe0, 0x00, 0x03, 0x0c,
-0x01, 0x14, 0x01, 0x5a, 0x05, 0x27, 0x00, 0x04, 0x7b, 0x7b, 0x5a, 0x5a,
-0x03, 0x12, 0x07, 0x02, 0x06, 0x14, 0x03, 0x0c, 0x04, 0x20, 0x07, 0x04,
-0x01, 0x62, 0x06, 0x01, 0x00, 0x06, 0x32, 0x32, 0x38, 0x32, 0x38, 0x38,
-0x03, 0x1f, 0x07, 0x08, 0x06, 0x1d, 0x07, 0x54, 0x01, 0x06, 0x01, 0x54,
-0x07, 0x06, 0x00, 0x07, 0x23, 0x06, 0x5a, 0x29, 0x27, 0xdf, 0xd0, 0x00,
-0x26, 0x00, 0x00, 0x05, 0xeb, 0xe1, 0x1d, 0x08, 0x08, 0x00, 0x05, 0x54,
-0x04, 0x1d, 0x09, 0x08, 0x03, 0x1f, 0x00, 0x03, 0x38, 0x38, 0x32, 0x00,
-0x08, 0x01, 0x04, 0x62, 0x04, 0x04, 0x00, 0x0d, 0x20, 0xaa, 0xaa, 0x0c,
-0xc6, 0xc7, 0x61, 0xcb, 0x89, 0x89, 0xce, 0xa5, 0x6b, 0x00, 0x54, 0x00,
-0x00, 0x00, 0x4f, 0x00, 0x00, 0x07, 0x7d, 0x13, 0x49, 0x67, 0xf8, 0x65,
-0x73, 0x00, 0x09, 0x65, 0x08, 0x53, 0x06, 0x44, 0x09, 0x22, 0x05, 0x4a,
-0x03, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x00, 0x0c, 0x63, 0x1e, 0x63, 0x30,
-0x1e, 0x37, 0xfb, 0xde, 0x78, 0x0f, 0x78, 0xec, 0x33, 0x00, 0x00, 0x06,
-0x03, 0x00, 0x00, 0x7e, 0x02, 0xdf, 0x04, 0x02, 0x01, 0x27, 0x01, 0x29,
-0x05, 0x27, 0x00, 0x03, 0x7b, 0x5a, 0x5a, 0x00, 0x03, 0x12, 0x07, 0x02,
-0x07, 0x14, 0x01, 0x0c, 0x01, 0x0c, 0x04, 0x20, 0x03, 0x04, 0x00, 0x05,
-0x62, 0x04, 0x04, 0x62, 0x62, 0x00, 0x05, 0x01, 0x03, 0x32, 0x03, 0x38,
-0x03, 0x1f, 0x08, 0x08, 0x04, 0x1d, 0x07, 0x54, 0x0c, 0x06, 0x00, 0x08,
-0x23, 0x18, 0x0c, 0x52, 0x52, 0xc0, 0xaf, 0xad, 0x23, 0x00, 0x00, 0x08,
-0x0d, 0x00, 0xec, 0xb7, 0xc6, 0x38, 0x32, 0x1d, 0x06, 0x54, 0x04, 0x1d,
-0x08, 0x08, 0x04, 0x1f, 0x00, 0x04, 0x38, 0x38, 0x32, 0x32, 0x06, 0x01,
-0x01, 0x62, 0x01, 0x62, 0x06, 0x04, 0x00, 0x0c, 0x20, 0x20, 0xaa, 0xaa,
-0x20, 0x04, 0xc0, 0x70, 0x9c, 0x89, 0xce, 0x96, 0x54, 0x00, 0x00, 0x00,
-0x4f, 0x00, 0x00, 0x07, 0xad, 0x50, 0x4c, 0x3d, 0x49, 0x2e, 0x73, 0x00,
-0x08, 0x65, 0x08, 0x53, 0x07, 0x44, 0x08, 0x22, 0x03, 0x4a, 0x05, 0x40,
-0x05, 0x2e, 0x03, 0x1e, 0x04, 0x63, 0x00, 0x08, 0x1e, 0x59, 0xfb, 0xde,
-0x3d, 0x41, 0x55, 0xec, 0x33, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x7d,
-0x5a, 0xdf, 0x5a, 0x5a, 0x02, 0x5a, 0x27, 0x29, 0x05, 0x27, 0x00, 0x03,
-0x5a, 0x12, 0x5a, 0x00, 0x04, 0x12, 0x05, 0x02, 0x06, 0x14, 0x04, 0x0c,
-0x04, 0x20, 0x03, 0x04, 0x00, 0x04, 0x62, 0x04, 0x62, 0x62, 0x05, 0x01,
-0x03, 0x32, 0x04, 0x38, 0x01, 0x1f, 0x01, 0x1f, 0x08, 0x08, 0x05, 0x1d,
-0x06, 0x54, 0x08, 0x06, 0x07, 0x23, 0x00, 0x07, 0x47, 0x08, 0x52, 0xc0,
-0xc0, 0xf0, 0x69, 0x00, 0x26, 0x00, 0x00, 0x06, 0xcc, 0xe0, 0x04, 0x0c,
-0x38, 0x06, 0x08, 0x54, 0x03, 0x1d, 0x08, 0x08, 0x03, 0x1f, 0x04, 0x38,
-0x01, 0x32, 0x06, 0x01, 0x00, 0x03, 0x62, 0x04, 0x62, 0x00, 0x04, 0x04,
-0x04, 0x20, 0x00, 0x07, 0x62, 0x14, 0x53, 0x6e, 0x57, 0x89, 0xf4, 0x00,
-0x54, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x06, 0xfa, 0x13, 0x3d, 0xde,
-0xaf, 0x73, 0x08, 0x65, 0x08, 0x53, 0x07, 0x44, 0x08, 0x22, 0x03, 0x4a,
-0x05, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x04, 0x63, 0x00, 0x07, 0x30, 0xf8,
-0xde, 0x55, 0x49, 0x78, 0xd9, 0x00, 0x33, 0x00, 0x00, 0x06, 0x03, 0x00,
-0x00, 0x8b, 0x29, 0xca, 0x04, 0x5a, 0x01, 0x27, 0x01, 0x29, 0x04, 0x27,
-0x00, 0x04, 0x7b, 0x7b, 0x5a, 0x7b, 0x03, 0x12, 0x06, 0x02, 0x06, 0x14,
-0x00, 0x03, 0x0c, 0x20, 0x0c, 0x00, 0x04, 0x20, 0x07, 0x04, 0x01, 0x62,
-0x06, 0x01, 0x00, 0x04, 0x32, 0x32, 0x38, 0x38, 0x04, 0x1f, 0x08, 0x08,
-0x00, 0x03, 0x1d, 0x54, 0x1d, 0x00, 0x05, 0x54, 0x01, 0x06, 0x01, 0x54,
-0x07, 0x06, 0x0a, 0x23, 0x00, 0x08, 0x47, 0x18, 0x5a, 0xc0, 0xc0, 0xf0,
-0x88, 0x4d, 0x25, 0x00, 0x00, 0x06, 0x7d, 0xc6, 0xc6, 0x0c, 0x0c, 0x54,
-0x04, 0x06, 0x04, 0x54, 0x04, 0x1d, 0x08, 0x08, 0x05, 0x1f, 0x01, 0x38,
-0x01, 0x32, 0x08, 0x01, 0x01, 0x62, 0x06, 0x04, 0x00, 0x0a, 0x20, 0x20,
-0x04, 0x04, 0x59, 0x73, 0x65, 0x57, 0x65, 0x75, 0x53, 0x00, 0x00, 0x00,
-0x4e, 0x00, 0x00, 0x09, 0x11, 0x00, 0xec, 0x78, 0x78, 0xde, 0xfb, 0x44,
-0x73, 0x00, 0x06, 0x65, 0x08, 0x53, 0x07, 0x44, 0x08, 0x22, 0x04, 0x4a,
-0x05, 0x40, 0x04, 0x2e, 0x03, 0x1e, 0x00, 0x0b, 0x63, 0x1e, 0x63, 0x63,
-0x1e, 0xaf, 0x50, 0x50, 0x3d, 0x67, 0x7d, 0x00, 0x36, 0x00, 0x00, 0x08,
-0xea, 0xca, 0xca, 0x5a, 0x27, 0x27, 0x29, 0x29, 0x05, 0x27, 0x00, 0x03,
-0x7b, 0x7b, 0x5a, 0x00, 0x05, 0x12, 0x05, 0x02, 0x07, 0x14, 0x03, 0x0c,
-0x03, 0x20, 0x04, 0x04, 0x04, 0x62, 0x04, 0x01, 0x03, 0x32, 0x00, 0x05,
-0x38, 0x38, 0x1f, 0x38, 0x1f, 0x00, 0x08, 0x08, 0x03, 0x1d, 0x06, 0x54,
-0x07, 0x06, 0x00, 0x03, 0x23, 0x23, 0x06, 0x00, 0x03, 0x23, 0x09, 0x18,
-0x00, 0x07, 0x21, 0x01, 0xb9, 0xc0, 0xf0, 0xb9, 0xb2, 0x00, 0x25, 0x00,
-0x00, 0x07, 0x6b, 0xf8, 0xe0, 0x02, 0x5a, 0x38, 0x23, 0x00, 0x05, 0x06,
-0x05, 0x54, 0x05, 0x1d, 0x07, 0x08, 0x03, 0x1f, 0x01, 0x38, 0x04, 0x32,
-0x04, 0x01, 0x01, 0x62, 0x01, 0x62, 0x06, 0x04, 0x00, 0x09, 0x20, 0x20,
-0x01, 0x7b, 0x65, 0x73, 0x73, 0x6e, 0xdb, 0x00, 0x53, 0x00, 0x00, 0x00,
-0x4e, 0x00, 0x00, 0x09, 0x0d, 0x00, 0xa3, 0xeb, 0x4c, 0x50, 0xde, 0xb4,
-0x6e, 0x00, 0x06, 0x65, 0x08, 0x53, 0x07, 0x44, 0x06, 0x22, 0x06, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x03, 0x1e, 0x03, 0x63, 0x00, 0x0b, 0x30, 0x40,
-0x52, 0x55, 0x5e, 0x55, 0x49, 0xfa, 0x0d, 0x00, 0x03, 0x00, 0x32, 0x00,
-0x00, 0x04, 0x4d, 0xea, 0xc0, 0xca, 0x05, 0x29, 0x04, 0x27, 0x04, 0x7b,
-0x01, 0x5a, 0x04, 0x12, 0x06, 0x02, 0x05, 0x14, 0x04, 0x0c, 0x03, 0x20,
-0x04, 0x04, 0x04, 0x62, 0x01, 0x01, 0x01, 0x62, 0x03, 0x01, 0x00, 0x04,
-0x32, 0x32, 0x38, 0x38, 0x03, 0x1f, 0x07, 0x08, 0x04, 0x1d, 0x06, 0x54,
-0x06, 0x06, 0x08, 0x23, 0x09, 0x18, 0x00, 0x07, 0x21, 0x06, 0xca, 0xb9,
-0xb9, 0xf0, 0xcf, 0x00, 0x26, 0x00, 0x00, 0x07, 0xea, 0xdf, 0x5a, 0x5a,
-0x0c, 0x06, 0x23, 0x00, 0x06, 0x06, 0x06, 0x54, 0x03, 0x1d, 0x07, 0x08,
-0x03, 0x1f, 0x01, 0x38, 0x01, 0x38, 0x04, 0x32, 0x04, 0x01, 0x03, 0x62,
-0x04, 0x04, 0x00, 0x09, 0x20, 0x62, 0x20, 0x63, 0x73, 0x65, 0xe5, 0xbb,
-0x71, 0x00, 0x52, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x09, 0x0d, 0x00,
-0xd9, 0x67, 0x50, 0x5e, 0x72, 0x65, 0x73, 0x00, 0x04, 0x65, 0x09, 0x53,
-0x06, 0x44, 0x06, 0x22, 0x01, 0x4a, 0x01, 0x22, 0x04, 0x4a, 0x04, 0x40,
-0x05, 0x2e, 0x04, 0x1e, 0x00, 0x0c, 0x63, 0x63, 0x1e, 0x3e, 0x80, 0x64,
-0x5e, 0x49, 0xeb, 0x6b, 0x00, 0x03, 0x32, 0x00, 0x00, 0x09, 0x11, 0xcf,
-0xb9, 0xc0, 0x52, 0xca, 0xca, 0x52, 0x29, 0x00, 0x03, 0x27, 0x00, 0x06,
-0x7b, 0x27, 0x7b, 0x7b, 0x5a, 0x5a, 0x04, 0x12, 0x05, 0x02, 0x06, 0x14,
-0x04, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x06, 0x04, 0x01, 0x62, 0x01, 0x62,
-0x06, 0x01, 0x00, 0x03, 0x38, 0x32, 0x38, 0x00, 0x04, 0x1f, 0x06, 0x08,
-0x03, 0x1d, 0x06, 0x54, 0x05, 0x06, 0x08, 0x23, 0x0c, 0x18, 0x00, 0x09,
-0x47, 0x47, 0x21, 0x02, 0x76, 0xb9, 0x0a, 0xb4, 0x7c, 0x00, 0x25, 0x00,
-0x00, 0x09, 0xe7, 0x5a, 0xca, 0x29, 0x29, 0x08, 0x18, 0x23, 0x23, 0x00,
-0x06, 0x06, 0x06, 0x54, 0x04, 0x1d, 0x06, 0x08, 0x03, 0x1f, 0x01, 0x38,
-0x03, 0x32, 0x05, 0x01, 0x03, 0x62, 0x00, 0x0c, 0x04, 0x04, 0x20, 0x04,
-0x04, 0x01, 0x29, 0x53, 0x53, 0x93, 0x44, 0x96, 0x52, 0x00, 0x00, 0x00,
-0x4f, 0x00, 0x00, 0x09, 0x0d, 0x00, 0x8e, 0x9d, 0x78, 0x5e, 0x50, 0x82,
-0x73, 0x00, 0x04, 0x65, 0x07, 0x53, 0x08, 0x44, 0x08, 0x22, 0x04, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x00, 0x0a, 0x63, 0x63, 0x1e, 0x1e,
-0xc1, 0x4e, 0x46, 0x55, 0x64, 0xad, 0x32, 0x00, 0x00, 0x06, 0x03, 0x00,
-0x6b, 0xf7, 0xf0, 0xb9, 0x03, 0xc0, 0x01, 0x52, 0x01, 0x29, 0x04, 0x27,
-0x03, 0x7b, 0x00, 0x03, 0x5a, 0x5a, 0x7b, 0x00, 0x03, 0x12, 0x06, 0x02,
-0x04, 0x14, 0x04, 0x0c, 0x03, 0x20, 0x04, 0x04, 0x00, 0x04, 0x62, 0x04,
-0x62, 0x62, 0x04, 0x01, 0x03, 0x32, 0x00, 0x05, 0x38, 0x1f, 0x1f, 0x38,
-0x1f, 0x00, 0x07, 0x08, 0x03, 0x1d, 0x06, 0x54, 0x05, 0x06, 0x05, 0x23,
-0x00, 0x04, 0x18, 0x18, 0x23, 0x23, 0x08, 0x18, 0x06, 0x47, 0x00, 0x07,
-0x10, 0x1d, 0xb9, 0x76, 0x76, 0xc3, 0xf1, 0x00, 0x25, 0x00, 0x00, 0x08,
-0x4d, 0x8f, 0xdf, 0x52, 0xc0, 0x14, 0x18, 0x18, 0x03, 0x23, 0x06, 0x06,
-0x06, 0x54, 0x03, 0x1d, 0x06, 0x08, 0x03, 0x1f, 0x00, 0x06, 0x38, 0x38,
-0x32, 0x01, 0x01, 0x32, 0x03, 0x01, 0x01, 0x62, 0x01, 0x62, 0x06, 0x04,
-0x00, 0x06, 0x20, 0x1e, 0x53, 0x44, 0x6e, 0xd4, 0x52, 0x00, 0x00, 0x00,
-0x52, 0x00, 0x00, 0x05, 0x68, 0x3d, 0x50, 0x64, 0xc1, 0x00, 0x04, 0x65,
-0x09, 0x53, 0x07, 0x44, 0x07, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x05, 0x2e,
-0x04, 0x1e, 0x00, 0x09, 0x63, 0x63, 0x40, 0x37, 0x46, 0x64, 0x5e, 0x3d,
-0x7d, 0x00, 0x32, 0x00, 0x00, 0x06, 0x0d, 0x00, 0x8e, 0x88, 0xf0, 0xb9,
-0x03, 0xc0, 0x01, 0x52, 0x01, 0x29, 0x04, 0x27, 0x03, 0x7b, 0x01, 0x5a,
-0x01, 0x5a, 0x04, 0x12, 0x06, 0x02, 0x04, 0x14, 0x04, 0x0c, 0x03, 0x20,
-0x04, 0x04, 0x00, 0x04, 0x62, 0x04, 0x62, 0x62, 0x03, 0x01, 0x03, 0x32,
-0x01, 0x38, 0x01, 0x38, 0x04, 0x1f, 0x07, 0x08, 0x01, 0x1d, 0x01, 0x1d,
-0x06, 0x54, 0x06, 0x06, 0x04, 0x23, 0x00, 0x03, 0x18, 0x18, 0x58, 0x00,
-0x07, 0x18, 0x05, 0x47, 0x06, 0x21, 0x00, 0x07, 0x10, 0x29, 0x8c, 0x76,
-0x17, 0xb8, 0x71, 0x00, 0x25, 0x00, 0x00, 0x07, 0x7e, 0xb9, 0xc0, 0xc0,
-0xca, 0x06, 0x47, 0x00, 0x05, 0x23, 0x06, 0x06, 0x05, 0x54, 0x03, 0x1d,
-0x06, 0x08, 0x04, 0x1f, 0x01, 0x38, 0x03, 0x32, 0x04, 0x01, 0x00, 0x04,
-0x62, 0x62, 0x04, 0x62, 0x03, 0x04, 0x00, 0x09, 0x01, 0x37, 0x44, 0xee,
-0x53, 0xa5, 0xb2, 0x00, 0x03, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x52, 0x00,
-0x00, 0x09, 0xad, 0x4e, 0x3d, 0x64, 0x7a, 0xed, 0x73, 0x65, 0x65, 0x00,
-0x08, 0x53, 0x07, 0x44, 0x07, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x04, 0x2e,
-0x04, 0x1e, 0x00, 0x0a, 0x63, 0x63, 0x1e, 0x63, 0x74, 0x56, 0x64, 0x50,
-0xeb, 0xa3, 0x33, 0x00, 0x00, 0x0a, 0x7c, 0xa8, 0xc3, 0xc0, 0xc0, 0xb9,
-0xb9, 0x52, 0x29, 0x29, 0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a, 0x01, 0x5a,
-0x04, 0x12, 0x05, 0x02, 0x05, 0x14, 0x04, 0x0c, 0x03, 0x20, 0x05, 0x04,
-0x03, 0x62, 0x04, 0x01, 0x03, 0x32, 0x00, 0x04, 0x38, 0x38, 0x1f, 0x1f,
-0x08, 0x08, 0x01, 0x1d, 0x05, 0x54, 0x06, 0x06, 0x04, 0x23, 0x00, 0x05,
-0x18, 0x18, 0x23, 0x18, 0x23, 0x00, 0x06, 0x18, 0x01, 0x47, 0x01, 0x47,
-0x0a, 0x21, 0x00, 0x0a, 0x47, 0x13, 0x04, 0x76, 0x76, 0x8c, 0x76, 0x7e,
-0x00, 0x03, 0x23, 0x00, 0x00, 0x07, 0x8e, 0xa8, 0xf0, 0xc0, 0xb9, 0x0c,
-0x21, 0x00, 0x03, 0x18, 0x04, 0x23, 0x06, 0x06, 0x04, 0x54, 0x04, 0x1d,
-0x06, 0x08, 0x03, 0x1f, 0x00, 0x04, 0x38, 0x38, 0x32, 0x32, 0x05, 0x01,
-0x01, 0x62, 0x04, 0x04, 0x00, 0x07, 0x01, 0x14, 0x2e, 0xee, 0xed, 0x93,
-0xdb, 0x00, 0x51, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x08, 0xfa, 0x55,
-0x46, 0x4e, 0xb4, 0x73, 0x65, 0x65, 0x06, 0x53, 0x01, 0x44, 0x01, 0x53,
-0x06, 0x44, 0x07, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x03, 0x1e,
-0x03, 0x63, 0x00, 0x07, 0x40, 0xb4, 0x60, 0x56, 0x64, 0x64, 0xe7, 0x00,
-0x33, 0x00, 0x00, 0x03, 0x75, 0xb8, 0xc3, 0x00, 0x04, 0xb9, 0x01, 0x52,
-0x03, 0x29, 0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a, 0x04, 0x12, 0x06, 0x02,
-0x05, 0x14, 0x03, 0x0c, 0x04, 0x20, 0x05, 0x04, 0x01, 0x62, 0x06, 0x01,
-0x01, 0x32, 0x03, 0x38, 0x01, 0x1f, 0x01, 0x1f, 0x06, 0x08, 0x01, 0x1d,
-0x01, 0x1d, 0x05, 0x54, 0x07, 0x06, 0x03, 0x23, 0x05, 0x18, 0x01, 0x23,
-0x03, 0x18, 0x04, 0x47, 0x07, 0x21, 0x01, 0x47, 0x05, 0x21, 0x00, 0x0a,
-0x10, 0x18, 0xb9, 0x8c, 0x76, 0x7f, 0xf7, 0x00, 0x00, 0x0d, 0x21, 0x00,
-0x00, 0x0c, 0x03, 0x00, 0xf1, 0x0a, 0xc0, 0xb9, 0xca, 0x47, 0x47, 0x18,
-0x58, 0x18, 0x04, 0x23, 0x06, 0x06, 0x05, 0x54, 0x03, 0x1d, 0x06, 0x08,
-0x04, 0x1f, 0x01, 0x38, 0x03, 0x32, 0x00, 0x06, 0x01, 0x62, 0x01, 0x01,
-0x62, 0x62, 0x03, 0x04, 0x00, 0x09, 0x01, 0x5c, 0xee, 0xed, 0x8c, 0xb8,
-0x7c, 0x00, 0x11, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x07,
-0xec, 0x5e, 0x46, 0x56, 0x91, 0x22, 0x73, 0x00, 0x09, 0x53, 0x07, 0x44,
-0x06, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x03, 0x1e, 0x00, 0x0a,
-0x63, 0x63, 0x1e, 0x1e, 0x74, 0x5f, 0x48, 0x5e, 0xfa, 0x4d, 0x2f, 0x00,
-0x00, 0x0b, 0x0d, 0x00, 0x00, 0xe7, 0xb4, 0x0a, 0xb9, 0xb9, 0x76, 0xb9,
-0x52, 0x00, 0x06, 0x27, 0x01, 0x7b, 0x01, 0x7b, 0x03, 0x5a, 0x03, 0x12,
-0x06, 0x02, 0x06, 0x14, 0x01, 0x0c, 0x01, 0x0c, 0x03, 0x20, 0x06, 0x04,
-0x01, 0x62, 0x04, 0x01, 0x00, 0x05, 0x32, 0x32, 0x01, 0x32, 0x38, 0x00,
-0x03, 0x1f, 0x06, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x05, 0x54, 0x05, 0x06,
-0x04, 0x23, 0x09, 0x18, 0x03, 0x47, 0x10, 0x21, 0x00, 0x03, 0x10, 0x13,
-0x5a, 0x00, 0x03, 0x8c, 0x00, 0x04, 0xa5, 0xb2, 0x00, 0x4d, 0x21, 0x00,
-0x00, 0x09, 0x4d, 0x00, 0xe7, 0x37, 0xf0, 0x76, 0xb9, 0x01, 0x21, 0x00,
-0x04, 0x18, 0x01, 0x23, 0x01, 0x18, 0x04, 0x23, 0x05, 0x06, 0x05, 0x54,
-0x03, 0x1d, 0x06, 0x08, 0x03, 0x1f, 0x00, 0x04, 0x38, 0x32, 0x01, 0x32,
-0x03, 0x01, 0x03, 0x62, 0x00, 0x0b, 0x04, 0x62, 0x01, 0x12, 0xed, 0xee,
-0xed, 0x8c, 0x69, 0x00, 0x26, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x53, 0x00,
-0x00, 0x08, 0x71, 0xeb, 0x46, 0x56, 0x5f, 0xbb, 0x73, 0x65, 0x07, 0x53,
-0x07, 0x44, 0x05, 0x22, 0x00, 0x03, 0x4a, 0x22, 0x22, 0x00, 0x03, 0x4a,
-0x04, 0x40, 0x05, 0x2e, 0x04, 0x1e, 0x00, 0x0b, 0x63, 0x63, 0x40, 0xb4,
-0x4e, 0x5f, 0x56, 0x5f, 0xad, 0x00, 0x11, 0x00, 0x2d, 0x00, 0x00, 0x06,
-0x03, 0x00, 0x00, 0xb1, 0x82, 0x86, 0x04, 0x76, 0x00, 0x04, 0x37, 0x27,
-0x29, 0x29, 0x04, 0x27, 0x00, 0x04, 0x7b, 0x7b, 0x5a, 0x5a, 0x03, 0x12,
-0x06, 0x02, 0x05, 0x14, 0x03, 0x0c, 0x03, 0x20, 0x05, 0x04, 0x01, 0x62,
-0x01, 0x62, 0x04, 0x01, 0x03, 0x32, 0x01, 0x38, 0x01, 0x38, 0x03, 0x1f,
-0x05, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x05, 0x54, 0x05, 0x06, 0x05, 0x23,
-0x08, 0x18, 0x03, 0x47, 0x05, 0x21, 0x01, 0x47, 0x06, 0x21, 0x00, 0x03,
-0x10, 0x10, 0x21, 0x00, 0x05, 0x10, 0x00, 0x08, 0x06, 0x76, 0x93, 0x8c,
-0x0e, 0xcf, 0x00, 0x03, 0x21, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x00, 0xcf,
-0x17, 0x1e, 0x8c, 0x52, 0x10, 0x47, 0x06, 0x18, 0x05, 0x23, 0x05, 0x06,
-0x05, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x06, 0x08, 0x03, 0x1f, 0x00, 0x04,
-0x38, 0x38, 0x01, 0x32, 0x04, 0x01, 0x00, 0x0b, 0x62, 0x62, 0x04, 0x62,
-0x04, 0xa6, 0xed, 0xa5, 0x8c, 0xd4, 0x6b, 0x00, 0x4f, 0x00, 0x00, 0x00,
-0x54, 0x00, 0x00, 0x07, 0xd9, 0x46, 0x56, 0x5f, 0x80, 0x53, 0x73, 0x00,
-0x07, 0x53, 0x06, 0x44, 0x08, 0x22, 0x04, 0x4a, 0x04, 0x40, 0x04, 0x2e,
-0x04, 0x1e, 0x03, 0x63, 0x00, 0x09, 0x40, 0x74, 0x9d, 0x9d, 0x64, 0x68,
-0x00, 0x00, 0x0d, 0x00, 0x2c, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x7e,
-0x3e, 0x17, 0x04, 0x76, 0x00, 0x04, 0x37, 0x27, 0x29, 0x29, 0x04, 0x27,
-0x03, 0x7b, 0x01, 0x5a, 0x04, 0x12, 0x05, 0x02, 0x06, 0x14, 0x03, 0x0c,
-0x01, 0x20, 0x01, 0x20, 0x06, 0x04, 0x01, 0x62, 0x04, 0x01, 0x03, 0x32,
-0x01, 0x38, 0x03, 0x1f, 0x06, 0x08, 0x03, 0x1d, 0x04, 0x54, 0x05, 0x06,
-0x00, 0x04, 0x23, 0x06, 0x23, 0x23, 0x06, 0x18, 0x01, 0x47, 0x01, 0x18,
-0x03, 0x47, 0x0e, 0x21, 0x06, 0x10, 0x00, 0x09, 0x16, 0x16, 0xbc, 0x52,
-0x93, 0x53, 0xe5, 0x82, 0xad, 0x00, 0x23, 0x00, 0x00, 0x0a, 0x26, 0x00,
-0x7e, 0x1e, 0x76, 0x8c, 0x76, 0x08, 0x10, 0x47, 0x03, 0x18, 0x01, 0x23,
-0x03, 0x18, 0x05, 0x23, 0x04, 0x06, 0x04, 0x54, 0x03, 0x1d, 0x07, 0x08,
-0x00, 0x06, 0x1f, 0x38, 0x38, 0x32, 0x32, 0x38, 0x04, 0x01, 0x03, 0x62,
-0x01, 0x01, 0x01, 0x7b, 0x03, 0xa5, 0x01, 0xed, 0x01, 0xb1, 0x4f, 0x00,
-0x00, 0x00, 0x54, 0x00, 0x00, 0x07, 0xd2, 0x5f, 0x4e, 0x5f, 0x48, 0xa5,
-0x73, 0x00, 0x06, 0x53, 0x07, 0x44, 0x06, 0x22, 0x06, 0x4a, 0x04, 0x40,
-0x04, 0x2e, 0x04, 0x1e, 0x00, 0x0b, 0x63, 0x63, 0x1e, 0x37, 0x8f, 0x9d,
-0x5f, 0x5f, 0xe7, 0x00, 0x03, 0x00, 0x2c, 0x00, 0x00, 0x0e, 0x03, 0x00,
-0x00, 0x69, 0x63, 0x7f, 0x76, 0x76, 0x8c, 0x76, 0x37, 0x27, 0x29, 0x29,
-0x05, 0x27, 0x00, 0x03, 0x7b, 0x5a, 0x5a, 0x00, 0x04, 0x12, 0x05, 0x02,
-0x05, 0x14, 0x04, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x04, 0x04, 0x03, 0x62,
-0x04, 0x01, 0x03, 0x32, 0x00, 0x04, 0x38, 0x38, 0x1f, 0x1f, 0x06, 0x08,
-0x01, 0x1d, 0x01, 0x1d, 0x05, 0x54, 0x03, 0x06, 0x05, 0x23, 0x08, 0x18,
-0x01, 0x47, 0x01, 0x47, 0x0b, 0x21, 0x06, 0x10, 0x08, 0x16, 0x00, 0x07,
-0xbc, 0x1f, 0x8c, 0x93, 0x93, 0x19, 0x69, 0x00, 0x23, 0x00, 0x00, 0x0d,
-0x0d, 0x00, 0x71, 0xf4, 0x7f, 0x8c, 0x8c, 0x5a, 0x10, 0x47, 0x47, 0x18,
-0x47, 0x00, 0x06, 0x18, 0x04, 0x23, 0x05, 0x06, 0x04, 0x54, 0x03, 0x1d,
-0x05, 0x08, 0x03, 0x1f, 0x00, 0x04, 0x38, 0x38, 0x32, 0x32, 0x04, 0x01,
-0x00, 0x0a, 0x62, 0x62, 0x01, 0x04, 0xa6, 0xa5, 0x82, 0x40, 0xcf, 0x4d,
-0x4e, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x08, 0x11, 0x68, 0x60, 0x9d,
-0x9d, 0xa8, 0x73, 0x65, 0x05, 0x53, 0x06, 0x44, 0x06, 0x22, 0x06, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x00, 0x0a, 0x63, 0x63, 0x30, 0x76,
-0xc1, 0x9d, 0xa7, 0x60, 0xfa, 0x4d, 0x30, 0x00, 0x00, 0x08, 0xc5, 0x8c,
-0x7f, 0x76, 0x8c, 0x8c, 0x76, 0x37, 0x04, 0x29, 0x03, 0x27, 0x00, 0x04,
-0x7b, 0x7b, 0x5a, 0x5a, 0x04, 0x12, 0x05, 0x02, 0x05, 0x14, 0x04, 0x0c,
-0x01, 0x20, 0x01, 0x20, 0x04, 0x04, 0x03, 0x62, 0x05, 0x01, 0x00, 0x03,
-0x32, 0x32, 0x38, 0x00, 0x03, 0x1f, 0x06, 0x08, 0x01, 0x1d, 0x06, 0x54,
-0x04, 0x06, 0x04, 0x23, 0x06, 0x18, 0x03, 0x47, 0x04, 0x21, 0x01, 0x47,
-0x01, 0x47, 0x06, 0x21, 0x03, 0x10, 0x04, 0x16, 0x01, 0x13, 0x06, 0x16,
-0x03, 0x13, 0x00, 0x06, 0x76, 0x6e, 0x93, 0xe5, 0xf4, 0x6b, 0x25, 0x00,
-0x00, 0x07, 0xf1, 0x93, 0x8c, 0x93, 0xb9, 0x06, 0x10, 0x00, 0x05, 0x47,
-0x00, 0x06, 0x18, 0x18, 0x58, 0x18, 0x23, 0x18, 0x04, 0x23, 0x04, 0x06,
-0x05, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x05, 0x08, 0x03, 0x1f, 0x00, 0x04,
-0x38, 0x38, 0x32, 0x38, 0x04, 0x01, 0x03, 0x62, 0x00, 0x06, 0x7b, 0x82,
-0x82, 0xa5, 0xbb, 0xad, 0x4e, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x07,
-0xe7, 0x48, 0x5f, 0x9d, 0x8f, 0xee, 0x65, 0x00, 0x05, 0x53, 0x06, 0x44,
-0x07, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x05, 0x2e, 0x04, 0x1e, 0x03, 0x63,
-0x00, 0x06, 0x30, 0x80, 0x9d, 0x4e, 0x4e, 0xd9, 0x30, 0x00, 0x00, 0x03,
-0xf1, 0x8c, 0x7f, 0x00, 0x03, 0x8c, 0x01, 0x76, 0x01, 0x37, 0x03, 0x29,
-0x06, 0x27, 0x00, 0x03, 0x7b, 0x5a, 0x5a, 0x00, 0x04, 0x12, 0x06, 0x02,
-0x03, 0x14, 0x00, 0x06, 0x0c, 0x0c, 0x20, 0x0c, 0x20, 0x20, 0x05, 0x04,
-0x01, 0x62, 0x01, 0x62, 0x04, 0x01, 0x00, 0x04, 0x32, 0x32, 0x01, 0x38,
-0x03, 0x1f, 0x05, 0x08, 0x03, 0x1d, 0x05, 0x54, 0x03, 0x06, 0x00, 0x0d,
-0x23, 0x06, 0x23, 0x23, 0x18, 0x18, 0x58, 0x23, 0x18, 0x18, 0x47, 0x47,
-0x21, 0x00, 0x05, 0x47, 0x07, 0x21, 0x04, 0x10, 0x0b, 0x16, 0x03, 0x13,
-0x00, 0x07, 0xbc, 0x02, 0x6e, 0x6e, 0xe5, 0x6e, 0xb1, 0x00, 0x25, 0x00,
-0x00, 0x0a, 0x7c, 0x82, 0xe5, 0x93, 0x93, 0x14, 0xbc, 0x18, 0x21, 0x21,
-0x03, 0x47, 0x07, 0x18, 0x04, 0x23, 0x03, 0x06, 0x05, 0x54, 0x03, 0x1d,
-0x05, 0x08, 0x03, 0x1f, 0x00, 0x04, 0x38, 0x38, 0x32, 0x32, 0x03, 0x01,
-0x00, 0x08, 0x62, 0x32, 0x20, 0x82, 0x82, 0xa6, 0xa5, 0x69, 0x4e, 0x00,
-0x00, 0x00, 0x55, 0x00, 0x00, 0x07, 0xa3, 0xfa, 0x60, 0x9d, 0x5f, 0xb8,
-0x73, 0x00, 0x04, 0x53, 0x07, 0x44, 0x07, 0x22, 0x04, 0x4a, 0x04, 0x40,
-0x05, 0x2e, 0x03, 0x1e, 0x00, 0x0a, 0x63, 0x63, 0x30, 0x40, 0xb4, 0x60,
-0x48, 0x46, 0x9d, 0xd2, 0x2f, 0x00, 0x00, 0x03, 0xdb, 0x93, 0x7f, 0x00,
-0x03, 0x8c, 0x00, 0x03, 0x76, 0x52, 0x27, 0x00, 0x03, 0x29, 0x04, 0x27,
-0x03, 0x7b, 0x05, 0x12, 0x05, 0x02, 0x04, 0x14, 0x04, 0x0c, 0x03, 0x20,
-0x03, 0x04, 0x04, 0x62, 0x03, 0x01, 0x00, 0x07, 0x32, 0x01, 0x01, 0x38,
-0x38, 0x1f, 0x1f, 0x00, 0x05, 0x08, 0x03, 0x1d, 0x00, 0x04, 0x54, 0x54,
-0x06, 0x54, 0x03, 0x06, 0x04, 0x23, 0x08, 0x18, 0x01, 0x47, 0x0a, 0x21,
-0x01, 0x10, 0x01, 0x16, 0x03, 0x10, 0x06, 0x16, 0x01, 0x13, 0x01, 0x16,
-0x03, 0x13, 0x01, 0x16, 0x01, 0x16, 0x04, 0x13, 0x00, 0x07, 0x2a, 0xb7,
-0x93, 0x6e, 0x6e, 0x83, 0x6a, 0x00, 0x26, 0x00, 0x00, 0x08, 0x6a, 0xe5,
-0x93, 0x6e, 0xb9, 0x21, 0x10, 0x47, 0x04, 0x21, 0x01, 0x47, 0x01, 0x47,
-0x05, 0x18, 0x05, 0x23, 0x04, 0x06, 0x04, 0x54, 0x03, 0x1d, 0x05, 0x08,
-0x00, 0x04, 0x1f, 0x1f, 0x38, 0x38, 0x03, 0x32, 0x00, 0x0b, 0x01, 0x01,
-0x62, 0x01, 0x62, 0xb4, 0x82, 0x82, 0xa5, 0xf4, 0x4d, 0x00, 0x4d, 0x00,
-0x00, 0x00, 0x54, 0x00, 0x00, 0x07, 0x03, 0x00, 0xec, 0x64, 0x48, 0x9d,
-0x81, 0x00, 0x04, 0x53, 0x07, 0x44, 0x08, 0x22, 0x04, 0x4a, 0x04, 0x40,
-0x04, 0x2e, 0x04, 0x1e, 0x00, 0x09, 0x63, 0x63, 0x30, 0x40, 0xc1, 0x5f,
-0x4e, 0x50, 0xfa, 0x00, 0x2c, 0x00, 0x00, 0x0c, 0x11, 0x00, 0x4d, 0x8a,
-0xe5, 0xe5, 0x8c, 0x93, 0x93, 0x76, 0x52, 0x27, 0x04, 0x29, 0x04, 0x27,
-0x00, 0x04, 0x7b, 0x7b, 0x5a, 0x5a, 0x03, 0x12, 0x05, 0x02, 0x01, 0x14,
-0x01, 0x02, 0x03, 0x14, 0x03, 0x0c, 0x04, 0x20, 0x03, 0x04, 0x03, 0x62,
-0x04, 0x01, 0x01, 0x32, 0x01, 0x38, 0x03, 0x1f, 0x06, 0x08, 0x03, 0x1d,
-0x04, 0x54, 0x03, 0x06, 0x04, 0x23, 0x06, 0x18, 0x03, 0x47, 0x00, 0x03,
-0x21, 0x21, 0x47, 0x00, 0x06, 0x21, 0x03, 0x10, 0x0a, 0x16, 0x01, 0x13,
-0x01, 0x16, 0x09, 0x13, 0x00, 0x08, 0x2a, 0x2a, 0x52, 0x57, 0x6e, 0x83,
-0x65, 0x7c, 0x25, 0x00, 0x00, 0x07, 0xb2, 0x93, 0xe5, 0x6e, 0x93, 0x04,
-0x10, 0x00, 0x06, 0x21, 0x01, 0x47, 0x01, 0x47, 0x07, 0x18, 0x00, 0x03,
-0x23, 0x06, 0x23, 0x00, 0x04, 0x06, 0x04, 0x54, 0x01, 0x1d, 0x01, 0x1d,
-0x06, 0x08, 0x03, 0x1f, 0x00, 0x03, 0x38, 0x32, 0x32, 0x00, 0x05, 0x01,
-0x00, 0x06, 0xaa, 0xbb, 0xbb, 0x82, 0xbb, 0xb1, 0x4d, 0x00, 0x00, 0x00,
-0x54, 0x00, 0x00, 0x0a, 0x03, 0x00, 0xd2, 0xeb, 0x46, 0x56, 0x4e, 0xbb,
-0x73, 0x53, 0x08, 0x44, 0x07, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x05, 0x2e,
-0x04, 0x1e, 0x00, 0x09, 0x63, 0x63, 0x30, 0x3e, 0x74, 0x56, 0x46, 0x46,
-0xd9, 0x00, 0x2d, 0x00, 0x00, 0x03, 0x71, 0xd4, 0xe5, 0x00, 0x04, 0x93,
-0x00, 0x04, 0x76, 0x52, 0x29, 0x52, 0x03, 0x29, 0x04, 0x27, 0x03, 0x7b,
-0x01, 0x5a, 0x03, 0x12, 0x06, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x03, 0x20,
-0x05, 0x04, 0x01, 0x62, 0x01, 0x62, 0x03, 0x01, 0x00, 0x06, 0x32, 0x32,
-0x38, 0x38, 0x1f, 0x1f, 0x06, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x04, 0x54,
-0x04, 0x06, 0x04, 0x23, 0x07, 0x18, 0x00, 0x05, 0x47, 0x21, 0x21, 0x47,
-0x47, 0x00, 0x06, 0x21, 0x00, 0x03, 0x10, 0x16, 0x10, 0x00, 0x09, 0x16,
-0x0c, 0x13, 0x00, 0x09, 0x2a, 0x2a, 0x4c, 0x1f, 0x6e, 0x57, 0x83, 0x6d,
-0x94, 0x00, 0x26, 0x00, 0x00, 0x07, 0xb8, 0x83, 0x6e, 0x57, 0xc0, 0x10,
-0x10, 0x00, 0x07, 0x21, 0x01, 0x47, 0x07, 0x18, 0x03, 0x23, 0x04, 0x06,
-0x05, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x05, 0x08, 0x03, 0x1f, 0x00, 0x04,
-0x38, 0x32, 0x01, 0x32, 0x03, 0x01, 0x00, 0x06, 0x62, 0xb4, 0xbb, 0xb4,
-0xa6, 0xcf, 0x4d, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x07, 0x68, 0x50,
-0x64, 0x5f, 0x72, 0x65, 0x53, 0x00, 0x07, 0x44, 0x06, 0x22, 0x01, 0x4a,
-0x01, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x03, 0x63,
-0x00, 0x07, 0x1e, 0x37, 0x7a, 0x64, 0x55, 0x64, 0xd2, 0x00, 0x2c, 0x00,
-0x00, 0x03, 0x6b, 0xf4, 0x83, 0x00, 0x04, 0x93, 0x01, 0x76, 0x01, 0x52,
-0x05, 0x29, 0x05, 0x27, 0x01, 0x7b, 0x01, 0x5a, 0x05, 0x12, 0x06, 0x02,
-0x04, 0x14, 0x03, 0x0c, 0x03, 0x20, 0x04, 0x04, 0x01, 0x62, 0x01, 0x62,
-0x03, 0x01, 0x03, 0x32, 0x01, 0x38, 0x03, 0x1f, 0x05, 0x08, 0x01, 0x1d,
-0x01, 0x1d, 0x04, 0x54, 0x06, 0x06, 0x01, 0x23, 0x01, 0x23, 0x06, 0x18,
-0x01, 0x47, 0x03, 0x21, 0x01, 0x47, 0x01, 0x47, 0x04, 0x21, 0x04, 0x10,
-0x08, 0x16, 0x0a, 0x13, 0x03, 0x2a, 0x01, 0x13, 0x01, 0x13, 0x04, 0x2a,
-0x00, 0x06, 0x30, 0x8d, 0x57, 0x9e, 0x87, 0x71, 0x25, 0x00, 0x00, 0x07,
-0x69, 0x83, 0x57, 0x57, 0x93, 0x54, 0xbc, 0x00, 0x09, 0x21, 0x01, 0x47,
-0x06, 0x18, 0x04, 0x23, 0x04, 0x06, 0x03, 0x54, 0x03, 0x1d, 0x05, 0x08,
-0x03, 0x1f, 0x00, 0x03, 0x38, 0x32, 0x32, 0x00, 0x04, 0x01, 0x00, 0x06,
-0xaa, 0xbb, 0xb8, 0x82, 0xa8, 0x75, 0x4c, 0x00, 0x00, 0x00, 0x57, 0x00,
-0x00, 0x07, 0xe7, 0x56, 0x55, 0x4e, 0x7a, 0xa5, 0x65, 0x00, 0x07, 0x44,
-0x07, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x03, 0x63,
-0x00, 0x08, 0x30, 0x2e, 0xb4, 0x64, 0x46, 0x3d, 0xeb, 0x11, 0x2b, 0x00,
-0x00, 0x0b, 0x8e, 0xf4, 0x66, 0x6e, 0x93, 0x6e, 0x93, 0x76, 0x52, 0x29,
-0x52, 0x00, 0x04, 0x29, 0x04, 0x27, 0x00, 0x03, 0x7b, 0x7b, 0x5a, 0x00,
-0x04, 0x12, 0x05, 0x02, 0x05, 0x14, 0x03, 0x0c, 0x01, 0x20, 0x01, 0x20,
-0x05, 0x04, 0x01, 0x62, 0x01, 0x62, 0x04, 0x01, 0x00, 0x06, 0x32, 0x32,
-0x38, 0x38, 0x1f, 0x1f, 0x04, 0x08, 0x03, 0x1d, 0x04, 0x54, 0x04, 0x06,
-0x03, 0x23, 0x06, 0x18, 0x01, 0x47, 0x09, 0x21, 0x04, 0x10, 0x06, 0x16,
-0x0a, 0x13, 0x03, 0x2a, 0x01, 0x13, 0x01, 0x13, 0x07, 0x2a, 0x00, 0x07,
-0x41, 0x14, 0x57, 0x57, 0x83, 0x73, 0x96, 0x00, 0x25, 0x00, 0x00, 0x09,
-0x7c, 0xed, 0x83, 0x8d, 0x8d, 0x5a, 0xbc, 0x10, 0x10, 0x00, 0x08, 0x21,
-0x01, 0x47, 0x01, 0x47, 0x03, 0x18, 0x00, 0x03, 0x23, 0x23, 0x18, 0x00,
-0x03, 0x23, 0x04, 0x06, 0x04, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x05, 0x08,
-0x03, 0x1f, 0x00, 0x0c, 0x38, 0x32, 0x32, 0x01, 0x01, 0x32, 0x62, 0xb4,
-0xb8, 0xb4, 0xb4, 0xf1, 0x4c, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x06,
-0xeb, 0x78, 0x46, 0x4e, 0xaf, 0x65, 0x07, 0x44, 0x07, 0x22, 0x04, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x03, 0x1e, 0x06, 0x63, 0x00, 0x05, 0xaf, 0x64,
-0x50, 0x78, 0x90, 0x00, 0x28, 0x00, 0x00, 0x0f, 0x0d, 0x00, 0x00, 0x8e,
-0xf4, 0x5d, 0x6e, 0x93, 0x6e, 0x6e, 0x63, 0x29, 0x29, 0x52, 0x52, 0x00,
-0x03, 0x29, 0x05, 0x27, 0x00, 0x03, 0x7b, 0x5a, 0x5a, 0x00, 0x04, 0x12,
-0x05, 0x02, 0x03, 0x14, 0x00, 0x04, 0x0c, 0x14, 0x0c, 0x0c, 0x03, 0x20,
-0x03, 0x04, 0x03, 0x62, 0x04, 0x01, 0x00, 0x03, 0x32, 0x32, 0x38, 0x00,
-0x03, 0x1f, 0x04, 0x08, 0x03, 0x1d, 0x04, 0x54, 0x05, 0x06, 0x01, 0x23,
-0x01, 0x23, 0x05, 0x18, 0x03, 0x47, 0x07, 0x21, 0x04, 0x10, 0x08, 0x16,
-0x09, 0x13, 0x0d, 0x2a, 0x00, 0x07, 0x0f, 0xf3, 0x40, 0x6e, 0x73, 0x83,
-0xd4, 0x00, 0x26, 0x00, 0x00, 0x09, 0xb6, 0x9e, 0x57, 0x8d, 0x8c, 0x13,
-0x13, 0x10, 0x10, 0x00, 0x08, 0x21, 0x01, 0x47, 0x01, 0x47, 0x06, 0x18,
-0x01, 0x23, 0x01, 0x23, 0x05, 0x06, 0x03, 0x54, 0x03, 0x1d, 0x05, 0x08,
-0x03, 0x1f, 0x00, 0x0e, 0x38, 0x32, 0x32, 0x01, 0x01, 0x32, 0xaf, 0xb8,
-0xb8, 0xb4, 0xf7, 0x6b, 0x00, 0x03, 0x49, 0x00, 0x00, 0x00, 0x58, 0x00,
-0x00, 0x07, 0xec, 0x55, 0x55, 0x64, 0x80, 0xee, 0x65, 0x00, 0x05, 0x44,
-0x07, 0x22, 0x04, 0x4a, 0x05, 0x40, 0x04, 0x2e, 0x03, 0x1e, 0x03, 0x63,
-0x00, 0x08, 0x30, 0x1e, 0x3e, 0xf8, 0x5e, 0x55, 0x78, 0xd9, 0x27, 0x00,
-0x00, 0x0e, 0x03, 0x00, 0x00, 0x75, 0xbb, 0x83, 0x6e, 0x6e, 0x57, 0x6e,
-0x63, 0x29, 0x29, 0x52, 0x04, 0x29, 0x06, 0x27, 0x01, 0x5a, 0x01, 0x5a,
-0x04, 0x12, 0x05, 0x02, 0x04, 0x14, 0x00, 0x03, 0x0c, 0x14, 0x0c, 0x00,
-0x03, 0x20, 0x04, 0x04, 0x01, 0x62, 0x01, 0x62, 0x04, 0x01, 0x01, 0x32,
-0x03, 0x38, 0x01, 0x1f, 0x01, 0x1f, 0x05, 0x08, 0x03, 0x1d, 0x03, 0x54,
-0x03, 0x06, 0x04, 0x23, 0x05, 0x18, 0x01, 0x47, 0x01, 0x47, 0x08, 0x21,
-0x03, 0x10, 0x07, 0x16, 0x08, 0x13, 0x0b, 0x2a, 0x00, 0x03, 0x0f, 0x2a,
-0x2a, 0x00, 0x03, 0x0f, 0x00, 0x0a, 0x2a, 0x41, 0x7b, 0x73, 0x65, 0x6e,
-0xed, 0x9a, 0x00, 0x11, 0x23, 0x00, 0x00, 0x07, 0xb1, 0x6e, 0x57, 0x57,
-0x6e, 0x62, 0xbc, 0x00, 0x05, 0x10, 0x07, 0x21, 0x07, 0x18, 0x00, 0x03,
-0x23, 0x06, 0x23, 0x00, 0x04, 0x06, 0x04, 0x54, 0x01, 0x1d, 0x01, 0x1d,
-0x05, 0x08, 0x00, 0x09, 0x1f, 0x1f, 0x38, 0x38, 0x32, 0x32, 0x01, 0x32,
-0xaa, 0x00, 0x04, 0xaf, 0x00, 0x03, 0x7e, 0x00, 0x11, 0x00, 0x49, 0x00,
-0x00, 0x00, 0x58, 0x00, 0x00, 0x07, 0x71, 0x5f, 0x67, 0x50, 0x5e, 0x82,
-0x65, 0x00, 0x05, 0x44, 0x08, 0x22, 0x03, 0x4a, 0x04, 0x40, 0x04, 0x2e,
-0x05, 0x1e, 0x00, 0x0a, 0x63, 0x63, 0x30, 0x1e, 0x59, 0xfb, 0x50, 0x78,
-0x78, 0xad, 0x26, 0x00, 0x00, 0x0e, 0x03, 0x00, 0x00, 0xb2, 0xed, 0x2d,
-0x6e, 0x6e, 0x57, 0x6e, 0x30, 0x29, 0x29, 0x52, 0x05, 0x29, 0x03, 0x27,
-0x03, 0x7b, 0x01, 0x5a, 0x01, 0x5a, 0x03, 0x12, 0x05, 0x02, 0x05, 0x14,
-0x01, 0x0c, 0x01, 0x0c, 0x03, 0x20, 0x05, 0x04, 0x01, 0x62, 0x05, 0x01,
-0x01, 0x32, 0x01, 0x38, 0x04, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x01, 0x1d,
-0x04, 0x54, 0x03, 0x06, 0x04, 0x23, 0x05, 0x18, 0x01, 0x47, 0x01, 0x47,
-0x08, 0x21, 0x07, 0x16, 0x0b, 0x13, 0x09, 0x2a, 0x0a, 0x0f, 0x00, 0x09,
-0x4c, 0xf3, 0x40, 0x65, 0x22, 0xe5, 0xdb, 0x00, 0x03, 0x00, 0x23, 0x00,
-0x00, 0x07, 0x4d, 0xd4, 0x6d, 0x73, 0x6e, 0x3e, 0xbc, 0x00, 0x03, 0x16,
-0x01, 0x10, 0x01, 0x16, 0x04, 0x21, 0x00, 0x06, 0x47, 0x47, 0x21, 0x21,
-0x47, 0x47, 0x05, 0x18, 0x03, 0x23, 0x04, 0x06, 0x03, 0x54, 0x03, 0x1d,
-0x05, 0x08, 0x00, 0x05, 0x1f, 0x1f, 0x38, 0x38, 0x32, 0x00, 0x03, 0x01,
-0x00, 0x06, 0xaf, 0xa8, 0xa8, 0xb4, 0xcf, 0x71, 0x4a, 0x00, 0x00, 0x00,
-0x59, 0x00, 0x00, 0x07, 0x7d, 0x49, 0x3d, 0x5e, 0xf8, 0x22, 0x53, 0x00,
-0x04, 0x44, 0x06, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x04, 0x2e, 0x04, 0x1e,
-0x00, 0x0b, 0x63, 0x63, 0x30, 0x30, 0x1e, 0x37, 0x78, 0x3d, 0x49, 0x46,
-0xd2, 0x00, 0x25, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x99, 0x44, 0x2d,
-0x57, 0x57, 0x8d, 0x6e, 0x30, 0x29, 0x03, 0x52, 0x05, 0x29, 0x01, 0x27,
-0x01, 0x27, 0x04, 0x7b, 0x01, 0x5a, 0x04, 0x12, 0x04, 0x02, 0x05, 0x14,
-0x01, 0x0c, 0x01, 0x0c, 0x03, 0x20, 0x04, 0x04, 0x03, 0x62, 0x03, 0x01,
-0x01, 0x32, 0x01, 0x32, 0x03, 0x38, 0x01, 0x1f, 0x05, 0x08, 0x01, 0x1d,
-0x01, 0x1d, 0x04, 0x54, 0x03, 0x06, 0x03, 0x23, 0x07, 0x18, 0x01, 0x47,
-0x07, 0x21, 0x01, 0x10, 0x06, 0x16, 0x00, 0x03, 0x13, 0x13, 0x16, 0x00,
-0x07, 0x13, 0x09, 0x2a, 0x0e, 0x0f, 0x00, 0x09, 0x41, 0xb4, 0x44, 0xee,
-0x93, 0xf4, 0x7c, 0x00, 0x26, 0x00, 0x21, 0x00, 0x00, 0x09, 0x4d, 0x00,
-0x96, 0x57, 0x6e, 0x6e, 0x44, 0x54, 0x13, 0x00, 0x03, 0x16, 0x03, 0x10,
-0x03, 0x21, 0x00, 0x06, 0x47, 0x47, 0x21, 0x21, 0x47, 0x47, 0x05, 0x18,
-0x04, 0x23, 0x03, 0x06, 0x03, 0x54, 0x03, 0x1d, 0x05, 0x08, 0x03, 0x1f,
-0x04, 0x32, 0x01, 0xaa, 0x04, 0xa8, 0x01, 0xe7, 0x4a, 0x00, 0x00, 0x00,
-0x59, 0x00, 0x00, 0x07, 0xad, 0x55, 0x49, 0xde, 0x3d, 0x3e, 0x65, 0x00,
-0x03, 0x44, 0x08, 0x22, 0x03, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x04, 0x1e,
-0x00, 0x0b, 0x63, 0x63, 0x30, 0x30, 0x1e, 0x7b, 0x3d, 0x3d, 0x0f, 0x9d,
-0x6b, 0x00, 0x27, 0x00, 0x00, 0x09, 0x96, 0x73, 0x2d, 0x57, 0x57, 0x8d,
-0x6e, 0x30, 0x29, 0x00, 0x03, 0x52, 0x05, 0x29, 0x03, 0x27, 0x03, 0x7b,
-0x00, 0x04, 0x5a, 0x7b, 0x12, 0x12, 0x06, 0x02, 0x04, 0x14, 0x03, 0x0c,
-0x03, 0x20, 0x04, 0x04, 0x01, 0x62, 0x01, 0x62, 0x04, 0x01, 0x00, 0x05,
-0x32, 0x38, 0x38, 0x1f, 0x1f, 0x00, 0x05, 0x08, 0x01, 0x1d, 0x04, 0x54,
-0x04, 0x06, 0x03, 0x23, 0x05, 0x18, 0x03, 0x47, 0x06, 0x21, 0x03, 0x10,
-0x06, 0x16, 0x09, 0x13, 0x07, 0x2a, 0x0e, 0x0f, 0x00, 0x0c, 0x4c, 0x0f,
-0x0f, 0x4c, 0xf8, 0xed, 0xee, 0xed, 0x8c, 0x96, 0x00, 0x26, 0x21, 0x00,
-0x00, 0x09, 0x03, 0x00, 0x8e, 0xb8, 0x83, 0x65, 0x73, 0x27, 0xbc, 0x00,
-0x04, 0x16, 0x03, 0x10, 0x07, 0x21, 0x01, 0x47, 0x01, 0x47, 0x06, 0x18,
-0x03, 0x23, 0x03, 0x06, 0x03, 0x54, 0x03, 0x1d, 0x05, 0x08, 0x03, 0x1f,
-0x03, 0x32, 0x00, 0x06, 0x62, 0xa8, 0xa8, 0x72, 0xaf, 0x8b, 0x4a, 0x00,
-0x00, 0x00, 0x59, 0x00, 0x00, 0x0a, 0x4d, 0xfa, 0x2a, 0x78, 0xde, 0xaf,
-0x53, 0x53, 0x44, 0x44, 0x06, 0x22, 0x06, 0x4a, 0x03, 0x40, 0x04, 0x2e,
-0x04, 0x1e, 0x03, 0x63, 0x00, 0x09, 0x30, 0x63, 0x63, 0x12, 0x67, 0x67,
-0x2a, 0xeb, 0xa3, 0x00, 0x26, 0x00, 0x00, 0x03, 0x99, 0x65, 0x6d, 0x00,
-0x03, 0x6e, 0x00, 0x03, 0x93, 0x3e, 0x29, 0x00, 0x04, 0x52, 0x04, 0x29,
-0x05, 0x27, 0x00, 0x03, 0x7b, 0x5a, 0x5a, 0x00, 0x03, 0x12, 0x05, 0x02,
-0x04, 0x14, 0x03, 0x0c, 0x03, 0x20, 0x03, 0x04, 0x03, 0x62, 0x00, 0x07,
-0x01, 0x62, 0x01, 0x32, 0x01, 0x38, 0x38, 0x00, 0x03, 0x1f, 0x04, 0x08,
-0x01, 0x1d, 0x01, 0x1d, 0x04, 0x54, 0x03, 0x06, 0x03, 0x23, 0x05, 0x18,
-0x01, 0x47, 0x01, 0x47, 0x08, 0x21, 0x01, 0x10, 0x01, 0x10, 0x05, 0x16,
-0x07, 0x13, 0x08, 0x2a, 0x11, 0x0f, 0x00, 0x0b, 0x4c, 0x0f, 0x0f, 0x4c,
-0x0f, 0x82, 0xed, 0xa5, 0x8c, 0xf7, 0x71, 0x00, 0x23, 0x00, 0x00, 0x09,
-0x03, 0x00, 0xdb, 0x57, 0x65, 0x73, 0x63, 0x16, 0x13, 0x00, 0x05, 0x16,
-0x01, 0x10, 0x01, 0x10, 0x08, 0x21, 0x01, 0x47, 0x01, 0x47, 0x03, 0x18,
-0x01, 0x58, 0x01, 0x18, 0x03, 0x23, 0x04, 0x06, 0x03, 0x54, 0x01, 0x1d,
-0x01, 0x1d, 0x05, 0x08, 0x00, 0x03, 0x1f, 0x38, 0x38, 0x00, 0x03, 0x32,
-0x00, 0x06, 0xc1, 0xa8, 0x72, 0xa8, 0x81, 0x8e, 0x49, 0x00, 0x00, 0x00,
-0x5a, 0x00, 0x00, 0x09, 0xec, 0x2a, 0x49, 0x3d, 0xfb, 0x4a, 0x53, 0x44,
-0x44, 0x00, 0x07, 0x22, 0x03, 0x4a, 0x05, 0x40, 0x04, 0x2e, 0x03, 0x1e,
-0x04, 0x63, 0x03, 0x30, 0x00, 0x06, 0xaa, 0x49, 0x41, 0x16, 0x90, 0x11,
-0x25, 0x00, 0x00, 0x03, 0x75, 0xed, 0x83, 0x00, 0x03, 0x73, 0x00, 0x04,
-0x53, 0x59, 0x29, 0x37, 0x04, 0x52, 0x04, 0x29, 0x04, 0x27, 0x00, 0x03,
-0x7b, 0x5a, 0x5a, 0x00, 0x04, 0x12, 0x05, 0x02, 0x03, 0x14, 0x04, 0x0c,
-0x03, 0x20, 0x03, 0x04, 0x01, 0x62, 0x01, 0x62, 0x04, 0x01, 0x00, 0x05,
-0x32, 0x32, 0x38, 0x38, 0x1f, 0x00, 0x05, 0x08, 0x01, 0x1d, 0x01, 0x1d,
-0x04, 0x54, 0x03, 0x06, 0x03, 0x23, 0x05, 0x18, 0x00, 0x06, 0x47, 0x47,
-0x21, 0x21, 0x47, 0x47, 0x03, 0x21, 0x03, 0x10, 0x05, 0x16, 0x07, 0x13,
-0x07, 0x2a, 0x0e, 0x0f, 0x01, 0x4c, 0x01, 0x4c, 0x04, 0x0f, 0x03, 0x4c,
-0x00, 0x07, 0x41, 0xc1, 0x82, 0x82, 0xa5, 0x82, 0x9a, 0x00, 0x23, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0x75, 0xed, 0x6e, 0x65, 0x53, 0xaa, 0xbc, 0x13,
-0x06, 0x16, 0x03, 0x10, 0x05, 0x21, 0x03, 0x47, 0x04, 0x18, 0x04, 0x23,
-0x03, 0x06, 0x04, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x04, 0x08, 0x03, 0x1f,
-0x00, 0x09, 0x38, 0x32, 0x32, 0x01, 0x72, 0x74, 0x72, 0xc1, 0x7e, 0x00,
-0x49, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x0a, 0xa3, 0x9d, 0x13, 0x67,
-0x49, 0xb4, 0x53, 0x44, 0x22, 0x44, 0x04, 0x22, 0x01, 0x4a, 0x01, 0x22,
-0x03, 0x4a, 0x05, 0x40, 0x03, 0x2e, 0x04, 0x1e, 0x03, 0x63, 0x00, 0x09,
-0x30, 0x30, 0x63, 0x30, 0xaa, 0x41, 0x0f, 0x47, 0x7d, 0x00, 0x25, 0x00,
-0x00, 0x0b, 0x11, 0xd4, 0x83, 0x65, 0x53, 0x65, 0x22, 0x5c, 0x52, 0x37,
-0x37, 0x00, 0x03, 0x52, 0x05, 0x29, 0x00, 0x06, 0x27, 0x27, 0x7b, 0x27,
-0x7b, 0x5a, 0x04, 0x12, 0x05, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x03, 0x20,
-0x03, 0x04, 0x03, 0x62, 0x01, 0x01, 0x01, 0x62, 0x03, 0x01, 0x01, 0x38,
-0x03, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x04, 0x54, 0x04, 0x06,
-0x01, 0x23, 0x01, 0x23, 0x05, 0x18, 0x01, 0x47, 0x01, 0x47, 0x06, 0x21,
-0x03, 0x10, 0x05, 0x16, 0x06, 0x13, 0x00, 0x03, 0x2a, 0x2a, 0x13, 0x00,
-0x06, 0x2a, 0x0d, 0x0f, 0x00, 0x06, 0x4c, 0x4c, 0x0f, 0x4c, 0x4c, 0x0f,
-0x05, 0x4c, 0x00, 0x08, 0x41, 0x4c, 0xb4, 0x82, 0x82, 0x63, 0xea, 0x0d,
-0x25, 0x00, 0x00, 0x05, 0x6a, 0x6e, 0x53, 0x65, 0x5c, 0x00, 0x03, 0x13,
-0x01, 0x16, 0x01, 0x13, 0x04, 0x16, 0x03, 0x10, 0x06, 0x21, 0x00, 0x0a,
-0x47, 0x47, 0x18, 0x18, 0x23, 0x18, 0x18, 0x23, 0x06, 0x23, 0x03, 0x06,
-0x04, 0x54, 0x01, 0x1d, 0x05, 0x08, 0x03, 0x1f, 0x00, 0x09, 0x38, 0x32,
-0x32, 0xc1, 0x88, 0x88, 0x72, 0xcc, 0x71, 0x00, 0x48, 0x00, 0x00, 0x00,
-0x59, 0x00, 0x00, 0x09, 0x03, 0x00, 0x7d, 0x18, 0x4c, 0x41, 0xf8, 0x44,
-0x44, 0x00, 0x06, 0x22, 0x05, 0x4a, 0x04, 0x40, 0x04, 0x2e, 0x03, 0x1e,
-0x03, 0x63, 0x05, 0x30, 0x00, 0x05, 0xaa, 0x4c, 0x2a, 0x23, 0xd9, 0x00,
-0x23, 0x00, 0x00, 0x0c, 0x11, 0x00, 0x7e, 0x53, 0x53, 0x44, 0x44, 0x4a,
-0x5c, 0x52, 0x37, 0x37, 0x03, 0x52, 0x05, 0x29, 0x00, 0x05, 0x27, 0x27,
-0x7b, 0x7b, 0x27, 0x00, 0x03, 0x5a, 0x03, 0x12, 0x04, 0x02, 0x05, 0x14,
-0x03, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x05, 0x04, 0x01, 0x62, 0x03, 0x01,
-0x03, 0x32, 0x00, 0x03, 0x38, 0x1f, 0x1f, 0x00, 0x05, 0x08, 0x01, 0x1d,
-0x04, 0x54, 0x03, 0x06, 0x03, 0x23, 0x05, 0x18, 0x01, 0x47, 0x01, 0x47,
-0x06, 0x21, 0x01, 0x10, 0x01, 0x10, 0x07, 0x16, 0x05, 0x13, 0x08, 0x2a,
-0x0d, 0x0f, 0x01, 0x4c, 0x01, 0x0f, 0x0b, 0x4c, 0x00, 0x08, 0x41, 0x41,
-0xc1, 0xbb, 0xbb, 0x82, 0xb8, 0x8e, 0x25, 0x00, 0x00, 0x07, 0xb1, 0xee,
-0x93, 0x44, 0xee, 0x1f, 0xbc, 0x00, 0x03, 0x13, 0x06, 0x16, 0x01, 0x10,
-0x07, 0x21, 0x01, 0x18, 0x01, 0x47, 0x05, 0x18, 0x01, 0x23, 0x01, 0x23,
-0x04, 0x06, 0x04, 0x54, 0x01, 0x1d, 0x05, 0x08, 0x00, 0x0b, 0x1f, 0x1f,
-0x38, 0x32, 0x32, 0xf8, 0x88, 0x88, 0x74, 0x74, 0xe7, 0x00, 0x48, 0x00,
-0x00, 0x00, 0x59, 0x00, 0x00, 0x09, 0x11, 0x00, 0xad, 0x5e, 0x16, 0x41,
-0x2a, 0x59, 0x53, 0x00, 0x05, 0x22, 0x01, 0x4a, 0x01, 0x22, 0x04, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x03, 0x1e, 0x04, 0x63, 0x00, 0x09, 0x30, 0x30,
-0x63, 0x30, 0x1f, 0x2a, 0x13, 0x06, 0xd9, 0x00, 0x25, 0x00, 0x00, 0x09,
-0x8a, 0xe5, 0xed, 0xee, 0xee, 0x5c, 0x52, 0x37, 0x37, 0x00, 0x05, 0x52,
-0x03, 0x29, 0x04, 0x27, 0x01, 0x7b, 0x03, 0x5a, 0x03, 0x12, 0x05, 0x02,
-0x04, 0x14, 0x03, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x05, 0x04, 0x01, 0x62,
-0x04, 0x01, 0x00, 0x05, 0x32, 0x38, 0x38, 0x1f, 0x1f, 0x00, 0x05, 0x08,
-0x01, 0x1d, 0x01, 0x1d, 0x03, 0x54, 0x03, 0x06, 0x03, 0x23, 0x05, 0x18,
-0x01, 0x47, 0x01, 0x47, 0x06, 0x21, 0x01, 0x10, 0x01, 0x10, 0x06, 0x16,
-0x08, 0x13, 0x03, 0x2a, 0x01, 0x0f, 0x01, 0x2a, 0x05, 0x0f, 0x01, 0x4c,
-0x05, 0x0f, 0x0c, 0x4c, 0x07, 0x41, 0x00, 0x06, 0xfb, 0xb8, 0xb8, 0xb4,
-0xb4, 0x7e, 0x26, 0x00, 0x00, 0x06, 0xf4, 0x93, 0x22, 0x44, 0x12, 0x2a,
-0x05, 0x13, 0x00, 0x04, 0x16, 0x16, 0x13, 0x16, 0x03, 0x10, 0x06, 0x21,
-0x03, 0x47, 0x04, 0x18, 0x03, 0x23, 0x03, 0x06, 0x03, 0x54, 0x01, 0x1d,
-0x01, 0x1d, 0x05, 0x08, 0x00, 0x0a, 0x1f, 0x1f, 0x38, 0x32, 0x1f, 0x74,
-0x81, 0x81, 0x74, 0xd0, 0x48, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x06,
-0xfa, 0x06, 0x4c, 0x0f, 0xaa, 0x44, 0x07, 0x22, 0x04, 0x4a, 0x03, 0x40,
-0x05, 0x2e, 0x03, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x05, 0x30, 0x00, 0x06,
-0x3e, 0x1f, 0x13, 0x16, 0xe1, 0xd9, 0x22, 0x00, 0x00, 0x09, 0x03, 0x00,
-0x8e, 0xd4, 0x8c, 0xed, 0xed, 0x3e, 0x52, 0x00, 0x03, 0x37, 0x04, 0x52,
-0x03, 0x29, 0x00, 0x08, 0x27, 0x27, 0x7b, 0x27, 0x27, 0x7b, 0x5a, 0x5a,
-0x03, 0x12, 0x05, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x03, 0x20, 0x00, 0x05,
-0x04, 0x04, 0x62, 0x04, 0x62, 0x00, 0x04, 0x01, 0x00, 0x05, 0x32, 0x32,
-0x38, 0x38, 0x1f, 0x00, 0x05, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x03, 0x54,
-0x04, 0x06, 0x00, 0x03, 0x23, 0x06, 0x23, 0x00, 0x04, 0x18, 0x01, 0x47,
-0x01, 0x47, 0x07, 0x21, 0x01, 0x10, 0x06, 0x16, 0x05, 0x13, 0x01, 0x2a,
-0x01, 0x13, 0x05, 0x2a, 0x09, 0x0f, 0x00, 0x03, 0x4c, 0x0f, 0x0f, 0x00,
-0x09, 0x4c, 0x0c, 0x41, 0x00, 0x06, 0xc1, 0xb8, 0xaf, 0xb4, 0xf7, 0x03,
-0x25, 0x00, 0x00, 0x07, 0x69, 0x65, 0x44, 0xee, 0xa5, 0xf3, 0xbc, 0x00,
-0x03, 0x13, 0x07, 0x16, 0x01, 0x10, 0x01, 0x10, 0x03, 0x21, 0x00, 0x05,
-0x47, 0x21, 0x21, 0x47, 0x47, 0x00, 0x05, 0x18, 0x01, 0x23, 0x01, 0x23,
-0x04, 0x06, 0x03, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x05, 0x08, 0x00, 0x0a,
-0x1f, 0x1f, 0x38, 0x32, 0xf8, 0x81, 0x91, 0x74, 0x8f, 0x8e, 0x47, 0x00,
-0x00, 0x00, 0x5a, 0x00, 0x00, 0x09, 0x03, 0x00, 0xec, 0x0f, 0x47, 0x2a,
-0x54, 0x63, 0x44, 0x00, 0x05, 0x22, 0x05, 0x4a, 0x01, 0x40, 0x01, 0x40,
-0x05, 0x2e, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x05, 0x30, 0x00, 0x06,
-0x3e, 0x01, 0x10, 0x21, 0xe1, 0xd9, 0x22, 0x00, 0x00, 0x08, 0x11, 0x00,
-0xad, 0xf4, 0x4a, 0xa5, 0xa5, 0x5c, 0x03, 0x37, 0x04, 0x52, 0x04, 0x29,
-0x00, 0x08, 0x27, 0x7b, 0x27, 0x27, 0x7b, 0x7b, 0x5a, 0x5a, 0x03, 0x12,
-0x04, 0x02, 0x04, 0x14, 0x00, 0x06, 0x0c, 0x14, 0x0c, 0x0c, 0x20, 0x20,
-0x03, 0x04, 0x00, 0x03, 0x62, 0x04, 0x62, 0x00, 0x04, 0x01, 0x00, 0x05,
-0x32, 0x38, 0x38, 0x1f, 0x1f, 0x00, 0x05, 0x08, 0x01, 0x1d, 0x04, 0x54,
-0x03, 0x06, 0x00, 0x04, 0x23, 0x06, 0x23, 0x58, 0x03, 0x18, 0x00, 0x04,
-0x47, 0x47, 0x21, 0x47, 0x04, 0x21, 0x03, 0x10, 0x05, 0x16, 0x04, 0x13,
-0x00, 0x03, 0x2a, 0x13, 0x13, 0x00, 0x04, 0x2a, 0x07, 0x0f, 0x01, 0x4c,
-0x03, 0x0f, 0x08, 0x4c, 0x10, 0x41, 0x00, 0x06, 0xfb, 0xa8, 0xa8, 0xaf,
-0xa8, 0xe7, 0x25, 0x00, 0x00, 0x08, 0x8e, 0x82, 0x8c, 0xee, 0xee, 0xaa,
-0xbc, 0x2a, 0x04, 0x13, 0x05, 0x16, 0x04, 0x10, 0x05, 0x21, 0x01, 0x47,
-0x01, 0x47, 0x04, 0x18, 0x04, 0x23, 0x01, 0x06, 0x01, 0x06, 0x04, 0x54,
-0x01, 0x1d, 0x01, 0x1d, 0x04, 0x08, 0x03, 0x1f, 0x00, 0x07, 0x32, 0x1f,
-0x91, 0x6c, 0x91, 0x91, 0x7d, 0x00, 0x47, 0x00, 0x00, 0x00, 0x5c, 0x00,
-0x00, 0x07, 0x0d, 0x9d, 0xe1, 0x21, 0x10, 0x27, 0x53, 0x00, 0x05, 0x22,
-0x03, 0x4a, 0x04, 0x40, 0x05, 0x2e, 0x04, 0x1e, 0x00, 0x03, 0x63, 0x30,
-0x63, 0x00, 0x03, 0x30, 0x00, 0x07, 0x63, 0x3e, 0x38, 0x10, 0x47, 0xe1,
-0xd9, 0x00, 0x22, 0x00, 0x00, 0x08, 0x11, 0x00, 0x7c, 0xd4, 0x63, 0x82,
-0x82, 0x5c, 0x03, 0x37, 0x03, 0x52, 0x05, 0x29, 0x04, 0x27, 0x00, 0x03,
-0x7b, 0x7b, 0x5a, 0x00, 0x04, 0x12, 0x04, 0x02, 0x04, 0x14, 0x03, 0x0c,
-0x01, 0x20, 0x01, 0x20, 0x05, 0x04, 0x01, 0x62, 0x01, 0x62, 0x03, 0x01,
-0x00, 0x06, 0x32, 0x32, 0x38, 0x38, 0x1f, 0x1f, 0x04, 0x08, 0x01, 0x1d,
-0x01, 0x1d, 0x03, 0x54, 0x03, 0x06, 0x03, 0x23, 0x00, 0x06, 0x18, 0x58,
-0x18, 0x18, 0x47, 0x47, 0x07, 0x21, 0x01, 0x10, 0x06, 0x16, 0x07, 0x13,
-0x04, 0x2a, 0x09, 0x0f, 0x01, 0x4c, 0x01, 0x0f, 0x06, 0x4c, 0x0e, 0x41,
-0x00, 0x03, 0x49, 0x41, 0x41, 0x00, 0x03, 0x49, 0x00, 0x05, 0x74, 0x72,
-0x72, 0xaf, 0xd0, 0x00, 0x26, 0x00, 0x00, 0x07, 0xdb, 0x93, 0xee, 0xed,
-0x37, 0x2a, 0x2a, 0x00, 0x05, 0x13, 0x05, 0x16, 0x01, 0x10, 0x01, 0x10,
-0x04, 0x21, 0x00, 0x05, 0x47, 0x21, 0x21, 0x47, 0x47, 0x00, 0x05, 0x18,
-0x01, 0x23, 0x04, 0x06, 0x03, 0x54, 0x03, 0x1d, 0x04, 0x08, 0x00, 0x0a,
-0x1f, 0x1f, 0x38, 0x32, 0x74, 0x8f, 0x6c, 0x91, 0xeb, 0x71, 0x46, 0x00,
-0x00, 0x00, 0x5d, 0x00, 0x00, 0x07, 0xd9, 0x18, 0x06, 0x10, 0x38, 0x40,
-0x44, 0x00, 0x03, 0x22, 0x05, 0x4a, 0x03, 0x40, 0x05, 0x2e, 0x03, 0x1e,
-0x00, 0x04, 0x63, 0x63, 0x30, 0x63, 0x04, 0x30, 0x00, 0x06, 0x3e, 0x01,
-0x47, 0x23, 0xe1, 0xd9, 0x22, 0x00, 0x00, 0x07, 0x03, 0x00, 0x71, 0x8a,
-0x63, 0xbb, 0xbb, 0x00, 0x03, 0x37, 0x05, 0x52, 0x04, 0x29, 0x01, 0x27,
-0x01, 0x27, 0x03, 0x7b, 0x01, 0x5a, 0x01, 0x5a, 0x03, 0x12, 0x04, 0x02,
-0x05, 0x14, 0x01, 0x0c, 0x01, 0x14, 0x03, 0x20, 0x05, 0x04, 0x03, 0x01,
-0x03, 0x32, 0x01, 0x38, 0x03, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x01, 0x1d,
-0x03, 0x54, 0x03, 0x06, 0x03, 0x23, 0x05, 0x18, 0x01, 0x47, 0x06, 0x21,
-0x01, 0x10, 0x01, 0x10, 0x05, 0x16, 0x05, 0x13, 0x06, 0x2a, 0x0a, 0x0f,
-0x07, 0x4c, 0x0b, 0x41, 0x0a, 0x49, 0x00, 0x07, 0x41, 0x80, 0x88, 0x88,
-0x72, 0x8f, 0xad, 0x00, 0x25, 0x00, 0x00, 0x09, 0x9a, 0xed, 0xee, 0xed,
-0xa5, 0xf8, 0x2a, 0x13, 0x2a, 0x00, 0x04, 0x13, 0x00, 0x07, 0x16, 0x16,
-0x13, 0x16, 0x16, 0x10, 0x10, 0x00, 0x07, 0x21, 0x01, 0x47, 0x01, 0x47,
-0x04, 0x18, 0x01, 0x23, 0x01, 0x23, 0x04, 0x06, 0x03, 0x54, 0x01, 0x1d,
-0x01, 0x1d, 0x04, 0x08, 0x03, 0x1f, 0x00, 0x09, 0x32, 0xf8, 0x7a, 0x8f,
-0x77, 0x8f, 0xec, 0x00, 0x0d, 0x00, 0x44, 0x00, 0x00, 0x00, 0x5d, 0x00,
-0x00, 0x07, 0x6b, 0x55, 0xe1, 0x18, 0x47, 0x5c, 0x44, 0x00, 0x04, 0x22,
-0x04, 0x4a, 0x04, 0x40, 0x03, 0x2e, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63,
-0x06, 0x30, 0x00, 0x06, 0x3e, 0x04, 0x18, 0x06, 0xe1, 0x7d, 0x23, 0x00,
-0x00, 0x09, 0x03, 0x00, 0x8b, 0xa6, 0xb8, 0xbb, 0xb4, 0x37, 0x37, 0x00,
-0x05, 0x52, 0x01, 0x29, 0x01, 0x29, 0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a,
-0x01, 0x5a, 0x04, 0x12, 0x04, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x03, 0x20,
-0x03, 0x04, 0x01, 0x62, 0x01, 0x62, 0x03, 0x01, 0x00, 0x06, 0x32, 0x32,
-0x38, 0x38, 0x1f, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x03, 0x54,
-0x03, 0x06, 0x03, 0x23, 0x04, 0x18, 0x01, 0x47, 0x01, 0x47, 0x06, 0x21,
-0x03, 0x10, 0x04, 0x16, 0x04, 0x13, 0x00, 0x03, 0x2a, 0x2a, 0x13, 0x00,
-0x04, 0x2a, 0x0a, 0x0f, 0x06, 0x4c, 0x0a, 0x41, 0x0e, 0x49, 0x00, 0x06,
-0x67, 0x91, 0x81, 0x80, 0x74, 0x7d, 0x25, 0x00, 0x00, 0x07, 0x71, 0x8a,
-0x8c, 0xa5, 0xa5, 0xb4, 0x0f, 0x00, 0x03, 0x2a, 0x05, 0x13, 0x05, 0x16,
-0x01, 0x10, 0x01, 0x10, 0x03, 0x21, 0x00, 0x09, 0x47, 0x21, 0x21, 0x47,
-0x18, 0x18, 0x58, 0x18, 0x18, 0x00, 0x03, 0x23, 0x03, 0x06, 0x04, 0x54,
-0x01, 0x1d, 0x05, 0x08, 0x00, 0x09, 0x1f, 0x38, 0x38, 0x91, 0xcc, 0xcc,
-0x7a, 0x90, 0x0d, 0x00, 0x45, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x09,
-0xfa, 0xe1, 0x06, 0x21, 0x14, 0x4a, 0x44, 0x22, 0x22, 0x00, 0x04, 0x4a,
-0x04, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x04, 0x30,
-0x03, 0x3e, 0x00, 0x05, 0x0c, 0x23, 0x06, 0xe1, 0x68, 0x00, 0x23, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0xad, 0xa8, 0xb4, 0xb8, 0xb8, 0xb4, 0x52, 0x37,
-0x05, 0x52, 0x01, 0x29, 0x01, 0x29, 0x05, 0x27, 0x03, 0x5a, 0x03, 0x12,
-0x05, 0x02, 0x00, 0x03, 0x14, 0x14, 0x02, 0x00, 0x03, 0x0c, 0x01, 0x20,
-0x01, 0x20, 0x05, 0x04, 0x04, 0x01, 0x00, 0x05, 0x32, 0x32, 0x38, 0x38,
-0x1f, 0x00, 0x05, 0x08, 0x04, 0x1d, 0x05, 0x06, 0x04, 0x23, 0x01, 0x18,
-0x03, 0x47, 0x01, 0x21, 0x04, 0x47, 0x00, 0x03, 0x21, 0x10, 0x10, 0x00,
-0x05, 0x16, 0x07, 0x13, 0x05, 0x2a, 0x09, 0x0f, 0x01, 0x4c, 0x01, 0x0f,
-0x05, 0x4c, 0x0b, 0x41, 0x00, 0x03, 0x49, 0x49, 0x41, 0x00, 0x0a, 0x49,
-0x00, 0x08, 0x91, 0x6c, 0x6c, 0x80, 0xeb, 0xa3, 0x00, 0x0d, 0x23, 0x00,
-0x00, 0x07, 0x7e, 0x4a, 0xa5, 0x82, 0x82, 0xf8, 0x4c, 0x00, 0x04, 0x2a,
-0x06, 0x13, 0x03, 0x16, 0x03, 0x10, 0x00, 0x04, 0x21, 0x21, 0x47, 0x21,
-0x04, 0x47, 0x01, 0x18, 0x04, 0x23, 0x04, 0x06, 0x01, 0x54, 0x03, 0x1d,
-0x04, 0x08, 0x03, 0x38, 0x00, 0x09, 0x04, 0xf8, 0xcc, 0xcc, 0x60, 0x9d,
-0xad, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x08,
-0xad, 0x06, 0xe1, 0x06, 0x06, 0x30, 0x44, 0x22, 0x04, 0x4a, 0x05, 0x40,
-0x03, 0x2e, 0x04, 0x1e, 0x04, 0x63, 0x03, 0x30, 0x03, 0x3e, 0x00, 0x06,
-0x02, 0x06, 0x1d, 0xe1, 0xfa, 0x0d, 0x25, 0x00, 0x00, 0x08, 0x69, 0xb4,
-0xb4, 0xaf, 0xa8, 0xaf, 0xb4, 0x7b, 0x03, 0x27, 0x05, 0x7b, 0x05, 0x12,
-0x00, 0x03, 0x14, 0x12, 0x12, 0x00, 0x05, 0x14, 0x0b, 0xaa, 0x00, 0x06,
-0x62, 0x62, 0x01, 0x1f, 0x01, 0x01, 0x05, 0x1f, 0x01, 0x54, 0x01, 0x1f,
-0x08, 0x54, 0x0b, 0xb7, 0x03, 0x16, 0x00, 0x03, 0xf3, 0x16, 0x16, 0x00,
-0x03, 0x13, 0x04, 0xf3, 0x04, 0x2a, 0x06, 0x0f, 0x08, 0xfb, 0x01, 0x4c,
-0x01, 0x4c, 0x04, 0x41, 0x09, 0x49, 0x06, 0x67, 0x0f, 0x78, 0x01, 0x55,
-0x04, 0x8f, 0x00, 0x03, 0xec, 0x00, 0x03, 0x00, 0x23, 0x00, 0x00, 0x07,
-0x6b, 0xd4, 0x4a, 0x82, 0x82, 0xbb, 0xc1, 0x00, 0x0c, 0xf3, 0x08, 0xb7,
-0x01, 0x16, 0x10, 0xb7, 0x00, 0x0e, 0x54, 0x54, 0xb7, 0x54, 0x54, 0xb7,
-0x54, 0x54, 0xf8, 0x77, 0xa7, 0xa7, 0x77, 0x7d, 0x45, 0x00, 0x00, 0x00,
-0x5e, 0x00, 0x00, 0x08, 0x0d, 0xa7, 0xc6, 0x1d, 0x06, 0x29, 0x22, 0x22,
-0x04, 0x4a, 0x05, 0x40, 0x03, 0x2e, 0x04, 0x1e, 0x04, 0x63, 0x01, 0x30,
-0x01, 0x30, 0x04, 0x3e, 0x00, 0x06, 0x7b, 0x1d, 0x1d, 0xc6, 0xeb, 0x71,
-0x25, 0x00, 0x00, 0x04, 0x26, 0xea, 0xb4, 0xaf, 0x11, 0xa8, 0x11, 0x72,
-0x10, 0x74, 0x13, 0x80, 0x12, 0x91, 0x0f, 0x7a, 0x0f, 0x77, 0x0b, 0x60,
-0x05, 0x4e, 0x03, 0x56, 0x00, 0x05, 0x48, 0xa7, 0xa7, 0x77, 0x7d, 0x00,
-0x24, 0x00, 0x00, 0x08, 0x11, 0x00, 0x7e, 0xa5, 0x63, 0x82, 0x82, 0xbb,
-0x05, 0xb4, 0x08, 0xaf, 0x03, 0xc1, 0x00, 0x03, 0xa8, 0xa8, 0xc1, 0x00,
-0x05, 0x72, 0x04, 0x74, 0x05, 0x80, 0x05, 0x91, 0x03, 0x7a, 0x04, 0x77,
-0x00, 0x07, 0x60, 0x56, 0xa7, 0x9d, 0x4e, 0xfa, 0x6b, 0x00, 0x44, 0x00,
-0x00, 0x00, 0x5f, 0x00, 0x00, 0x07, 0xec, 0xe1, 0x38, 0x1d, 0x32, 0x40,
-0x22, 0x00, 0x03, 0x4a, 0x05, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x01, 0x63,
-0x01, 0x63, 0x04, 0x30, 0x04, 0x3e, 0x00, 0x06, 0x29, 0x08, 0x08, 0xc6,
-0x8f, 0x6b, 0x26, 0x00, 0x00, 0x05, 0x4d, 0xd0, 0x72, 0xc1, 0x72, 0x00,
-0x10, 0x88, 0x10, 0x81, 0x01, 0x6c, 0x03, 0x81, 0x15, 0x6c, 0x17, 0x8f,
-0x13, 0xcc, 0x0f, 0xa7, 0x17, 0x9d, 0x01, 0x77, 0x01, 0x7d, 0x24, 0x00,
-0x00, 0x06, 0x0d, 0x00, 0x00, 0x69, 0xbb, 0x1e, 0x05, 0xbb, 0x08, 0xb8,
-0x07, 0xa8, 0x01, 0x72, 0x01, 0x72, 0x05, 0x88, 0x04, 0x81, 0x04, 0x6c,
-0x04, 0x8f, 0x04, 0xcc, 0x03, 0xa7, 0x05, 0x9d, 0x00, 0x03, 0x60, 0xfa,
-0xa3, 0x00, 0x44, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x0a, 0x6b, 0x7a,
-0xc6, 0x08, 0x08, 0x5c, 0x22, 0x22, 0x4a, 0x4a, 0x05, 0x40, 0x04, 0x2e,
-0x03, 0x1e, 0x04, 0x63, 0x01, 0x30, 0x01, 0x30, 0x05, 0x3e, 0x00, 0x06,
-0x37, 0x38, 0x38, 0xc6, 0xf8, 0xd2, 0x28, 0x00, 0x00, 0x04, 0xd9, 0xcf,
-0x81, 0xc1, 0x08, 0x72, 0x11, 0x74, 0x03, 0x80, 0x01, 0x74, 0x0f, 0x80,
-0x01, 0x91, 0x01, 0x80, 0x11, 0x91, 0x0d, 0x7a, 0x0d, 0x77, 0x00, 0x03,
-0x64, 0x77, 0x64, 0x00, 0x2b, 0x60, 0x00, 0x05, 0x64, 0xeb, 0xad, 0x00,
-0x03, 0x00, 0x23, 0x00, 0x00, 0x07, 0x03, 0x00, 0x00, 0xb1, 0xd4, 0xbb,
-0x3e, 0x00, 0x03, 0xa6, 0x01, 0x82, 0x01, 0x37, 0x08, 0xb4, 0x06, 0xaf,
-0x05, 0xc1, 0x03, 0x72, 0x04, 0x74, 0x03, 0x80, 0x04, 0x91, 0x03, 0x7a,
-0x01, 0x77, 0x01, 0x77, 0x05, 0x60, 0x00, 0x05, 0x64, 0x48, 0xec, 0x00,
-0x0d, 0x00, 0x43, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x07, 0x68, 0xe0,
-0x32, 0x08, 0x02, 0x22, 0x22, 0x00, 0x03, 0x4a, 0x03, 0x40, 0x04, 0x2e,
-0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x04, 0x30, 0x05, 0x3e, 0x00, 0x06,
-0x5c, 0x04, 0x38, 0xc6, 0x04, 0xad, 0x29, 0x00, 0x00, 0x03, 0x71, 0xec,
-0x7d, 0x00, 0x19, 0xd0, 0x0f, 0x8b, 0x20, 0x90, 0x3e, 0x68, 0x00, 0x03,
-0x90, 0x7d, 0xad, 0x00, 0x2a, 0x00, 0x00, 0x03, 0x6b, 0x7e, 0xf1, 0x00,
-0x09, 0xcf, 0x0d, 0xea, 0x0a, 0xd0, 0x04, 0x8b, 0x05, 0x90, 0x08, 0x68,
-0x01, 0xe7, 0x46, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x09, 0xad, 0xf8,
-0xc6, 0x38, 0x04, 0x30, 0x22, 0x4a, 0x4a, 0x00, 0x04, 0x40, 0x04, 0x2e,
-0x03, 0x1e, 0x03, 0x63, 0x04, 0x30, 0x05, 0x3e, 0x00, 0x06, 0x5c, 0x0c,
-0x32, 0xc6, 0xc6, 0xd9, 0x2d, 0x00, 0x14, 0x4d, 0x08, 0x11, 0x05, 0x4d,
-0x12, 0x11, 0x01, 0x4d, 0x12, 0x11, 0x01, 0x26, 0x03, 0x11, 0x01, 0x4d,
-0x01, 0x11, 0x11, 0x4d, 0x01, 0x11, 0x0a, 0x4d, 0x00, 0x04, 0x11, 0x4d,
-0x4d, 0x11, 0x0f, 0x4d, 0x01, 0x11, 0x06, 0x4d, 0x00, 0x04, 0x11, 0x11,
-0x4d, 0x4d, 0x30, 0x00, 0x08, 0x71, 0x1a, 0x4d, 0x01, 0x11, 0x01, 0x11,
-0x03, 0x4d, 0x01, 0x11, 0x01, 0x11, 0x06, 0x4d, 0x48, 0x00, 0x00, 0x00,
-0x61, 0x00, 0x00, 0x07, 0xeb, 0xe0, 0x01, 0x32, 0x29, 0x22, 0x4a, 0x00,
-0x05, 0x40, 0x04, 0x2e, 0x03, 0x1e, 0x03, 0x63, 0x04, 0x30, 0x05, 0x3e,
-0x00, 0x06, 0x59, 0x5a, 0x04, 0xc6, 0xe0, 0xd0, 0x2a, 0x00, 0x01, 0x03,
-0x01, 0x03, 0x88, 0x00, 0x01, 0x0d, 0x2b, 0x00, 0x01, 0x03, 0x01, 0x03,
-0x31, 0x00, 0x01, 0x0d, 0x46, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x09,
-0x11, 0x00, 0xec, 0x04, 0xc6, 0x04, 0x02, 0x1e, 0x22, 0x00, 0x04, 0x40,
-0x04, 0x2e, 0x04, 0x1e, 0x03, 0x63, 0x04, 0x30, 0x05, 0x3e, 0x00, 0x06,
-0x59, 0x29, 0x04, 0x0c, 0xe0, 0x6c, 0x2d, 0x00, 0x3d, 0x0d, 0x00, 0x05,
-0x00, 0x00, 0x0d, 0x00, 0x0d, 0x00, 0x42, 0x00, 0x01, 0x0d, 0x01, 0x0d,
-0x2f, 0x00, 0x01, 0x0d, 0x0b, 0x03, 0x1e, 0x0d, 0x05, 0x00, 0x01, 0x0d,
-0x48, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x09, 0x0d, 0x00, 0x4d, 0xcc,
-0xe0, 0x0c, 0x04, 0x37, 0x22, 0x00, 0x04, 0x40, 0x04, 0x2e, 0x03, 0x1e,
-0x04, 0x63, 0x03, 0x30, 0x05, 0x3e, 0x00, 0x08, 0x59, 0x3e, 0x37, 0x0c,
-0x0c, 0xe0, 0xaa, 0x8e, 0xff, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x60, 0x00,
-0x00, 0x09, 0x03, 0x00, 0x7d, 0xe0, 0x02, 0x0c, 0x5a, 0x2e, 0x4a, 0x00,
-0x03, 0x40, 0x04, 0x2e, 0x04, 0x1e, 0x03, 0x63, 0x01, 0x30, 0x01, 0x30,
-0x05, 0x3e, 0x00, 0x09, 0x59, 0x59, 0x3e, 0x5c, 0x02, 0x02, 0xe0, 0x02,
-0xd9, 0x00, 0xff, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x07,
-0x8e, 0x74, 0xdf, 0x02, 0x02, 0x3e, 0x4a, 0x00, 0x03, 0x40, 0x03, 0x2e,
-0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x05, 0x30, 0x04, 0x3e, 0x03, 0x59,
-0x00, 0x06, 0x5c, 0x29, 0x02, 0x5a, 0xdf, 0xeb, 0xff, 0x00, 0x5a, 0x00,
-0x00, 0x00, 0x63, 0x00, 0x00, 0x05, 0xea, 0xdf, 0x5a, 0x02, 0x52, 0x00,
-0x03, 0x40, 0x04, 0x2e, 0x05, 0x1e, 0x01, 0x63, 0x05, 0x30, 0x04, 0x3e,
-0x04, 0x59, 0x00, 0x06, 0x52, 0x02, 0x5a, 0xdf, 0x74, 0xa3, 0xff, 0x00,
-0x59, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x08, 0xe7, 0x02, 0xdf, 0x02,
-0x5a, 0x30, 0x4a, 0x40, 0x04, 0x2e, 0x05, 0x1e, 0x01, 0x63, 0x01, 0x63,
-0x04, 0x30, 0x04, 0x3e, 0x04, 0x59, 0x00, 0x06, 0x37, 0x5a, 0x5a, 0xca,
-0x14, 0xd9, 0xff, 0x00, 0x59, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x07,
-0x8f, 0xdf, 0x5a, 0x02, 0x5c, 0x40, 0x40, 0x00, 0x04, 0x2e, 0x04, 0x1e,
-0x03, 0x63, 0x03, 0x30, 0x04, 0x3e, 0x05, 0x59, 0x00, 0x06, 0x5c, 0x29,
-0x5a, 0x27, 0xdf, 0xcc, 0xff, 0x00, 0x59, 0x00, 0x00, 0x00, 0x64, 0x00,
-0x00, 0x07, 0xd9, 0xca, 0xca, 0x5a, 0x29, 0x1e, 0x4a, 0x00, 0x04, 0x2e,
-0x03, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x05, 0x30, 0x05, 0x3e, 0x03, 0x59,
-0x00, 0x0a, 0x5c, 0x59, 0x37, 0x27, 0x29, 0xca, 0xaf, 0x75, 0x00, 0x03,
-0xff, 0x00, 0x56, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x0a, 0x6b, 0xc1,
-0xca, 0x29, 0x27, 0x3e, 0x40, 0x40, 0x2e, 0x2e, 0x04, 0x1e, 0x03, 0x63,
-0x01, 0x30, 0x01, 0x30, 0x07, 0x3e, 0x01, 0x59, 0x01, 0x59, 0x04, 0x5c,
-0x00, 0x07, 0x52, 0x29, 0x27, 0xb9, 0xd0, 0x00, 0x03, 0x00, 0xff, 0x00,
-0x56, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x09, 0x8b, 0xf0, 0xca, 0x29,
-0x37, 0x2e, 0x40, 0x2e, 0x2e, 0x00, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63,
-0x04, 0x30, 0x05, 0x3e, 0x04, 0x59, 0x03, 0x5c, 0x00, 0x08, 0x52, 0x52,
-0x29, 0xdf, 0x72, 0x8e, 0x00, 0x26, 0xff, 0x00, 0x55, 0x00, 0x00, 0x00,
-0x65, 0x00, 0x00, 0x09, 0x75, 0x7b, 0xc0, 0x29, 0x52, 0x63, 0x40, 0x2e,
-0x2e, 0x00, 0x04, 0x1e, 0x03, 0x63, 0x03, 0x30, 0x05, 0x3e, 0x03, 0x59,
-0x04, 0x5c, 0x00, 0x08, 0x37, 0xca, 0xca, 0x52, 0xf0, 0x69, 0x00, 0x03,
-0xff, 0x00, 0x55, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x08, 0x4d, 0xcf,
-0xf0, 0x52, 0x52, 0x59, 0x40, 0x2e, 0x05, 0x1e, 0x01, 0x63, 0x01, 0x63,
-0x04, 0x30, 0x05, 0x3e, 0x03, 0x59, 0x05, 0x5c, 0x00, 0x06, 0x37, 0xc0,
-0x52, 0xf0, 0xa8, 0x8e, 0xff, 0x00, 0x56, 0x00, 0x00, 0x00, 0x64, 0x00,
-0x00, 0x0a, 0x4d, 0x00, 0xb1, 0xc0, 0xc0, 0xca, 0xc0, 0x1e, 0x2e, 0x2e,
-0x03, 0x1e, 0x03, 0x63, 0x04, 0x30, 0x04, 0x3e, 0x04, 0x59, 0x06, 0x5c,
-0x03, 0xc0, 0x01, 0xf0, 0x01, 0xf1, 0xff, 0x00, 0x56, 0x00, 0x00, 0x00,
-0x64, 0x00, 0x00, 0x0a, 0x03, 0x00, 0xa3, 0x81, 0xf0, 0x37, 0xc0, 0x30,
-0x2e, 0x2e, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x03, 0x30, 0x05, 0x3e,
-0x04, 0x59, 0x04, 0x5c, 0x01, 0x37, 0x01, 0x5c, 0x03, 0xc0, 0x00, 0x03,
-0xf0, 0x37, 0x75, 0x00, 0xff, 0x00, 0x55, 0x00, 0x00, 0x00, 0x65, 0x00,
-0x00, 0x09, 0x11, 0x00, 0x69, 0xf0, 0xc0, 0xc0, 0xb9, 0x1e, 0x2e, 0x00,
-0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x03, 0x30, 0x04, 0x3e, 0x04, 0x59,
-0x05, 0x5c, 0x00, 0x08, 0x37, 0x37, 0x5c, 0xc0, 0xc0, 0xb9, 0xc3, 0xf7,
-0xff, 0x00, 0x55, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x09, 0x03, 0x00,
-0x7c, 0xaf, 0xf0, 0xc0, 0xc0, 0x30, 0x2e, 0x00, 0x03, 0x1e, 0x01, 0x63,
-0x01, 0x63, 0x04, 0x30, 0x05, 0x3e, 0x04, 0x59, 0x05, 0x5c, 0x00, 0x08,
-0x37, 0x37, 0x59, 0xb9, 0xb9, 0xf0, 0xf0, 0x7e, 0xff, 0x00, 0x54, 0x00,
-0x00, 0x00, 0x68, 0x00, 0x00, 0x05, 0xcf, 0xc3, 0xb9, 0xb9, 0x30, 0x00,
-0x03, 0x1e, 0x03, 0x63, 0x03, 0x30, 0x06, 0x3e, 0x03, 0x59, 0x05, 0x5c,
-0x03, 0x37, 0x01, 0x5c, 0x03, 0xb9, 0x00, 0x05, 0xc3, 0xb4, 0xad, 0x00,
-0x03, 0x00, 0xff, 0x00, 0x51, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x05,
-0xb2, 0x37, 0xc3, 0xb9, 0xb9, 0x00, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63,
-0x04, 0x30, 0x05, 0x3e, 0x03, 0x59, 0x04, 0x5c, 0x00, 0x06, 0x37, 0x5c,
-0x37, 0x5c, 0x37, 0x59, 0x03, 0xb9, 0x00, 0x05, 0x0a, 0xd4, 0x71, 0x00,
-0x26, 0x00, 0xff, 0x00, 0x50, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x04,
-0xd4, 0x0a, 0xb9, 0xb9, 0x04, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x04, 0x30,
-0x04, 0x3e, 0x03, 0x59, 0x06, 0x5c, 0x05, 0x37, 0x00, 0x09, 0xb9, 0x76,
-0xb9, 0x76, 0x17, 0xcf, 0x00, 0x00, 0x03, 0x00, 0xff, 0x00, 0x4f, 0x00,
-0x00, 0x00, 0x69, 0x00, 0x00, 0x05, 0x7e, 0xc3, 0xc3, 0x76, 0x76, 0x00,
-0x03, 0x1e, 0x01, 0x63, 0x01, 0x63, 0x04, 0x30, 0x05, 0x3e, 0x01, 0x59,
-0x01, 0x59, 0x05, 0x5c, 0x07, 0x37, 0x03, 0x76, 0x00, 0x06, 0xc3, 0xc3,
-0x69, 0x00, 0x00, 0x0d, 0xff, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x69, 0x00,
-0x00, 0x06, 0x6b, 0xbb, 0x0a, 0x76, 0x76, 0x1e, 0x03, 0x63, 0x03, 0x30,
-0x06, 0x3e, 0x03, 0x59, 0x04, 0x5c, 0x01, 0x37, 0x01, 0x5c, 0x05, 0x37,
-0x01, 0x52, 0x01, 0x59, 0x03, 0x76, 0x00, 0x03, 0xc3, 0x76, 0x96, 0x00,
-0xff, 0x00, 0x50, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x01, 0xea, 0x01, 0x17,
-0x03, 0x76, 0x03, 0x63, 0x04, 0x30, 0x04, 0x3e, 0x03, 0x59, 0x07, 0x5c,
-0x06, 0x37, 0x01, 0x52, 0x01, 0x3e, 0x03, 0x76, 0x00, 0x06, 0x17, 0x63,
-0xb1, 0x00, 0x00, 0x0d, 0xff, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x6a, 0x00,
-0x00, 0x08, 0x75, 0x76, 0xc3, 0x76, 0x76, 0x1e, 0x63, 0x63, 0x04, 0x30,
-0x03, 0x3e, 0x01, 0x59, 0x01, 0x3e, 0x03, 0x59, 0x04, 0x5c, 0x01, 0x37,
-0x01, 0x5c, 0x06, 0x37, 0x00, 0x0c, 0x52, 0x52, 0x30, 0x8c, 0x76, 0x76,
-0x7f, 0x82, 0xb1, 0x00, 0x00, 0x03, 0xff, 0x00, 0x4b, 0x00, 0x00, 0x00,
-0x6a, 0x00, 0x00, 0x03, 0x26, 0xf7, 0x7f, 0x00, 0x03, 0x76, 0x03, 0x63,
-0x03, 0x30, 0x05, 0x3e, 0x03, 0x59, 0x04, 0x5c, 0x07, 0x37, 0x00, 0x0e,
-0x52, 0x52, 0x29, 0x52, 0x76, 0x8c, 0x76, 0x8c, 0x7f, 0x1e, 0x69, 0x00,
-0x00, 0x26, 0xff, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x01, 0x99,
-0x03, 0x8c, 0x00, 0x04, 0x76, 0x1e, 0x63, 0x63, 0x03, 0x30, 0x04, 0x3e,
-0x03, 0x59, 0x05, 0x5c, 0x07, 0x37, 0x03, 0x52, 0x00, 0x03, 0x29, 0x37,
-0x76, 0x00, 0x03, 0x8c, 0x00, 0x03, 0x7f, 0x8c, 0xf1, 0x00, 0xff, 0x00,
-0x4c, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x06, 0x6b, 0xf4, 0x7f, 0x8c,
-0x8c, 0x40, 0x05, 0x30, 0x04, 0x3e, 0x04, 0x59, 0x05, 0x5c, 0x07, 0x37,
-0x03, 0x52, 0x00, 0x03, 0x27, 0x52, 0x76, 0x00, 0x03, 0x8c, 0x00, 0x04,
-0x7f, 0x7f, 0x8a, 0x6b, 0xff, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x6a, 0x00,
-0x00, 0x07, 0x11, 0x00, 0xf1, 0xe5, 0x8c, 0x8c, 0x4a, 0x00, 0x05, 0x30,
-0x03, 0x3e, 0x05, 0x59, 0x05, 0x5c, 0x07, 0x37, 0x03, 0x52, 0x00, 0x04,
-0x29, 0x27, 0x52, 0x76, 0x03, 0x8c, 0x00, 0x04, 0x93, 0xe5, 0xb8, 0xb2,
-0xff, 0x00, 0x49, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x08, 0x26, 0x00,
-0x75, 0x82, 0x7f, 0x8c, 0x8c, 0x40, 0x03, 0x30, 0x05, 0x3e, 0x03, 0x59,
-0x06, 0x5c, 0x00, 0x03, 0x37, 0x37, 0x5c, 0x00, 0x03, 0x37, 0x05, 0x52,
-0x00, 0x0c, 0x29, 0x27, 0x29, 0x76, 0x93, 0x93, 0x8c, 0x8c, 0xe5, 0xed,
-0xf1, 0x71, 0xff, 0x00, 0x47, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x01, 0xcf,
-0x01, 0xe5, 0x03, 0x8c, 0x03, 0x30, 0x05, 0x3e, 0x03, 0x59, 0x04, 0x5c,
-0x01, 0x37, 0x01, 0x5c, 0x05, 0x37, 0x05, 0x52, 0x03, 0x29, 0x00, 0x10,
-0x7b, 0x27, 0x30, 0x93, 0x93, 0x8c, 0x93, 0xe5, 0xe5, 0xb8, 0x99, 0x26,
-0x00, 0x00, 0x4d, 0x03, 0xff, 0x00, 0x41, 0x00, 0x00, 0x00, 0x6b, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0xb1, 0xee, 0x93, 0x93, 0x8c, 0x1e, 0x3e, 0x30,
-0x04, 0x3e, 0x04, 0x59, 0x04, 0x5c, 0x00, 0x03, 0x37, 0x5c, 0x5c, 0x00,
-0x05, 0x37, 0x04, 0x52, 0x04, 0x29, 0x00, 0x04, 0x7b, 0x7b, 0x59, 0x8c,
-0x04, 0x93, 0x00, 0x04, 0xe5, 0x93, 0xd4, 0xb2, 0x03, 0x00, 0x01, 0x26,
-0x01, 0x03, 0xff, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x07,
-0xf4, 0xe5, 0x93, 0x93, 0x4a, 0x3e, 0x30, 0x00, 0x05, 0x3e, 0x03, 0x59,
-0x04, 0x5c, 0x01, 0x37, 0x01, 0x5c, 0x06, 0x37, 0x04, 0x52, 0x04, 0x29,
-0x00, 0x05, 0x27, 0x7b, 0x12, 0x52, 0x76, 0x00, 0x04, 0x93, 0x00, 0x06,
-0xe5, 0x15, 0x53, 0x8a, 0xb1, 0x0d, 0xff, 0x00, 0x41, 0x00, 0x00, 0x00,
-0x6e, 0x00, 0x00, 0x06, 0x69, 0x93, 0xe5, 0x93, 0x8c, 0x63, 0x06, 0x3e,
-0x03, 0x59, 0x06, 0x5c, 0x05, 0x37, 0x04, 0x52, 0x01, 0x29, 0x01, 0x52,
-0x03, 0x29, 0x00, 0x08, 0x27, 0x27, 0x7b, 0x12, 0x12, 0x59, 0x8c, 0x6e,
-0x03, 0x93, 0x00, 0x06, 0xe5, 0x15, 0x53, 0xd4, 0x69, 0x8e, 0xff, 0x00,
-0x3f, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x06, 0x6b, 0x82, 0x15, 0x93,
-0x93, 0x76, 0x04, 0x3e, 0x00, 0x04, 0x59, 0x3e, 0x59, 0x59, 0x05, 0x5c,
-0x00, 0x03, 0x37, 0x5c, 0x5c, 0x00, 0x04, 0x37, 0x04, 0x52, 0x04, 0x29,
-0x04, 0x27, 0x00, 0x11, 0x7b, 0x12, 0x02, 0x52, 0x76, 0x93, 0x6e, 0x6e,
-0x93, 0x93, 0xe5, 0x66, 0x6e, 0xbb, 0x8a, 0x99, 0x71, 0x00, 0xff, 0x00,
-0x3c, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x06, 0xcf, 0x83, 0xe5, 0x93,
-0x8c, 0x30, 0x04, 0x3e, 0x03, 0x59, 0x05, 0x5c, 0x01, 0x37, 0x01, 0x5c,
-0x05, 0x37, 0x05, 0x52, 0x03, 0x29, 0x04, 0x27, 0x00, 0x15, 0x7b, 0x7b,
-0x5a, 0x12, 0x02, 0x52, 0x76, 0x93, 0x6e, 0x6e, 0x73, 0x93, 0x6e, 0x83,
-0x83, 0x53, 0x82, 0xd4, 0xc5, 0x75, 0x71, 0x00, 0xff, 0x00, 0x38, 0x00,
-0x00, 0x00, 0x6f, 0x00, 0x00, 0x06, 0xad, 0x53, 0xe5, 0x6e, 0x6e, 0x40,
-0x04, 0x3e, 0x04, 0x59, 0x06, 0x5c, 0x05, 0x37, 0x05, 0x52, 0x04, 0x29,
-0x03, 0x27, 0x00, 0x0a, 0x7b, 0x7b, 0x12, 0x5a, 0x12, 0x14, 0x02, 0x52,
-0x76, 0x93, 0x05, 0x6e, 0x00, 0x10, 0x83, 0x5d, 0x83, 0x57, 0x73, 0xed,
-0xd4, 0xdb, 0x84, 0xb1, 0x75, 0x7c, 0x8e, 0x6b, 0xa3, 0x71, 0xf7, 0x4d,
-0x03, 0x00, 0x01, 0x0d, 0x32, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x05,
-0x6a, 0x66, 0x6e, 0x6e, 0x93, 0x00, 0x04, 0x3e, 0x04, 0x59, 0x06, 0x5c,
-0x05, 0x37, 0x04, 0x52, 0x04, 0x29, 0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a,
-0x03, 0x12, 0x00, 0x08, 0x02, 0x14, 0x14, 0x29, 0x76, 0x8c, 0x6e, 0x57,
-0x04, 0x6e, 0x01, 0x57, 0x06, 0x83, 0x00, 0x06, 0x73, 0xed, 0xbb, 0xf4,
-0xd4, 0x6a, 0x11, 0x8a, 0x01, 0x6a, 0x01, 0x8a, 0x99, 0x6a, 0x00, 0x04,
-0x8a, 0x8a, 0x6a, 0x6a, 0x04, 0x8a, 0x01, 0x6a, 0x42, 0x8a, 0x01, 0xdb,
-0x01, 0x9a, 0x34, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x09, 0xb2, 0x6e,
-0x57, 0x6e, 0x6e, 0x40, 0x59, 0x3e, 0x3e, 0x00, 0x03, 0x59, 0x07, 0x5c,
-0x05, 0x37, 0x04, 0x52, 0x03, 0x29, 0x05, 0x27, 0x00, 0x03, 0x7b, 0x7b,
-0x5a, 0x00, 0x04, 0x12, 0x00, 0x09, 0x02, 0x02, 0x14, 0x20, 0x12, 0xc0,
-0x76, 0x93, 0x6e, 0x00, 0x03, 0x57, 0x01, 0x6e, 0x01, 0x6e, 0x04, 0x57,
-0x06, 0x83, 0x9a, 0x6d, 0x30, 0x83, 0x01, 0x8d, 0x0c, 0x83, 0x20, 0x57,
-0x00, 0x03, 0x83, 0xed, 0x9a, 0x00, 0x33, 0x00, 0x00, 0x00, 0x70, 0x00,
-0x00, 0x09, 0x0d, 0x6a, 0x3c, 0x6e, 0x6e, 0x93, 0x30, 0x59, 0x3e, 0x00,
-0x03, 0x59, 0x04, 0x5c, 0x00, 0x03, 0x37, 0x37, 0x5c, 0x00, 0x06, 0x37,
-0x03, 0x52, 0x04, 0x29, 0x04, 0x27, 0x00, 0x03, 0x7b, 0x5a, 0x5a, 0x00,
-0x03, 0x12, 0x05, 0x02, 0x00, 0x08, 0x0c, 0x04, 0x20, 0x27, 0xc0, 0x76,
-0x8c, 0x6e, 0x36, 0x57, 0x00, 0x03, 0x8d, 0x57, 0x57, 0x00, 0x03, 0x8d,
-0x00, 0x06, 0x57, 0x57, 0x8d, 0x57, 0x8d, 0x57, 0x04, 0x8d, 0x08, 0x57,
-0x01, 0x8d, 0x01, 0x8d, 0x2b, 0x57, 0x2f, 0x6e, 0x2a, 0x73, 0x04, 0x65,
-0x00, 0x05, 0x73, 0x73, 0x65, 0x65, 0x73, 0x00, 0x03, 0x65, 0x01, 0x73,
-0x1e, 0x65, 0x05, 0x53, 0x00, 0x03, 0x83, 0x6a, 0x26, 0x00, 0x32, 0x00,
-0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0xb2, 0x65, 0x83, 0x6e, 0x57, 0x8c,
-0x59, 0x3e, 0x05, 0x59, 0x00, 0x05, 0x5c, 0x5c, 0x37, 0x37, 0x5c, 0x00,
-0x06, 0x37, 0x03, 0x52, 0x04, 0x29, 0x03, 0x27, 0x00, 0x06, 0x7b, 0x7b,
-0x5a, 0x7b, 0x12, 0x12, 0x07, 0x02, 0x00, 0x0c, 0x14, 0x14, 0x0c, 0x01,
-0x62, 0x02, 0x27, 0x37, 0xb9, 0x8c, 0x93, 0x6e, 0x04, 0x57, 0x4b, 0x8d,
-0x00, 0x04, 0x57, 0x57, 0x8d, 0x8d, 0x26, 0x57, 0x00, 0x04, 0x6e, 0x6e,
-0x57, 0x57, 0x24, 0x6e, 0x01, 0x73, 0x01, 0x6e, 0x2c, 0x73, 0x1d, 0x65,
-0x11, 0x53, 0x00, 0x05, 0x44, 0x44, 0x93, 0xee, 0x75, 0x00, 0x32, 0x00,
-0x00, 0x00, 0x72, 0x00, 0x00, 0x08, 0xdb, 0x6d, 0x6e, 0x57, 0x6e, 0x1e,
-0x59, 0x3e, 0x03, 0x59, 0x03, 0x5c, 0x08, 0x37, 0x03, 0x52, 0x05, 0x29,
-0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a, 0x03, 0x12, 0x05, 0x02, 0x04, 0x14,
-0x00, 0x10, 0x0c, 0x20, 0x62, 0x01, 0x1f, 0x01, 0x04, 0x0c, 0x14, 0x12,
-0x52, 0xc0, 0xb9, 0xb9, 0x76, 0x76, 0x0c, 0x8c, 0x1a, 0x76, 0x01, 0x2e,
-0x03, 0x76, 0x01, 0x2e, 0x01, 0x2e, 0x06, 0x1e, 0x01, 0x63, 0x04, 0x1e,
-0x0e, 0x63, 0x01, 0x30, 0x01, 0x3e, 0x1c, 0xa5, 0x01, 0xa6, 0x25, 0x82,
-0x00, 0x03, 0xa6, 0x82, 0x82, 0x00, 0x29, 0xa6, 0x00, 0x06, 0x59, 0xa6,
-0x59, 0x59, 0xa6, 0xa6, 0x19, 0x59, 0x00, 0x05, 0x3e, 0x59, 0x3e, 0x3e,
-0x59, 0x00, 0x17, 0x3e, 0x00, 0x0b, 0x30, 0x30, 0x3e, 0x30, 0x3e, 0x63,
-0xee, 0xee, 0x44, 0x93, 0xdb, 0x00, 0x32, 0x00, 0x00, 0x00, 0x70, 0x00,
-0x00, 0x09, 0x11, 0x00, 0x8e, 0x87, 0x6d, 0x57, 0x8d, 0x73, 0x3e, 0x00,
-0x03, 0x59, 0x04, 0x5c, 0x01, 0x37, 0x01, 0x5c, 0x07, 0x37, 0x03, 0x52,
-0x04, 0x29, 0x05, 0x27, 0x01, 0x5a, 0x01, 0x5a, 0x03, 0x12, 0x04, 0x02,
-0x04, 0x14, 0x03, 0x0c, 0x00, 0x06, 0x20, 0x20, 0x04, 0x62, 0x01, 0x38,
-0x07, 0x1f, 0x04, 0x08, 0x03, 0x1d, 0x00, 0x09, 0x54, 0x54, 0x06, 0x06,
-0x23, 0x06, 0x23, 0x23, 0x18, 0x00, 0x03, 0x47, 0x01, 0x21, 0x01, 0x21,
-0x06, 0x10, 0x01, 0x16, 0x01, 0x16, 0x03, 0x13, 0x04, 0x2a, 0x04, 0x0f,
-0x05, 0x4c, 0x04, 0x41, 0x03, 0x49, 0x03, 0x67, 0x03, 0x78, 0x08, 0x3d,
-0x01, 0xde, 0x03, 0x55, 0x01, 0x50, 0x01, 0x55, 0x06, 0x50, 0x03, 0x5e,
-0x06, 0x46, 0x07, 0x64, 0x07, 0x4e, 0x04, 0x56, 0x04, 0x48, 0x00, 0x03,
-0x5f, 0x48, 0x5f, 0x00, 0x05, 0x48, 0x01, 0x5f, 0x04, 0x48, 0x01, 0x5f,
-0x04, 0x48, 0x05, 0x56, 0x07, 0x4e, 0x05, 0x64, 0x07, 0x46, 0x03, 0x5e,
-0x05, 0x50, 0x07, 0x55, 0x06, 0x3d, 0x04, 0x78, 0x03, 0x67, 0x04, 0x49,
-0x04, 0x41, 0x04, 0x4c, 0x05, 0x0f, 0x03, 0x2a, 0x05, 0x13, 0x01, 0x16,
-0x04, 0x10, 0x04, 0x21, 0x01, 0x47, 0x04, 0x18, 0x01, 0x23, 0x01, 0x23,
-0x03, 0x06, 0x01, 0x54, 0x03, 0x1d, 0x03, 0x08, 0x01, 0x1f, 0x04, 0x38,
-0x00, 0x04, 0x32, 0x32, 0x01, 0x01, 0x03, 0x62, 0x03, 0x04, 0x00, 0x08,
-0x20, 0x0c, 0x59, 0xee, 0xee, 0x93, 0xbb, 0x6b, 0x31, 0x00, 0x00, 0x00,
-0x73, 0x00, 0x00, 0x06, 0x96, 0x8d, 0x6d, 0x57, 0x8d, 0x8c, 0x03, 0x59,
-0x04, 0x5c, 0x01, 0x37, 0x01, 0x5c, 0x07, 0x37, 0x03, 0x52, 0x04, 0x29,
-0x00, 0x07, 0x27, 0x7b, 0x7b, 0x27, 0x7b, 0x5a, 0x5a, 0x00, 0x03, 0x12,
-0x04, 0x02, 0x00, 0x04, 0x14, 0x02, 0x14, 0x14, 0x03, 0x0c, 0x01, 0x20,
-0x01, 0x20, 0x04, 0x04, 0x00, 0x04, 0x62, 0x01, 0x32, 0x01, 0x03, 0x1f,
-0x00, 0x06, 0x08, 0x54, 0x1d, 0x1d, 0x54, 0x1d, 0x03, 0x06, 0x03, 0x23,
-0x00, 0x05, 0x18, 0x47, 0x18, 0x10, 0x10, 0x00, 0x03, 0x21, 0x06, 0x10,
-0x04, 0x13, 0x01, 0xbc, 0x05, 0x2a, 0x07, 0x4c, 0x05, 0x41, 0x01, 0x49,
-0x05, 0x67, 0x01, 0x78, 0x01, 0x78, 0x05, 0x3d, 0x09, 0xde, 0x04, 0x50,
-0x05, 0x5e, 0x04, 0x46, 0x08, 0x64, 0x05, 0x4e, 0x03, 0x56, 0x01, 0x48,
-0x01, 0x56, 0x03, 0x48, 0x18, 0x5f, 0x04, 0x48, 0x03, 0x56, 0x06, 0x4e,
-0x09, 0x64, 0x03, 0x46, 0x04, 0x5e, 0x05, 0x50, 0x07, 0xde, 0x01, 0x3d,
-0x01, 0xde, 0x05, 0x3d, 0x01, 0x78, 0x06, 0x67, 0x01, 0x49, 0x04, 0x41,
-0x07, 0x4c, 0x01, 0x0f, 0x03, 0x2a, 0x01, 0x13, 0x01, 0x2a, 0x04, 0x13,
-0x06, 0x10, 0x05, 0x21, 0x00, 0x03, 0x47, 0x18, 0x18, 0x00, 0x03, 0x23,
-0x00, 0x07, 0x06, 0x06, 0x54, 0x1d, 0x54, 0x1d, 0x1d, 0x00, 0x03, 0x08,
-0x00, 0x05, 0x1f, 0x1f, 0x38, 0x32, 0x38, 0x00, 0x04, 0x01, 0x01, 0x62,
-0x03, 0x04, 0x00, 0x08, 0x20, 0x04, 0x7b, 0xed, 0xed, 0x22, 0x4a, 0x96,
-0x31, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x06, 0x6a, 0x2d, 0x57, 0x6e,
-0x6e, 0x40, 0x07, 0x5c, 0x07, 0x37, 0x03, 0x52, 0x04, 0x29, 0x01, 0x27,
-0x01, 0x27, 0x04, 0x7b, 0x01, 0x5a, 0x01, 0x5a, 0x03, 0x12, 0x04, 0x02,
-0x04, 0x14, 0x03, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x04, 0x04, 0x01, 0x62,
-0x04, 0x01, 0x03, 0x38, 0x01, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x04, 0x54,
-0x00, 0x04, 0x06, 0x06, 0x23, 0x23, 0x05, 0x18, 0x00, 0x06, 0x21, 0x21,
-0x47, 0x21, 0x21, 0x10, 0x05, 0x16, 0x03, 0x13, 0x03, 0x2a, 0x05, 0x0f,
-0x01, 0x4c, 0x01, 0x0f, 0x03, 0x4c, 0x04, 0x41, 0x05, 0x49, 0x01, 0x67,
-0x05, 0x78, 0x06, 0x3d, 0x06, 0x55, 0x00, 0x04, 0x50, 0x50, 0x5e, 0x50,
-0x05, 0x5e, 0x05, 0x46, 0x06, 0x64, 0x01, 0x60, 0x06, 0x4e, 0x06, 0x56,
-0x09, 0x48, 0x01, 0x5f, 0x08, 0x48, 0x06, 0x56, 0x05, 0x4e, 0x01, 0x64,
-0x01, 0x60, 0x06, 0x64, 0x06, 0x46, 0x04, 0x5e, 0x05, 0x50, 0x05, 0x55,
-0x07, 0x3d, 0x03, 0x78, 0x03, 0x67, 0x04, 0x49, 0x04, 0x41, 0x04, 0x4c,
-0x05, 0x0f, 0x05, 0x2a, 0x01, 0x13, 0x01, 0x13, 0x05, 0x16, 0x01, 0x10,
-0x04, 0x21, 0x01, 0x47, 0x01, 0x47, 0x03, 0x18, 0x01, 0x23, 0x01, 0x23,
-0x03, 0x06, 0x03, 0x54, 0x00, 0x04, 0x1d, 0x1d, 0x08, 0x08, 0x03, 0x1f,
-0x00, 0x03, 0x38, 0x32, 0x32, 0x00, 0x04, 0x01, 0x01, 0x62, 0x04, 0x04,
-0x00, 0x0a, 0x20, 0x20, 0x0c, 0x0c, 0x14, 0xa6, 0xed, 0xed, 0x8c, 0xd4,
-0x31, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x08, 0x8e, 0x82, 0x5d, 0x6e,
-0x6e, 0x73, 0x30, 0x37, 0x05, 0x5c, 0x01, 0x37, 0x01, 0x5c, 0x05, 0x37,
-0x04, 0x52, 0x03, 0x29, 0x03, 0x27, 0x00, 0x07, 0x7b, 0x7b, 0x5a, 0x7b,
-0x7b, 0x12, 0x12, 0x00, 0x05, 0x02, 0x03, 0x14, 0x03, 0x0c, 0x03, 0x20,
-0x03, 0x04, 0x01, 0x62, 0x01, 0x62, 0x04, 0x01, 0x03, 0x38, 0x01, 0x1f,
-0x04, 0x08, 0x00, 0x04, 0x1d, 0x1d, 0x54, 0x54, 0x03, 0x06, 0x01, 0x23,
-0x01, 0x23, 0x05, 0x18, 0x05, 0x21, 0x01, 0x10, 0x01, 0x10, 0x03, 0x16,
-0x03, 0x13, 0x04, 0x2a, 0x05, 0x0f, 0x00, 0x04, 0x4c, 0x0f, 0x4c, 0x4c,
-0x03, 0x41, 0x06, 0x49, 0x03, 0x67, 0x04, 0x78, 0x04, 0x3d, 0x07, 0x55,
-0x04, 0x50, 0x05, 0x5e, 0x07, 0x46, 0x05, 0x64, 0x01, 0x60, 0x06, 0x4e,
-0x04, 0x56, 0x15, 0x48, 0x05, 0x56, 0x05, 0x4e, 0x01, 0x64, 0x01, 0x60,
-0x05, 0x64, 0x06, 0x46, 0x05, 0x5e, 0x05, 0x50, 0x06, 0x55, 0x05, 0x3d,
-0x04, 0x78, 0x03, 0x67, 0x04, 0x49, 0x04, 0x41, 0x01, 0x4c, 0x01, 0x4c,
-0x07, 0x0f, 0x05, 0x2a, 0x03, 0x13, 0x03, 0x16, 0x01, 0x10, 0x01, 0x10,
-0x04, 0x21, 0x01, 0x47, 0x04, 0x18, 0x01, 0x23, 0x01, 0x23, 0x03, 0x06,
-0x03, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x03, 0x08, 0x00, 0x06, 0x1f, 0x1f,
-0x38, 0x38, 0x32, 0x32, 0x03, 0x01, 0x01, 0x62, 0x04, 0x04, 0x00, 0x0b,
-0x20, 0x20, 0x0c, 0x0c, 0x20, 0x29, 0xa5, 0xa5, 0x40, 0xbb, 0x9a, 0x00,
-0x30, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x07, 0xb1, 0x73, 0x83, 0x65,
-0x73, 0x53, 0x59, 0x00, 0x04, 0x5c, 0x00, 0x03, 0x37, 0x37, 0x5c, 0x00,
-0x04, 0x37, 0x04, 0x52, 0x05, 0x29, 0x04, 0x27, 0x01, 0x5a, 0x01, 0x5a,
-0x04, 0x12, 0x04, 0x02, 0x05, 0x14, 0x01, 0x0c, 0x03, 0x20, 0x04, 0x04,
-0x01, 0x62, 0x04, 0x01, 0x00, 0x04, 0x32, 0x38, 0x38, 0x1f, 0x04, 0x08,
-0x00, 0x04, 0x1d, 0x1d, 0x54, 0x54, 0x03, 0x06, 0x01, 0x23, 0x01, 0x23,
-0x05, 0x18, 0x05, 0x21, 0x05, 0x16, 0x04, 0x13, 0x04, 0x2a, 0x06, 0x0f,
-0x01, 0x4c, 0x01, 0x4c, 0x04, 0x41, 0x04, 0x49, 0x04, 0x67, 0x04, 0x78,
-0x06, 0x3d, 0x05, 0x55, 0x04, 0x50, 0x05, 0x5e, 0x07, 0x46, 0x06, 0x64,
-0x05, 0x4e, 0x05, 0x56, 0x08, 0x48, 0x06, 0x5f, 0x08, 0x48, 0x05, 0x56,
-0x05, 0x4e, 0x06, 0x64, 0x06, 0x46, 0x05, 0x5e, 0x05, 0x50, 0x06, 0x55,
-0x05, 0x3d, 0x04, 0x78, 0x04, 0x67, 0x04, 0x49, 0x04, 0x41, 0x01, 0x4c,
-0x01, 0x4c, 0x06, 0x0f, 0x04, 0x2a, 0x05, 0x13, 0x00, 0x04, 0x16, 0x16,
-0x10, 0x10, 0x04, 0x21, 0x03, 0x18, 0x01, 0x23, 0x01, 0x18, 0x03, 0x23,
-0x01, 0x06, 0x01, 0x06, 0x03, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x03, 0x08,
-0x03, 0x1f, 0x00, 0x0d, 0x38, 0x32, 0x32, 0x01, 0x01, 0x62, 0x62, 0x04,
-0x04, 0x20, 0x04, 0x20, 0x20, 0x00, 0x03, 0x0c, 0x00, 0x06, 0x02, 0x82,
-0x82, 0xa6, 0x1e, 0xea, 0x30, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x07,
-0xc5, 0x6e, 0x73, 0x65, 0x73, 0x22, 0x59, 0x00, 0x03, 0x5c, 0x01, 0x37,
-0x01, 0x5c, 0x06, 0x37, 0x03, 0x52, 0x04, 0x29, 0x05, 0x27, 0x00, 0x03,
-0x7b, 0x7b, 0x5a, 0x00, 0x03, 0x12, 0x04, 0x02, 0x04, 0x14, 0x01, 0x0c,
-0x01, 0x0c, 0x03, 0x20, 0x04, 0x04, 0x00, 0x09, 0x62, 0x01, 0x62, 0x01,
-0x32, 0x32, 0x38, 0x1f, 0x1f, 0x00, 0x04, 0x08, 0x00, 0x04, 0x1d, 0x1d,
-0x54, 0x54, 0x03, 0x06, 0x01, 0x23, 0x01, 0x23, 0x04, 0x18, 0x00, 0x08,
-0x47, 0x21, 0x21, 0x47, 0x21, 0x21, 0x10, 0x10, 0x03, 0x16, 0x04, 0x13,
-0x03, 0x2a, 0x06, 0x0f, 0x03, 0x4c, 0x05, 0x41, 0x03, 0x49, 0x04, 0x67,
-0x05, 0x78, 0x04, 0x3d, 0x05, 0x55, 0x06, 0x50, 0x04, 0x5e, 0x07, 0x46,
-0x04, 0x64, 0x01, 0x60, 0x01, 0x64, 0x05, 0x4e, 0x04, 0x56, 0x07, 0x48,
-0x01, 0x5f, 0x01, 0x48, 0x08, 0x5f, 0x06, 0x48, 0x04, 0x56, 0x06, 0x4e,
-0x07, 0x64, 0x05, 0x46, 0x05, 0x5e, 0x04, 0x50, 0x01, 0x55, 0x01, 0x50,
-0x05, 0x55, 0x05, 0x3d, 0x05, 0x78, 0x01, 0x67, 0x01, 0x67, 0x05, 0x49,
-0x03, 0x41, 0x04, 0x4c, 0x05, 0x0f, 0x04, 0x2a, 0x05, 0x13, 0x03, 0x16,
-0x01, 0x10, 0x04, 0x21, 0x01, 0x47, 0x04, 0x18, 0x03, 0x23, 0x03, 0x06,
-0x00, 0x04, 0x54, 0x54, 0x1d, 0x1d, 0x04, 0x08, 0x00, 0x05, 0x1f, 0x1f,
-0x38, 0x32, 0x32, 0x00, 0x03, 0x01, 0x01, 0x62, 0x04, 0x04, 0x00, 0x0e,
-0x20, 0x20, 0x0c, 0x0c, 0x14, 0x0c, 0xb4, 0x82, 0x82, 0x63, 0xf4, 0x7c,
-0x00, 0x03, 0x2d, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x09, 0x0d, 0x00,
-0x00, 0xdb, 0x6e, 0x65, 0x53, 0x65, 0x4a, 0x00, 0x05, 0x5c, 0x06, 0x37,
-0x04, 0x52, 0x03, 0x29, 0x04, 0x27, 0x00, 0x06, 0x7b, 0x7b, 0x5a, 0x5a,
-0x12, 0x12, 0x05, 0x02, 0x04, 0x14, 0x01, 0x0c, 0x01, 0x0c, 0x03, 0x20,
-0x04, 0x04, 0x01, 0x62, 0x04, 0x01, 0x00, 0x04, 0x38, 0x38, 0x1f, 0x1f,
-0x04, 0x08, 0x01, 0x1d, 0x03, 0x54, 0x03, 0x06, 0x00, 0x0e, 0x23, 0x23,
-0x18, 0x18, 0x23, 0x18, 0x47, 0x21, 0x47, 0x47, 0x21, 0x21, 0x10, 0x10,
-0x04, 0x16, 0x04, 0x13, 0x01, 0x2a, 0x01, 0x2a, 0x06, 0x0f, 0x03, 0x4c,
-0x04, 0x41, 0x04, 0x49, 0x04, 0x67, 0x05, 0x78, 0x04, 0x3d, 0x06, 0x55,
-0x05, 0x50, 0x04, 0x5e, 0x06, 0x46, 0x05, 0x64, 0x01, 0x60, 0x01, 0x64,
-0x04, 0x4e, 0x05, 0x56, 0x07, 0x48, 0x0a, 0x5f, 0x07, 0x48, 0x04, 0x56,
-0x05, 0x4e, 0x01, 0x60, 0x01, 0x60, 0x05, 0x64, 0x06, 0x46, 0x05, 0x5e,
-0x03, 0x50, 0x01, 0x55, 0x01, 0x50, 0x05, 0x55, 0x06, 0x3d, 0x04, 0x78,
-0x01, 0x67, 0x01, 0x67, 0x05, 0x49, 0x03, 0x41, 0x04, 0x4c, 0x06, 0x0f,
-0x03, 0x2a, 0x04, 0x13, 0x03, 0x16, 0x01, 0x10, 0x01, 0x10, 0x04, 0x21,
-0x01, 0x47, 0x01, 0x47, 0x04, 0x18, 0x00, 0x04, 0x23, 0x23, 0x06, 0x06,
-0x03, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x04, 0x08, 0x00, 0x04, 0x1f, 0x38,
-0x38, 0x32, 0x04, 0x01, 0x03, 0x62, 0x00, 0x09, 0x04, 0x04, 0x20, 0x20,
-0x0c, 0x0c, 0x14, 0x0c, 0x12, 0x00, 0x03, 0xbb, 0x00, 0x04, 0xa5, 0x69,
-0x00, 0x11, 0x2d, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x05, 0x03, 0x00,
-0x4d, 0x6a, 0x6e, 0x00, 0x03, 0x44, 0x00, 0x03, 0x40, 0x5c, 0x5c, 0x00,
-0x08, 0x37, 0x05, 0x52, 0x01, 0x29, 0x01, 0x29, 0x03, 0x27, 0x04, 0x7b,
-0x00, 0x03, 0x5a, 0x12, 0x12, 0x00, 0x05, 0x02, 0x04, 0x14, 0x01, 0x0c,
-0x01, 0x0c, 0x03, 0x20, 0x04, 0x04, 0x01, 0x62, 0x04, 0x01, 0x00, 0x04,
-0x32, 0x38, 0x1f, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x03, 0x54, 0x03, 0x06,
-0x00, 0x03, 0x23, 0x23, 0x58, 0x00, 0x04, 0x18, 0x05, 0x21, 0x05, 0x16,
-0x05, 0x13, 0x01, 0x2a, 0x01, 0x2a, 0x06, 0x0f, 0x03, 0x4c, 0x04, 0x41,
-0x04, 0x49, 0x04, 0x67, 0x05, 0x78, 0x04, 0x3d, 0x06, 0x55, 0x03, 0x50,
-0x05, 0x5e, 0x06, 0x46, 0x08, 0x64, 0x05, 0x4e, 0x04, 0x56, 0x05, 0x48,
-0x0d, 0x5f, 0x06, 0x48, 0x04, 0x56, 0x05, 0x4e, 0x01, 0x60, 0x01, 0x60,
-0x06, 0x64, 0x04, 0x46, 0x06, 0x5e, 0x05, 0x50, 0x05, 0x55, 0x04, 0x3d,
-0x01, 0x78, 0x01, 0x3d, 0x04, 0x78, 0x01, 0x67, 0x01, 0x67, 0x04, 0x49,
-0x04, 0x41, 0x04, 0x4c, 0x05, 0x0f, 0x04, 0x2a, 0x04, 0x13, 0x04, 0x16,
-0x05, 0x21, 0x01, 0x47, 0x01, 0x47, 0x04, 0x18, 0x01, 0x23, 0x01, 0x23,
-0x03, 0x06, 0x00, 0x04, 0x54, 0x54, 0x1d, 0x1d, 0x04, 0x08, 0x00, 0x04,
-0x1f, 0x38, 0x38, 0x32, 0x03, 0x01, 0x03, 0x62, 0x03, 0x04, 0x00, 0x04,
-0x20, 0x20, 0x0c, 0x0c, 0x03, 0x14, 0x00, 0x06, 0xb4, 0xbb, 0xbb, 0xa6,
-0xf7, 0x6b, 0x2e, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x0a, 0x03, 0x00,
-0x6b, 0xd4, 0x93, 0x44, 0xee, 0x22, 0x2e, 0x5c, 0x08, 0x37, 0x04, 0x52,
-0x03, 0x29, 0x04, 0x27, 0x00, 0x03, 0x7b, 0x7b, 0x5a, 0x00, 0x04, 0x12,
-0x04, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x03, 0x20, 0x03, 0x04, 0x00, 0x09,
-0x62, 0x62, 0x01, 0x01, 0x32, 0x32, 0x38, 0x38, 0x1f, 0x00, 0x04, 0x08,
-0x01, 0x1d, 0x01, 0x1d, 0x03, 0x54, 0x00, 0x0f, 0x06, 0x06, 0x23, 0x23,
-0x18, 0x23, 0x18, 0x47, 0x47, 0x21, 0x21, 0x47, 0x21, 0x21, 0x10, 0x00,
-0x05, 0x16, 0x04, 0x13, 0x01, 0x2a, 0x01, 0x2a, 0x07, 0x0f, 0x01, 0x4c,
-0x01, 0x4c, 0x03, 0x41, 0x05, 0x49, 0x03, 0x67, 0x04, 0x78, 0x06, 0x3d,
-0x06, 0x55, 0x05, 0x50, 0x03, 0x5e, 0x06, 0x46, 0x08, 0x64, 0x05, 0x4e,
-0x04, 0x56, 0x05, 0x48, 0x06, 0x5f, 0x01, 0xa7, 0x07, 0x5f, 0x05, 0x48,
-0x04, 0x56, 0x05, 0x4e, 0x01, 0x60, 0x01, 0x60, 0x05, 0x64, 0x05, 0x46,
-0x05, 0x5e, 0x06, 0x50, 0x05, 0x55, 0x06, 0x3d, 0x04, 0x78, 0x01, 0x67,
-0x01, 0x67, 0x05, 0x49, 0x03, 0x41, 0x05, 0x4c, 0x04, 0x0f, 0x04, 0x2a,
-0x04, 0x13, 0x04, 0x16, 0x01, 0x10, 0x04, 0x21, 0x01, 0x47, 0x01, 0x47,
-0x04, 0x18, 0x01, 0x23, 0x01, 0x23, 0x03, 0x06, 0x01, 0x54, 0x01, 0x54,
-0x03, 0x1d, 0x03, 0x08, 0x00, 0x07, 0x1f, 0x1f, 0x38, 0x32, 0x32, 0x01,
-0x01, 0x00, 0x04, 0x62, 0x00, 0x04, 0x04, 0x04, 0x20, 0x20, 0x03, 0x0c,
-0x03, 0x14, 0x00, 0x05, 0xb4, 0xb8, 0xb4, 0xb4, 0xb1, 0x00, 0x2e, 0x00,
-0x00, 0x00, 0x77, 0x00, 0x00, 0x0a, 0x03, 0x00, 0x6b, 0xd4, 0x93, 0x22,
-0xee, 0xee, 0x1e, 0x59, 0x07, 0x37, 0x03, 0x52, 0x00, 0x04, 0x29, 0x52,
-0x29, 0x29, 0x03, 0x27, 0x03, 0x7b, 0x01, 0x5a, 0x01, 0x5a, 0x03, 0x12,
-0x04, 0x02, 0x04, 0x14, 0x01, 0x0c, 0x01, 0x0c, 0x03, 0x20, 0x03, 0x04,
-0x01, 0x62, 0x01, 0x62, 0x03, 0x01, 0x00, 0x05, 0x32, 0x32, 0x38, 0x1f,
-0x1f, 0x00, 0x03, 0x08, 0x01, 0x1d, 0x01, 0x1d, 0x03, 0x54, 0x00, 0x05,
-0x06, 0x06, 0x23, 0x06, 0x23, 0x00, 0x03, 0x18, 0x00, 0x09, 0x47, 0x47,
-0x21, 0x21, 0x47, 0x21, 0x21, 0x10, 0x10, 0x00, 0x04, 0x16, 0x01, 0x13,
-0x01, 0x13, 0x03, 0x2a, 0x07, 0x0f, 0x03, 0x4c, 0x04, 0x41, 0x04, 0x49,
-0x03, 0x67, 0x04, 0x78, 0x06, 0x3d, 0x05, 0x55, 0x06, 0x50, 0x04, 0x5e,
-0x06, 0x46, 0x05, 0x64, 0x01, 0x60, 0x01, 0x64, 0x04, 0x4e, 0x05, 0x56,
-0x06, 0x48, 0x05, 0x5f, 0x01, 0xa7, 0x01, 0xa7, 0x05, 0x5f, 0x06, 0x48,
-0x04, 0x56, 0x05, 0x4e, 0x00, 0x04, 0x60, 0x60, 0x64, 0x60, 0x03, 0x64,
-0x06, 0x46, 0x04, 0x5e, 0x04, 0x50, 0x07, 0x55, 0x05, 0x3d, 0x05, 0x78,
-0x03, 0x67, 0x04, 0x49, 0x04, 0x41, 0x03, 0x4c, 0x05, 0x0f, 0x04, 0x2a,
-0x03, 0x13, 0x01, 0x16, 0x01, 0x13, 0x03, 0x16, 0x01, 0x10, 0x03, 0x21,
-0x00, 0x03, 0x47, 0x21, 0x47, 0x00, 0x03, 0x18, 0x03, 0x23, 0x01, 0x06,
-0x01, 0x06, 0x03, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x04, 0x08, 0x00, 0x05,
-0x1f, 0x1f, 0x38, 0x32, 0x32, 0x00, 0x03, 0x01, 0x00, 0x03, 0x62, 0x04,
-0x62, 0x00, 0x03, 0x04, 0x01, 0x20, 0x03, 0x0c, 0x03, 0x14, 0x00, 0x05,
-0xaf, 0xb8, 0xb8, 0x82, 0xea, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x78, 0x00,
-0x00, 0x0a, 0x03, 0x00, 0x6b, 0xd4, 0x93, 0x4a, 0xed, 0xee, 0xed, 0x5c,
-0x06, 0x37, 0x03, 0x52, 0x04, 0x29, 0x03, 0x27, 0x01, 0x7b, 0x01, 0x7b,
-0x03, 0x5a, 0x03, 0x12, 0x04, 0x02, 0x05, 0x14, 0x01, 0x0c, 0x04, 0x20,
-0x00, 0x04, 0x04, 0x04, 0x62, 0x62, 0x03, 0x01, 0x00, 0x05, 0x32, 0x32,
-0x38, 0x1f, 0x1f, 0x00, 0x04, 0x08, 0x01, 0x1d, 0x03, 0x54, 0x03, 0x06,
-0x03, 0x23, 0x00, 0x0a, 0x18, 0x58, 0x18, 0x47, 0x47, 0x21, 0x47, 0x21,
-0x21, 0x10, 0x05, 0x16, 0x01, 0x13, 0x01, 0x13, 0x04, 0x2a, 0x03, 0x0f,
-0x01, 0x4c, 0x03, 0x0f, 0x01, 0x4c, 0x01, 0x4c, 0x04, 0x41, 0x04, 0x49,
-0x03, 0x67, 0x04, 0x78, 0x06, 0x3d, 0x05, 0x55, 0x04, 0x50, 0x06, 0x5e,
-0x06, 0x46, 0x05, 0x64, 0x01, 0x60, 0x05, 0x4e, 0x05, 0x56, 0x05, 0x48,
-0x05, 0x5f, 0x03, 0xa7, 0x05, 0x5f, 0x06, 0x48, 0x04, 0x56, 0x05, 0x4e,
-0x00, 0x03, 0x64, 0x4e, 0x60, 0x00, 0x05, 0x64, 0x05, 0x46, 0x04, 0x5e,
-0x06, 0x50, 0x05, 0x55, 0x00, 0x05, 0x3d, 0x3d, 0x78, 0x3d, 0x3d, 0x00,
-0x05, 0x78, 0x03, 0x67, 0x04, 0x49, 0x00, 0x04, 0x41, 0x49, 0x41, 0x41,
-0x03, 0x4c, 0x01, 0x0f, 0x01, 0x4c, 0x03, 0x0f, 0x04, 0x2a, 0x05, 0x13,
-0x00, 0x0d, 0x16, 0x16, 0x10, 0x10, 0x21, 0x21, 0x47, 0x47, 0x21, 0x47,
-0x47, 0x18, 0x18, 0x00, 0x03, 0x23, 0x03, 0x06, 0x00, 0x0d, 0x54, 0x54,
-0x1d, 0x1d, 0x08, 0x08, 0x1f, 0x08, 0x1f, 0x1f, 0x38, 0x32, 0x32, 0x00,
-0x03, 0x01, 0x03, 0x62, 0x00, 0x04, 0x04, 0x04, 0x20, 0x20, 0x03, 0x0c,
-0x03, 0x14, 0x00, 0x06, 0xaa, 0xb8, 0xaf, 0xb4, 0xa8, 0xad, 0x2d, 0x00,
-0x00, 0x00, 0x7b, 0x00, 0x00, 0x08, 0x6b, 0x8a, 0x4a, 0xee, 0xa5, 0xed,
-0xa5, 0xa6, 0x06, 0x37, 0x03, 0x52, 0x03, 0x29, 0x04, 0x27, 0x00, 0x04,
-0x7b, 0x7b, 0x5a, 0x5a, 0x03, 0x12, 0x04, 0x02, 0x05, 0x14, 0x00, 0x04,
-0x0c, 0x0c, 0x20, 0x20, 0x04, 0x04, 0x01, 0x62, 0x03, 0x01, 0x00, 0x05,
-0x32, 0x32, 0x38, 0x38, 0x1f, 0x00, 0x04, 0x08, 0x01, 0x1d, 0x03, 0x54,
-0x03, 0x06, 0x00, 0x10, 0x23, 0x23, 0x18, 0x23, 0x18, 0x18, 0x47, 0x21,
-0x21, 0x47, 0x21, 0x21, 0x10, 0x10, 0x16, 0x16, 0x05, 0x13, 0x03, 0x2a,
-0x05, 0x0f, 0x04, 0x4c, 0x04, 0x41, 0x03, 0x49, 0x04, 0x67, 0x05, 0x78,
-0x05, 0x3d, 0x06, 0x55, 0x04, 0x50, 0x04, 0x5e, 0x07, 0x46, 0x03, 0x64,
-0x01, 0x60, 0x01, 0x64, 0x06, 0x4e, 0x05, 0x56, 0x05, 0x48, 0x06, 0x5f,
-0x01, 0xa7, 0x01, 0xa7, 0x05, 0x5f, 0x06, 0x48, 0x04, 0x56, 0x06, 0x4e,
-0x01, 0x64, 0x01, 0x60, 0x03, 0x64, 0x07, 0x46, 0x04, 0x5e, 0x06, 0x50,
-0x05, 0x55, 0x05, 0x3d, 0x05, 0x78, 0x03, 0x67, 0x04, 0x49, 0x04, 0x41,
-0x01, 0x4c, 0x01, 0x4c, 0x06, 0x0f, 0x05, 0x2a, 0x04, 0x13, 0x03, 0x16,
-0x01, 0x10, 0x05, 0x21, 0x01, 0x47, 0x03, 0x18, 0x01, 0x23, 0x01, 0x23,
-0x04, 0x06, 0x01, 0x54, 0x01, 0x54, 0x03, 0x1d, 0x03, 0x08, 0x00, 0x05,
-0x1f, 0x1f, 0x38, 0x32, 0x32, 0x00, 0x03, 0x01, 0x01, 0x62, 0x01, 0x62,
-0x03, 0x04, 0x01, 0x20, 0x01, 0x20, 0x03, 0x0c, 0x04, 0x14, 0x00, 0x05,
-0xaf, 0xa8, 0xaf, 0xb4, 0x69, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x7c, 0x00,
-0x00, 0x04, 0x4d, 0xf1, 0xed, 0x1e, 0x03, 0xa5, 0x01, 0xa6, 0x04, 0x37,
-0x03, 0x52, 0x05, 0x29, 0x00, 0x06, 0x7b, 0x27, 0x27, 0x7b, 0x7b, 0x5a,
-0x04, 0x12, 0x04, 0x02, 0x04, 0x14, 0x01, 0x0c, 0x01, 0x0c, 0x03, 0x20,
-0x04, 0x04, 0x00, 0x09, 0x62, 0x62, 0x01, 0x01, 0x32, 0x32, 0x38, 0x1f,
-0x1f, 0x00, 0x03, 0x08, 0x03, 0x1d, 0x01, 0x54, 0x01, 0x54, 0x03, 0x06,
-0x01, 0x23, 0x01, 0x23, 0x04, 0x18, 0x00, 0x0a, 0x47, 0x21, 0x21, 0x47,
-0x21, 0x21, 0x10, 0x10, 0x16, 0x16, 0x05, 0x13, 0x04, 0x2a, 0x05, 0x0f,
-0x03, 0x4c, 0x04, 0x41, 0x05, 0x49, 0x01, 0x67, 0x01, 0x67, 0x04, 0x78,
-0x06, 0x3d, 0x05, 0x55, 0x06, 0x50, 0x04, 0x5e, 0x06, 0x46, 0x04, 0x64,
-0x01, 0x60, 0x01, 0x64, 0x06, 0x4e, 0x04, 0x56, 0x06, 0x48, 0x0b, 0x5f,
-0x06, 0x48, 0x05, 0x56, 0x06, 0x4e, 0x01, 0x60, 0x01, 0x60, 0x04, 0x64,
-0x05, 0x46, 0x05, 0x5e, 0x05, 0x50, 0x06, 0x55, 0x05, 0x3d, 0x04, 0x78,
-0x03, 0x67, 0x04, 0x49, 0x05, 0x41, 0x03, 0x4c, 0x06, 0x0f, 0x03, 0x2a,
-0x04, 0x13, 0x00, 0x05, 0x16, 0x13, 0x16, 0x10, 0x10, 0x00, 0x05, 0x21,
-0x01, 0x47, 0x03, 0x18, 0x00, 0x05, 0x23, 0x06, 0x23, 0x06, 0x06, 0x00,
-0x04, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x03, 0x08, 0x00, 0x05, 0x1f, 0x38,
-0x38, 0x32, 0x32, 0x00, 0x03, 0x01, 0x01, 0x62, 0x04, 0x04, 0x01, 0x20,
-0x01, 0x20, 0x03, 0x0c, 0x00, 0x0a, 0x14, 0x14, 0x02, 0x14, 0xaf, 0xa8,
-0xa8, 0xaf, 0xf7, 0x71, 0x2c, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x00, 0x07,
-0x03, 0x00, 0x00, 0x96, 0xbb, 0x76, 0xa6, 0x00, 0x03, 0x82, 0x01, 0xa6,
-0x01, 0x37, 0x05, 0x52, 0x04, 0x29, 0x03, 0x27, 0x00, 0x06, 0x7b, 0x7b,
-0x5a, 0x5a, 0x12, 0x12, 0x05, 0x02, 0x04, 0x14, 0x01, 0x0c, 0x01, 0x0c,
-0x03, 0x20, 0x04, 0x04, 0x01, 0x62, 0x04, 0x01, 0x00, 0x04, 0x32, 0x38,
-0x1f, 0x1f, 0x04, 0x08, 0x01, 0x1d, 0x03, 0x54, 0x03, 0x06, 0x01, 0x23,
-0x01, 0x23, 0x04, 0x18, 0x00, 0x0a, 0x47, 0x21, 0x21, 0x47, 0x21, 0x21,
-0x10, 0x10, 0x16, 0x16, 0x05, 0x13, 0x04, 0x2a, 0x04, 0x0f, 0x04, 0x4c,
-0x04, 0x41, 0x04, 0x49, 0x03, 0x67, 0x04, 0x78, 0x06, 0x3d, 0x05, 0x55,
-0x06, 0x50, 0x04, 0x5e, 0x06, 0x46, 0x05, 0x64, 0x01, 0x60, 0x01, 0x64,
-0x05, 0x4e, 0x05, 0x56, 0x05, 0x48, 0x0b, 0x5f, 0x07, 0x48, 0x04, 0x56,
-0x05, 0x4e, 0x07, 0x64, 0x06, 0x46, 0x05, 0x5e, 0x05, 0x50, 0x05, 0x55,
-0x06, 0x3d, 0x03, 0x78, 0x04, 0x67, 0x04, 0x49, 0x04, 0x41, 0x03, 0x4c,
-0x06, 0x0f, 0x03, 0x2a, 0x04, 0x13, 0x00, 0x05, 0x16, 0x16, 0x13, 0x16,
-0x10, 0x00, 0x05, 0x21, 0x01, 0x47, 0x04, 0x18, 0x01, 0x23, 0x04, 0x06,
-0x00, 0x04, 0x54, 0x54, 0x1d, 0x1d, 0x04, 0x08, 0x00, 0x05, 0x1f, 0x1f,
-0x38, 0x32, 0x32, 0x00, 0x03, 0x01, 0x01, 0x62, 0x04, 0x04, 0x00, 0x04,
-0x20, 0x20, 0x0c, 0x0c, 0x04, 0x14, 0x00, 0x07, 0x02, 0xaa, 0x72, 0x72,
-0xc1, 0xa8, 0xb2, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x07,
-0x03, 0x00, 0x00, 0xb2, 0xf4, 0x76, 0xa5, 0x00, 0x04, 0x82, 0x01, 0x37,
-0x04, 0x52, 0x04, 0x29, 0x03, 0x27, 0x00, 0x03, 0x7b, 0x7b, 0x5a, 0x00,
-0x03, 0x12, 0x05, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x03, 0x20, 0x03, 0x04,
-0x01, 0x62, 0x03, 0x01, 0x00, 0x05, 0x32, 0x38, 0x38, 0x1f, 0x1f, 0x00,
-0x04, 0x08, 0x01, 0x1d, 0x04, 0x54, 0x00, 0x04, 0x06, 0x06, 0x23, 0x23,
-0x04, 0x18, 0x01, 0x47, 0x05, 0x21, 0x00, 0x04, 0x10, 0x10, 0x16, 0x16,
-0x06, 0x13, 0x03, 0x2a, 0x05, 0x0f, 0x03, 0x4c, 0x04, 0x41, 0x04, 0x49,
-0x05, 0x67, 0x01, 0x78, 0x01, 0x78, 0x06, 0x3d, 0x05, 0x55, 0x06, 0x50,
-0x04, 0x5e, 0x05, 0x46, 0x06, 0x64, 0x01, 0x60, 0x06, 0x4e, 0x04, 0x56,
-0x06, 0x48, 0x0b, 0x5f, 0x06, 0x48, 0x06, 0x56, 0x05, 0x4e, 0x07, 0x64,
-0x05, 0x46, 0x06, 0x5e, 0x04, 0x50, 0x06, 0x55, 0x01, 0x3d, 0x01, 0x78,
-0x03, 0x3d, 0x03, 0x78, 0x04, 0x67, 0x04, 0x49, 0x04, 0x41, 0x03, 0x4c,
-0x05, 0x0f, 0x04, 0x2a, 0x04, 0x13, 0x04, 0x16, 0x01, 0x10, 0x04, 0x21,
-0x01, 0x47, 0x01, 0x47, 0x04, 0x18, 0x01, 0x23, 0x04, 0x06, 0x03, 0x54,
-0x01, 0x1d, 0x04, 0x08, 0x00, 0x05, 0x1f, 0x1f, 0x38, 0x32, 0x32, 0x00,
-0x03, 0x01, 0x01, 0x62, 0x04, 0x04, 0x00, 0x04, 0x20, 0x20, 0x0c, 0x0c,
-0x04, 0x14, 0x00, 0x07, 0x02, 0x14, 0xc1, 0x88, 0x72, 0xc1, 0xea, 0x00,
-0x2c, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0x8e,
-0xcf, 0x82, 0xa5, 0x82, 0x03, 0xbb, 0x01, 0x82, 0x01, 0x37, 0x03, 0x52,
-0x03, 0x29, 0x04, 0x27, 0x00, 0x05, 0x7b, 0x5a, 0x5a, 0x12, 0x12, 0x00,
-0x05, 0x02, 0x04, 0x14, 0x03, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x04, 0x04,
-0x01, 0x62, 0x04, 0x01, 0x03, 0x38, 0x01, 0x1f, 0x04, 0x08, 0x01, 0x1d,
-0x01, 0x1d, 0x03, 0x54, 0x03, 0x06, 0x01, 0x23, 0x03, 0x18, 0x01, 0x47,
-0x01, 0x18, 0x05, 0x21, 0x00, 0x04, 0x10, 0x10, 0x16, 0x16, 0x06, 0x13,
-0x01, 0x2a, 0x01, 0x2a, 0x07, 0x0f, 0x01, 0x4c, 0x01, 0x4c, 0x05, 0x41,
-0x04, 0x49, 0x03, 0x67, 0x04, 0x78, 0x05, 0x3d, 0x05, 0x55, 0x05, 0x50,
-0x05, 0x5e, 0x05, 0x46, 0x06, 0x64, 0x01, 0x60, 0x01, 0x60, 0x05, 0x4e,
-0x05, 0x56, 0x07, 0x48, 0x05, 0x5f, 0x00, 0x03, 0x48, 0x5f, 0x5f, 0x00,
-0x07, 0x48, 0x04, 0x56, 0x06, 0x4e, 0x01, 0x64, 0x01, 0x60, 0x04, 0x64,
-0x07, 0x46, 0x04, 0x5e, 0x01, 0x50, 0x01, 0x5e, 0x04, 0x50, 0x05, 0x55,
-0x05, 0x3d, 0x03, 0x78, 0x04, 0x67, 0x05, 0x49, 0x03, 0x41, 0x04, 0x4c,
-0x01, 0x0f, 0x01, 0x4c, 0x03, 0x0f, 0x04, 0x2a, 0x05, 0x13, 0x00, 0x04,
-0x16, 0x16, 0x10, 0x10, 0x04, 0x21, 0x01, 0x47, 0x05, 0x18, 0x00, 0x04,
-0x23, 0x23, 0x06, 0x06, 0x04, 0x54, 0x01, 0x1d, 0x04, 0x08, 0x00, 0x05,
-0x1f, 0x1f, 0x38, 0x38, 0x32, 0x00, 0x03, 0x01, 0x01, 0x62, 0x01, 0x62,
-0x03, 0x04, 0x01, 0x20, 0x01, 0x20, 0x03, 0x0c, 0x04, 0x14, 0x00, 0x07,
-0x02, 0xaf, 0x88, 0x88, 0x72, 0x6c, 0xad, 0x00, 0x2b, 0x00, 0x00, 0x00,
-0x82, 0x00, 0x00, 0x05, 0xb1, 0xd4, 0x82, 0x82, 0xb8, 0x00, 0x03, 0xbb,
-0x01, 0xb4, 0x01, 0x52, 0x04, 0x29, 0x04, 0x27, 0x00, 0x05, 0x7b, 0x5a,
-0x5a, 0x12, 0x12, 0x00, 0x05, 0x02, 0x05, 0x14, 0x00, 0x04, 0x0c, 0x0c,
-0x20, 0x20, 0x04, 0x04, 0x01, 0x62, 0x03, 0x01, 0x00, 0x05, 0x32, 0x32,
-0x38, 0x1f, 0x1f, 0x00, 0x04, 0x08, 0x00, 0x04, 0x1d, 0x1d, 0x54, 0x54,
-0x04, 0x06, 0x01, 0x23, 0x04, 0x18, 0x00, 0x06, 0x47, 0x21, 0x21, 0x47,
-0x21, 0x21, 0x04, 0x16, 0x04, 0x13, 0x05, 0x2a, 0x06, 0x0f, 0x03, 0x4c,
-0x04, 0x41, 0x04, 0x49, 0x01, 0x67, 0x01, 0x67, 0x05, 0x78, 0x05, 0x3d,
-0x06, 0x55, 0x05, 0x50, 0x04, 0x5e, 0x05, 0x46, 0x01, 0x64, 0x01, 0x46,
-0x04, 0x64, 0x03, 0x60, 0x04, 0x4e, 0x05, 0x56, 0x07, 0x48, 0x01, 0x5f,
-0x01, 0x48, 0x04, 0x5f, 0x09, 0x48, 0x04, 0x56, 0x06, 0x4e, 0x06, 0x64,
-0x07, 0x46, 0x04, 0x5e, 0x06, 0x50, 0x05, 0x55, 0x05, 0x3d, 0x05, 0x78,
-0x03, 0x67, 0x05, 0x49, 0x01, 0x41, 0x01, 0x41, 0x04, 0x4c, 0x05, 0x0f,
-0x04, 0x2a, 0x04, 0x13, 0x03, 0x16, 0x01, 0x10, 0x01, 0x10, 0x04, 0x21,
-0x01, 0x47, 0x05, 0x18, 0x00, 0x04, 0x23, 0x23, 0x06, 0x06, 0x03, 0x54,
-0x01, 0x1d, 0x01, 0x1d, 0x04, 0x08, 0x00, 0x05, 0x1f, 0x1f, 0x38, 0x32,
-0x32, 0x00, 0x03, 0x01, 0x01, 0x62, 0x01, 0x62, 0x03, 0x04, 0x01, 0x20,
-0x01, 0x20, 0x03, 0x0c, 0x04, 0x14, 0x00, 0x07, 0x02, 0xaa, 0x74, 0x81,
-0x88, 0x74, 0x90, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x05,
-0x6b, 0x8b, 0xf4, 0xa6, 0xb4, 0x00, 0x04, 0xb8, 0x00, 0x0b, 0xb4, 0x7b,
-0x27, 0x29, 0x29, 0x27, 0x7b, 0x27, 0x7b, 0x12, 0x5a, 0x00, 0x03, 0x12,
-0x05, 0x02, 0x03, 0x14, 0x03, 0x0c, 0x01, 0x20, 0x01, 0x20, 0x03, 0x04,
-0x04, 0x62, 0x00, 0x04, 0x01, 0x01, 0x32, 0x38, 0x03, 0x1f, 0x03, 0x08,
-0x00, 0x04, 0x1d, 0x1d, 0x54, 0x54, 0x03, 0x06, 0x01, 0x23, 0x01, 0x23,
-0x04, 0x18, 0x03, 0x47, 0x01, 0x21, 0x01, 0x21, 0x03, 0x10, 0x03, 0x16,
-0x04, 0x13, 0x04, 0x2a, 0x05, 0x0f, 0x04, 0x4c, 0x04, 0x41, 0x04, 0x49,
-0x01, 0x67, 0x01, 0x67, 0x04, 0x78, 0x07, 0x3d, 0x05, 0x55, 0x06, 0x50,
-0x04, 0x5e, 0x05, 0x46, 0x06, 0x64, 0x01, 0x60, 0x01, 0x60, 0x05, 0x4e,
-0x05, 0x56, 0x14, 0x48, 0x05, 0x56, 0x06, 0x4e, 0x06, 0x64, 0x06, 0x46,
-0x05, 0x5e, 0x06, 0x50, 0x05, 0x55, 0x06, 0x3d, 0x03, 0x78, 0x03, 0x67,
-0x05, 0x49, 0x03, 0x41, 0x04, 0x4c, 0x05, 0x0f, 0x03, 0x2a, 0x05, 0x13,
-0x03, 0x16, 0x01, 0x10, 0x01, 0x10, 0x04, 0x21, 0x00, 0x07, 0x47, 0x47,
-0x18, 0x18, 0x58, 0x23, 0x23, 0x00, 0x03, 0x06, 0x03, 0x54, 0x01, 0x1d,
-0x01, 0x1d, 0x04, 0x08, 0x00, 0x05, 0x1f, 0x1f, 0x38, 0x32, 0x32, 0x00,
-0x03, 0x01, 0x01, 0x62, 0x01, 0x62, 0x03, 0x04, 0x01, 0x20, 0x01, 0x20,
-0x03, 0x0c, 0x04, 0x14, 0x00, 0x08, 0x02, 0x02, 0xc1, 0x6c, 0x6c, 0x74,
-0xa7, 0x6b, 0x2a, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x05, 0xad, 0xea,
-0xb8, 0x37, 0xb4, 0x00, 0x04, 0xb8, 0x00, 0x04, 0xaf, 0xb4, 0xb4, 0x7b,
-0x04, 0x27, 0x01, 0x5a, 0x03, 0x12, 0x06, 0x02, 0x03, 0x14, 0x00, 0x04,
-0x0c, 0x0c, 0x20, 0x20, 0x03, 0x04, 0x03, 0x62, 0x00, 0x05, 0x01, 0x01,
-0x32, 0x32, 0x38, 0x00, 0x04, 0x1f, 0x00, 0x06, 0x08, 0x08, 0x1d, 0x1d,
-0x54, 0x54, 0x03, 0x06, 0x01, 0x23, 0x01, 0x23, 0x04, 0x18, 0x00, 0x04,
-0x47, 0x47, 0x21, 0x47, 0x03, 0x21, 0x00, 0x04, 0x10, 0x10, 0x16, 0x16,
-0x04, 0x13, 0x04, 0x2a, 0x06, 0x0f, 0x03, 0x4c, 0x03, 0x41, 0x03, 0x49,
-0x01, 0x67, 0x01, 0x49, 0x03, 0x67, 0x04, 0x78, 0x06, 0x3d, 0x06, 0x55,
-0x04, 0x50, 0x05, 0x5e, 0x05, 0x46, 0x04, 0x64, 0x01, 0x60, 0x03, 0x64,
-0x06, 0x4e, 0x05, 0x56, 0x12, 0x48, 0x06, 0x56, 0x05, 0x4e, 0x07, 0x64,
-0x06, 0x46, 0x04, 0x5e, 0x07, 0x50, 0x05, 0x55, 0x03, 0x3d, 0x00, 0x03,
-0x78, 0x3d, 0x3d, 0x00, 0x03, 0x78, 0x03, 0x67, 0x04, 0x49, 0x05, 0x41,
-0x01, 0x4c, 0x01, 0x4c, 0x06, 0x0f, 0x03, 0x2a, 0x05, 0x13, 0x03, 0x16,
-0x01, 0x10, 0x01, 0x10, 0x04, 0x21, 0x01, 0x47, 0x04, 0x18, 0x01, 0x23,
-0x01, 0x23, 0x03, 0x06, 0x03, 0x54, 0x01, 0x1d, 0x01, 0x1d, 0x04, 0x08,
-0x00, 0x05, 0x1f, 0x38, 0x38, 0x32, 0x32, 0x00, 0x03, 0x01, 0x01, 0x62,
-0x03, 0x04, 0x03, 0x20, 0x03, 0x0c, 0x04, 0x14, 0x00, 0x0a, 0x02, 0x5a,
-0xaa, 0x91, 0x6c, 0x6c, 0x81, 0xd9, 0x00, 0x03, 0x28, 0x00, 0x00, 0x00,
-0x87, 0x00, 0x00, 0x05, 0xb2, 0xea, 0xa8, 0xb4, 0xb4, 0x00, 0x03, 0xaf,
-0x01, 0xa8, 0x03, 0xaf, 0x00, 0x04, 0xb4, 0xb4, 0x12, 0x7b, 0x03, 0x5a,
-0x01, 0x02, 0x01, 0x12, 0x04, 0x02, 0x01, 0x14, 0x01, 0x14, 0x04, 0x0c,
-0x01, 0x20, 0x01, 0x20, 0x04, 0x04, 0x03, 0x01, 0x00, 0x05, 0x32, 0x32,
-0x38, 0x38, 0x1f, 0x00, 0x05, 0x08, 0x00, 0x03, 0x1d, 0x54, 0x1d, 0x00,
-0x03, 0x06, 0x03, 0x23, 0x01, 0x18, 0x01, 0x18, 0x03, 0x47, 0x01, 0x21,
-0x01, 0x47, 0x04, 0x21, 0x00, 0x04, 0x10, 0x10, 0x16, 0x16, 0x04, 0x13,
-0x04, 0x2a, 0x05, 0x0f, 0x01, 0x4c, 0x01, 0x4c, 0x05, 0x41, 0x04, 0x49,
-0x04, 0x67, 0x01, 0x78, 0x01, 0x78, 0x08, 0x3d, 0x05, 0x55, 0x05, 0x50,
-0x04, 0x5e, 0x07, 0x46, 0x04, 0x64, 0x08, 0x4e, 0x03, 0x56, 0x13, 0x48,
-0x06, 0x56, 0x06, 0x4e, 0x01, 0x64, 0x01, 0x4e, 0x04, 0x64, 0x07, 0x46,
-0x05, 0x5e, 0x04, 0x50, 0x04, 0x55, 0x01, 0x3d, 0x01, 0x55, 0x03, 0x3d,
-0x06, 0x78, 0x04, 0x67, 0x01, 0x49, 0x01, 0x49, 0x05, 0x41, 0x03, 0x4c,
-0x05, 0x0f, 0x04, 0x2a, 0x03, 0x13, 0x04, 0x16, 0x00, 0x04, 0x10, 0x10,
-0x21, 0x21, 0x05, 0x47, 0x01, 0x58, 0x01, 0x58, 0x03, 0x23, 0x04, 0x06,
-0x04, 0x1d, 0x04, 0x08, 0x03, 0x38, 0x00, 0x03, 0x32, 0x01, 0x01, 0x00,
-0x05, 0x04, 0x06, 0x0c, 0x07, 0x02, 0x00, 0x08, 0x5a, 0x5a, 0x74, 0x8f,
-0x8f, 0x80, 0xd0, 0x4d, 0x29, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x07,
-0x03, 0x00, 0x00, 0x0d, 0x75, 0x8b, 0x88, 0x00, 0x04, 0xaf, 0x06, 0xa8,
-0x03, 0xaf, 0x03, 0xaa, 0x03, 0x14, 0x0c, 0xaa, 0x01, 0x62, 0x06, 0x01,
-0x07, 0x1f, 0x06, 0x54, 0x01, 0x06, 0x04, 0xb7, 0x03, 0x18, 0x03, 0x16,
-0x01, 0x10, 0x03, 0x16, 0x04, 0xf3, 0x00, 0x04, 0x13, 0xf3, 0xf3, 0x2a,
-0x08, 0x0f, 0x00, 0x05, 0x4c, 0x4c, 0xfb, 0xfb, 0x41, 0x00, 0x06, 0x49,
-0x01, 0x67, 0x01, 0x67, 0x09, 0x78, 0x03, 0x3d, 0x07, 0x55, 0x05, 0x50,
-0x06, 0x5e, 0x06, 0x46, 0x03, 0x64, 0x05, 0x60, 0x07, 0x4e, 0x10, 0x56,
-0x04, 0x4e, 0x00, 0x04, 0x60, 0x60, 0x4e, 0x4e, 0x04, 0x60, 0x04, 0x64,
-0x0a, 0x46, 0x01, 0x5e, 0x01, 0x5e, 0x05, 0x50, 0x07, 0x55, 0x03, 0x3d,
-0x00, 0x03, 0x78, 0x3d, 0x3d, 0x00, 0x07, 0x78, 0x01, 0x67, 0x01, 0x67,
-0x06, 0x49, 0x01, 0x41, 0x07, 0x4c, 0x05, 0x0f, 0x03, 0x2a, 0x06, 0x13,
-0x06, 0x16, 0x00, 0x03, 0xb7, 0xb7, 0x16, 0x00, 0x08, 0xb7, 0x06, 0x54,
-0x08, 0x1f, 0x04, 0x01, 0x00, 0x04, 0x62, 0xaa, 0x62, 0xaa, 0x03, 0x20,
-0x03, 0xaa, 0x00, 0x0b, 0x14, 0x14, 0x02, 0xf8, 0x8f, 0xcc, 0x8f, 0xcc,
-0xe7, 0x00, 0x03, 0x00, 0x27, 0x00, 0x00, 0x00, 0x86, 0x00, 0x01, 0x0d,
-0x01, 0x11, 0x03, 0x00, 0x00, 0x05, 0x6b, 0x7e, 0xcf, 0x88, 0xa8, 0x00,
-0x03, 0xaf, 0x03, 0xa8, 0x03, 0x72, 0x06, 0xa8, 0x00, 0x06, 0x72, 0xa8,
-0xa8, 0x72, 0x72, 0xa8, 0x23, 0x72, 0x1d, 0x74, 0x13, 0x80, 0x00, 0x04,
-0x81, 0x80, 0x80, 0x81, 0x04, 0x80, 0x1b, 0x81, 0x00, 0x04, 0x91, 0x91,
-0x81, 0x91, 0x34, 0x6c, 0x03, 0x7a, 0x01, 0x6c, 0x22, 0x7a, 0x03, 0x77,
-0x00, 0x03, 0x7a, 0x7a, 0x77, 0x00, 0x03, 0x7a, 0x05, 0x77, 0x01, 0x7a,
-0x2a, 0x77, 0x03, 0xcc, 0x00, 0x04, 0x91, 0xd9, 0x00, 0x03, 0x27, 0x00,
-0x00, 0x00, 0x8e, 0x00, 0x00, 0x0b, 0x8e, 0x7e, 0xea, 0x8f, 0x88, 0xa8,
-0xaf, 0xaf, 0xa8, 0x72, 0x72, 0x00, 0x3d, 0x88, 0x2c, 0x81, 0x01, 0x6c,
-0x09, 0x81, 0x01, 0x6c, 0x03, 0x81, 0x2e, 0x6c, 0x28, 0x8f, 0x1c, 0xcc,
-0x01, 0xa7, 0x03, 0xcc, 0x00, 0x05, 0xa7, 0xcc, 0xa7, 0xa7, 0xcc, 0x00,
-0x14, 0xa7, 0x13, 0x9d, 0x00, 0x07, 0xa7, 0x9d, 0x9d, 0x77, 0xec, 0x00,
-0x03, 0x00, 0x27, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x08, 0x6b, 0xb2,
-0x7d, 0xd0, 0xea, 0xcc, 0x81, 0x88, 0x12, 0xc1, 0x00, 0x03, 0x72, 0x72,
-0xc1, 0x00, 0x24, 0x72, 0x01, 0x74, 0x03, 0x72, 0x01, 0x74, 0x01, 0x72,
-0x27, 0x74, 0x2c, 0x80, 0x01, 0x91, 0x01, 0x80, 0x23, 0x91, 0x05, 0x7a,
-0x01, 0x91, 0x18, 0x7a, 0x04, 0x77, 0x01, 0x7a, 0x1b, 0x77, 0x01, 0x60,
-0x01, 0x64, 0x24, 0x60, 0x00, 0x05, 0x77, 0xfa, 0x6b, 0x00, 0x0d, 0x00,
-0x27, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x08, 0x71, 0x7c, 0xe7, 0xec,
-0x7e, 0x7d, 0x68, 0x90, 0x45, 0x8b, 0x00, 0x03, 0x90, 0x90, 0x8b, 0x00,
-0x2b, 0x90, 0x01, 0x68, 0x04, 0x90, 0x4d, 0x68, 0x00, 0x03, 0x7d, 0x7d,
-0x68, 0x00, 0x4f, 0x7d, 0x00, 0x04, 0xd9, 0x8e, 0x00, 0x0d, 0x28, 0x00,
-0x00, 0x00, 0x9d, 0x00, 0xff, 0x0d, 0x18, 0x0d, 0x2c, 0x00, 0x00, 0x00,
-0x95, 0x00, 0x01, 0x0d, 0x03, 0x03, 0x00, 0x03, 0x11, 0x11, 0x0d, 0x00,
-0xff, 0x00, 0x1a, 0x00, 0x01, 0x0d, 0x2a, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe1, 0x00, 0x00, 0x00, 0xff, 0x00,
-0xe1, 0x00, 0x00, 0x01
-};
diff --git a/include/stm32-reset-core.h b/include/stm32-reset-core.h
new file mode 100644
index 0000000000..90d574bd28
--- /dev/null
+++ b/include/stm32-reset-core.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics SA 2024
+ * Author(s): Gabriel Fernandez, <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <reset-uclass.h>
+
+struct stm32_reset_cfg {
+	u16 offset;
+	u8 bit_idx;
+	bool set_clr;
+	bool inverted;
+};
+
+struct stm32_reset_data {
+	const struct stm32_reset_cfg * (*get_reset_line)(struct reset_ctl *reset_ctl);
+	u32 clear_offset;
+	u32 reset_us;
+};
+
+struct stm32_reset_priv {
+	fdt_addr_t base;
+	struct stm32_reset_cfg reset_line;
+	const struct stm32_reset_data *data;
+};
+
+extern const struct reset_ops stm32_reset_ops;
+
+int stm32_reset_core_probe(struct udevice *dev,
+			   const struct stm32_reset_data *data);
diff --git a/include/stm32_omi.h b/include/stm32_omi.h
new file mode 100644
index 0000000000..119992bfea
--- /dev/null
+++ b/include/stm32_omi.h
@@ -0,0 +1,182 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <clk.h>
+#include <reset.h>
+#include <linux/iopoll.h>
+#include <linux/ioport.h>
+
+/*
+ * OCTOSPI control register
+ */
+#define OSPI_CR			0x00
+#define OSPI_CR_EN		BIT(0)
+#define OSPI_CR_ABORT		BIT(1)
+#define OSPI_CR_TCEN		BIT(3)
+#define OSPI_CR_FSEL		BIT(7)
+#define OSPI_CR_FTHRES_MASK	GENMASK(12,8)
+#define OSPI_CR_CSSEL		BIT(24)
+#define OSPI_CR_FMODE_SHIFT	28
+#define OSPI_CR_FMODE_MASK	GENMASK(29, 28)
+#define OSPI_CR_FMODE_IND_WRITE	0
+#define OSPI_CR_FMODE_IND_READ	1
+#define OSPI_CR_FMODE_MMAP	3
+/*
+ * OCTOSPI device configuration register
+ */
+#define OSPI_DCR1		0x08
+#define OSPI_DCR1_CKMODE	BIT(0)
+#define OSPI_DCR1_DLYBYP	BIT(3)
+#define OSPI_DCR1_CSHT_SHIFT	8
+#define OSPI_DCR1_CSHT_MASK	GENMASK(13, 8)
+#define OSPI_DCR1_DEVSIZE_MASK	GENMASK(20,16)
+#define OSPI_DCR1_MTYP_MASK	GENMASK(26, 24)
+#define OSPI_DCR1_MTYP_SHIFT	24
+#define OSPI_DCR1_MTYP_MX_MODE	1
+#define OSPI_DCR1_MTYP_HP_MEMMODE	4
+/*
+ * OCTOSPI device configuration register 2
+ */
+#define OSPI_DCR2		0x0c
+#define OSPI_DCR2_PRESC_SHIFT	0
+#define OSPI_DCR2_PRESC_MASK	GENMASK(7, 0)
+/*
+ * OCTOSPI status register
+ */
+#define OSPI_SR			0x20
+#define OSPI_SR_TEF		BIT(0)
+#define OSPI_SR_TCF		BIT(1)
+#define OSPI_SR_FTF		BIT(2)
+#define OSPI_SR_BUSY		BIT(5)
+/*
+ * OCTOSPI flag clear register
+ */
+#define OSPI_FCR		0x24
+#define OSPI_FCR_CTEF		BIT(0)
+#define OSPI_FCR_CTCF		BIT(1)
+/*
+ * OCTOSPI data length register
+ */
+#define OSPI_DLR		0x40
+/*
+ * OCTOSPI address register
+ */
+#define OSPI_AR			0x48
+/*
+ * OCTOSPI data configuration register
+ */
+#define OSPI_DR			0x50
+/*
+ * OCTOSPI communication configuration register
+ */
+#define OSPI_CCR		0x100
+#define OSPI_CCR_IMODE_SHIFT	0
+#define OSPI_CCR_IMODE_MASK	GENMASK(2, 0)
+#define OSPI_CCR_IDTR		BIT(3)
+#define OSPI_CCR_ISIZE_SHIFT	4
+#define OSPI_CCR_ISIZE_MASK	GENMASK(5, 4)
+#define OSPI_CCR_ADMODE_SHIFT	8
+#define OSPI_CCR_ADMODE_MASK	GENMASK(10, 8)
+#define OSPI_CCR_ADMODE_8LINES	4
+#define OSPI_CCR_ADDTR		BIT(11)
+#define OSPI_CCR_ADSIZE_SHIFT	12
+#define OSPI_CCR_ADSIZE_MASK	GENMASK(13,12)
+#define OSPI_CCR_ADSIZE_32BITS	3
+#define OSPI_CCR_DMODE_SHIFT	24
+#define OSPI_CCR_DMODE_MASK	GENMASK(26, 24)
+#define OSPI_CCR_DMODE_8LINES	4
+#define OSPI_CCR_IND_WRITE	0
+#define OSPI_CCR_IND_READ	1
+#define OSPI_CCR_MEM_MAP	3
+#define OSPI_CCR_DDTR		BIT(27)
+#define OSPI_CCR_DQSE		BIT(29)
+/*
+ * OCTOSPI timing configuration register
+ */
+#define OSPI_TCR		0x108
+#define OSPI_TCR_DCYC_SHIFT	0x0
+#define OSPI_TCR_DCYC_MASK	GENMASK(4, 0)
+#define OSPI_TCR_DHQC		BIT(28)
+#define OSPI_TCR_SSHIFT		BIT(30)
+/*
+ * OCTOSPI instruction register
+ */
+#define OSPI_IR			0x110
+/*
+ * OCTOSPI low power timeout register
+ */
+#define OSPI_LPTR		0x130
+#define OSPI_LPTR_TIMEOUT_MASK	GENMASK(15, 0)
+
+/*
+ * OCTOSPI write communication configuration register
+ */
+#define OSPI_WCCR		0x180
+/*
+ * HyperBus latency configuration register
+ */
+#define OSPI_HLCR		0x200
+#define OSPI_HLCR_WZL		BIT(1)
+#define OSPI_HLCR_TACC_MASK	GENMASK(15,8)
+#define OSPI_HLCR_TRWR_MASK	GENMASK(23,16)
+
+#define SYSCFG_DLYBOS_CR		0
+#define DLYBOS_CR_EN			BIT(0)
+#define DLYBOS_CR_RXTAPSEL_SHIFT	1
+#define DLYBOS_CR_RXTAPSEL_MASK		GENMASK(6, 1)
+#define DLYBOS_CR_TXTAPSEL_SHIFT	7
+#define DLYBOS_CR_TXTAPSEL_MASK		GENMASK(12, 7)
+#define DLYBOS_TAPSEL_NB		33
+#define DLYBOS_BYP_EN			BIT(16)
+#define DLYBOS_BYP_CMD_MASK		GENMASK(21, 17)
+
+#define SYSCFG_DLYBOS_SR	4
+#define DLYBOS_SR_LOCK		BIT(0)
+#define DLYBOS_SR_RXTAPSEL_ACK	BIT(1)
+#define DLYBOS_SR_TXTAPSEL_ACK	BIT(2)
+
+#define OSPI_MAX_MMAP_SZ	SZ_256M
+#define OSPI_MAX_CHIP		2
+
+#define OSPI_ABT_TIMEOUT_US		100000
+#define OSPI_BUSY_TIMEOUT_US		100000
+#define OSPI_CMD_TIMEOUT_US		1000000
+#define OSPI_FIFO_TIMEOUT_US		30000
+#define STM32_DLYB_FREQ_THRESHOLD	50000000
+#define STM32_DLYBOS_TIMEOUT_MS		1000
+#define STM32_DLYBOS_DELAY_NB		24
+
+struct stm32_omi_plat {
+	struct regmap *regmap;
+	phys_addr_t regs_base;		/* register base address */
+	phys_addr_t mm_base;		/* memory map base address */
+	resource_size_t mm_size;
+	struct clk clk;
+	struct reset_ctl_bulk rst_ctl;
+	ulong clock_rate;
+	u32 dlyb_base;
+	bool jedec_flash;
+};
+
+struct stm32_omi_priv {
+	int (*check_transfer)(struct udevice * omi_dev);
+	struct udevice *dev;
+	bool is_calibrating;
+};
+
+struct stm32_tap_window {
+	u8 end;
+	u8 length;
+};
+
+int stm32_omi_dlyb_configure(struct udevice *dev,
+			     bool bypass_mode, u16 period_ps);
+int stm32_omi_dlyb_find_tap(struct udevice *dev, bool rx_only, u8 *window_len);
+int stm32_omi_dlyb_set_cr(struct udevice *dev, u32 dlyb_cr);
+void stm32_omi_dlyb_get_cr(struct udevice *dev, u32 *dlyb_cr);
+void stm32_omi_dlyb_stop(struct udevice *dev);
+int stm32_omi_tx_poll(struct udevice *dev, u8 *buf, u32 len, bool read);
+int stm32_omi_wait_cmd(struct udevice *dev);
+int stm32_omi_wait_for_not_busy(struct udevice *dev);
diff --git a/include/stm32_rcc.h b/include/stm32_rcc.h
index b559ea7728..447a555dcf 100644
--- a/include/stm32_rcc.h
+++ b/include/stm32_rcc.h
@@ -39,11 +39,11 @@ struct stm32_clk_info {
 	bool v2;
 };
 
+/* platdata used for clk-stm32f.c driver */
 enum soc_family {
 	STM32F42X,
 	STM32F469,
 	STM32F7,
-	STM32MP1,
 };
 
 enum apb {
@@ -51,8 +51,9 @@ enum apb {
 	APB2,
 };
 
-struct stm32_rcc_clk {
-	char *drv_name;
+struct stm32_rcc {
+	char *drv_name_clk;
+	char *drv_name_rst;
 	enum soc_family soc;
 };
 
diff --git a/drivers/clk/stm32/stm32mp13_rcc.h b/include/stm32mp13_rcc.h
similarity index 100%
rename from drivers/clk/stm32/stm32mp13_rcc.h
rename to include/stm32mp13_rcc.h
diff --git a/include/stm32mp21_rcc.h b/include/stm32mp21_rcc.h
new file mode 100644
index 0000000000..2c153f305b
--- /dev/null
+++ b/include/stm32mp21_rcc.h
@@ -0,0 +1,652 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef STM32MP21_RCC_H
+#define STM32MP21_RCC_H
+
+#define RCC_SECCFGR0				0x0
+#define RCC_SECCFGR1				0x4
+#define RCC_SECCFGR2				0x8
+#define RCC_SECCFGR3				0xC
+#define RCC_PRIVCFGR0				0x10
+#define RCC_PRIVCFGR1				0x14
+#define RCC_PRIVCFGR2				0x18
+#define RCC_PRIVCFGR3				0x1C
+#define RCC_RCFGLOCKR0				0x20
+#define RCC_RCFGLOCKR1				0x24
+#define RCC_RCFGLOCKR2				0x28
+#define RCC_RCFGLOCKR3				0x2C
+#define RCC_R0CIDCFGR				0x30
+#define RCC_R0SEMCR				0x34
+#define RCC_R1CIDCFGR				0x38
+#define RCC_R1SEMCR				0x3C
+#define RCC_R2CIDCFGR				0x40
+#define RCC_R2SEMCR				0x44
+#define RCC_R3CIDCFGR				0x48
+#define RCC_R3SEMCR				0x4C
+#define RCC_R4CIDCFGR				0x50
+#define RCC_R4SEMCR				0x54
+#define RCC_R5CIDCFGR				0x58
+#define RCC_R5SEMCR				0x5C
+#define RCC_R6CIDCFGR				0x60
+#define RCC_R6SEMCR				0x64
+#define RCC_R7CIDCFGR				0x68
+#define RCC_R7SEMCR				0x6C
+#define RCC_R8CIDCFGR				0x70
+#define RCC_R8SEMCR				0x74
+#define RCC_R9CIDCFGR				0x78
+#define RCC_R9SEMCR				0x7C
+#define RCC_R10CIDCFGR				0x80
+#define RCC_R10SEMCR				0x84
+#define RCC_R11CIDCFGR				0x88
+#define RCC_R11SEMCR				0x8C
+#define RCC_R12CIDCFGR				0x90
+#define RCC_R12SEMCR				0x94
+#define RCC_R13CIDCFGR				0x98
+#define RCC_R13SEMCR				0x9C
+#define RCC_R14CIDCFGR				0xA0
+#define RCC_R14SEMCR				0xA4
+#define RCC_R15CIDCFGR				0xA8
+#define RCC_R15SEMCR				0xAC
+#define RCC_R16CIDCFGR				0xB0
+#define RCC_R16SEMCR				0xB4
+#define RCC_R17CIDCFGR				0xB8
+#define RCC_R17SEMCR				0xBC
+#define RCC_R18CIDCFGR				0xC0
+#define RCC_R18SEMCR				0xC4
+#define RCC_R19CIDCFGR				0xC8
+#define RCC_R19SEMCR				0xCC
+#define RCC_R20CIDCFGR				0xD0
+#define RCC_R20SEMCR				0xD4
+#define RCC_R21CIDCFGR				0xD8
+#define RCC_R21SEMCR				0xDC
+#define RCC_R22CIDCFGR				0xE0
+#define RCC_R22SEMCR				0xE4
+#define RCC_R23CIDCFGR				0xE8
+#define RCC_R23SEMCR				0xEC
+#define RCC_R24CIDCFGR				0xF0
+#define RCC_R24SEMCR				0xF4
+#define RCC_R25CIDCFGR				0xF8
+#define RCC_R25SEMCR				0xFC
+#define RCC_R26CIDCFGR				0x100
+#define RCC_R26SEMCR				0x104
+#define RCC_R27CIDCFGR				0x108
+#define RCC_R27SEMCR				0x10C
+#define RCC_R28CIDCFGR				0x110
+#define RCC_R28SEMCR				0x114
+#define RCC_R29CIDCFGR				0x118
+#define RCC_R29SEMCR				0x11C
+#define RCC_R30CIDCFGR				0x120
+#define RCC_R30SEMCR				0x124
+#define RCC_R31CIDCFGR				0x128
+#define RCC_R31SEMCR				0x12C
+#define RCC_R32CIDCFGR				0x130
+#define RCC_R32SEMCR				0x134
+#define RCC_R33CIDCFGR				0x138
+#define RCC_R33SEMCR				0x13C
+#define RCC_R34CIDCFGR				0x140
+#define RCC_R34SEMCR				0x144
+#define RCC_R35CIDCFGR				0x148
+#define RCC_R35SEMCR				0x14C
+#define RCC_R36CIDCFGR				0x150
+#define RCC_R36SEMCR				0x154
+#define RCC_R37CIDCFGR				0x158
+#define RCC_R37SEMCR				0x15C
+#define RCC_R38CIDCFGR				0x160
+#define RCC_R38SEMCR				0x164
+#define RCC_R39CIDCFGR				0x168
+#define RCC_R39SEMCR				0x16C
+#define RCC_R40CIDCFGR				0x170
+#define RCC_R40SEMCR				0x174
+#define RCC_R41CIDCFGR				0x178
+#define RCC_R41SEMCR				0x17C
+#define RCC_R42CIDCFGR				0x180
+#define RCC_R42SEMCR				0x184
+#define RCC_R43CIDCFGR				0x188
+#define RCC_R43SEMCR				0x18C
+#define RCC_R44CIDCFGR				0x190
+#define RCC_R44SEMCR				0x194
+#define RCC_R45CIDCFGR				0x198
+#define RCC_R45SEMCR				0x19C
+#define RCC_R46CIDCFGR				0x1A0
+#define RCC_R46SEMCR				0x1A4
+#define RCC_R47CIDCFGR				0x1A8
+#define RCC_R47SEMCR				0x1AC
+#define RCC_R48CIDCFGR				0x1B0
+#define RCC_R48SEMCR				0x1B4
+#define RCC_R49CIDCFGR				0x1B8
+#define RCC_R49SEMCR				0x1BC
+#define RCC_R50CIDCFGR				0x1C0
+#define RCC_R50SEMCR				0x1C4
+#define RCC_R51CIDCFGR				0x1C8
+#define RCC_R51SEMCR				0x1CC
+#define RCC_R52CIDCFGR				0x1D0
+#define RCC_R52SEMCR				0x1D4
+#define RCC_R53CIDCFGR				0x1D8
+#define RCC_R53SEMCR				0x1DC
+#define RCC_R54CIDCFGR				0x1E0
+#define RCC_R54SEMCR				0x1E4
+#define RCC_R55CIDCFGR				0x1E8
+#define RCC_R55SEMCR				0x1EC
+#define RCC_R56CIDCFGR				0x1F0
+#define RCC_R56SEMCR				0x1F4
+#define RCC_R57CIDCFGR				0x1F8
+#define RCC_R57SEMCR				0x1FC
+#define RCC_R58CIDCFGR				0x200
+#define RCC_R58SEMCR				0x204
+#define RCC_R59CIDCFGR				0x208
+#define RCC_R59SEMCR				0x20C
+#define RCC_R60CIDCFGR				0x210
+#define RCC_R60SEMCR				0x214
+#define RCC_R61CIDCFGR				0x218
+#define RCC_R61SEMCR				0x21C
+#define RCC_R62CIDCFGR				0x220
+#define RCC_R62SEMCR				0x224
+#define RCC_R63CIDCFGR				0x228
+#define RCC_R63SEMCR				0x22C
+#define RCC_R64CIDCFGR				0x230
+#define RCC_R64SEMCR				0x234
+#define RCC_R65CIDCFGR				0x238
+#define RCC_R65SEMCR				0x23C
+#define RCC_R66CIDCFGR				0x240
+#define RCC_R66SEMCR				0x244
+#define RCC_R67CIDCFGR				0x248
+#define RCC_R67SEMCR				0x24C
+#define RCC_R68CIDCFGR				0x250
+#define RCC_R68SEMCR				0x254
+#define RCC_R69CIDCFGR				0x258
+#define RCC_R69SEMCR				0x25C
+#define RCC_R70CIDCFGR				0x260
+#define RCC_R70SEMCR				0x264
+#define RCC_R71CIDCFGR				0x268
+#define RCC_R71SEMCR				0x26C
+#define RCC_R73CIDCFGR				0x278
+#define RCC_R73SEMCR				0x27C
+#define RCC_R74CIDCFGR				0x280
+#define RCC_R74SEMCR				0x284
+#define RCC_R75CIDCFGR				0x288
+#define RCC_R75SEMCR				0x28C
+#define RCC_R76CIDCFGR				0x290
+#define RCC_R76SEMCR				0x294
+#define RCC_R77CIDCFGR				0x298
+#define RCC_R77SEMCR				0x29C
+#define RCC_R78CIDCFGR				0x2A0
+#define RCC_R78SEMCR				0x2A4
+#define RCC_R79CIDCFGR				0x2A8
+#define RCC_R79SEMCR				0x2AC
+#define RCC_R83CIDCFGR				0x2C8
+#define RCC_R83SEMCR				0x2CC
+#define RCC_R84CIDCFGR				0x2D0
+#define RCC_R84SEMCR				0x2D4
+#define RCC_R85CIDCFGR				0x2D8
+#define RCC_R85SEMCR				0x2DC
+#define RCC_R86CIDCFGR				0x2E0
+#define RCC_R86SEMCR				0x2E4
+#define RCC_R87CIDCFGR				0x2E8
+#define RCC_R87SEMCR				0x2EC
+#define RCC_R88CIDCFGR				0x2F0
+#define RCC_R88SEMCR				0x2F4
+#define RCC_R90CIDCFGR				0x300
+#define RCC_R90SEMCR				0x304
+#define RCC_R91CIDCFGR				0x308
+#define RCC_R91SEMCR				0x30C
+#define RCC_R92CIDCFGR				0x310
+#define RCC_R92SEMCR				0x314
+#define RCC_R93CIDCFGR				0x318
+#define RCC_R93SEMCR				0x31C
+#define RCC_R94CIDCFGR				0x320
+#define RCC_R94SEMCR				0x324
+#define RCC_R95CIDCFGR				0x328
+#define RCC_R95SEMCR				0x32C
+#define RCC_R96CIDCFGR				0x330
+#define RCC_R96SEMCR				0x334
+#define RCC_R97CIDCFGR				0x338
+#define RCC_R97SEMCR				0x33C
+#define RCC_R98CIDCFGR				0x340
+#define RCC_R98SEMCR				0x344
+#define RCC_R101CIDCFGR				0x358
+#define RCC_R101SEMCR				0x35C
+#define RCC_R102CIDCFGR				0x360
+#define RCC_R102SEMCR				0x364
+#define RCC_R103CIDCFGR				0x368
+#define RCC_R103SEMCR				0x36C
+#define RCC_R104CIDCFGR				0x370
+#define RCC_R104SEMCR				0x374
+#define RCC_R105CIDCFGR				0x378
+#define RCC_R105SEMCR				0x37C
+#define RCC_R106CIDCFGR				0x380
+#define RCC_R106SEMCR				0x384
+#define RCC_R108CIDCFGR				0x390
+#define RCC_R108SEMCR				0x394
+#define RCC_R109CIDCFGR				0x398
+#define RCC_R109SEMCR				0x39C
+#define RCC_R110CIDCFGR				0x3A0
+#define RCC_R110SEMCR				0x3A4
+#define RCC_R111CIDCFGR				0x3A8
+#define RCC_R111SEMCR				0x3AC
+#define RCC_R112CIDCFGR				0x3B0
+#define RCC_R112SEMCR				0x3B4
+#define RCC_R113CIDCFGR				0x3B8
+#define RCC_R113SEMCR				0x3BC
+#define RCC_GRSTCSETR				0x400
+#define RCC_C1RSTCSETR				0x404
+#define RCC_C2RSTCSETR				0x40C
+#define RCC_HWRSTSCLRR				0x410
+#define RCC_C1HWRSTSCLRR			0x414
+#define RCC_C2HWRSTSCLRR			0x418
+#define RCC_C1BOOTRSTSSETR			0x41C
+#define RCC_C1BOOTRSTSCLRR			0x420
+#define RCC_C2BOOTRSTSSETR			0x424
+#define RCC_C2BOOTRSTSCLRR			0x428
+#define RCC_C1SREQSETR				0x42C
+#define RCC_C1SREQCLRR				0x430
+#define RCC_CPUBOOTCR				0x434
+#define RCC_STBYBOOTCR				0x438
+#define RCC_LEGBOOTCR				0x43C
+#define RCC_BDCR				0x440
+#define RCC_RDCR				0x44C
+#define RCC_C1MSRDCR				0x450
+#define RCC_PWRLPDLYCR				0x454
+#define RCC_C1CIESETR				0x458
+#define RCC_C1CIFCLRR				0x45C
+#define RCC_C2CIESETR				0x460
+#define RCC_C2CIFCLRR				0x464
+#define RCC_IWDGC1FZSETR			0x468
+#define RCC_IWDGC1FZCLRR			0x46C
+#define RCC_IWDGC1CFGSETR			0x470
+#define RCC_IWDGC1CFGCLRR			0x474
+#define RCC_IWDGC2FZSETR			0x478
+#define RCC_IWDGC2FZCLRR			0x47C
+#define RCC_IWDGC2CFGSETR			0x480
+#define RCC_IWDGC2CFGCLRR			0x484
+#define RCC_MCO1CFGR				0x488
+#define RCC_MCO2CFGR				0x48C
+#define RCC_OCENSETR				0x490
+#define RCC_OCENCLRR				0x494
+#define RCC_OCRDYR				0x498
+#define RCC_HSICFGR				0x49C
+#define RCC_MSICFGR				0x4A0
+#define RCC_LSICR				0x4A4
+#define RCC_RTCDIVR				0x4A8
+#define RCC_APB1DIVR				0x4AC
+#define RCC_APB2DIVR				0x4B0
+#define RCC_APB3DIVR				0x4B4
+#define RCC_APB4DIVR				0x4B8
+#define RCC_APB5DIVR				0x4BC
+#define RCC_APBDBGDIVR				0x4C0
+#define RCC_TIMG1PRER				0x4C8
+#define RCC_TIMG2PRER				0x4CC
+#define RCC_LSMCUDIVR				0x4D0
+#define RCC_DDRCPCFGR				0x4D4
+#define RCC_DDRCAPBCFGR				0x4D8
+#define RCC_DDRPHYCAPBCFGR			0x4DC
+#define RCC_DDRPHYCCFGR				0x4E0
+#define RCC_DDRCFGR				0x4E4
+#define RCC_DDRITFCFGR				0x4E8
+#define RCC_SYSRAMCFGR				0x4F0
+#define RCC_SRAM1CFGR				0x4F8
+#define RCC_RETRAMCFGR				0x500
+#define RCC_BKPSRAMCFGR				0x504
+#define RCC_OSPI1CFGR				0x514
+#define RCC_FMCCFGR				0x51C
+#define RCC_DBGCFGR				0x520
+#define RCC_STMCFGR				0x524
+#define RCC_ETRCFGR				0x528
+#define RCC_GPIOACFGR				0x52C
+#define RCC_GPIOBCFGR				0x530
+#define RCC_GPIOCCFGR				0x534
+#define RCC_GPIODCFGR				0x538
+#define RCC_GPIOECFGR				0x53C
+#define RCC_GPIOFCFGR				0x540
+#define RCC_GPIOGCFGR				0x544
+#define RCC_GPIOHCFGR				0x548
+#define RCC_GPIOICFGR				0x54C
+#define RCC_GPIOZCFGR				0x558
+#define RCC_HPDMA1CFGR				0x55C
+#define RCC_HPDMA2CFGR				0x560
+#define RCC_HPDMA3CFGR				0x564
+#define RCC_IPCC1CFGR				0x570
+#define RCC_RTCCFGR				0x578
+#define RCC_SYSCPU1CFGR				0x580
+#define RCC_BSECCFGR				0x584
+#define RCC_PLL2CFGR1				0x590
+#define RCC_PLL2CFGR2				0x594
+#define RCC_PLL2CFGR3				0x598
+#define RCC_PLL2CFGR4				0x59C
+#define RCC_PLL2CFGR5				0x5A0
+#define RCC_PLL2CFGR6				0x5A8
+#define RCC_PLL2CFGR7				0x5AC
+#define RCC_HSIFMONCR				0x5E0
+#define RCC_HSIFVALR				0x5E4
+#define RCC_MSIFMONCR				0x5E8
+#define RCC_MSIFVALR				0x5EC
+#define RCC_TIM1CFGR				0x700
+#define RCC_TIM2CFGR				0x704
+#define RCC_TIM3CFGR				0x708
+#define RCC_TIM4CFGR				0x70C
+#define RCC_TIM5CFGR				0x710
+#define RCC_TIM6CFGR				0x714
+#define RCC_TIM7CFGR				0x718
+#define RCC_TIM8CFGR				0x71C
+#define RCC_TIM10CFGR				0x720
+#define RCC_TIM11CFGR				0x724
+#define RCC_TIM12CFGR				0x728
+#define RCC_TIM13CFGR				0x72C
+#define RCC_TIM14CFGR				0x730
+#define RCC_TIM15CFGR				0x734
+#define RCC_TIM16CFGR				0x738
+#define RCC_TIM17CFGR				0x73C
+#define RCC_LPTIM1CFGR				0x744
+#define RCC_LPTIM2CFGR				0x748
+#define RCC_LPTIM3CFGR				0x74C
+#define RCC_LPTIM4CFGR				0x750
+#define RCC_LPTIM5CFGR				0x754
+#define RCC_SPI1CFGR				0x758
+#define RCC_SPI2CFGR				0x75C
+#define RCC_SPI3CFGR				0x760
+#define RCC_SPI4CFGR				0x764
+#define RCC_SPI5CFGR				0x768
+#define RCC_SPI6CFGR				0x76C
+#define RCC_SPDIFRXCFGR				0x778
+#define RCC_USART1CFGR				0x77C
+#define RCC_USART2CFGR				0x780
+#define RCC_USART3CFGR				0x784
+#define RCC_UART4CFGR				0x788
+#define RCC_UART5CFGR				0x78C
+#define RCC_USART6CFGR				0x790
+#define RCC_UART7CFGR				0x794
+#define RCC_LPUART1CFGR				0x7A0
+#define RCC_I2C1CFGR				0x7A4
+#define RCC_I2C2CFGR				0x7A8
+#define RCC_I2C3CFGR				0x7AC
+#define RCC_SAI1CFGR				0x7C4
+#define RCC_SAI2CFGR				0x7C8
+#define RCC_SAI3CFGR				0x7CC
+#define RCC_SAI4CFGR				0x7D0
+#define RCC_MDF1CFGR				0x7D8
+#define RCC_FDCANCFGR				0x7E0
+#define RCC_HDPCFGR				0x7E4
+#define RCC_ADC1CFGR				0x7E8
+#define RCC_ADC2CFGR				0x7EC
+#define RCC_ETH1CFGR				0x7F0
+#define RCC_ETH2CFGR				0x7F4
+#define RCC_USBHCFGR				0x7FC
+#define RCC_USB2PHY1CFGR			0x800
+#define RCC_OTGCFGR				0x808
+#define RCC_USB2PHY2CFGR			0x80C
+#define RCC_STGENCFGR				0x824
+#define RCC_SDMMC1CFGR				0x830
+#define RCC_SDMMC2CFGR				0x834
+#define RCC_SDMMC3CFGR				0x838
+#define RCC_LTDCCFGR				0x840
+#define RCC_CSICFGR				0x858
+#define RCC_DCMIPPCFGR				0x85C
+#define RCC_DCMIPSSICFGR			0x860
+#define RCC_RNG1CFGR				0x870
+#define RCC_RNG2CFGR				0x874
+#define RCC_PKACFGR				0x878
+#define RCC_SAESCFGR				0x87C
+#define RCC_HASH1CFGR				0x880
+#define RCC_HASH2CFGR				0x884
+#define RCC_CRYP1CFGR				0x888
+#define RCC_CRYP2CFGR				0x88C
+#define RCC_CCBCFGR				0x890
+#define RCC_IWDG1CFGR				0x894
+#define RCC_IWDG2CFGR				0x898
+#define RCC_IWDG3CFGR				0x89C
+#define RCC_IWDG4CFGR				0x8A0
+#define RCC_WWDG1CFGR				0x8A4
+#define RCC_VREFCFGR				0x8AC
+#define RCC_DTSCFGR				0x8B0
+#define RCC_CRCCFGR				0x8B4
+#define RCC_SERCCFGR				0x8B8
+#define RCC_DDRPERFMCFGR			0x8C0
+#define RCC_I3C1CFGR				0x8C8
+#define RCC_I3C2CFGR				0x8CC
+#define RCC_I3C3CFGR				0x8D0
+#define RCC_MUXSELCFGR				0x1000
+#define RCC_XBAR0CFGR				0x1018
+#define RCC_XBAR1CFGR				0x101C
+#define RCC_XBAR2CFGR				0x1020
+#define RCC_XBAR3CFGR				0x1024
+#define RCC_XBAR4CFGR				0x1028
+#define RCC_XBAR5CFGR				0x102C
+#define RCC_XBAR6CFGR				0x1030
+#define RCC_XBAR7CFGR				0x1034
+#define RCC_XBAR8CFGR				0x1038
+#define RCC_XBAR9CFGR				0x103C
+#define RCC_XBAR10CFGR				0x1040
+#define RCC_XBAR11CFGR				0x1044
+#define RCC_XBAR12CFGR				0x1048
+#define RCC_XBAR13CFGR				0x104C
+#define RCC_XBAR14CFGR				0x1050
+#define RCC_XBAR15CFGR				0x1054
+#define RCC_XBAR16CFGR				0x1058
+#define RCC_XBAR17CFGR				0x105C
+#define RCC_XBAR18CFGR				0x1060
+#define RCC_XBAR19CFGR				0x1064
+#define RCC_XBAR20CFGR				0x1068
+#define RCC_XBAR21CFGR				0x106C
+#define RCC_XBAR22CFGR				0x1070
+#define RCC_XBAR23CFGR				0x1074
+#define RCC_XBAR24CFGR				0x1078
+#define RCC_XBAR25CFGR				0x107C
+#define RCC_XBAR26CFGR				0x1080
+#define RCC_XBAR27CFGR				0x1084
+#define RCC_XBAR28CFGR				0x1088
+#define RCC_XBAR29CFGR				0x108C
+#define RCC_XBAR30CFGR				0x1090
+#define RCC_XBAR31CFGR				0x1094
+#define RCC_XBAR32CFGR				0x1098
+#define RCC_XBAR33CFGR				0x109C
+#define RCC_XBAR34CFGR				0x10A0
+#define RCC_XBAR35CFGR				0x10A4
+#define RCC_XBAR36CFGR				0x10A8
+#define RCC_XBAR37CFGR				0x10AC
+#define RCC_XBAR38CFGR				0x10B0
+#define RCC_XBAR39CFGR				0x10B4
+#define RCC_XBAR40CFGR				0x10B8
+#define RCC_XBAR41CFGR				0x10BC
+#define RCC_XBAR42CFGR				0x10C0
+#define RCC_XBAR43CFGR				0x10C4
+#define RCC_XBAR44CFGR				0x10C8
+#define RCC_XBAR45CFGR				0x10CC
+#define RCC_XBAR46CFGR				0x10D0
+#define RCC_XBAR47CFGR				0x10D4
+#define RCC_XBAR48CFGR				0x10D8
+#define RCC_XBAR49CFGR				0x10DC
+#define RCC_XBAR50CFGR				0x10E0
+#define RCC_XBAR51CFGR				0x10E4
+#define RCC_XBAR52CFGR				0x10E8
+#define RCC_XBAR53CFGR				0x10EC
+#define RCC_XBAR54CFGR				0x10F0
+#define RCC_XBAR55CFGR				0x10F4
+#define RCC_XBAR56CFGR				0x10F8
+#define RCC_XBAR57CFGR				0x10FC
+#define RCC_XBAR58CFGR				0x1100
+#define RCC_XBAR59CFGR				0x1104
+#define RCC_XBAR60CFGR				0x1108
+#define RCC_XBAR61CFGR				0x110C
+#define RCC_XBAR62CFGR				0x1110
+#define RCC_XBAR63CFGR				0x1114
+#define RCC_PREDIV0CFGR				0x1118
+#define RCC_PREDIV1CFGR				0x111C
+#define RCC_PREDIV2CFGR				0x1120
+#define RCC_PREDIV3CFGR				0x1124
+#define RCC_PREDIV4CFGR				0x1128
+#define RCC_PREDIV5CFGR				0x112C
+#define RCC_PREDIV6CFGR				0x1130
+#define RCC_PREDIV7CFGR				0x1134
+#define RCC_PREDIV8CFGR				0x1138
+#define RCC_PREDIV9CFGR				0x113C
+#define RCC_PREDIV10CFGR			0x1140
+#define RCC_PREDIV11CFGR			0x1144
+#define RCC_PREDIV12CFGR			0x1148
+#define RCC_PREDIV13CFGR			0x114C
+#define RCC_PREDIV14CFGR			0x1150
+#define RCC_PREDIV15CFGR			0x1154
+#define RCC_PREDIV16CFGR			0x1158
+#define RCC_PREDIV17CFGR			0x115C
+#define RCC_PREDIV18CFGR			0x1160
+#define RCC_PREDIV19CFGR			0x1164
+#define RCC_PREDIV20CFGR			0x1168
+#define RCC_PREDIV21CFGR			0x116C
+#define RCC_PREDIV22CFGR			0x1170
+#define RCC_PREDIV23CFGR			0x1174
+#define RCC_PREDIV24CFGR			0x1178
+#define RCC_PREDIV25CFGR			0x117C
+#define RCC_PREDIV26CFGR			0x1180
+#define RCC_PREDIV27CFGR			0x1184
+#define RCC_PREDIV28CFGR			0x1188
+#define RCC_PREDIV29CFGR			0x118C
+#define RCC_PREDIV30CFGR			0x1190
+#define RCC_PREDIV31CFGR			0x1194
+#define RCC_PREDIV32CFGR			0x1198
+#define RCC_PREDIV33CFGR			0x119C
+#define RCC_PREDIV34CFGR			0x11A0
+#define RCC_PREDIV35CFGR			0x11A4
+#define RCC_PREDIV36CFGR			0x11A8
+#define RCC_PREDIV37CFGR			0x11AC
+#define RCC_PREDIV38CFGR			0x11B0
+#define RCC_PREDIV39CFGR			0x11B4
+#define RCC_PREDIV40CFGR			0x11B8
+#define RCC_PREDIV41CFGR			0x11BC
+#define RCC_PREDIV42CFGR			0x11C0
+#define RCC_PREDIV43CFGR			0x11C4
+#define RCC_PREDIV44CFGR			0x11C8
+#define RCC_PREDIV45CFGR			0x11CC
+#define RCC_PREDIV46CFGR			0x11D0
+#define RCC_PREDIV47CFGR			0x11D4
+#define RCC_PREDIV48CFGR			0x11D8
+#define RCC_PREDIV49CFGR			0x11DC
+#define RCC_PREDIV50CFGR			0x11E0
+#define RCC_PREDIV51CFGR			0x11E4
+#define RCC_PREDIV52CFGR			0x11E8
+#define RCC_PREDIV53CFGR			0x11EC
+#define RCC_PREDIV54CFGR			0x11F0
+#define RCC_PREDIV55CFGR			0x11F4
+#define RCC_PREDIV56CFGR			0x11F8
+#define RCC_PREDIV57CFGR			0x11FC
+#define RCC_PREDIV58CFGR			0x1200
+#define RCC_PREDIV59CFGR			0x1204
+#define RCC_PREDIV60CFGR			0x1208
+#define RCC_PREDIV61CFGR			0x120C
+#define RCC_PREDIV62CFGR			0x1210
+#define RCC_PREDIV63CFGR			0x1214
+#define RCC_PREDIVSR1				0x1218
+#define RCC_PREDIVSR2				0x121C
+#define RCC_FINDIV0CFGR				0x1224
+#define RCC_FINDIV1CFGR				0x1228
+#define RCC_FINDIV2CFGR				0x122C
+#define RCC_FINDIV3CFGR				0x1230
+#define RCC_FINDIV4CFGR				0x1234
+#define RCC_FINDIV5CFGR				0x1238
+#define RCC_FINDIV6CFGR				0x123C
+#define RCC_FINDIV7CFGR				0x1240
+#define RCC_FINDIV8CFGR				0x1244
+#define RCC_FINDIV9CFGR				0x1248
+#define RCC_FINDIV10CFGR			0x124C
+#define RCC_FINDIV11CFGR			0x1250
+#define RCC_FINDIV12CFGR			0x1254
+#define RCC_FINDIV13CFGR			0x1258
+#define RCC_FINDIV14CFGR			0x125C
+#define RCC_FINDIV15CFGR			0x1260
+#define RCC_FINDIV16CFGR			0x1264
+#define RCC_FINDIV17CFGR			0x1268
+#define RCC_FINDIV18CFGR			0x126C
+#define RCC_FINDIV19CFGR			0x1270
+#define RCC_FINDIV20CFGR			0x1274
+#define RCC_FINDIV21CFGR			0x1278
+#define RCC_FINDIV22CFGR			0x127C
+#define RCC_FINDIV23CFGR			0x1280
+#define RCC_FINDIV24CFGR			0x1284
+#define RCC_FINDIV25CFGR			0x1288
+#define RCC_FINDIV26CFGR			0x128C
+#define RCC_FINDIV27CFGR			0x1290
+#define RCC_FINDIV28CFGR			0x1294
+#define RCC_FINDIV29CFGR			0x1298
+#define RCC_FINDIV30CFGR			0x129C
+#define RCC_FINDIV31CFGR			0x12A0
+#define RCC_FINDIV32CFGR			0x12A4
+#define RCC_FINDIV33CFGR			0x12A8
+#define RCC_FINDIV34CFGR			0x12AC
+#define RCC_FINDIV35CFGR			0x12B0
+#define RCC_FINDIV36CFGR			0x12B4
+#define RCC_FINDIV37CFGR			0x12B8
+#define RCC_FINDIV38CFGR			0x12BC
+#define RCC_FINDIV39CFGR			0x12C0
+#define RCC_FINDIV40CFGR			0x12C4
+#define RCC_FINDIV41CFGR			0x12C8
+#define RCC_FINDIV42CFGR			0x12CC
+#define RCC_FINDIV43CFGR			0x12D0
+#define RCC_FINDIV44CFGR			0x12D4
+#define RCC_FINDIV45CFGR			0x12D8
+#define RCC_FINDIV46CFGR			0x12DC
+#define RCC_FINDIV47CFGR			0x12E0
+#define RCC_FINDIV48CFGR			0x12E4
+#define RCC_FINDIV49CFGR			0x12E8
+#define RCC_FINDIV50CFGR			0x12EC
+#define RCC_FINDIV51CFGR			0x12F0
+#define RCC_FINDIV52CFGR			0x12F4
+#define RCC_FINDIV53CFGR			0x12F8
+#define RCC_FINDIV54CFGR			0x12FC
+#define RCC_FINDIV55CFGR			0x1300
+#define RCC_FINDIV56CFGR			0x1304
+#define RCC_FINDIV57CFGR			0x1308
+#define RCC_FINDIV58CFGR			0x130C
+#define RCC_FINDIV59CFGR			0x1310
+#define RCC_FINDIV60CFGR			0x1314
+#define RCC_FINDIV61CFGR			0x1318
+#define RCC_FINDIV62CFGR			0x131C
+#define RCC_FINDIV63CFGR			0x1320
+#define RCC_FINDIVSR1				0x1324
+#define RCC_FINDIVSR2				0x1328
+#define RCC_FCALCOBS0CFGR			0x1340
+#define RCC_FCALCOBS1CFGR			0x1344
+#define RCC_FCALCREFCFGR			0x1348
+#define RCC_FCALCCR1				0x134C
+#define RCC_FCALCCR2				0x1354
+#define RCC_FCALCSR				0x1358
+#define RCC_PLL4CFGR1				0x1360
+#define RCC_PLL4CFGR2				0x1364
+#define RCC_PLL4CFGR3				0x1368
+#define RCC_PLL4CFGR4				0x136C
+#define RCC_PLL4CFGR5				0x1370
+#define RCC_PLL4CFGR6				0x1378
+#define RCC_PLL4CFGR7				0x137C
+#define RCC_PLL5CFGR1				0x1388
+#define RCC_PLL5CFGR2				0x138C
+#define RCC_PLL5CFGR3				0x1390
+#define RCC_PLL5CFGR4				0x1394
+#define RCC_PLL5CFGR5				0x1398
+#define RCC_PLL5CFGR6				0x13A0
+#define RCC_PLL5CFGR7				0x13A4
+#define RCC_PLL6CFGR1				0x13B0
+#define RCC_PLL6CFGR2				0x13B4
+#define RCC_PLL6CFGR3				0x13B8
+#define RCC_PLL6CFGR4				0x13BC
+#define RCC_PLL6CFGR5				0x13C0
+#define RCC_PLL6CFGR6				0x13C8
+#define RCC_PLL6CFGR7				0x13CC
+#define RCC_PLL7CFGR1				0x13D8
+#define RCC_PLL7CFGR2				0x13DC
+#define RCC_PLL7CFGR3				0x13E0
+#define RCC_PLL7CFGR4				0x13E4
+#define RCC_PLL7CFGR5				0x13E8
+#define RCC_PLL7CFGR6				0x13F0
+#define RCC_PLL7CFGR7				0x13F4
+#define RCC_PLL8CFGR1				0x1400
+#define RCC_PLL8CFGR2				0x1404
+#define RCC_PLL8CFGR3				0x1408
+#define RCC_PLL8CFGR4				0x140C
+#define RCC_PLL8CFGR5				0x1410
+#define RCC_PLL8CFGR6				0x1418
+#define RCC_PLL8CFGR7				0x141C
+#define RCC_VERR				0xFFF4
+#define RCC_IDR					0xFFF8
+#define RCC_SIDR				0xFFFC
+
+#endif /* STM32MP21_RCC_H */
diff --git a/include/stm32mp25_rcc.h b/include/stm32mp25_rcc.h
new file mode 100644
index 0000000000..93f5c8347f
--- /dev/null
+++ b/include/stm32mp25_rcc.h
@@ -0,0 +1,712 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C STMicroelectronics 2019 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef STM32MP2_RCC_H
+#define STM32MP2_RCC_H
+
+#define RCC_SECCFGR0				0x0
+#define RCC_SECCFGR1				0x4
+#define RCC_SECCFGR2				0x8
+#define RCC_SECCFGR3				0xC
+#define RCC_PRIVCFGR0				0x10
+#define RCC_PRIVCFGR1				0x14
+#define RCC_PRIVCFGR2				0x18
+#define RCC_PRIVCFGR3				0x1C
+#define RCC_RCFGLOCKR0				0x20
+#define RCC_RCFGLOCKR1				0x24
+#define RCC_RCFGLOCKR2				0x28
+#define RCC_RCFGLOCKR3				0x2C
+#define RCC_R0CIDCFGR				0x30
+#define RCC_R0SEMCR				0x34
+#define RCC_R1CIDCFGR				0x38
+#define RCC_R1SEMCR				0x3C
+#define RCC_R2CIDCFGR				0x40
+#define RCC_R2SEMCR				0x44
+#define RCC_R3CIDCFGR				0x48
+#define RCC_R3SEMCR				0x4C
+#define RCC_R4CIDCFGR				0x50
+#define RCC_R4SEMCR				0x54
+#define RCC_R5CIDCFGR				0x58
+#define RCC_R5SEMCR				0x5C
+#define RCC_R6CIDCFGR				0x60
+#define RCC_R6SEMCR				0x64
+#define RCC_R7CIDCFGR				0x68
+#define RCC_R7SEMCR				0x6C
+#define RCC_R8CIDCFGR				0x70
+#define RCC_R8SEMCR				0x74
+#define RCC_R9CIDCFGR				0x78
+#define RCC_R9SEMCR				0x7C
+#define RCC_R10CIDCFGR				0x80
+#define RCC_R10SEMCR				0x84
+#define RCC_R11CIDCFGR				0x88
+#define RCC_R11SEMCR				0x8C
+#define RCC_R12CIDCFGR				0x90
+#define RCC_R12SEMCR				0x94
+#define RCC_R13CIDCFGR				0x98
+#define RCC_R13SEMCR				0x9C
+#define RCC_R14CIDCFGR				0xA0
+#define RCC_R14SEMCR				0xA4
+#define RCC_R15CIDCFGR				0xA8
+#define RCC_R15SEMCR				0xAC
+#define RCC_R16CIDCFGR				0xB0
+#define RCC_R16SEMCR				0xB4
+#define RCC_R17CIDCFGR				0xB8
+#define RCC_R17SEMCR				0xBC
+#define RCC_R18CIDCFGR				0xC0
+#define RCC_R18SEMCR				0xC4
+#define RCC_R19CIDCFGR				0xC8
+#define RCC_R19SEMCR				0xCC
+#define RCC_R20CIDCFGR				0xD0
+#define RCC_R20SEMCR				0xD4
+#define RCC_R21CIDCFGR				0xD8
+#define RCC_R21SEMCR				0xDC
+#define RCC_R22CIDCFGR				0xE0
+#define RCC_R22SEMCR				0xE4
+#define RCC_R23CIDCFGR				0xE8
+#define RCC_R23SEMCR				0xEC
+#define RCC_R24CIDCFGR				0xF0
+#define RCC_R24SEMCR				0xF4
+#define RCC_R25CIDCFGR				0xF8
+#define RCC_R25SEMCR				0xFC
+#define RCC_R26CIDCFGR				0x100
+#define RCC_R26SEMCR				0x104
+#define RCC_R27CIDCFGR				0x108
+#define RCC_R27SEMCR				0x10C
+#define RCC_R28CIDCFGR				0x110
+#define RCC_R28SEMCR				0x114
+#define RCC_R29CIDCFGR				0x118
+#define RCC_R29SEMCR				0x11C
+#define RCC_R30CIDCFGR				0x120
+#define RCC_R30SEMCR				0x124
+#define RCC_R31CIDCFGR				0x128
+#define RCC_R31SEMCR				0x12C
+#define RCC_R32CIDCFGR				0x130
+#define RCC_R32SEMCR				0x134
+#define RCC_R33CIDCFGR				0x138
+#define RCC_R33SEMCR				0x13C
+#define RCC_R34CIDCFGR				0x140
+#define RCC_R34SEMCR				0x144
+#define RCC_R35CIDCFGR				0x148
+#define RCC_R35SEMCR				0x14C
+#define RCC_R36CIDCFGR				0x150
+#define RCC_R36SEMCR				0x154
+#define RCC_R37CIDCFGR				0x158
+#define RCC_R37SEMCR				0x15C
+#define RCC_R38CIDCFGR				0x160
+#define RCC_R38SEMCR				0x164
+#define RCC_R39CIDCFGR				0x168
+#define RCC_R39SEMCR				0x16C
+#define RCC_R40CIDCFGR				0x170
+#define RCC_R40SEMCR				0x174
+#define RCC_R41CIDCFGR				0x178
+#define RCC_R41SEMCR				0x17C
+#define RCC_R42CIDCFGR				0x180
+#define RCC_R42SEMCR				0x184
+#define RCC_R43CIDCFGR				0x188
+#define RCC_R43SEMCR				0x18C
+#define RCC_R44CIDCFGR				0x190
+#define RCC_R44SEMCR				0x194
+#define RCC_R45CIDCFGR				0x198
+#define RCC_R45SEMCR				0x19C
+#define RCC_R46CIDCFGR				0x1A0
+#define RCC_R46SEMCR				0x1A4
+#define RCC_R47CIDCFGR				0x1A8
+#define RCC_R47SEMCR				0x1AC
+#define RCC_R48CIDCFGR				0x1B0
+#define RCC_R48SEMCR				0x1B4
+#define RCC_R49CIDCFGR				0x1B8
+#define RCC_R49SEMCR				0x1BC
+#define RCC_R50CIDCFGR				0x1C0
+#define RCC_R50SEMCR				0x1C4
+#define RCC_R51CIDCFGR				0x1C8
+#define RCC_R51SEMCR				0x1CC
+#define RCC_R52CIDCFGR				0x1D0
+#define RCC_R52SEMCR				0x1D4
+#define RCC_R53CIDCFGR				0x1D8
+#define RCC_R53SEMCR				0x1DC
+#define RCC_R54CIDCFGR				0x1E0
+#define RCC_R54SEMCR				0x1E4
+#define RCC_R55CIDCFGR				0x1E8
+#define RCC_R55SEMCR				0x1EC
+#define RCC_R56CIDCFGR				0x1F0
+#define RCC_R56SEMCR				0x1F4
+#define RCC_R57CIDCFGR				0x1F8
+#define RCC_R57SEMCR				0x1FC
+#define RCC_R58CIDCFGR				0x200
+#define RCC_R58SEMCR				0x204
+#define RCC_R59CIDCFGR				0x208
+#define RCC_R59SEMCR				0x20C
+#define RCC_R60CIDCFGR				0x210
+#define RCC_R60SEMCR				0x214
+#define RCC_R61CIDCFGR				0x218
+#define RCC_R61SEMCR				0x21C
+#define RCC_R62CIDCFGR				0x220
+#define RCC_R62SEMCR				0x224
+#define RCC_R63CIDCFGR				0x228
+#define RCC_R63SEMCR				0x22C
+#define RCC_R64CIDCFGR				0x230
+#define RCC_R64SEMCR				0x234
+#define RCC_R65CIDCFGR				0x238
+#define RCC_R65SEMCR				0x23C
+#define RCC_R66CIDCFGR				0x240
+#define RCC_R66SEMCR				0x244
+#define RCC_R67CIDCFGR				0x248
+#define RCC_R67SEMCR				0x24C
+#define RCC_R68CIDCFGR				0x250
+#define RCC_R68SEMCR				0x254
+#define RCC_R69CIDCFGR				0x258
+#define RCC_R69SEMCR				0x25C
+#define RCC_R70CIDCFGR				0x260
+#define RCC_R70SEMCR				0x264
+#define RCC_R71CIDCFGR				0x268
+#define RCC_R71SEMCR				0x26C
+#define RCC_R72CIDCFGR				0x270
+#define RCC_R72SEMCR				0x274
+#define RCC_R73CIDCFGR				0x278
+#define RCC_R73SEMCR				0x27C
+#define RCC_R74CIDCFGR				0x280
+#define RCC_R74SEMCR				0x284
+#define RCC_R75CIDCFGR				0x288
+#define RCC_R75SEMCR				0x28C
+#define RCC_R76CIDCFGR				0x290
+#define RCC_R76SEMCR				0x294
+#define RCC_R77CIDCFGR				0x298
+#define RCC_R77SEMCR				0x29C
+#define RCC_R78CIDCFGR				0x2A0
+#define RCC_R78SEMCR				0x2A4
+#define RCC_R79CIDCFGR				0x2A8
+#define RCC_R79SEMCR				0x2AC
+#define RCC_R80CIDCFGR				0x2B0
+#define RCC_R80SEMCR				0x2B4
+#define RCC_R81CIDCFGR				0x2B8
+#define RCC_R81SEMCR				0x2BC
+#define RCC_R82CIDCFGR				0x2C0
+#define RCC_R82SEMCR				0x2C4
+#define RCC_R83CIDCFGR				0x2C8
+#define RCC_R83SEMCR				0x2CC
+#define RCC_R84CIDCFGR				0x2D0
+#define RCC_R84SEMCR				0x2D4
+#define RCC_R85CIDCFGR				0x2D8
+#define RCC_R85SEMCR				0x2DC
+#define RCC_R86CIDCFGR				0x2E0
+#define RCC_R86SEMCR				0x2E4
+#define RCC_R87CIDCFGR				0x2E8
+#define RCC_R87SEMCR				0x2EC
+#define RCC_R88CIDCFGR				0x2F0
+#define RCC_R88SEMCR				0x2F4
+#define RCC_R89CIDCFGR				0x2F8
+#define RCC_R89SEMCR				0x2FC
+#define RCC_R90CIDCFGR				0x300
+#define RCC_R90SEMCR				0x304
+#define RCC_R91CIDCFGR				0x308
+#define RCC_R91SEMCR				0x30C
+#define RCC_R92CIDCFGR				0x310
+#define RCC_R92SEMCR				0x314
+#define RCC_R93CIDCFGR				0x318
+#define RCC_R93SEMCR				0x31C
+#define RCC_R94CIDCFGR				0x320
+#define RCC_R94SEMCR				0x324
+#define RCC_R95CIDCFGR				0x328
+#define RCC_R95SEMCR				0x32C
+#define RCC_R96CIDCFGR				0x330
+#define RCC_R96SEMCR				0x334
+#define RCC_R97CIDCFGR				0x338
+#define RCC_R97SEMCR				0x33C
+#define RCC_R98CIDCFGR				0x340
+#define RCC_R98SEMCR				0x344
+#define RCC_R99CIDCFGR				0x348
+#define RCC_R99SEMCR				0x34C
+#define RCC_R100CIDCFGR				0x350
+#define RCC_R100SEMCR				0x354
+#define RCC_R101CIDCFGR				0x358
+#define RCC_R101SEMCR				0x35C
+#define RCC_R102CIDCFGR				0x360
+#define RCC_R102SEMCR				0x364
+#define RCC_R103CIDCFGR				0x368
+#define RCC_R103SEMCR				0x36C
+#define RCC_R104CIDCFGR				0x370
+#define RCC_R104SEMCR				0x374
+#define RCC_R105CIDCFGR				0x378
+#define RCC_R105SEMCR				0x37C
+#define RCC_R106CIDCFGR				0x380
+#define RCC_R106SEMCR				0x384
+#define RCC_R107CIDCFGR				0x388
+#define RCC_R107SEMCR				0x38C
+#define RCC_R108CIDCFGR				0x390
+#define RCC_R108SEMCR				0x394
+#define RCC_R109CIDCFGR				0x398
+#define RCC_R109SEMCR				0x39C
+#define RCC_R110CIDCFGR				0x3A0
+#define RCC_R110SEMCR				0x3A4
+#define RCC_R111CIDCFGR				0x3A8
+#define RCC_R111SEMCR				0x3AC
+#define RCC_R112CIDCFGR				0x3B0
+#define RCC_R112SEMCR				0x3B4
+#define RCC_R113CIDCFGR				0x3B8
+#define RCC_R113SEMCR				0x3BC
+#define RCC_GRSTCSETR				0x400
+#define RCC_C1RSTCSETR				0x404
+#define RCC_C1P1RSTCSETR			0x408
+#define RCC_C2RSTCSETR				0x40C
+#define RCC_HWRSTSCLRR				0x410
+#define RCC_C1HWRSTSCLRR			0x414
+#define RCC_C2HWRSTSCLRR			0x418
+#define RCC_C1BOOTRSTSSETR			0x41C
+#define RCC_C1BOOTRSTSCLRR			0x420
+#define RCC_C2BOOTRSTSSETR			0x424
+#define RCC_C2BOOTRSTSCLRR			0x428
+#define RCC_C1SREQSETR				0x42C
+#define RCC_C1SREQCLRR				0x430
+#define RCC_CPUBOOTCR				0x434
+#define RCC_STBYBOOTCR				0x438
+#define RCC_LEGBOOTCR				0x43C
+#define RCC_BDCR				0x440
+#define RCC_D3DCR				0x444
+#define RCC_D3DSR				0x448
+#define RCC_RDCR				0x44C
+#define RCC_C1MSRDCR				0x450
+#define RCC_PWRLPDLYCR				0x454
+#define RCC_C1CIESETR				0x458
+#define RCC_C1CIFCLRR				0x45C
+#define RCC_C2CIESETR				0x460
+#define RCC_C2CIFCLRR				0x464
+#define RCC_IWDGC1FZSETR			0x468
+#define RCC_IWDGC1FZCLRR			0x46C
+#define RCC_IWDGC1CFGSETR			0x470
+#define RCC_IWDGC1CFGCLRR			0x474
+#define RCC_IWDGC2FZSETR			0x478
+#define RCC_IWDGC2FZCLRR			0x47C
+#define RCC_IWDGC2CFGSETR			0x480
+#define RCC_IWDGC2CFGCLRR			0x484
+#define RCC_IWDGC3CFGSETR			0x488
+#define RCC_IWDGC3CFGCLRR			0x48C
+#define RCC_C3CFGR				0x490
+#define RCC_MCO1CFGR				0x494
+#define RCC_MCO2CFGR				0x498
+#define RCC_OCENSETR				0x49C
+#define RCC_OCENCLRR				0x4A0
+#define RCC_OCRDYR				0x4A4
+#define RCC_HSICFGR				0x4A8
+#define RCC_MSICFGR				0x4AC
+#define RCC_RTCDIVR				0x4B0
+#define RCC_APB1DIVR				0x4B4
+#define RCC_APB2DIVR				0x4B8
+#define RCC_APB3DIVR				0x4BC
+#define RCC_APB4DIVR				0x4C0
+#define RCC_APBDBGDIVR				0x4C4
+#define RCC_TIMG1PRER				0x4C8
+#define RCC_TIMG2PRER				0x4CC
+#define RCC_LSMCUDIVR				0x4D0
+#define RCC_DDRCPCFGR				0x4D4
+#define RCC_DDRCAPBCFGR				0x4D8
+#define RCC_DDRPHYCAPBCFGR			0x4DC
+#define RCC_DDRPHYCCFGR				0x4E0
+#define RCC_DDRCFGR				0x4E4
+#define RCC_DDRITFCFGR				0x4E8
+#define RCC_SYSRAMCFGR				0x4F0
+#define RCC_VDERAMCFGR				0x4F4
+#define RCC_SRAM1CFGR				0x4F8
+#define RCC_SRAM2CFGR				0x4FC
+#define RCC_RETRAMCFGR				0x500
+#define RCC_BKPSRAMCFGR				0x504
+#define RCC_LPSRAM1CFGR				0x508
+#define RCC_LPSRAM2CFGR				0x50C
+#define RCC_LPSRAM3CFGR				0x510
+#define RCC_OSPI1CFGR				0x514
+#define RCC_OSPI2CFGR				0x518
+#define RCC_FMCCFGR				0x51C
+#define RCC_DBGCFGR				0x520
+#define RCC_STM500CFGR				0x524
+#define RCC_ETRCFGR				0x528
+#define RCC_GPIOACFGR				0x52C
+#define RCC_GPIOBCFGR				0x530
+#define RCC_GPIOCCFGR				0x534
+#define RCC_GPIODCFGR				0x538
+#define RCC_GPIOECFGR				0x53C
+#define RCC_GPIOFCFGR				0x540
+#define RCC_GPIOGCFGR				0x544
+#define RCC_GPIOHCFGR				0x548
+#define RCC_GPIOICFGR				0x54C
+#define RCC_GPIOJCFGR				0x550
+#define RCC_GPIOKCFGR				0x554
+#define RCC_GPIOZCFGR				0x558
+#define RCC_HPDMA1CFGR				0x55C
+#define RCC_HPDMA2CFGR				0x560
+#define RCC_HPDMA3CFGR				0x564
+#define RCC_LPDMACFGR				0x568
+#define RCC_HSEMCFGR				0x56C
+#define RCC_IPCC1CFGR				0x570
+#define RCC_IPCC2CFGR				0x574
+#define RCC_RTCCFGR				0x578
+#define RCC_SYSCPU1CFGR				0x580
+#define RCC_BSECCFGR				0x584
+#define RCC_IS2MCFGR				0x58C
+#define RCC_PLL2CFGR1				0x590
+#define RCC_PLL2CFGR2				0x594
+#define RCC_PLL2CFGR3				0x598
+#define RCC_PLL2CFGR4				0x59C
+#define RCC_PLL2CFGR5				0x5A0
+#define RCC_PLL2CFGR6				0x5A8
+#define RCC_PLL2CFGR7				0x5AC
+#define RCC_PLL3CFGR1				0x5B8
+#define RCC_PLL3CFGR2				0x5BC
+#define RCC_PLL3CFGR3				0x5C0
+#define RCC_PLL3CFGR4				0x5C4
+#define RCC_PLL3CFGR5				0x5C8
+#define RCC_PLL3CFGR6				0x5D0
+#define RCC_PLL3CFGR7				0x5D4
+#define RCC_HSIFMONCR				0x5E0
+#define RCC_HSIFVALR				0x5E4
+#define RCC_TIM1CFGR				0x700
+#define RCC_TIM2CFGR				0x704
+#define RCC_TIM3CFGR				0x708
+#define RCC_TIM4CFGR				0x70C
+#define RCC_TIM5CFGR				0x710
+#define RCC_TIM6CFGR				0x714
+#define RCC_TIM7CFGR				0x718
+#define RCC_TIM8CFGR				0x71C
+#define RCC_TIM10CFGR				0x720
+#define RCC_TIM11CFGR				0x724
+#define RCC_TIM12CFGR				0x728
+#define RCC_TIM13CFGR				0x72C
+#define RCC_TIM14CFGR				0x730
+#define RCC_TIM15CFGR				0x734
+#define RCC_TIM16CFGR				0x738
+#define RCC_TIM17CFGR				0x73C
+#define RCC_TIM20CFGR				0x740
+#define RCC_LPTIM1CFGR				0x744
+#define RCC_LPTIM2CFGR				0x748
+#define RCC_LPTIM3CFGR				0x74C
+#define RCC_LPTIM4CFGR				0x750
+#define RCC_LPTIM5CFGR				0x754
+#define RCC_SPI1CFGR				0x758
+#define RCC_SPI2CFGR				0x75C
+#define RCC_SPI3CFGR				0x760
+#define RCC_SPI4CFGR				0x764
+#define RCC_SPI5CFGR				0x768
+#define RCC_SPI6CFGR				0x76C
+#define RCC_SPI7CFGR				0x770
+#define RCC_SPI8CFGR				0x774
+#define RCC_SPDIFRXCFGR				0x778
+#define RCC_USART1CFGR				0x77C
+#define RCC_USART2CFGR				0x780
+#define RCC_USART3CFGR				0x784
+#define RCC_UART4CFGR				0x788
+#define RCC_UART5CFGR				0x78C
+#define RCC_USART6CFGR				0x790
+#define RCC_UART7CFGR				0x794
+#define RCC_UART8CFGR				0x798
+#define RCC_UART9CFGR				0x79C
+#define RCC_LPUART1CFGR				0x7A0
+#define RCC_I2C1CFGR				0x7A4
+#define RCC_I2C2CFGR				0x7A8
+#define RCC_I2C3CFGR				0x7AC
+#define RCC_I2C4CFGR				0x7B0
+#define RCC_I2C5CFGR				0x7B4
+#define RCC_I2C6CFGR				0x7B8
+#define RCC_I2C7CFGR				0x7BC
+#define RCC_I2C8CFGR				0x7C0
+#define RCC_SAI1CFGR				0x7C4
+#define RCC_SAI2CFGR				0x7C8
+#define RCC_SAI3CFGR				0x7CC
+#define RCC_SAI4CFGR				0x7D0
+#define RCC_MDF1CFGR				0x7D8
+#define RCC_ADF1CFGR				0x7DC
+#define RCC_FDCANCFGR				0x7E0
+#define RCC_HDPCFGR				0x7E4
+#define RCC_ADC12CFGR				0x7E8
+#define RCC_ADC3CFGR				0x7EC
+#define RCC_ETH1CFGR				0x7F0
+#define RCC_ETH2CFGR				0x7F4
+#define RCC_USB2CFGR				0x7FC
+#define RCC_USB2PHY1CFGR			0x800
+#define RCC_USB2PHY2CFGR			0x804
+#define RCC_USB3DRCFGR				0x808
+#define RCC_USB3PCIEPHYCFGR			0x80C
+#define RCC_PCIECFGR				0x810
+#define RCC_USBTCCFGR				0x814
+#define RCC_ETHSWCFGR				0x818
+#define RCC_ETHSWACMCFGR			0x81C
+#define RCC_ETHSWACMMSGCFGR			0x820
+#define RCC_STGENCFGR				0x824
+#define RCC_SDMMC1CFGR				0x830
+#define RCC_SDMMC2CFGR				0x834
+#define RCC_SDMMC3CFGR				0x838
+#define RCC_GPUCFGR				0x83C
+#define RCC_LTDCCFGR				0x840
+#define RCC_DSICFGR				0x844
+#define RCC_LVDSCFGR				0x850
+#define RCC_CSICFGR				0x858
+#define RCC_DCMIPPCFGR				0x85C
+#define RCC_CCICFGR				0x860
+#define RCC_VDECCFGR				0x864
+#define RCC_VENCCFGR				0x868
+#define RCC_RNGCFGR				0x870
+#define RCC_PKACFGR				0x874
+#define RCC_SAESCFGR				0x878
+#define RCC_HASHCFGR				0x87C
+#define RCC_CRYP1CFGR				0x880
+#define RCC_CRYP2CFGR				0x884
+#define RCC_IWDG1CFGR				0x888
+#define RCC_IWDG2CFGR				0x88C
+#define RCC_IWDG3CFGR				0x890
+#define RCC_IWDG4CFGR				0x894
+#define RCC_IWDG5CFGR				0x898
+#define RCC_WWDG1CFGR				0x89C
+#define RCC_WWDG2CFGR				0x8A0
+#define RCC_VREFCFGR				0x8A8
+#define RCC_DTSCFGR				0x8AC
+#define RCC_CRCCFGR				0x8B4
+#define RCC_SERCCFGR				0x8B8
+#define RCC_OSPIIOMCFGR				0x8BC
+#define RCC_GICV2MCFGR				0x8C0
+#define RCC_I3C1CFGR				0x8C8
+#define RCC_I3C2CFGR				0x8CC
+#define RCC_I3C3CFGR				0x8D0
+#define RCC_I3C4CFGR				0x8D4
+#define RCC_MUXSELCFGR				0x1000
+#define RCC_XBAR0CFGR				0x1018
+#define RCC_XBAR1CFGR				0x101C
+#define RCC_XBAR2CFGR				0x1020
+#define RCC_XBAR3CFGR				0x1024
+#define RCC_XBAR4CFGR				0x1028
+#define RCC_XBAR5CFGR				0x102C
+#define RCC_XBAR6CFGR				0x1030
+#define RCC_XBAR7CFGR				0x1034
+#define RCC_XBAR8CFGR				0x1038
+#define RCC_XBAR9CFGR				0x103C
+#define RCC_XBAR10CFGR				0x1040
+#define RCC_XBAR11CFGR				0x1044
+#define RCC_XBAR12CFGR				0x1048
+#define RCC_XBAR13CFGR				0x104C
+#define RCC_XBAR14CFGR				0x1050
+#define RCC_XBAR15CFGR				0x1054
+#define RCC_XBAR16CFGR				0x1058
+#define RCC_XBAR17CFGR				0x105C
+#define RCC_XBAR18CFGR				0x1060
+#define RCC_XBAR19CFGR				0x1064
+#define RCC_XBAR20CFGR				0x1068
+#define RCC_XBAR21CFGR				0x106C
+#define RCC_XBAR22CFGR				0x1070
+#define RCC_XBAR23CFGR				0x1074
+#define RCC_XBAR24CFGR				0x1078
+#define RCC_XBAR25CFGR				0x107C
+#define RCC_XBAR26CFGR				0x1080
+#define RCC_XBAR27CFGR				0x1084
+#define RCC_XBAR28CFGR				0x1088
+#define RCC_XBAR29CFGR				0x108C
+#define RCC_XBAR30CFGR				0x1090
+#define RCC_XBAR31CFGR				0x1094
+#define RCC_XBAR32CFGR				0x1098
+#define RCC_XBAR33CFGR				0x109C
+#define RCC_XBAR34CFGR				0x10A0
+#define RCC_XBAR35CFGR				0x10A4
+#define RCC_XBAR36CFGR				0x10A8
+#define RCC_XBAR37CFGR				0x10AC
+#define RCC_XBAR38CFGR				0x10B0
+#define RCC_XBAR39CFGR				0x10B4
+#define RCC_XBAR40CFGR				0x10B8
+#define RCC_XBAR41CFGR				0x10BC
+#define RCC_XBAR42CFGR				0x10C0
+#define RCC_XBAR43CFGR				0x10C4
+#define RCC_XBAR44CFGR				0x10C8
+#define RCC_XBAR45CFGR				0x10CC
+#define RCC_XBAR46CFGR				0x10D0
+#define RCC_XBAR47CFGR				0x10D4
+#define RCC_XBAR48CFGR				0x10D8
+#define RCC_XBAR49CFGR				0x10DC
+#define RCC_XBAR50CFGR				0x10E0
+#define RCC_XBAR51CFGR				0x10E4
+#define RCC_XBAR52CFGR				0x10E8
+#define RCC_XBAR53CFGR				0x10EC
+#define RCC_XBAR54CFGR				0x10F0
+#define RCC_XBAR55CFGR				0x10F4
+#define RCC_XBAR56CFGR				0x10F8
+#define RCC_XBAR57CFGR				0x10FC
+#define RCC_XBAR58CFGR				0x1100
+#define RCC_XBAR59CFGR				0x1104
+#define RCC_XBAR60CFGR				0x1108
+#define RCC_XBAR61CFGR				0x110C
+#define RCC_XBAR62CFGR				0x1110
+#define RCC_XBAR63CFGR				0x1114
+#define RCC_PREDIV0CFGR				0x1118
+#define RCC_PREDIV1CFGR				0x111C
+#define RCC_PREDIV2CFGR				0x1120
+#define RCC_PREDIV3CFGR				0x1124
+#define RCC_PREDIV4CFGR				0x1128
+#define RCC_PREDIV5CFGR				0x112C
+#define RCC_PREDIV6CFGR				0x1130
+#define RCC_PREDIV7CFGR				0x1134
+#define RCC_PREDIV8CFGR				0x1138
+#define RCC_PREDIV9CFGR				0x113C
+#define RCC_PREDIV10CFGR			0x1140
+#define RCC_PREDIV11CFGR			0x1144
+#define RCC_PREDIV12CFGR			0x1148
+#define RCC_PREDIV13CFGR			0x114C
+#define RCC_PREDIV14CFGR			0x1150
+#define RCC_PREDIV15CFGR			0x1154
+#define RCC_PREDIV16CFGR			0x1158
+#define RCC_PREDIV17CFGR			0x115C
+#define RCC_PREDIV18CFGR			0x1160
+#define RCC_PREDIV19CFGR			0x1164
+#define RCC_PREDIV20CFGR			0x1168
+#define RCC_PREDIV21CFGR			0x116C
+#define RCC_PREDIV22CFGR			0x1170
+#define RCC_PREDIV23CFGR			0x1174
+#define RCC_PREDIV24CFGR			0x1178
+#define RCC_PREDIV25CFGR			0x117C
+#define RCC_PREDIV26CFGR			0x1180
+#define RCC_PREDIV27CFGR			0x1184
+#define RCC_PREDIV28CFGR			0x1188
+#define RCC_PREDIV29CFGR			0x118C
+#define RCC_PREDIV30CFGR			0x1190
+#define RCC_PREDIV31CFGR			0x1194
+#define RCC_PREDIV32CFGR			0x1198
+#define RCC_PREDIV33CFGR			0x119C
+#define RCC_PREDIV34CFGR			0x11A0
+#define RCC_PREDIV35CFGR			0x11A4
+#define RCC_PREDIV36CFGR			0x11A8
+#define RCC_PREDIV37CFGR			0x11AC
+#define RCC_PREDIV38CFGR			0x11B0
+#define RCC_PREDIV39CFGR			0x11B4
+#define RCC_PREDIV40CFGR			0x11B8
+#define RCC_PREDIV41CFGR			0x11BC
+#define RCC_PREDIV42CFGR			0x11C0
+#define RCC_PREDIV43CFGR			0x11C4
+#define RCC_PREDIV44CFGR			0x11C8
+#define RCC_PREDIV45CFGR			0x11CC
+#define RCC_PREDIV46CFGR			0x11D0
+#define RCC_PREDIV47CFGR			0x11D4
+#define RCC_PREDIV48CFGR			0x11D8
+#define RCC_PREDIV49CFGR			0x11DC
+#define RCC_PREDIV50CFGR			0x11E0
+#define RCC_PREDIV51CFGR			0x11E4
+#define RCC_PREDIV52CFGR			0x11E8
+#define RCC_PREDIV53CFGR			0x11EC
+#define RCC_PREDIV54CFGR			0x11F0
+#define RCC_PREDIV55CFGR			0x11F4
+#define RCC_PREDIV56CFGR			0x11F8
+#define RCC_PREDIV57CFGR			0x11FC
+#define RCC_PREDIV58CFGR			0x1200
+#define RCC_PREDIV59CFGR			0x1204
+#define RCC_PREDIV60CFGR			0x1208
+#define RCC_PREDIV61CFGR			0x120C
+#define RCC_PREDIV62CFGR			0x1210
+#define RCC_PREDIV63CFGR			0x1214
+#define RCC_PREDIVSR1				0x1218
+#define RCC_PREDIVSR2				0x121C
+#define RCC_FINDIV0CFGR				0x1224
+#define RCC_FINDIV1CFGR				0x1228
+#define RCC_FINDIV2CFGR				0x122C
+#define RCC_FINDIV3CFGR				0x1230
+#define RCC_FINDIV4CFGR				0x1234
+#define RCC_FINDIV5CFGR				0x1238
+#define RCC_FINDIV6CFGR				0x123C
+#define RCC_FINDIV7CFGR				0x1240
+#define RCC_FINDIV8CFGR				0x1244
+#define RCC_FINDIV9CFGR				0x1248
+#define RCC_FINDIV10CFGR			0x124C
+#define RCC_FINDIV11CFGR			0x1250
+#define RCC_FINDIV12CFGR			0x1254
+#define RCC_FINDIV13CFGR			0x1258
+#define RCC_FINDIV14CFGR			0x125C
+#define RCC_FINDIV15CFGR			0x1260
+#define RCC_FINDIV16CFGR			0x1264
+#define RCC_FINDIV17CFGR			0x1268
+#define RCC_FINDIV18CFGR			0x126C
+#define RCC_FINDIV19CFGR			0x1270
+#define RCC_FINDIV20CFGR			0x1274
+#define RCC_FINDIV21CFGR			0x1278
+#define RCC_FINDIV22CFGR			0x127C
+#define RCC_FINDIV23CFGR			0x1280
+#define RCC_FINDIV24CFGR			0x1284
+#define RCC_FINDIV25CFGR			0x1288
+#define RCC_FINDIV26CFGR			0x128C
+#define RCC_FINDIV27CFGR			0x1290
+#define RCC_FINDIV28CFGR			0x1294
+#define RCC_FINDIV29CFGR			0x1298
+#define RCC_FINDIV30CFGR			0x129C
+#define RCC_FINDIV31CFGR			0x12A0
+#define RCC_FINDIV32CFGR			0x12A4
+#define RCC_FINDIV33CFGR			0x12A8
+#define RCC_FINDIV34CFGR			0x12AC
+#define RCC_FINDIV35CFGR			0x12B0
+#define RCC_FINDIV36CFGR			0x12B4
+#define RCC_FINDIV37CFGR			0x12B8
+#define RCC_FINDIV38CFGR			0x12BC
+#define RCC_FINDIV39CFGR			0x12C0
+#define RCC_FINDIV40CFGR			0x12C4
+#define RCC_FINDIV41CFGR			0x12C8
+#define RCC_FINDIV42CFGR			0x12CC
+#define RCC_FINDIV43CFGR			0x12D0
+#define RCC_FINDIV44CFGR			0x12D4
+#define RCC_FINDIV45CFGR			0x12D8
+#define RCC_FINDIV46CFGR			0x12DC
+#define RCC_FINDIV47CFGR			0x12E0
+#define RCC_FINDIV48CFGR			0x12E4
+#define RCC_FINDIV49CFGR			0x12E8
+#define RCC_FINDIV50CFGR			0x12EC
+#define RCC_FINDIV51CFGR			0x12F0
+#define RCC_FINDIV52CFGR			0x12F4
+#define RCC_FINDIV53CFGR			0x12F8
+#define RCC_FINDIV54CFGR			0x12FC
+#define RCC_FINDIV55CFGR			0x1300
+#define RCC_FINDIV56CFGR			0x1304
+#define RCC_FINDIV57CFGR			0x1308
+#define RCC_FINDIV58CFGR			0x130C
+#define RCC_FINDIV59CFGR			0x1310
+#define RCC_FINDIV60CFGR			0x1314
+#define RCC_FINDIV61CFGR			0x1318
+#define RCC_FINDIV62CFGR			0x131C
+#define RCC_FINDIV63CFGR			0x1320
+#define RCC_FINDIVSR1				0x1324
+#define RCC_FINDIVSR2				0x1328
+#define RCC_FCALCOBS0CFGR			0x1340
+#define RCC_FCALCOBS1CFGR			0x1344
+#define RCC_FCALCREFCFGR			0x1348
+#define RCC_FCALCCR1				0x134C
+#define RCC_FCALCCR2				0x1354
+#define RCC_FCALCSR				0x1358
+#define RCC_PLL4CFGR1				0x1360
+#define RCC_PLL4CFGR2				0x1364
+#define RCC_PLL4CFGR3				0x1368
+#define RCC_PLL4CFGR4				0x136C
+#define RCC_PLL4CFGR5				0x1370
+#define RCC_PLL4CFGR6				0x1378
+#define RCC_PLL4CFGR7				0x137C
+#define RCC_PLL5CFGR1				0x1388
+#define RCC_PLL5CFGR2				0x138C
+#define RCC_PLL5CFGR3				0x1390
+#define RCC_PLL5CFGR4				0x1394
+#define RCC_PLL5CFGR5				0x1398
+#define RCC_PLL5CFGR6				0x13A0
+#define RCC_PLL5CFGR7				0x13A4
+#define RCC_PLL6CFGR1				0x13B0
+#define RCC_PLL6CFGR2				0x13B4
+#define RCC_PLL6CFGR3				0x13B8
+#define RCC_PLL6CFGR4				0x13BC
+#define RCC_PLL6CFGR5				0x13C0
+#define RCC_PLL6CFGR6				0x13C8
+#define RCC_PLL6CFGR7				0x13CC
+#define RCC_PLL7CFGR1				0x13D8
+#define RCC_PLL7CFGR2				0x13DC
+#define RCC_PLL7CFGR3				0x13E0
+#define RCC_PLL7CFGR4				0x13E4
+#define RCC_PLL7CFGR5				0x13E8
+#define RCC_PLL7CFGR6				0x13F0
+#define RCC_PLL7CFGR7				0x13F4
+#define RCC_PLL8CFGR1				0x1400
+#define RCC_PLL8CFGR2				0x1404
+#define RCC_PLL8CFGR3				0x1408
+#define RCC_PLL8CFGR4				0x140C
+#define RCC_PLL8CFGR5				0x1410
+#define RCC_PLL8CFGR6				0x1418
+#define RCC_PLL8CFGR7				0x141C
+#define RCC_VERR				0xFFF4
+#define RCC_IDR					0xFFF8
+#define RCC_SIDR				0xFFFC
+
+#endif /* STM32MP2_RCC_H */
diff --git a/include/typec.h b/include/typec.h
new file mode 100644
index 0000000000..9241da4614
--- /dev/null
+++ b/include/typec.h
@@ -0,0 +1,154 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+enum typec_state {
+	TYPEC_UNATTACHED,
+	TYPEC_ATTACHED,
+};
+
+enum typec_data_role {
+	TYPEC_DEVICE,
+	TYPEC_HOST,
+};
+
+/**
+ * struct typec_ops - driver I/O operations for TYPEC uclass
+ *
+ * Drivers should support 2 operations. These operations is intended
+ * to be used by uclass code, not directly from other code.
+ */
+struct typec_ops {
+	/**
+	 * is_attached() - Return if cable is attached
+	 *
+	 * @dev: TYPEC device to read from
+	 * @con_idx: connector index (0 is the first one)
+	 * @return  TYPEC_UNATTACHED if not attached, TYPEC_ATTACHED if attached, -ve on error
+	 */
+	int (*is_attached)(struct udevice *dev, u8 con_idx);
+
+	/**
+	 * get_data_role() - Return data role (HOST or DEVICE)
+	 *
+	 * @dev: TYPEC device to read from
+	 * @con_idx: connector index (0 is the first one)
+	 * @return: TYPEC_DEVICE if device role, TYPEC_HOST if host role, -ve on error
+	 */
+	int (*get_data_role)(struct udevice *dev, u8 con_idx);
+
+	/**
+	 * get_nb_connector() - Return connector number managed by TypeC controller.
+	 *
+	 * @dev: TYPEC device to read from
+	 * @return: number of connector managed by TypeC controller, -ve on error
+	 */
+	u8 (*get_nb_connector)(struct udevice *dev);
+};
+
+#ifdef CONFIG_TYPEC
+/**
+ * typec_is_attached() - Test if Type-C connector is attached
+ *
+ * @return TYPEC_ATTACHED if attached, TYPEC_UNATTACHED is not attached,
+ * or -ve on error.
+ */
+int typec_is_attached(struct udevice *dev, u8 con_idx);
+
+/**
+ * typec_get_data_role() - Return current Type-C data role
+ *
+ * @return TYPEC_DEVICE if attached to a host, TYPEC_HOST is attached to a
+ * device or -ve on error.
+ */
+int typec_get_data_role(struct udevice *dev, u8 con_idx);
+
+/**
+ * typec_get_nb_connector() - Return Type-C connector supported by controller
+ *
+ * @return Type-C connector number or -ve on error.
+ */
+int typec_get_nb_connector(struct udevice *dev);
+
+/**
+ * typec_get_device_from_usb() - Allows to retrieve a Type-C device from
+ * an USB device. typec_get_driver_from_usb() checks in USB device node
+ * for port and endpoint sub-node, if exist, retrieve the connector node,
+ * probe the associated Type-C device and return it (see DT example below).
+ * See Documentation/devicetree/bindings/connector/usb-connector.yaml for more
+ * details
+ *
+ * @dev: USB device
+ * @typec: Type-C device
+ * @index: USB controller port number
+ * @return -ve on error.
+ *
+ * usb_dwc3_0: usb@10000000 {
+ *	...
+ *	port@0 {
+ *		reg = <0>;
+ *		typec_hs: endpoint {
+ *			remote-endpoint = <&usb_con_hs>;
+ *		};
+ *	};
+ *
+ *	port@1 {
+ *		reg = <1>;
+ *		typec_ss: endpoint {
+ *			remote-endpoint = <&usb_con_ss>;
+ *		};
+ *	};
+ * };
+ *
+ * usb-typec@1 {
+ *	...
+ *	connector {
+ *		compatible = "usb-c-connector";
+ *		label = "USB-C";
+ *
+ *		ports {
+ *			#address-cells = <1>;
+ *			#size-cells = <0>;
+ *
+ *			port@0 {
+ *				reg = <0>;
+ *				usb_con_hs: endpoint {
+ *					remote-endpoint = <&typec_hs>;
+ *				};
+ *			};
+ *
+ *			port@1 {
+ *				reg = <1>;
+ *				usb_con_ss: endpoint {
+ *					remote-endpoint = <&typec_ss>;
+ *				};
+ *			};
+ *		};
+ *	};
+ * };
+ */
+int typec_get_device_from_usb(struct udevice *dev, struct udevice **typec, u8
+			      index);
+#else
+static inline int typec_is_attached(struct udevice *dev, u8 con_idx)
+{
+	return -ENODEV;
+}
+
+static inline int typec_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	return -EINVAL;
+}
+
+static inline int typec_get_nb_connector(struct udevice *dev)
+{
+	return -EINVAL;
+}
+
+static inline int typec_get_device_from_usb(struct udevice *dev, struct udevice **typec,
+					    u8 index)
+{
+	return -ENODEV;
+}
+#endif
diff --git a/include/ucsi.h b/include/ucsi.h
new file mode 100644
index 0000000000..1c46e05481
--- /dev/null
+++ b/include/ucsi.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+
+#ifndef _UCSI_H_
+#define _UCSI_H_
+
+/* UCSI offsets (Bytes) */
+#define UCSI_VERSION			0
+#define UCSI_CCI			4
+#define UCSI_CONTROL			8
+#define UCSI_MESSAGE_IN			16
+
+/* Commands */
+#define UCSI_PPM_RESET			0x01
+#define UCSI_ACK_CC_CI			0x04
+#define UCSI_SET_NOTIFICATION_ENABLE	0x05
+#define UCSI_GET_CAPABILITY		0x06
+#define UCSI_GET_ALTERNATE_MODES	0x0c
+#define UCSI_GET_CONNECTOR_STATUS	0x12
+#define UCSI_GET_ERROR_STATUS		0x13
+
+#define UCSI_CONNECTOR_NUMBER(_num_)		((u64)(_num_) << 16)
+
+/* ACK_CC_CI bits */
+#define UCSI_ACK_CONNECTOR_CHANGE		BIT(16)
+#define UCSI_ACK_COMMAND_COMPLETE		BIT(17)
+
+/* SET_NOTIFICATION_ENABLE command bits */
+#define UCSI_ENABLE_NTFY_CONNECTOR_CHANGE	BIT(30)
+
+/* Command Status and Connector Change Indication (CCI) bits */
+#define UCSI_CCI_CONNECTOR(_c_)		(((_c_) & GENMASK(7, 1)) >> 1)
+#define UCSI_CCI_LENGTH(_c_)		(((_c_) & GENMASK(15, 8)) >> 8)
+#define UCSI_CCI_NOT_SUPPORTED		BIT(25)
+#define UCSI_CCI_RESET_COMPLETE		BIT(27)
+#define UCSI_CCI_BUSY			BIT(28)
+#define UCSI_CCI_ERROR			BIT(30)
+#define UCSI_CCI_COMMAND_COMPLETE	BIT(31)
+
+/* Error information returned by PPM in response to GET_ERROR_STATUS command. */
+#define UCSI_ERROR_UNREGONIZED_CMD		BIT(0)
+#define UCSI_ERROR_INVALID_CON_NUM		BIT(1)
+#define UCSI_ERROR_INVALID_CMD_ARGUMENT		BIT(2)
+#define UCSI_ERROR_INCOMPATIBLE_PARTNER		BIT(3)
+#define UCSI_ERROR_CC_COMMUNICATION_ERR		BIT(4)
+#define UCSI_ERROR_DEAD_BATTERY			BIT(5)
+#define UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL	BIT(6)
+#define UCSI_ERROR_OVERCURRENT			BIT(7)
+#define UCSI_ERROR_UNDEFINED			BIT(8)
+#define UCSI_ERROR_PARTNER_REJECTED_SWAP	BIT(9)
+#define UCSI_ERROR_HARD_RESET			BIT(10)
+#define UCSI_ERROR_PPM_POLICY_CONFLICT		BIT(11)
+#define UCSI_ERROR_SWAP_REJECTED		BIT(12)
+
+/* Data structure filled by PPM in response to GET_CAPABILITY command. */
+struct ucsi_capability {
+	u32 attributes;
+	u8 num_connectors;
+	u8 features;
+	u16 reserved_1;
+	u8 num_alt_modes;
+	u8 reserved_2;
+	u16 bc_version;
+	u16 pd_version;
+	u16 typec_version;
+} __packed;
+
+/* Data structure filled by PPM in response to GET_CONNECTOR_STATUS command. */
+struct ucsi_connector_status {
+	u16 change;
+	u16 flags;
+#define UCSI_CONSTAT_CONNECTED			BIT(3)
+#define UCSI_CONSTAT_PARTNER_TYPE(_f_)		(((_f_) & GENMASK(15, 13)) >> 13)
+#define   UCSI_CONSTAT_PARTNER_TYPE_DFP		1
+#define   UCSI_CONSTAT_PARTNER_TYPE_UFP		2
+#define   UCSI_CONSTAT_PARTNER_TYPE_CABLE	3 /* Powered Cable */
+#define   UCSI_CONSTAT_PARTNER_TYPE_CABLE_AND_UFP	4 /* Powered Cable */
+#define   UCSI_CONSTAT_PARTNER_TYPE_DEBUG	5
+#define   UCSI_CONSTAT_PARTNER_TYPE_AUDIO	6
+	u32 request_data_obj;
+	u8 pwr_status;
+} __packed;
+
+/**
+ * struct ucsi_ops - driver I/O operations for UCSI uclass
+ *
+ * Drivers should support 2 operations. These operations are intended to be used
+ * by uclass code, not directly from other code.
+ */
+struct ucsi_ops {
+	/**
+	 * read() - Read operation
+	 *
+	 * @ucsi:	UCSI device to read from
+	 * @offset:	UCSI data structure offset
+	 * @buf:	Buffer to receive the data
+	 * @len		Number of bytes to read
+	 * @return 0 on success, -ve on failure
+	 */
+	int (*read)(struct udevice *ucsi, unsigned int offset, void *val, size_t len);
+
+	/**
+	 * write() - Write operation
+	 *
+	 * @ucsi:	UCSI device to write to
+	 * @offset:	UCSI data structure offset
+	 * @buf:	Buffer data to write
+	 * @len		Number of bytes to write
+	 * @return 0 on success, -ve on failure
+	 */
+	int (*write)(struct udevice *ucsi, unsigned int offset, const void *val, size_t len);
+};
+#endif /* _UCSI_H_ */
diff --git a/include/usb.h b/include/usb.h
index 09e3f0cb30..54b641e563 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -49,6 +49,12 @@ extern bool usb_started; /* flag for the started/stopped USB status */
  */
 #define USB_TIMEOUT_MS(pipe) (usb_pipebulk(pipe) ? 5000 : 1000)
 
+/*
+ * USB Resume Timer: Every Host controller driver should drive the resume
+ * signalling on the bus for the amount of time defined by this macro.
+ */
+#define USB_RESUME_TIMEOUT      40 /* ms */
+
 /* device request (setup) */
 struct devrequest {
 	__u8	requesttype;
diff --git a/include/usb/dwc2_udc.h b/include/usb/dwc2_udc.h
index aa37e957b4..04521d0f5b 100644
--- a/include/usb/dwc2_udc.h
+++ b/include/usb/dwc2_udc.h
@@ -30,6 +30,8 @@ struct dwc2_plat_otg_data {
 	bool		force_b_session_valid;
 	bool		force_vbus_detection;
 	bool		activate_stm_id_vb_detection;
+	bool		activate_stm_ggpio_idpullup_dis;
+	bool		activate_stm_ggpio_vbvaloval;
 };
 
 int dwc2_udc_probe(struct dwc2_plat_otg_data *pdata);
diff --git a/include/wdt.h b/include/wdt.h
index 5026f5a6db..14349c1c0c 100644
--- a/include/wdt.h
+++ b/include/wdt.h
@@ -18,6 +18,15 @@ struct udevice;
  * which typically include placing the system in a safe, known state.
  */
 
+/*
+ * Force watchdog start during init. Called by driver's probe when the watchdog
+ * is detected as already started.
+ *
+ * @dev: WDT Device
+ * @return: 0 if OK, -ve on error
+ */
+int wdt_set_force_start(struct udevice *dev);
+
 /*
  * Start the timer
  *
diff --git a/lib/efi_loader/efi_capsule.c b/lib/efi_loader/efi_capsule.c
index af8a2ee940..c416613dd4 100644
--- a/lib/efi_loader/efi_capsule.c
+++ b/lib/efi_loader/efi_capsule.c
@@ -481,6 +481,11 @@ static __maybe_unused efi_status_t fwu_empty_capsule_process(
 		if (ret != EFI_SUCCESS)
 			log_err("Unable to set the Accept bit for the image %pUs\n",
 				image_guid);
+
+		status = fwu_state_machine_updates(0, active_idx);
+		if (status < 0)
+			ret = EFI_DEVICE_ERROR;
+
 	}
 
 	return ret;
@@ -522,11 +527,10 @@ static __maybe_unused efi_status_t fwu_post_update_process(bool fw_accept_os)
 		log_err("Failed to update FWU metadata index values\n");
 	} else {
 		log_debug("Successfully updated the active_index\n");
-		if (fw_accept_os) {
-			status = fwu_trial_state_ctr_start();
-			if (status < 0)
-				ret = EFI_DEVICE_ERROR;
-		}
+		status = fwu_state_machine_updates(fw_accept_os ? 1 : 0,
+						   update_index);
+		if (status < 0)
+			ret = EFI_DEVICE_ERROR;
 	}
 
 	return ret;
diff --git a/lib/efi_loader/efi_disk.c b/lib/efi_loader/efi_disk.c
index f0d76113b0..acab5676c3 100644
--- a/lib/efi_loader/efi_disk.c
+++ b/lib/efi_loader/efi_disk.c
@@ -495,8 +495,10 @@ static efi_status_t efi_disk_add_dev(
 		ret = efi_add_protocol(&diskobj->header,
 				       &efi_simple_file_system_protocol_guid,
 				       diskobj->volume);
-		if (ret != EFI_SUCCESS)
+		if (ret != EFI_SUCCESS) {
+			log_debug("simple FS failed\n");
 			goto error;
+		}
 	}
 	diskobj->ops = block_io_disk_template;
 	diskobj->dev_index = dev_index;
diff --git a/lib/efi_loader/efi_firmware.c b/lib/efi_loader/efi_firmware.c
index 9abb29f1df..9b8630625f 100644
--- a/lib/efi_loader/efi_firmware.c
+++ b/lib/efi_loader/efi_firmware.c
@@ -611,6 +611,7 @@ efi_status_t EFIAPI efi_firmware_raw_set_image(
 	u16 **abort_reason)
 {
 	int ret;
+	u8 dfu_alt_num;
 	efi_status_t status;
 	struct fmp_state state = { 0 };
 
@@ -625,19 +626,25 @@ efi_status_t EFIAPI efi_firmware_raw_set_image(
 	if (status != EFI_SUCCESS)
 		return EFI_EXIT(status);
 
+	/*
+	 * dfu_alt_num is assigned from 0 while image_index starts from 1.
+	 * dfu_alt_num is calculated by (image_index - 1) when multi bank update
+	 * is not used.
+	 */
+	dfu_alt_num = image_index - 1;
 	if (IS_ENABLED(CONFIG_FWU_MULTI_BANK_UPDATE)) {
 		/*
 		 * Based on the value of update bank, derive the
 		 * image index value.
 		 */
-		ret = fwu_get_image_index(&image_index);
+		ret = fwu_get_dfu_alt_num(image_index, &dfu_alt_num);
 		if (ret) {
 			log_debug("Unable to get FWU image_index\n");
 			return EFI_EXIT(EFI_DEVICE_ERROR);
 		}
 	}
 
-	if (dfu_write_by_alt(image_index - 1, (void *)image, image_size,
+	if (dfu_write_by_alt(dfu_alt_num, (void *)image, image_size,
 			     NULL, NULL))
 		return EFI_EXIT(EFI_DEVICE_ERROR);
 
diff --git a/lib/fwu_updates/Kconfig b/lib/fwu_updates/Kconfig
index 71f34793d9..ae060c1f1a 100644
--- a/lib/fwu_updates/Kconfig
+++ b/lib/fwu_updates/Kconfig
@@ -31,3 +31,17 @@ config FWU_TRIAL_STATE_CNT
 	  With FWU Multi Bank Update feature enabled, number of times
 	  the platform is allowed to boot in Trial State after an
 	  update.
+
+config FWU_MDATA_V1
+	bool "Enable support FWU Metadata version 1"
+	help
+	  The FWU specification supports two versions of the
+	  metadata structure. This option enables support for FWU
+	  Metadata version 1 access.
+
+config FWU_MDATA_V2
+	bool "Enable support FWU Metadata version 2"
+	help
+	  The FWU specification supports two versions of the
+	  metadata structure. This option enables support for FWU
+	  Metadata version 2 access.
diff --git a/lib/fwu_updates/Makefile b/lib/fwu_updates/Makefile
index c9e3c06b48..3681bef46c 100644
--- a/lib/fwu_updates/Makefile
+++ b/lib/fwu_updates/Makefile
@@ -6,3 +6,5 @@
 obj-$(CONFIG_FWU_MULTI_BANK_UPDATE) += fwu.o
 obj-$(CONFIG_FWU_MDATA_GPT_BLK) += fwu_gpt.o
 obj-$(CONFIG_FWU_MDATA_MTD) += fwu_mtd.o
+obj-$(CONFIG_FWU_MDATA_V1) += fwu_v1.o
+obj-$(CONFIG_FWU_MDATA_V2) += fwu_v2.o
diff --git a/lib/fwu_updates/fwu.c b/lib/fwu_updates/fwu.c
index 4d0c8b84b9..f5e0315b79 100644
--- a/lib/fwu_updates/fwu.c
+++ b/lib/fwu_updates/fwu.c
@@ -10,6 +10,7 @@
 #include <event.h>
 #include <fwu.h>
 #include <fwu_mdata.h>
+#include <log.h>
 #include <malloc.h>
 
 #include <linux/errno.h>
@@ -17,7 +18,7 @@
 
 #include <u-boot/crc.h>
 
-static struct fwu_mdata g_mdata; /* = {0} makes uninit crc32 always invalid */
+struct fwu_data g_fwu_data;
 static struct udevice *g_dev;
 static u8 in_trial;
 static u8 boottime_check;
@@ -27,12 +28,6 @@ enum {
 	IMAGE_ACCEPT_CLEAR,
 };
 
-enum {
-	PRIMARY_PART = 1,
-	SECONDARY_PART,
-	BOTH_PARTS,
-};
-
 static int trial_counter_update(u16 *trial_state_ctr)
 {
 	bool delete;
@@ -106,35 +101,19 @@ out:
 	return ret;
 }
 
-static int in_trial_state(struct fwu_mdata *mdata)
+static u32 in_trial_state(void)
 {
-	u32 i, active_bank;
-	struct fwu_image_entry *img_entry;
-	struct fwu_image_bank_info *img_bank_info;
-
-	active_bank = mdata->active_index;
-	img_entry = &mdata->img_entry[0];
-	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
-		img_bank_info = &img_entry[i].img_bank_info[active_bank];
-		if (!img_bank_info->accepted) {
-			log_info("System booting in Trial State\n");
-			return 1;
-		}
-	}
-
-	return 0;
+	return g_fwu_data.trial_state;
 }
 
-static int fwu_get_image_type_id(u8 *image_index, efi_guid_t *image_type_id)
+static int fwu_get_image_type_id(u8 image_index, efi_guid_t *image_type_id)
 {
-	u8 index;
 	int i;
 	struct efi_fw_image *image;
 
-	index = *image_index;
 	image = update_info.images;
 	for (i = 0; i < update_info.num_images; i++) {
-		if (index == image[i].image_index) {
+		if (image_index == image[i].image_index) {
 			guidcpy(image_type_id, &image[i].image_type_id);
 			return 0;
 		}
@@ -143,17 +122,70 @@ static int fwu_get_image_type_id(u8 *image_index, efi_guid_t *image_type_id)
 	return -ENOENT;
 }
 
+static int mdata_crc_check(struct fwu_mdata *mdata)
+{
+	int ret;
+	u32 calc_crc32;
+	uint32_t mdata_size;
+	void *buf = &mdata->version;
+
+	ret = fwu_get_mdata_size(&mdata_size);
+	if (ret)
+		return ret;
+
+	calc_crc32 = crc32(0, buf, mdata_size - sizeof(u32));
+	return calc_crc32 == mdata->crc32 ? 0 : -EINVAL;
+}
+
+static void fwu_data_crc_update(uint32_t crc32)
+{
+	g_fwu_data.crc32 = crc32;
+}
+
+/**
+ * fwu_get_data() - Return the version agnostic FWU structure
+ *
+ * Return the pointer to the version agnostic FWU structure.
+ *
+ * Return: Pointer to the FWU data structure
+ */
+struct fwu_data *fwu_get_data(void)
+{
+	return &g_fwu_data;
+}
+
+static void fwu_populate_mdata_bank_index(struct fwu_data *fwu_data)
+{
+	struct fwu_mdata *mdata = fwu_data->fwu_mdata;
+
+	mdata->active_index = fwu_data->active_index;
+	mdata->previous_active_index = fwu_data->previous_active_index;
+}
+
+/**
+ * fwu_get_dev() - Return the FWU metadata device
+ *
+ * Return the pointer to the FWU metadata device.
+ *
+ * Return: Pointer to the FWU metadata dev
+ */
+struct udevice *fwu_get_dev(void)
+{
+	return g_dev;
+}
+
 /**
  * fwu_sync_mdata() - Update given meta-data partition(s) with the copy provided
- * @mdata: FWU metadata structure
+ * @data: FWU Data structure
  * @part: Bitmask of FWU metadata partitions to be written to
  *
  * Return: 0 if OK, -ve on error
  */
-static int fwu_sync_mdata(struct fwu_mdata *mdata, int part)
+int fwu_sync_mdata(struct fwu_mdata *mdata, int part)
 {
-	void *buf = &mdata->version;
 	int err;
+	uint mdata_size;
+	void *buf = &mdata->version;
 
 	if (part == BOTH_PARTS) {
 		err = fwu_sync_mdata(mdata, SECONDARY_PART);
@@ -162,32 +194,53 @@ static int fwu_sync_mdata(struct fwu_mdata *mdata, int part)
 		part = PRIMARY_PART;
 	}
 
+	err = fwu_get_mdata_size(&mdata_size);
+	if (err)
+		return err;
+
 	/*
 	 * Calculate the crc32 for the updated FWU metadata
 	 * and put the updated value in the FWU metadata crc32
 	 * field
 	 */
-	mdata->crc32 = crc32(0, buf, sizeof(*mdata) - sizeof(u32));
+	mdata->crc32 = crc32(0, buf, mdata_size - sizeof(u32));
+	fwu_data_crc_update(mdata->crc32);
 
-	err = fwu_write_mdata(g_dev, mdata, part == PRIMARY_PART);
+	err = fwu_write_mdata(g_dev, mdata, part == PRIMARY_PART, mdata_size);
 	if (err) {
 		log_err("Unable to write %s mdata\n",
 			part == PRIMARY_PART ?  "primary" : "secondary");
 		return err;
 	}
 
-	/* update the cached copy of meta-data */
-	memcpy(&g_mdata, mdata, sizeof(struct fwu_mdata));
-
 	return 0;
 }
 
-static inline int mdata_crc_check(struct fwu_mdata *mdata)
+/**
+ * fwu_mdata_copies_allocate() - Allocate memory for metadata
+ * @mdata_size: Size of the metadata structure
+ *
+ * Allocate memory for storing both the copies of the FWU metadata. The
+ * copies are then used as a cache for storing FWU metadata contents.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_mdata_copies_allocate(u32 mdata_size)
 {
-	void *buf = &mdata->version;
-	u32 calc_crc32 = crc32(0, buf, sizeof(*mdata) - sizeof(u32));
+	if (g_fwu_data.fwu_mdata)
+		return 0;
 
-	return calc_crc32 == mdata->crc32 ? 0 : -EINVAL;
+	/*
+	 * Allocate the total memory that would be needed for both
+	 * the copies.
+	 */
+	g_fwu_data.fwu_mdata = calloc(2, mdata_size);
+	if (!g_fwu_data.fwu_mdata) {
+		log_err("Unable to allocate space for FWU metadata\n");
+		return -ENOMEM;
+	}
+
+	return 0;
 }
 
 /**
@@ -203,21 +256,33 @@ static inline int mdata_crc_check(struct fwu_mdata *mdata)
 int fwu_get_mdata(struct fwu_mdata *mdata)
 {
 	int err;
+	uint32_t mdata_size;
 	bool parts_ok[2] = { false };
-	struct fwu_mdata s, *parts_mdata[2];
+	struct fwu_mdata *parts_mdata[2];
 
-	parts_mdata[0] = &g_mdata;
-	parts_mdata[1] = &s;
+	err = fwu_get_mdata_size(&mdata_size);
+	if (err)
+		return err;
+
+	parts_mdata[0] = g_fwu_data.fwu_mdata;
+	if (!parts_mdata[0]) {
+		log_err("Memory not allocated for the FWU Metadata copies\n");
+		return -ENOMEM;
+	}
+
+	parts_mdata[1] = (struct fwu_mdata *)((char *)parts_mdata[0] +
+					      mdata_size);
 
 	/* if mdata already read and ready */
 	err = mdata_crc_check(parts_mdata[0]);
 	if (!err)
 		goto ret_mdata;
-	/* else read, verify and, if needed, fix mdata */
 
+
+	/* else read, verify and, if needed, fix mdata */
 	for (int i = 0; i < 2; i++) {
 		parts_ok[i] = false;
-		err = fwu_read_mdata(g_dev, parts_mdata[i], !i);
+		err = fwu_read_mdata(g_dev, parts_mdata[i], !i, mdata_size);
 		if (!err) {
 			err = mdata_crc_check(parts_mdata[i]);
 			if (!err)
@@ -232,7 +297,7 @@ int fwu_get_mdata(struct fwu_mdata *mdata)
 		 * Before returning, check that both the
 		 * FWU metadata copies are the same.
 		 */
-		err = memcmp(parts_mdata[0], parts_mdata[1], sizeof(struct fwu_mdata));
+		err = memcmp(parts_mdata[0], parts_mdata[1], mdata_size);
 		if (!err)
 			goto ret_mdata;
 
@@ -249,7 +314,7 @@ int fwu_get_mdata(struct fwu_mdata *mdata)
 		if (parts_ok[i])
 			continue;
 
-		memcpy(parts_mdata[i], parts_mdata[1 - i], sizeof(struct fwu_mdata));
+		memcpy(parts_mdata[i], parts_mdata[1 - i], mdata_size);
 		err = fwu_sync_mdata(parts_mdata[i], i ? SECONDARY_PART : PRIMARY_PART);
 		if (err) {
 			log_debug("mdata : %s write failed\n", i ? "secondary" : "primary");
@@ -259,7 +324,7 @@ int fwu_get_mdata(struct fwu_mdata *mdata)
 
 ret_mdata:
 	if (!err && mdata)
-		memcpy(mdata, parts_mdata[0], sizeof(struct fwu_mdata));
+		memcpy(mdata, parts_mdata[0], mdata_size);
 
 	return err;
 }
@@ -277,13 +342,13 @@ ret_mdata:
 int fwu_get_active_index(uint *active_idx)
 {
 	int ret = 0;
-	struct fwu_mdata *mdata = &g_mdata;
+	struct fwu_data *data = &g_fwu_data;
 
 	/*
 	 * Found the FWU metadata partition, now read the active_index
 	 * value
 	 */
-	*active_idx = mdata->active_index;
+	*active_idx = data->active_index;
 	if (*active_idx >= CONFIG_FWU_NUM_BANKS) {
 		log_debug("Active index value read is incorrect\n");
 		ret = -EINVAL;
@@ -304,7 +369,7 @@ int fwu_get_active_index(uint *active_idx)
 int fwu_set_active_index(uint active_idx)
 {
 	int ret;
-	struct fwu_mdata *mdata = &g_mdata;
+	struct fwu_data *data =  &g_fwu_data;
 
 	if (active_idx >= CONFIG_FWU_NUM_BANKS) {
 		log_debug("Invalid active index value\n");
@@ -315,14 +380,16 @@ int fwu_set_active_index(uint active_idx)
 	 * Update the active index and previous_active_index fields
 	 * in the FWU metadata
 	 */
-	mdata->previous_active_index = mdata->active_index;
-	mdata->active_index = active_idx;
+	data->previous_active_index = data->active_index;
+	data->active_index = active_idx;
+
+	fwu_populate_mdata_bank_index(data);
 
 	/*
 	 * Now write this updated FWU metadata to both the
 	 * FWU metadata partitions
 	 */
-	ret = fwu_sync_mdata(mdata, BOTH_PARTS);
+	ret = fwu_sync_mdata(data->fwu_mdata, BOTH_PARTS);
 	if (ret) {
 		log_debug("Failed to update FWU metadata partitions\n");
 		ret = -EIO;
@@ -332,27 +399,23 @@ int fwu_set_active_index(uint active_idx)
 }
 
 /**
- * fwu_get_image_index() - Get the Image Index to be used for capsule update
- * @image_index: The Image Index for the image
- *
- * The FWU multi bank update feature computes the value of image_index at
- * runtime, based on the bank to which the image needs to be written to.
- * Derive the image_index value for the image.
+ * fwu_get_dfu_alt_num() - Get the dfu_alt_num to be used for capsule update
+ * @image_index:	The Image Index for the image
+ * @alt_num:		pointer to store dfu_alt_num
  *
  * Currently, the capsule update driver uses the DFU framework for
  * the updates. This function gets the DFU alt number which is to
- * be used as the Image Index
+ * be used for capsule update.
  *
  * Return: 0 if OK, -ve on error
  *
  */
-int fwu_get_image_index(u8 *image_index)
+int fwu_get_dfu_alt_num(u8 image_index, u8 *alt_num)
 {
 	int ret, i;
-	u8 alt_num;
 	uint update_bank;
 	efi_guid_t *image_guid, image_type_id;
-	struct fwu_mdata *mdata = &g_mdata;
+	struct fwu_data *data = &g_fwu_data;
 	struct fwu_image_entry *img_entry;
 	struct fwu_image_bank_info *img_bank_info;
 
@@ -365,30 +428,28 @@ int fwu_get_image_index(u8 *image_index)
 	ret = fwu_get_image_type_id(image_index, &image_type_id);
 	if (ret) {
 		log_debug("Unable to get image_type_id for image_index %u\n",
-			  *image_index);
+			  image_index);
 		goto out;
 	}
 
 	ret = -EINVAL;
 	/*
-	 * The FWU metadata has been read. Now get the image_uuid for the
+	 * The FWU metadata has been read. Now get the image_guid for the
 	 * image with the update_bank.
 	 */
 	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
 		if (!guidcmp(&image_type_id,
-			     &mdata->img_entry[i].image_type_uuid)) {
-			img_entry = &mdata->img_entry[i];
+			     &data->fwu_images[i].image_type_guid)) {
+			img_entry = &data->fwu_images[i];
 			img_bank_info = &img_entry->img_bank_info[update_bank];
-			image_guid = &img_bank_info->image_uuid;
-			ret = fwu_plat_get_alt_num(g_dev, image_guid, &alt_num);
-			if (ret) {
+			image_guid = &img_bank_info->image_guid;
+			ret = fwu_plat_get_alt_num(g_dev, image_guid, alt_num);
+			if (ret)
 				log_debug("alt_num not found for partition with GUID %pUs\n",
 					  image_guid);
-			} else {
+			else
 				log_debug("alt_num %d for partition %pUs\n",
-					  alt_num, image_guid);
-				*image_index = alt_num + 1;
-			}
+					  *alt_num, image_guid);
 
 			goto out;
 		}
@@ -415,21 +476,23 @@ int fwu_revert_boot_index(void)
 {
 	int ret;
 	u32 cur_active_index;
-	struct fwu_mdata *mdata = &g_mdata;
+	struct fwu_data *data =  &g_fwu_data;
 
 	/*
 	 * Swap the active index and previous_active_index fields
 	 * in the FWU metadata
 	 */
-	cur_active_index = mdata->active_index;
-	mdata->active_index = mdata->previous_active_index;
-	mdata->previous_active_index = cur_active_index;
+	cur_active_index = data->active_index;
+	data->active_index = data->previous_active_index;
+	data->previous_active_index = cur_active_index;
+
+	fwu_populate_mdata_bank_index(data);
 
 	/*
 	 * Now write this updated FWU metadata to both the
 	 * FWU metadata partitions
 	 */
-	ret = fwu_sync_mdata(mdata, BOTH_PARTS);
+	ret = fwu_sync_mdata(data->fwu_mdata, BOTH_PARTS);
 	if (ret) {
 		log_debug("Failed to update FWU metadata partitions\n");
 		ret = -EIO;
@@ -456,20 +519,21 @@ int fwu_revert_boot_index(void)
 static int fwu_clrset_image_accept(efi_guid_t *img_type_id, u32 bank, u8 action)
 {
 	int ret, i;
-	struct fwu_mdata *mdata = &g_mdata;
+	struct fwu_data *data = &g_fwu_data;
 	struct fwu_image_entry *img_entry;
 	struct fwu_image_bank_info *img_bank_info;
 
-	img_entry = &mdata->img_entry[0];
+	img_entry = &data->fwu_images[0];
 	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
-		if (!guidcmp(&img_entry[i].image_type_uuid, img_type_id)) {
+		if (!guidcmp(&img_entry[i].image_type_guid, img_type_id)) {
 			img_bank_info = &img_entry[i].img_bank_info[bank];
 			if (action == IMAGE_ACCEPT_SET)
 				img_bank_info->accepted |= FWU_IMAGE_ACCEPTED;
 			else
 				img_bank_info->accepted = 0;
 
-			ret = fwu_sync_mdata(mdata, BOTH_PARTS);
+			fwu_populate_mdata_image_info(data);
+			ret = fwu_sync_mdata(data->fwu_mdata, BOTH_PARTS);
 			goto out;
 		}
 	}
@@ -623,21 +687,21 @@ static int fwu_boottime_checks(void *ctx, struct event *event)
 	int ret;
 	u32 boot_idx, active_idx;
 
-	/* Don't have boot time checks on sandbox */
-	if (IS_ENABLED(CONFIG_SANDBOX)) {
-		boottime_check = 1;
-		return 0;
-	}
-
 	ret = uclass_first_device_err(UCLASS_FWU_MDATA, &g_dev);
 	if (ret) {
 		log_debug("Cannot find fwu device\n");
 		return ret;
 	}
 
-	ret = fwu_get_mdata(NULL);
+	/* Don't have boot time checks on sandbox */
+	if (IS_ENABLED(CONFIG_SANDBOX)) {
+		boottime_check = 1;
+		return 0;
+	}
+
+	ret = fwu_init();
 	if (ret) {
-		log_debug("Unable to read meta-data\n");
+		log_debug("fwu_init() failed\n");
 		return ret;
 	}
 
@@ -673,7 +737,7 @@ static int fwu_boottime_checks(void *ctx, struct event *event)
 	if (efi_init_obj_list() != EFI_SUCCESS)
 		return 0;
 
-	in_trial = in_trial_state(&g_mdata);
+	in_trial = in_trial_state();
 	if (!in_trial || (ret = fwu_trial_count_update()) > 0)
 		ret = trial_counter_update(NULL);
 
diff --git a/lib/fwu_updates/fwu_mtd.c b/lib/fwu_updates/fwu_mtd.c
index 69cd3d7001..e8211dd5ba 100644
--- a/lib/fwu_updates/fwu_mtd.c
+++ b/lib/fwu_updates/fwu_mtd.c
@@ -15,16 +15,21 @@
 
 #include <dm/ofnode.h>
 
-struct fwu_mtd_image_info
-fwu_mtd_images[CONFIG_FWU_NUM_BANKS * CONFIG_FWU_NUM_IMAGES_PER_BANK];
-
 static struct fwu_mtd_image_info *mtd_img_by_uuid(const char *uuidbuf)
 {
-	int num_images = ARRAY_SIZE(fwu_mtd_images);
+	int num_images;
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(fwu_get_dev());
+	struct fwu_mtd_image_info *image_info = mtd_priv->fwu_mtd_images;
+
+	if (!image_info)
+		return NULL;
+
+	num_images = CONFIG_FWU_NUM_BANKS *
+		CONFIG_FWU_NUM_IMAGES_PER_BANK;
 
 	for (int i = 0; i < num_images; i++)
-		if (!strcmp(uuidbuf, fwu_mtd_images[i].uuidbuf))
-			return &fwu_mtd_images[i];
+		if (!strcmp(uuidbuf, image_info[i].uuidbuf))
+			return &image_info[i];
 
 	return NULL;
 }
@@ -107,7 +112,7 @@ __weak int fwu_plat_get_alt_num(struct udevice *dev, efi_guid_t *image_id,
 	return fwu_mtd_get_alt_num(image_id, alt_num, "nor1");
 }
 
-static int gen_image_alt_info(char *buf, size_t len, int sidx,
+static int gen_image_alt_info(char *buf, size_t len,
 			      struct fwu_image_entry *img, struct mtd_info *mtd)
 {
 	char *p = buf, *end = buf + len;
@@ -131,7 +136,7 @@ static int gen_image_alt_info(char *buf, size_t len, int sidx,
 
 		/* Query a partition by image UUID */
 		bank = &img->img_bank_info[i];
-		uuid_bin_to_str(bank->image_uuid.b, uuidbuf, UUID_STR_FORMAT_STD);
+		uuid_bin_to_str(bank->image_guid.b, uuidbuf, UUID_STR_FORMAT_STD);
 
 		mtd_img_info = mtd_img_by_uuid(uuidbuf);
 		if (!mtd_img_info) {
@@ -158,18 +163,13 @@ static int gen_image_alt_info(char *buf, size_t len, int sidx,
 
 int fwu_gen_alt_info_from_mtd(char *buf, size_t len, struct mtd_info *mtd)
 {
-	struct fwu_mdata mdata;
 	int i, l, ret;
-
-	ret = fwu_get_mdata(&mdata);
-	if (ret < 0) {
-		log_err("Failed to get the FWU mdata.\n");
-		return ret;
-	}
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_image_entry *img_entry;
 
 	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
-		ret = gen_image_alt_info(buf, len, i * CONFIG_FWU_NUM_BANKS,
-					 &mdata.img_entry[i], mtd);
+		img_entry = &data->fwu_images[i];
+		ret = gen_image_alt_info(buf, len, img_entry, mtd);
 		if (ret)
 			break;
 
diff --git a/lib/fwu_updates/fwu_v1.c b/lib/fwu_updates/fwu_v1.c
new file mode 100644
index 0000000000..efb8d51500
--- /dev/null
+++ b/lib/fwu_updates/fwu_v1.c
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024, Linaro Limited
+ */
+
+#include <fwu.h>
+#include <fwu_mdata.h>
+
+#include <linux/types.h>
+
+#define FWU_MDATA_VERSION	0x1U
+
+static uint32_t fwu_check_trial_state(struct fwu_mdata *mdata, uint32_t bank)
+{
+	u32 i;
+	struct fwu_image_entry *img_entry;
+	struct fwu_image_bank_info *img_bank_info;
+
+	img_entry = &mdata->img_entry[0];
+	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
+		img_bank_info = &img_entry[i].img_bank_info[bank];
+		if (!img_bank_info->accepted) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void fwu_data_init(void)
+{
+	size_t image_info_size;
+	void *dst_img_info, *src_img_info;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	data->crc32 = mdata->crc32;
+	data->version = mdata->version;
+	data->active_index = mdata->active_index;
+	data->previous_active_index = mdata->previous_active_index;
+
+	data->metadata_size = sizeof(struct fwu_mdata);
+	data->num_banks = CONFIG_FWU_NUM_BANKS;
+	data->num_images = CONFIG_FWU_NUM_IMAGES_PER_BANK;
+	fwu_plat_get_bootidx(&data->boot_index);
+	data->trial_state = fwu_check_trial_state(mdata, data->boot_index);
+
+	src_img_info = &mdata->img_entry[0];
+	dst_img_info = &data->fwu_images[0];
+	image_info_size = sizeof(data->fwu_images);
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+static int fwu_trial_state_update(bool trial_state)
+{
+	int ret;
+	struct fwu_data *data = fwu_get_data();
+
+	if (trial_state) {
+		ret = fwu_trial_state_ctr_start();
+		if (ret)
+			return ret;
+	}
+
+	data->trial_state = trial_state;
+
+	return 0;
+}
+
+/**
+ * fwu_populate_mdata_image_info() - Populate the image information
+ * of the metadata
+ * @data: Version agnostic FWU metadata information
+ *
+ * Populate the image information in the FWU metadata by copying it
+ * from the version agnostic structure. This is done before the
+ * metadata gets written to the storage media.
+ *
+ * Return: None
+ */
+void fwu_populate_mdata_image_info(struct fwu_data *data)
+{
+	size_t image_info_size;
+	void *dst_img_info, *src_img_info;
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	image_info_size = sizeof(data->fwu_images);
+	dst_img_info = &mdata->img_entry[0];
+	src_img_info = &data->fwu_images[0];
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+/**
+ * fwu_state_machine_updates() - Update FWU state of the platform
+ * @trial_state: Is platform transitioning into Trial State
+ * @update_index: Bank number to which images have been updated
+ *
+ * On successful completion of updates, transition the platform to
+ * either Trial State or Regular State.
+ *
+ * To transition the platform to Trial State, start the
+ * TrialStateCtr counter, followed by setting the value of bank_state
+ * field of the metadata to Valid state(applicable only in version 2
+ * of metadata).
+ *
+ * In case, the platform is to transition directly to Regular State,
+ * update the bank_state field of the metadata to Accepted
+ * state(applicable only in version 2 of metadata).
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_state_machine_updates(bool trial_state,
+			      __maybe_unused uint32_t update_index)
+{
+	return fwu_trial_state_update(trial_state);
+}
+
+/**
+ * fwu_get_mdata_size() - Get the FWU metadata size
+ * @mdata_size: Size of the metadata structure
+ *
+ * Get the size of the FWU metadata.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata_size(uint32_t *mdata_size)
+{
+	*mdata_size = sizeof(struct fwu_mdata);
+
+	return 0;
+}
+
+/**
+ * fwu_init() - FWU specific initialisations
+ *
+ * Carry out some FWU specific initialisations including allocation
+ * of memory for the metadata copies, and reading the FWU metadata
+ * copies into the allocated memory. The metadata fields are then
+ * copied into a version agnostic structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_init(void)
+{
+	int ret;
+	uint32_t mdata_size;
+
+	fwu_get_mdata_size(&mdata_size);
+
+	ret = fwu_mdata_copies_allocate(mdata_size);
+	if (ret)
+		return ret;
+
+	/*
+	 * Now read the entire structure, both copies, and
+	 * validate that the copies.
+	 */
+	ret = fwu_get_mdata(NULL);
+	if (ret)
+		return ret;
+
+	fwu_data_init();
+
+	return 0;
+}
diff --git a/lib/fwu_updates/fwu_v2.c b/lib/fwu_updates/fwu_v2.c
new file mode 100644
index 0000000000..108bc9bb4a
--- /dev/null
+++ b/lib/fwu_updates/fwu_v2.c
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024, Linaro Limited
+ */
+
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+
+#include <linux/types.h>
+
+#define FWU_MDATA_VERSION	0x2U
+
+static inline struct fwu_fw_store_desc *fwu_get_fw_desc(struct fwu_mdata *mdata)
+{
+	return (struct fwu_fw_store_desc *)((u8 *)mdata + sizeof(*mdata));
+}
+
+static uint32_t fwu_check_trial_state(struct fwu_mdata *mdata, uint32_t bank)
+{
+	return mdata->bank_state[bank] == FWU_BANK_VALID ? 1 : 0;
+}
+
+static void fwu_data_init(void)
+{
+	int i;
+	size_t image_info_size;
+	void *dst_img_info, *src_img_info;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	data->crc32 = mdata->crc32;
+	data->version = mdata->version;
+	data->active_index = mdata->active_index;
+	data->previous_active_index = mdata->previous_active_index;
+	data->metadata_size = mdata->metadata_size;
+	fwu_plat_get_bootidx(&data->boot_index);
+	data->trial_state = fwu_check_trial_state(mdata, data->boot_index);
+
+	data->num_banks = fwu_get_fw_desc(mdata)->num_banks;
+	data->num_images = fwu_get_fw_desc(mdata)->num_images;
+
+	for (i = 0; i < 4; i++) {
+		data->bank_state[i] = mdata->bank_state[i];
+	}
+
+	image_info_size = sizeof(data->fwu_images);
+	src_img_info = &fwu_get_fw_desc(mdata)->img_entry[0];
+	dst_img_info = &data->fwu_images[0];
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+static int fwu_mdata_sanity_checks(void)
+{
+	uint8_t num_banks;
+	uint16_t num_images;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	if (mdata->version != FWU_MDATA_VERSION) {
+		log_err("FWU metadata version %u. Expected value of %u\n",
+			mdata->version, FWU_MDATA_VERSION);
+		return -EINVAL;
+	}
+
+	if (!mdata->desc_offset) {
+		log_err("No image information provided with the Metadata. ");
+		log_err("Image information expected in the metadata\n");
+		return -EINVAL;
+	}
+
+	if (mdata->desc_offset != 0x20) {
+		log_err("Descriptor Offset(0x%x) in the FWU Metadata not equal to 0x20\n",
+			mdata->desc_offset);
+		return -EINVAL;
+	}
+
+	num_banks = fwu_get_fw_desc(mdata)->num_banks;
+	num_images = fwu_get_fw_desc(mdata)->num_images;
+
+	if (num_banks != CONFIG_FWU_NUM_BANKS) {
+		log_err("Number of Banks(%u) in FWU Metadata different from the configured value(%d)",
+			num_banks, CONFIG_FWU_NUM_BANKS);
+		return -EINVAL;
+	}
+
+	if (num_images != CONFIG_FWU_NUM_IMAGES_PER_BANK) {
+		log_err("Number of Images(%u) in FWU Metadata different from the configured value(%d)",
+			num_images, CONFIG_FWU_NUM_IMAGES_PER_BANK);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int fwu_bank_state_update(bool trial_state, uint32_t bank)
+{
+	int ret;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	mdata->bank_state[bank] = data->bank_state[bank] = trial_state ?
+		FWU_BANK_VALID : FWU_BANK_ACCEPTED;
+
+	ret = fwu_sync_mdata(mdata, BOTH_PARTS);
+	if (ret)
+		log_err("Unable to set bank_state for bank %u\n", bank);
+	else
+		data->trial_state = trial_state;
+
+	return ret;
+}
+
+static int fwu_trial_state_start(uint update_index)
+{
+	int ret;
+
+	ret = fwu_trial_state_ctr_start();
+	if (ret)
+		return ret;
+
+	ret = fwu_bank_state_update(1, update_index);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/**
+ * fwu_populate_mdata_image_info() - Populate the image information
+ * of the metadata
+ * @data: Version agnostic FWU metadata information
+ *
+ * Populate the image information in the FWU metadata by copying it
+ * from the version agnostic structure. This is done before the
+ * metadata gets written to the storage media.
+ *
+ * Return: None
+ */
+void fwu_populate_mdata_image_info(struct fwu_data *data)
+{
+	size_t image_info_size;
+	struct fwu_mdata *mdata = data->fwu_mdata;
+	void *dst_img_info, *src_img_info;
+
+	image_info_size = sizeof(data->fwu_images);
+	dst_img_info = &fwu_get_fw_desc(mdata)->img_entry[0];
+	src_img_info = &data->fwu_images[0];
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+/**
+ * fwu_state_machine_updates() - Update FWU state of the platform
+ * @trial_state: Is platform transitioning into Trial State
+ * @update_index: Bank number to which images have been updated
+ *
+ * On successful completion of updates, transition the platform to
+ * either Trial State or Regular State.
+ *
+ * To transition the platform to Trial State, start the
+ * TrialStateCtr counter, followed by setting the value of bank_state
+ * field of the metadata to Valid state(applicable only in version 2
+ * of metadata).
+ *
+ * In case, the platform is to transition directly to Regular State,
+ * update the bank_state field of the metadata to Accepted
+ * state(applicable only in version 2 of metadata).
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_state_machine_updates(bool trial_state, uint32_t update_index)
+{
+	return trial_state ? fwu_trial_state_start(update_index) :
+		fwu_bank_state_update(0, update_index);
+}
+
+/**
+ * fwu_get_mdata_size() - Get the FWU metadata size
+ * @mdata_size: Size of the metadata structure
+ *
+ * Get the size of the FWU metadata from the structure. This is later used
+ * to allocate memory for the structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata_size(uint32_t *mdata_size)
+{
+	int ret = 0;
+	struct fwu_mdata mdata = { 0 };
+	struct fwu_data *data = fwu_get_data();
+	struct udevice *fwu_dev = fwu_get_dev();
+
+	if (data->metadata_size) {
+		*mdata_size = data->metadata_size;
+		return 0;
+	}
+
+	ret = fwu_read_mdata(fwu_dev, &mdata, 1,
+			     sizeof(struct fwu_mdata));
+	if (ret) {
+		log_err("FWU metadata read failed\n");
+		return ret;
+	}
+
+	*mdata_size = mdata.metadata_size;
+	if (!*mdata_size)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * fwu_init() - FWU specific initialisations
+ *
+ * Carry out some FWU specific initialisations including allocation
+ * of memory for the metadata copies, and reading the FWU metadata
+ * copies into the allocated memory. The metadata fields are then
+ * copied into a version agnostic structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_init(void)
+{
+	int ret;
+	struct fwu_mdata mdata = { 0 };
+	struct udevice *fwu_dev = fwu_get_dev();
+
+	/*
+	 * First we read only the top level structure
+	 * and get the size of the complete structure.
+	 */
+	ret = fwu_read_mdata(fwu_dev, &mdata, 1,
+			     sizeof(struct fwu_mdata));
+	if (ret) {
+		log_err("FWU metadata read failed\n");
+		return ret;
+	}
+
+	ret = fwu_mdata_copies_allocate(mdata.metadata_size);
+	if (ret)
+		return ret;
+
+	/*
+	 * Now read the entire structure, both copies, and
+	 * validate that the copies.
+	 */
+	ret = fwu_get_mdata(NULL);
+	if (ret)
+		return ret;
+
+	ret = fwu_mdata_sanity_checks();
+	if (ret)
+		return ret;
+
+	fwu_data_init();
+
+	return 0;
+}
diff --git a/lib/lmb.c b/lib/lmb.c
index b2c233edb6..52e8af41ee 100644
--- a/lib/lmb.c
+++ b/lib/lmb.c
@@ -105,6 +105,22 @@ static void lmb_coalesce_regions(struct lmb_region *rgn, unsigned long r1,
 	lmb_remove_region(rgn, r2);
 }
 
+static long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
+				phys_size_t size)
+{
+	unsigned long i;
+
+	for (i = 0; i < rgn->cnt; i++) {
+		phys_addr_t rgnbase = rgn->region[i].base;
+		phys_size_t rgnsize = rgn->region[i].size;
+
+		if (lmb_addrs_overlap(base, size, rgnbase, rgnsize))
+			break;
+	}
+
+	return (i < rgn->cnt) ? i : -1;
+}
+
 void lmb_init(struct lmb *lmb)
 {
 #if IS_ENABLED(CONFIG_LMB_USE_MAX_REGIONS)
@@ -232,7 +248,7 @@ static long lmb_add_region_flags(struct lmb_region *rgn, phys_addr_t base,
 				 phys_size_t size, enum lmb_flags flags)
 {
 	unsigned long coalesced = 0;
-	long adjacent, i;
+	long adjacent, i, overlap;
 
 	if (rgn->cnt == 0) {
 		rgn->region[0].base = base;
@@ -259,19 +275,19 @@ static long lmb_add_region_flags(struct lmb_region *rgn, phys_addr_t base,
 		}
 
 		adjacent = lmb_addrs_adjacent(base, size, rgnbase, rgnsize);
-		if (adjacent > 0) {
-			if (flags != rgnflags)
-				break;
-			rgn->region[i].base -= size;
-			rgn->region[i].size += size;
-			coalesced++;
-			break;
-		} else if (adjacent < 0) {
+		if (adjacent != 0) {
 			if (flags != rgnflags)
+				continue;
+			overlap = lmb_overlaps_region(rgn, base, size);
+			if (overlap < 0) {
+				/* no overlap detected, extend region */
+				if  (adjacent > 0)
+					rgn->region[i].base -= size;
+				rgn->region[i].size += size;
+				coalesced++;
 				break;
-			rgn->region[i].size += size;
-			coalesced++;
-			break;
+			}
+			continue;
 		} else if (lmb_addrs_overlap(base, size, rgnbase, rgnsize)) {
 			/* regions overlap */
 			return -1;
@@ -392,21 +408,6 @@ long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
 	return lmb_reserve_flags(lmb, base, size, LMB_NONE);
 }
 
-static long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
-				phys_size_t size)
-{
-	unsigned long i;
-
-	for (i = 0; i < rgn->cnt; i++) {
-		phys_addr_t rgnbase = rgn->region[i].base;
-		phys_size_t rgnsize = rgn->region[i].size;
-		if (lmb_addrs_overlap(base, size, rgnbase, rgnsize))
-			break;
-	}
-
-	return (i < rgn->cnt) ? i : -1;
-}
-
 phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align)
 {
 	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index f5ab7af0f4..3fa1166d8c 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -187,8 +187,10 @@ u_boot_dtsi = $(strip $(u_boot_dtsi_options_debug) \
 dtc_cpp_flags  = -Wp,-MD,$(depfile).pre.tmp -nostdinc                    \
 		 $(UBOOTINCLUDE)                                         \
 		 -I$(dir $<)                                             \
+		 -I$(srctree)/arch/$(ARCH)/dts                           \
 		 -I$(srctree)/arch/$(ARCH)/dts/include                   \
 		 -I$(srctree)/include                                    \
+		 -I$(EXT_DTS)                                            \
 		 -D__ASSEMBLY__                                          \
 		 -undef -D__DTS__
 
diff --git a/scripts/dtc/pylibfdt/setup.py b/scripts/dtc/pylibfdt/setup.py
index 8baae08770..c6fe5a6a44 100755
--- a/scripts/dtc/pylibfdt/setup.py
+++ b/scripts/dtc/pylibfdt/setup.py
@@ -37,7 +37,7 @@ with open(os.path.join(srcdir, "../README"), "r") as fh:
     long_description = fh.read()
 
 # Decodes a Makefile assignment line into key and value (and plus for +=)
-RE_KEY_VALUE = re.compile('(?P<key>\w+) *(?P<plus>[+])?= *(?P<value>.*)$')
+RE_KEY_VALUE = re.compile(r'(?P<key>\w+) *(?P<plus>[+])?= *(?P<value>.*)$')
 
 def get_top_builddir():
     if '--top-builddir' in sys.argv:
diff --git a/test/dm/clk_ccf.c b/test/dm/clk_ccf.c
index e4ebb93cda..41d1c2190c 100644
--- a/test/dm/clk_ccf.c
+++ b/test/dm/clk_ccf.c
@@ -31,13 +31,13 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_assertok(uclass_get_device_by_name(UCLASS_CLK, "clk-ccf", &dev));
 
 	/* Test for clk_get_by_id() */
-	ret = clk_get_by_id(SANDBOX_CLK_ECSPI_ROOT, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_ECSPI_ROOT), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("ecspi_root", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_PARENT, clk->flags);
 
 	/* Test for clk_get_parent_rate() */
-	ret = clk_get_by_id(SANDBOX_CLK_ECSPI1, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_ECSPI1), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("ecspi1", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_PARENT, clk->flags);
@@ -46,7 +46,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(rate, 20000000);
 
 	/* test the gate of CCF */
-	ret = clk_get_by_id(SANDBOX_CLK_ECSPI0, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_ECSPI0), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("ecspi0", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_PARENT, clk->flags);
@@ -55,7 +55,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(rate, 20000000);
 
 	/* Test the mux of CCF */
-	ret = clk_get_by_id(SANDBOX_CLK_USDHC1_SEL, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_USDHC1_SEL), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("usdhc1_sel", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_NO_REPARENT, clk->flags);
@@ -66,7 +66,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	rate = clk_get_rate(clk);
 	ut_asserteq(rate, 60000000);
 
-	ret = clk_get_by_id(SANDBOX_CLK_PLL3_80M, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_PLL3_80M), &pclk);
 	ut_assertok(ret);
 
 	ret = clk_set_parent(clk, pclk);
@@ -75,7 +75,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	rate = clk_get_rate(clk);
 	ut_asserteq(rate, 80000000);
 
-	ret = clk_get_by_id(SANDBOX_CLK_USDHC2_SEL, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_USDHC2_SEL), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("usdhc2_sel", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_NO_REPARENT, clk->flags);
@@ -90,7 +90,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	rate = clk_get_rate(clk);
 	ut_asserteq(rate, 80000000);
 
-	ret = clk_get_by_id(SANDBOX_CLK_PLL3_60M, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_PLL3_60M), &pclk);
 	ut_assertok(ret);
 
 	ret = clk_set_parent(clk, pclk);
@@ -100,7 +100,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(rate, 60000000);
 
 	/* Test the composite of CCF */
-	ret = clk_get_by_id(SANDBOX_CLK_I2C, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("i2c", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_UNGATE, clk->flags);
@@ -110,7 +110,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 
 #if CONFIG_IS_ENABLED(CLK_CCF)
 	/* Test clk tree enable/disable */
-	ret = clk_get_by_id(SANDBOX_CLK_I2C_ROOT, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C_ROOT), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("i2c_root", clk->dev->name);
 
@@ -120,7 +120,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ret = sandbox_clk_enable_count(clk);
 	ut_asserteq(ret, 1);
 
-	ret = clk_get_by_id(SANDBOX_CLK_I2C, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C), &pclk);
 	ut_assertok(ret);
 
 	ret = sandbox_clk_enable_count(pclk);
@@ -136,7 +136,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(ret, 0);
 
 	/* Test clock re-parenting. */
-	ret = clk_get_by_id(SANDBOX_CLK_USDHC1_SEL, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_USDHC1_SEL), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("usdhc1_sel", clk->dev->name);
 
@@ -150,7 +150,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 		clkid = SANDBOX_CLK_PLL3_60M;
 	}
 
-	ret = clk_get_by_id(clkid, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, clkid), &pclk);
 	ut_assertok(ret);
 	ret = clk_set_parent(clk, pclk);
 	ut_assertok(ret);
@@ -159,7 +159,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq_str(clkname, pclk->dev->name);
 
 	/* Test disabling critical clock. */
-	ret = clk_get_by_id(SANDBOX_CLK_I2C_ROOT, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C_ROOT), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("i2c_root", clk->dev->name);
 
diff --git a/test/dm/fwu_mdata.c b/test/dm/fwu_mdata.c
index 8b5c83ef4e..6f2e7a09b6 100644
--- a/test/dm/fwu_mdata.c
+++ b/test/dm/fwu_mdata.c
@@ -93,11 +93,19 @@ static int dm_test_fwu_mdata_read(struct unit_test_state *uts)
 	struct udevice *dev;
 	struct fwu_mdata mdata = { 0 };
 
-	ut_assertok(uclass_first_device_err(UCLASS_FWU_MDATA, &dev));
 	ut_assertok(setup_blk_device(uts));
 	ut_assertok(populate_mmc_disk_image(uts));
 	ut_assertok(write_mmc_blk_device(uts));
 
+	/*
+	 * Trigger lib/fwu_updates/fwu.c fwu_boottime_checks()
+	 * to populate g_dev global pointer in that library.
+	 */
+	event_notify_null(EVT_MAIN_LOOP);
+
+	ut_assertok(uclass_first_device_err(UCLASS_FWU_MDATA, &dev));
+	ut_assertok(fwu_init());
+
 	ut_assertok(fwu_get_mdata(&mdata));
 
 	ut_asserteq(mdata.version, 0x1);
@@ -116,8 +124,15 @@ static int dm_test_fwu_mdata_write(struct unit_test_state *uts)
 	ut_assertok(populate_mmc_disk_image(uts));
 	ut_assertok(write_mmc_blk_device(uts));
 
+	/*
+	 * Trigger lib/fwu_updates/fwu.c fwu_boottime_checks()
+	 * to populate g_dev global pointer in that library.
+	 */
+	event_notify_null(EVT_MAIN_LOOP);
+
 	ut_assertok(uclass_first_device_err(UCLASS_FWU_MDATA, &dev));
 
+	ut_assertok(fwu_init());
 	ut_assertok(fwu_get_mdata(&mdata));
 
 	active_idx = (mdata.active_index + 1) % CONFIG_FWU_NUM_BANKS;
diff --git a/test/dm/gpio.c b/test/dm/gpio.c
index 0d88ec24bd..d494b61e60 100644
--- a/test/dm/gpio.c
+++ b/test/dm/gpio.c
@@ -113,6 +113,11 @@ static int dm_test_gpio(struct unit_test_state *uts)
 	ut_asserteq_str("a", name);
 	ut_asserteq(20, offset_count);
 
+	/* Flag a pin as protected, and check its status */
+	ut_assertok(gpio_lookup_name("a1", &dev, &offset, &gpio));
+	sandbox_gpio_set_flags(dev, 1, GPIOD_EXT_PROTECTED);
+	ut_asserteq(GPIOF_PROTECTED, gpio_get_raw_function(dev, 1, NULL));
+
 	/* add gpio hog tests */
 	ut_assertok(gpio_hog_lookup_name("hog_input_active_low", &desc));
 	ut_asserteq(GPIOD_IS_IN | GPIOD_ACTIVE_LOW, desc->flags);
diff --git a/test/dm/reset.c b/test/dm/reset.c
index e2d6f45623..1728f7516f 100644
--- a/test/dm/reset.c
+++ b/test/dm/reset.c
@@ -144,7 +144,29 @@ static int dm_test_reset_bulk(struct unit_test_state *uts)
 	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
 	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
 
+	/* reset release don't change the reset level */
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
+	ut_assertok(sandbox_reset_test_release_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(sandbox_reset_test_get_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(sandbox_reset_test_assert_bulk(dev_test));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	/* reset release don't change the reset level */
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
 	ut_assertok(sandbox_reset_test_release_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
 	ut_asserteq(1, sandbox_reset_query(dev_reset, TEST_RESET_ID));
 	ut_asserteq(1, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
 
diff --git a/test/py/tests/test_pinmux.py b/test/py/tests/test_pinmux.py
index 794994e12d..7f83e9e137 100644
--- a/test/py/tests/test_pinmux.py
+++ b/test/py/tests/test_pinmux.py
@@ -24,19 +24,19 @@ def test_pinmux_status_all(u_boot_console):
     output = u_boot_console.run_command('pinmux status -a')
 
     assert ('pinctrl-gpio:' in output)
-    assert ('a5        : gpio output .' in output)
-    assert ('a6        : gpio output .' in output)
+    assert ('a5              : gpio output .' in output)
+    assert ('a6              : gpio output .' in output)
 
     assert ('pinctrl:' in output)
-    assert ('P0        : UART TX.' in output)
-    assert ('P1        : UART RX.' in output)
-    assert ('P2        : I2S SCK.' in output)
-    assert ('P3        : I2S SD.' in output)
-    assert ('P4        : I2S WS.' in output)
-    assert ('P5        : GPIO0 bias-pull-up input-disable.' in output)
-    assert ('P6        : GPIO1 drive-open-drain.' in output)
-    assert ('P7        : GPIO2 bias-pull-down input-enable.' in output)
-    assert ('P8        : GPIO3 bias-disable.' in output)
+    assert ('P0              : UART TX.' in output)
+    assert ('P1              : UART RX.' in output)
+    assert ('P2              : I2S SCK.' in output)
+    assert ('P3              : I2S SD.' in output)
+    assert ('P4              : I2S WS.' in output)
+    assert ('P5              : GPIO0 bias-pull-up input-disable.' in output)
+    assert ('P6              : GPIO1 drive-open-drain.' in output)
+    assert ('P7              : GPIO2 bias-pull-down input-enable.' in output)
+    assert ('P8              : GPIO3 bias-disable.' in output)
 
 @pytest.mark.buildconfigspec('cmd_pinmux')
 @pytest.mark.boardspec('sandbox')
@@ -74,12 +74,12 @@ def test_pinmux_status(u_boot_console):
     assert (not 'pinctrl-gpio:' in output)
     assert (not 'pinctrl:' in output)
 
-    assert ('P0        : UART TX.' in output)
-    assert ('P1        : UART RX.' in output)
-    assert ('P2        : I2S SCK.' in output)
-    assert ('P3        : I2S SD.' in output)
-    assert ('P4        : I2S WS.' in output)
-    assert ('P5        : GPIO0 bias-pull-up input-disable.' in output)
-    assert ('P6        : GPIO1 drive-open-drain.' in output)
-    assert ('P7        : GPIO2 bias-pull-down input-enable.' in output)
-    assert ('P8        : GPIO3 bias-disable.' in output)
+    assert ('P0              : UART TX.' in output)
+    assert ('P1              : UART RX.' in output)
+    assert ('P2              : I2S SCK.' in output)
+    assert ('P3              : I2S SD.' in output)
+    assert ('P4              : I2S WS.' in output)
+    assert ('P5              : GPIO0 bias-pull-up input-disable.' in output)
+    assert ('P6              : GPIO1 drive-open-drain.' in output)
+    assert ('P7              : GPIO2 bias-pull-down input-enable.' in output)
+    assert ('P8              : GPIO3 bias-disable.' in output)
diff --git a/tools/buildman/bsettings.py b/tools/buildman/bsettings.py
index f7f8276e62..e225ac2ca0 100644
--- a/tools/buildman/bsettings.py
+++ b/tools/buildman/bsettings.py
@@ -16,7 +16,7 @@ def setup(fname=''):
     global settings
     global config_fname
 
-    settings = configparser.SafeConfigParser()
+    settings = configparser.ConfigParser()
     if fname is not None:
         config_fname = fname
         if config_fname == '':
diff --git a/tools/eficapsule.h b/tools/eficapsule.h
index 2099a2e9b8..6efd07d2eb 100644
--- a/tools/eficapsule.h
+++ b/tools/eficapsule.h
@@ -22,6 +22,8 @@
 #define __aligned(x)	__attribute__((__aligned__(x)))
 #endif
 
+#define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
+
 typedef struct {
 	uint8_t b[16];
 } efi_guid_t __aligned(8);
diff --git a/tools/mkeficapsule.c b/tools/mkeficapsule.c
index 52be1f122e..57bddbe4d0 100644
--- a/tools/mkeficapsule.c
+++ b/tools/mkeficapsule.c
@@ -29,7 +29,7 @@ static const char *tool_name = "mkeficapsule";
 efi_guid_t efi_guid_fm_capsule = EFI_FIRMWARE_MANAGEMENT_CAPSULE_ID_GUID;
 efi_guid_t efi_guid_cert_type_pkcs7 = EFI_CERT_TYPE_PKCS7_GUID;
 
-static const char *opts_short = "g:i:I:v:p:c:m:o:dhAR";
+static const char *opts_short = "g:i:I:v:p:c:m:o:dhARD";
 
 enum {
 	CAPSULE_NORMAL_BLOB = 0,
@@ -49,6 +49,7 @@ static struct option options[] = {
 	{"fw-accept", no_argument, NULL, 'A'},
 	{"fw-revert", no_argument, NULL, 'R'},
 	{"capoemflag", required_argument, NULL, 'o'},
+	{"dump-capsule", no_argument, NULL, 'D'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
@@ -69,6 +70,7 @@ static void print_usage(void)
 		"\t-A, --fw-accept  firmware accept capsule, requires GUID, no image blob\n"
 		"\t-R, --fw-revert  firmware revert capsule, takes no GUID, no image blob\n"
 		"\t-o, --capoemflag Capsule OEM Flag, an integer between 0x0000 and 0xffff\n"
+		"\t-D, --dump-capsule          dump the contents of the capsule headers\n"
 		"\t-h, --help                  print a help message\n",
 		tool_name);
 }
@@ -647,6 +649,211 @@ err:
 	return ret;
 }
 
+static void print_guid(void *ptr)
+{
+	int i;
+	efi_guid_t *guid = ptr;
+	const uint8_t seq[] = {
+		3, 2, 1, 0, '-', 5, 4, '-', 7, 6,
+		'-', 8, 9, '-', 10, 11, 12, 13, 14, 15 };
+
+	for (i = 0; i < ARRAY_SIZE(seq); i++) {
+		if (seq[i] == '-')
+			putchar(seq[i]);
+		else
+			printf("%02X", guid->b[seq[i]]);
+	}
+
+	printf("\n");
+}
+
+static uint32_t dump_fmp_payload_header(struct fmp_payload_header *fmp_payload_hdr)
+{
+	if (fmp_payload_hdr->signature == FMP_PAYLOAD_HDR_SIGNATURE) {
+		printf("--------\n");
+		printf("FMP_PAYLOAD_HDR.SIGNATURE\t\t\t: %08X\n",
+		       FMP_PAYLOAD_HDR_SIGNATURE);
+		printf("FMP_PAYLOAD_HDR.HEADER_SIZE\t\t\t: %08X\n",
+		       fmp_payload_hdr->header_size);
+		printf("FMP_PAYLOAD_HDR.FW_VERSION\t\t\t: %08X\n",
+		       fmp_payload_hdr->fw_version);
+		printf("FMP_PAYLOAD_HDR.LOWEST_SUPPORTED_VERSION\t: %08X\n",
+		       fmp_payload_hdr->lowest_supported_version);
+		return fmp_payload_hdr->header_size;
+	}
+
+	return 0;
+}
+
+static void dump_capsule_auth_header(struct efi_firmware_image_authentication *capsule_auth_hdr)
+{
+	printf("EFI_FIRMWARE_IMAGE_AUTH.MONOTONIC_COUNT\t\t: %08lX\n",
+	       capsule_auth_hdr->monotonic_count);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.HDR.dwLENGTH\t: %08X\n",
+	       capsule_auth_hdr->auth_info.hdr.dwLength);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.HDR.wREVISION\t: %08X\n",
+	       capsule_auth_hdr->auth_info.hdr.wRevision);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.HDR.wCERTTYPE\t: %08X\n",
+	       capsule_auth_hdr->auth_info.hdr.wCertificateType);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.CERT_TYPE\t: ");
+	print_guid(&capsule_auth_hdr->auth_info.cert_type);
+}
+
+static void dump_fmp_capsule_image_header(struct efi_firmware_management_capsule_image_header *image_hdr)
+{
+	void *capsule_auth_hdr;
+	void *fmp_payload_hdr;
+	uint64_t signature_size = 0;
+	uint32_t payload_size = 0;
+	uint32_t fmp_payload_hdr_size = 0;
+	struct efi_firmware_image_authentication *auth_hdr;
+
+	printf("--------\n");
+	printf("FMP_CAPSULE_IMAGE_HDR.VERSION\t\t\t: %08X\n",
+	       image_hdr->version);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_IMAGE_TYPE_ID\t: ");
+	print_guid(&image_hdr->update_image_type_id);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_IMAGE_INDEX\t: %08X\n",
+	       image_hdr->update_image_index);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_IMAGE_SIZE\t\t: %08X\n",
+	       image_hdr->update_image_size);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_VENDOR_CODE_SIZE\t: %08X\n",
+	       image_hdr->update_vendor_code_size);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_HARDWARE_INSTANCE\t: %08lX\n",
+	       image_hdr->update_hardware_instance);
+	printf("FMP_CAPSULE_IMAGE_HDR.IMAGE_CAPSULE_SUPPORT\t: %08lX\n",
+	       image_hdr->image_capsule_support);
+
+	printf("--------\n");
+	if (image_hdr->image_capsule_support & CAPSULE_SUPPORT_AUTHENTICATION) {
+		capsule_auth_hdr = (char *)image_hdr + sizeof(*image_hdr);
+		dump_capsule_auth_header(capsule_auth_hdr);
+
+		auth_hdr = capsule_auth_hdr;
+		signature_size = sizeof(auth_hdr->monotonic_count) +
+			auth_hdr->auth_info.hdr.dwLength;
+		fmp_payload_hdr = (char *)capsule_auth_hdr + signature_size;
+	} else {
+		printf("Capsule Authentication Not Enabled\n");
+		fmp_payload_hdr = (char *)image_hdr + sizeof(*image_hdr);
+	}
+
+	fmp_payload_hdr_size = dump_fmp_payload_header(fmp_payload_hdr);
+
+	payload_size = image_hdr->update_image_size - signature_size -
+		fmp_payload_hdr_size;
+	printf("--------\n");
+	printf("Payload Image Size\t\t\t\t: %08X\n", payload_size);
+}
+
+static void dump_fmp_header(struct efi_firmware_management_capsule_header *fmp_hdr)
+{
+	int i;
+	void *capsule_image_hdr;
+
+	printf("EFI_FMP_HDR.VERSION\t\t\t\t: %08X\n", fmp_hdr->version);
+	printf("EFI_FMP_HDR.EMBEDDED_DRIVER_COUNT\t\t: %08X\n",
+	       fmp_hdr->embedded_driver_count);
+	printf("EFI_FMP_HDR.PAYLOAD_ITEM_COUNT\t\t\t: %08X\n",
+	       fmp_hdr->payload_item_count);
+
+	/*
+	 * We currently don't support Embedded Drivers.
+	 * Only worry about the payload items.
+	 */
+	for (i = 0; i < fmp_hdr->payload_item_count; i++) {
+		capsule_image_hdr = (char *)fmp_hdr +
+			fmp_hdr->item_offset_list[i];
+		dump_fmp_capsule_image_header(capsule_image_hdr);
+	}
+}
+
+static void dump_capsule_header(struct efi_capsule_header *capsule_hdr)
+{
+	printf("EFI_CAPSULE_HDR.CAPSULE_GUID\t\t\t: ");
+	print_guid((void *)&capsule_hdr->capsule_guid);
+	printf("EFI_CAPSULE_HDR.HEADER_SIZE\t\t\t: %08X\n",
+	       capsule_hdr->header_size);
+	printf("EFI_CAPSULE_HDR.FLAGS\t\t\t\t: %08X\n", capsule_hdr->flags);
+	printf("EFI_CAPSULE_HDR.CAPSULE_IMAGE_SIZE\t\t: %08X\n",
+	       capsule_hdr->capsule_image_size);
+}
+
+static void normal_capsule_dump(void *capsule_buf)
+{
+	void *fmp_hdr;
+	struct efi_capsule_header *hdr = capsule_buf;
+
+	dump_capsule_header(hdr);
+	printf("--------\n");
+
+	fmp_hdr = (char *)capsule_buf + sizeof(*hdr);
+	dump_fmp_header(fmp_hdr);
+}
+
+static void empty_capsule_dump(void *capsule_buf)
+{
+	efi_guid_t *accept_image_guid;
+	struct efi_capsule_header *hdr = capsule_buf;
+	efi_guid_t efi_empty_accept_capsule = FW_ACCEPT_OS_GUID;
+
+	dump_capsule_header(hdr);
+
+	if (!memcmp(&efi_empty_accept_capsule, &hdr->capsule_guid,
+		    sizeof(efi_guid_t))) {
+		accept_image_guid = (void *)(char *)capsule_buf +
+			sizeof(struct efi_capsule_header);
+		printf("--------\n");
+		printf("ACCEPT_IMAGE_GUID\t\t\t\t: ");
+		print_guid(accept_image_guid);
+	}
+}
+
+static void dump_capsule_contents(char *capsule_file)
+{
+	int fd;
+	char *ptr;
+	efi_guid_t efi_fmp_guid = EFI_FIRMWARE_MANAGEMENT_CAPSULE_ID_GUID;
+	efi_guid_t efi_empty_accept_capsule = FW_ACCEPT_OS_GUID;
+	efi_guid_t efi_empty_revert_capsule = FW_REVERT_OS_GUID;
+	struct stat sbuf;
+
+	if (!capsule_file) {
+		fprintf(stderr, "No capsule file provided\n");
+		exit(EXIT_FAILURE);
+	}
+
+	if ((fd = open(capsule_file, O_RDONLY)) < 0) {
+		fprintf(stderr, "Error opening capsule file: %s\n",
+			capsule_file);
+		exit(EXIT_FAILURE);
+	}
+
+	if (fstat(fd, &sbuf) < 0) {
+		fprintf(stderr, "Can't stat capsule file: %s\n", capsule_file);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0))
+	    == MAP_FAILED) {
+		fprintf(stderr, "Can't mmap capsule file: %s\n", capsule_file);
+		exit(EXIT_FAILURE);
+	}
+
+	if (!memcmp(&efi_fmp_guid, ptr, sizeof(efi_guid_t))) {
+		normal_capsule_dump(ptr);
+	} else if (!memcmp(&efi_empty_accept_capsule, ptr,
+		   sizeof(efi_guid_t)) ||
+		   !memcmp(&efi_empty_revert_capsule, ptr,
+			   sizeof(efi_guid_t))) {
+		empty_capsule_dump(ptr);
+	} else {
+		fprintf(stderr, "Unable to decode the capsule file: %s\n",
+			capsule_file);
+		exit(EXIT_FAILURE);
+	}
+}
+
 /**
  * main - main entry function of mkeficapsule
  * @argc:	Number of arguments
@@ -666,6 +873,7 @@ int main(int argc, char **argv)
 	unsigned long index, instance;
 	uint64_t mcount;
 	unsigned long oemflags;
+	bool capsule_dump;
 	char *privkey_file, *cert_file;
 	int c, idx;
 	struct fmp_payload_header_params fmp_ph_params = { 0 };
@@ -676,6 +884,7 @@ int main(int argc, char **argv)
 	mcount = 0;
 	privkey_file = NULL;
 	cert_file = NULL;
+	capsule_dump = false;
 	dump_sig = 0;
 	capsule_type = CAPSULE_NORMAL_BLOB;
 	oemflags = 0;
@@ -754,12 +963,24 @@ int main(int argc, char **argv)
 				exit(1);
 			}
 			break;
+		case 'D':
+			capsule_dump = true;
+			break;
 		default:
 			print_usage();
 			exit(EXIT_SUCCESS);
 		}
 	}
 
+	if (capsule_dump) {
+		if (argc != optind + 1) {
+			fprintf(stderr, "Must provide the capsule file to parse\n");
+			exit(EXIT_FAILURE);
+		}
+		dump_capsule_contents(argv[argc - 1]);
+		exit(EXIT_SUCCESS);
+	}
+
 	/* check necessary parameters */
 	if ((capsule_type == CAPSULE_NORMAL_BLOB &&
 	    ((argc != optind + 2) || !guid ||
diff --git a/tools/mkfwumdata.c b/tools/mkfwumdata.c
index 9732a8ddc5..fbc2067bc1 100644
--- a/tools/mkfwumdata.c
+++ b/tools/mkfwumdata.c
@@ -10,28 +10,35 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
-#include <u-boot/crc.h>
 #include <unistd.h>
+#include <generated/autoconf.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <u-boot/crc.h>
 #include <uuid/uuid.h>
 
-/* This will dynamically allocate the fwu_mdata */
-#define CONFIG_FWU_NUM_BANKS		0
-#define CONFIG_FWU_NUM_IMAGES_PER_BANK	0
-
-/* Since we can not include fwu.h, redefine version here. */
-#define FWU_MDATA_VERSION		1
-
 typedef uint8_t u8;
 typedef int16_t s16;
 typedef uint16_t u16;
 typedef uint32_t u32;
 typedef uint64_t u64;
 
-#include <fwu_mdata.h>
+#undef CONFIG_FWU_NUM_BANKS
+#undef CONFIG_FWU_NUM_IMAGES_PER_BANK
 
-/* TODO: Endianness conversion may be required for some arch. */
+/* This will dynamically allocate the fwu_mdata */
+#define CONFIG_FWU_NUM_BANKS		0
+#define CONFIG_FWU_NUM_IMAGES_PER_BANK	0
+
+/* version 2 supports maximum of 4 banks */
+#define MAX_BANKS_V2			4
+
+#define BANK_INVALID			(u8)0xFF
+#define BANK_ACCEPTED			(u8)0xFC
 
-static const char *opts_short = "b:i:a:p:gh";
+#include <fwu_mdata.h>
+
+static const char *opts_short = "b:i:a:p:v:V:gh";
 
 static struct option options[] = {
 	{"banks", required_argument, NULL, 'b'},
@@ -39,6 +46,8 @@ static struct option options[] = {
 	{"guid", required_argument, NULL, 'g'},
 	{"active-bank", required_argument, NULL, 'a'},
 	{"previous-bank", required_argument, NULL, 'p'},
+	{"version", required_argument, NULL, 'v'},
+	{"vendor-file", required_argument, NULL, 'V'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
@@ -49,9 +58,11 @@ static void print_usage(void)
 	fprintf(stderr, "Options:\n"
 		"\t-i, --images <num>          Number of images (mandatory)\n"
 		"\t-b, --banks  <num>          Number of banks (mandatory)\n"
+		"\t-v, --version               Metadata version (mandatory)\n"
 		"\t-a, --active-bank  <num>    Active bank (default=0)\n"
 		"\t-p, --previous-bank  <num>  Previous active bank (default=active_bank - 1)\n"
 		"\t-g, --guid                  Use GUID instead of UUID\n"
+		"\t-V, --vendor-file           Vendor data file to append to the metadata\n"
 		"\t-h, --help                  print a help message\n"
 		);
 	fprintf(stderr, "  UUIDs list syntax:\n"
@@ -70,13 +81,28 @@ struct fwu_mdata_object {
 	size_t images;
 	size_t banks;
 	size_t size;
+	u8 version;
+	size_t vsize;
+	void *vbuf;
 	struct fwu_mdata *mdata;
 };
 
 static int previous_bank, active_bank;
 static bool __use_guid;
 
-static struct fwu_mdata_object *fwu_alloc_mdata(size_t images, size_t banks)
+static bool supported_mdata_version(unsigned long version)
+{
+	switch (version) {
+	case 1:
+	case 2:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static struct fwu_mdata_object *fwu_alloc_mdata(size_t images, size_t banks,
+						u8 version, size_t vendor_size)
 {
 	struct fwu_mdata_object *mobj;
 
@@ -84,19 +110,40 @@ static struct fwu_mdata_object *fwu_alloc_mdata(size_t images, size_t banks)
 	if (!mobj)
 		return NULL;
 
-	mobj->size = sizeof(struct fwu_mdata) +
-		(sizeof(struct fwu_image_entry) +
-		 sizeof(struct fwu_image_bank_info) * banks) * images;
+	if (version == 1) {
+		mobj->size = sizeof(struct fwu_mdata) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * banks) * images;
+	} else {
+		mobj->size = sizeof(struct fwu_mdata) +
+			sizeof(struct fwu_fw_store_desc) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * banks) * images;
+
+		mobj->size += vendor_size;
+		mobj->vsize = vendor_size;
+	}
+
 	mobj->images = images;
 	mobj->banks = banks;
+	mobj->version = version;
 
 	mobj->mdata = calloc(1, mobj->size);
-	if (!mobj->mdata) {
-		free(mobj);
-		return NULL;
+	if (!mobj->mdata)
+		goto alloc_err;
+
+	if (vendor_size) {
+		mobj->vbuf = calloc(1, mobj->vsize);
+		if (!mobj->vbuf)
+			goto alloc_err;
 	}
 
 	return mobj;
+
+alloc_err:
+	free(mobj->mdata);
+	free(mobj);
+	return NULL;
 }
 
 static struct fwu_image_entry *
@@ -104,9 +151,18 @@ fwu_get_image(struct fwu_mdata_object *mobj, size_t idx)
 {
 	size_t offset;
 
-	offset = sizeof(struct fwu_mdata) +
-		(sizeof(struct fwu_image_entry) +
-		 sizeof(struct fwu_image_bank_info) * mobj->banks) * idx;
+	if (mobj->version == 1) {
+		offset = sizeof(struct fwu_mdata) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			idx;
+	} else {
+		offset = sizeof(struct fwu_mdata) +
+			sizeof(struct fwu_fw_store_desc) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			idx;
+	}
 
 	return (struct fwu_image_entry *)((char *)mobj->mdata + offset);
 }
@@ -116,11 +172,20 @@ fwu_get_bank(struct fwu_mdata_object *mobj, size_t img_idx, size_t bnk_idx)
 {
 	size_t offset;
 
-	offset = sizeof(struct fwu_mdata) +
-		(sizeof(struct fwu_image_entry) +
-		 sizeof(struct fwu_image_bank_info) * mobj->banks) * img_idx +
-		sizeof(struct fwu_image_entry) +
-		sizeof(struct fwu_image_bank_info) * bnk_idx;
+	if (mobj->version == 1) {
+		offset = sizeof(struct fwu_mdata) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			img_idx + sizeof(struct fwu_image_entry) +
+			sizeof(struct fwu_image_bank_info) * bnk_idx;
+	} else {
+		offset = sizeof(struct fwu_mdata) +
+			sizeof(struct fwu_fw_store_desc) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			img_idx + sizeof(struct fwu_image_entry) +
+			sizeof(struct fwu_image_bank_info) * bnk_idx;
+	}
 
 	return (struct fwu_image_bank_info *)((char *)mobj->mdata + offset);
 }
@@ -188,7 +253,7 @@ fwu_parse_fill_image_uuid(struct fwu_mdata_object *mobj,
 		return -EINVAL;
 
 	if (strcmp(uuid, "0") &&
-	    uuid_guid_parse(uuid, (unsigned char *)&image->location_uuid) < 0)
+	    uuid_guid_parse(uuid, (unsigned char *)&image->location_guid) < 0)
 		return -EINVAL;
 
 	/* Image type UUID */
@@ -196,7 +261,7 @@ fwu_parse_fill_image_uuid(struct fwu_mdata_object *mobj,
 	if (!uuid)
 		return -EINVAL;
 
-	if (uuid_guid_parse(uuid, (unsigned char *)&image->image_type_uuid) < 0)
+	if (uuid_guid_parse(uuid, (unsigned char *)&image->image_type_guid) < 0)
 		return -EINVAL;
 
 	/* Fill bank image-UUID */
@@ -210,45 +275,118 @@ fwu_parse_fill_image_uuid(struct fwu_mdata_object *mobj,
 			return -EINVAL;
 
 		if (strcmp(uuid, "0") &&
-		    uuid_guid_parse(uuid, (unsigned char *)&bank->image_uuid) < 0)
+		    uuid_guid_parse(uuid, (unsigned char *)&bank->image_guid) < 0)
 			return -EINVAL;
 	}
 	return 0;
 }
 
+#if defined(CONFIG_FWU_MDATA_V1)
+static void fwu_fill_version_specific_mdata(struct fwu_mdata_object *mobj)
+{
+}
+#else
+static void fwu_fill_version_specific_mdata(struct fwu_mdata_object *mobj)
+{
+	int i;
+	struct fwu_fw_store_desc *fw_desc;
+	struct fwu_mdata *mdata = mobj->mdata;
+
+	mdata->metadata_size = mobj->size;
+	mdata->desc_offset = sizeof(struct fwu_mdata);
+
+	for (i = 0; i < MAX_BANKS_V2; i++)
+		mdata->bank_state[i] = i < mobj->banks ?
+			BANK_ACCEPTED : BANK_INVALID;
+
+	fw_desc = (struct fwu_fw_store_desc *)((u8 *)mdata + sizeof(*mdata));
+	fw_desc->num_banks = mobj->banks;
+	fw_desc->num_images = mobj->images;
+	fw_desc->img_entry_size = sizeof(struct fwu_image_entry) +
+		(sizeof(struct fwu_image_bank_info) * mobj->banks);
+	fw_desc->bank_info_entry_size =
+		sizeof(struct fwu_image_bank_info);
+}
+#endif /* CONFIG_FWU_MDATA_V1 */
+
 /* Caller must ensure that @uuids[] has @mobj->images entries. */
 static int fwu_parse_fill_uuids(struct fwu_mdata_object *mobj, char *uuids[])
 {
 	struct fwu_mdata *mdata = mobj->mdata;
+	char *vdata;
 	int i, ret;
 
-	mdata->version = FWU_MDATA_VERSION;
+	mdata->version = mobj->version;
 	mdata->active_index = active_bank;
 	mdata->previous_active_index = previous_bank;
 
+	fwu_fill_version_specific_mdata(mobj);
+
 	for (i = 0; i < mobj->images; i++) {
 		ret = fwu_parse_fill_image_uuid(mobj, i, uuids[i]);
 		if (ret < 0)
 			return ret;
 	}
 
+	if (mobj->vsize) {
+		vdata = (char *)mobj->mdata + (mobj->size - mobj->vsize);
+		memcpy(vdata, mobj->vbuf, mobj->vsize);
+	}
+
 	mdata->crc32 = crc32(0, (const unsigned char *)&mdata->version,
 			     mobj->size - sizeof(uint32_t));
 
 	return 0;
 }
 
-static int
-fwu_make_mdata(size_t images, size_t banks, char *uuids[], char *output)
+static int fwu_read_vendor_data(struct fwu_mdata_object *mobj,
+				const char *vendor_file)
+{
+	int ret = 0;
+	FILE *vfile = NULL;
+
+	vfile = fopen(vendor_file, "r");
+	if (!vfile) {
+		ret = -1;
+		goto out;
+	}
+
+	if (fread(mobj->vbuf, 1, mobj->vsize, vfile) != mobj->vsize)
+		ret = -1;
+
+out:
+	fclose(vfile);
+	return ret;
+}
+
+static int fwu_make_mdata(size_t images, size_t banks, u8 version,
+			  const char *vendor_file, char *uuids[],
+			  char *output)
 {
-	struct fwu_mdata_object *mobj;
-	FILE *file;
 	int ret;
+	FILE *file;
+	struct stat sbuf;
+	size_t vendor_size = 0;
+	struct fwu_mdata_object *mobj;
+
+	if (vendor_file) {
+		ret = stat(vendor_file, &sbuf);
+		if (ret)
+			return -errno;
 
-	mobj = fwu_alloc_mdata(images, banks);
+		vendor_size = sbuf.st_size;
+	}
+
+	mobj = fwu_alloc_mdata(images, banks, version, vendor_size);
 	if (!mobj)
 		return -ENOMEM;
 
+	if (vendor_file) {
+		ret = fwu_read_vendor_data(mobj, vendor_file);
+		if (ret)
+			goto done_make;
+	}
+
 	ret = fwu_parse_fill_uuids(mobj, uuids);
 	if (ret < 0)
 		goto done_make;
@@ -259,7 +397,7 @@ fwu_make_mdata(size_t images, size_t banks, char *uuids[], char *output)
 		goto done_make;
 	}
 
-	ret = fwrite(mobj->mdata, mobj->size, 1, file);
+	ret = fwrite(mobj->mdata, 1, mobj->size, file);
 	if (ret != mobj->size)
 		ret = -errno;
 	else
@@ -269,6 +407,7 @@ fwu_make_mdata(size_t images, size_t banks, char *uuids[], char *output)
 
 done_make:
 	free(mobj->mdata);
+	free(mobj->vbuf);
 	free(mobj);
 
 	return ret;
@@ -276,13 +415,15 @@ done_make:
 
 int main(int argc, char *argv[])
 {
-	unsigned long banks = 0, images = 0;
+	unsigned long banks = 0, images = 0, version = 0;
 	int c, ret;
+	const char *vendor_file;
 
 	/* Explicitly initialize defaults */
 	active_bank = 0;
 	__use_guid = false;
 	previous_bank = INT_MAX;
+	vendor_file = NULL;
 
 	do {
 		c = getopt_long(argc, argv, opts_short, options, NULL);
@@ -305,6 +446,12 @@ int main(int argc, char *argv[])
 		case 'a':
 			active_bank = strtoul(optarg, NULL, 0);
 			break;
+		case 'v':
+			version = strtoul(optarg, NULL, 0);
+			break;
+		case 'V':
+			vendor_file = optarg;
+			break;
 		}
 	} while (c != -1);
 
@@ -313,6 +460,17 @@ int main(int argc, char *argv[])
 		return -EINVAL;
 	}
 
+	if (!version || !supported_mdata_version(version)) {
+		fprintf(stderr, "Error: Version value can only be either 1 or 2, not %ld.\n",
+			version);
+		return -EINVAL;
+	}
+
+	if (version == 1 && vendor_file) {
+		fprintf(stderr, "Error: Vendor Data can only be appended in version 2 of FWU Metadata.\n");
+		return -EINVAL;
+	}
+
 	/* This command takes UUIDs * images and output file. */
 	if (optind + images + 1 != argc) {
 		fprintf(stderr, "Error: UUID list or output file is not specified or too much.\n");
@@ -325,7 +483,8 @@ int main(int argc, char *argv[])
 		previous_bank = active_bank > 0 ? active_bank - 1 : banks - 1;
 	}
 
-	ret = fwu_make_mdata(images, banks, argv + optind, argv[argc - 1]);
+	ret = fwu_make_mdata(images, banks, (u8)version, vendor_file,
+			     argv + optind, argv[argc - 1]);
 	if (ret < 0)
 		fprintf(stderr, "Error: Failed to parse and write image: %s\n",
 			strerror(-ret));
-- 
2.34.1

